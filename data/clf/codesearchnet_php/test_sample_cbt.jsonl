{"input": "注册监听完成\n\n@param FormEvent $event [SEP] public function onRegisterSuccess(FormEvent $event)\n    {\n        $user = $event->getForm()->getData();\n        $response = new RedirectResponse($this->router->generate('user_view', [\n            'username' => $user->getUsername(),\n        ]));\n        $event->setResponse($response);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "注册监听完成\n\n@param FormEvent $event [SEP] protected function extendResolved($abstract, &$resolved): void\n    {\n        if (! isset($this->extenders[$abstract])) {\n            return;\n        }\n\n        $binding = $this->bindings[$abstract];\n\n        foreach ($this->extenders[$abstract] as $extender) {\n            $resolved = $this->extendConcrete($resolved, $extender);\n        }\n\n        if ($binding && $binding[TypesContract::BINDING_TYPE] !== TypesContract::SERVICE) {\n            unset($this->extenders[$abstract]);\n\n            $this->bindings[$abstract][TypesContract::VALUE] = $resolved;\n        }\n    }", "target": 0, "target_options": ["no_match", "match"]}
{"input": "Checks if a deprecation exists and triggers a deprecation error.\n\n@param string             $configClass\n@param array              $deprecatedOptions\n@param array|\\ArrayAccess $config\n\n@throws \\Viserio\\Component\\Contract\\OptionsResolver\\Exception\\InvalidArgumentException If deprecation message cant be found or\nthe key don't exists in the config array\n\n@return void [SEP] private static function checkDeprecatedOptions(string $configClass, array $deprecatedOptions, $config): void\n    {\n        foreach ($deprecatedOptions as $key => $deprecationMessage) {\n            if (\\is_array($deprecationMessage)) {\n                self::checkDeprecatedOptions($configClass, $deprecationMessage, $config[$key]);\n\n                continue;\n            }\n\n            if (\\is_int($key)) {\n                $key                = $deprecationMessage;\n                $deprecationMessage = 'The option [%s] is deprecated.';\n            }\n\n            if (! \\array_key_exists($key, (array) $config)) {\n                throw new InvalidArgumentException(\\sprintf(\n                    'Option [%s] cant be deprecated, because it does not exist, in [%s].',\n                    $key,\n                    $configClass\n                ));\n            }\n\n            if (! \\is_string($deprecationMessage)) {\n                throw new InvalidArgumentException(\\sprintf(\n                    'Invalid deprecation message value provided for [%s]; Expected [string], but got [%s], in [%s].',\n                    $key,\n                    (\\is_object($deprecationMessage) ? \\get_class($deprecationMessage) : \\gettype($deprecationMessage)),\n                    $configClass\n                ));\n            }\n\n            if (empty($deprecationMessage)) {\n                throw new InvalidArgumentException(\\sprintf(\n                    'Deprecation message cant be empty, for option [%s], in [%s].',\n                    $key,\n                    $configClass\n                ));\n            }\n\n            @\\trigger_error(\\sprintf($deprecationMessage, $key), \\E_USER_DEPRECATED);\n        }\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if a deprecation exists and triggers a deprecation error.\n\n@param string             $configClass\n@param array              $deprecatedOptions\n@param array|\\ArrayAccess $config\n\n@throws \\Viserio\\Component\\Contract\\OptionsResolver\\Exception\\InvalidArgumentException If deprecation message cant be found or\nthe key don't exists in the config array\n\n@return void [SEP] public function find($id = null)\n\t{\n\t\t$builder = $this->builder();\n\n\t\tif ($this->tempUseSoftDeletes === true)\n\t\t{\n\t\t\t$builder->where($this->table . '.' . $this->deletedField, 0);\n\t\t}\n\n\t\tif (is_array($id))\n\t\t{\n\t\t\t$row = $builder->whereIn($this->table . '.' . $this->primaryKey, $id)\n\t\t\t\t\t->get();\n\t\t\t$row = $row->getResult($this->tempReturnType);\n\t\t}\n\t\telseif (is_numeric($id) || is_string($id))\n\t\t{\n\t\t\t$row = $builder->where($this->table . '.' . $this->primaryKey, $id)\n\t\t\t\t\t->get();\n\n\t\t\t$row = $row->getFirstRow($this->tempReturnType);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$row = $builder->get();\n\n\t\t\t$row = $row->getResult($this->tempReturnType);\n\t\t}\n\n\t\t$row = $this->trigger('afterFind', ['id' => $id, 'data' => $row]);\n\n\t\t$this->tempReturnType     = $this->returnType;\n\t\t$this->tempUseSoftDeletes = $this->useSoftDeletes;\n\n\t\treturn $row['data'];\n\t}", "target": 0, "target_options": ["no_match", "match"]}
{"input": "Registers the post type with WP\n@return string Post type slug [SEP] public function registerPostType()\n    {\n        $labels = array(\n            'name'                => $this->nameSingular,\n            'singular_name'       => $this->nameSingular,\n            'add_new'             => sprintf(__('Add new %s', 'event-manager'), $this->nameSingular),\n            'add_new_item'        => sprintf(__('Add new %s', 'event-manager'), $this->nameSingular),\n            'edit_item'           => sprintf(__('Edit %s', 'event-manager'), $this->nameSingular),\n            'new_item'            => sprintf(__('New %s', 'event-manager'), $this->nameSingular),\n            'view_item'           => sprintf(__('View %s', 'event-manager'), $this->nameSingular),\n            'search_items'        => sprintf(__('Search %s', 'event-manager'), $this->namePlural),\n            'not_found'           => sprintf(__('No %s found', 'event-manager'), $this->namePlural),\n            'not_found_in_trash'  => sprintf(__('No %s found in trash', 'event-manager'), $this->namePlural),\n            'parent_item_colon'   => sprintf(__('Parent %s:', 'event-manager'), $this->nameSingular),\n            'menu_name'           => $this->namePlural,\n        );\n\n        $this->args['labels'] = $labels;\n\n        register_post_type($this->slug, $this->args);\n\n        return $this->slug;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Registers the post type with WP\n@return string Post type slug [SEP] protected function extendResolved($abstract, &$resolved): void\n    {\n        if (! isset($this->extenders[$abstract])) {\n            return;\n        }\n\n        $binding = $this->bindings[$abstract];\n\n        foreach ($this->extenders[$abstract] as $extender) {\n            $resolved = $this->extendConcrete($resolved, $extender);\n        }\n\n        if ($binding && $binding[TypesContract::BINDING_TYPE] !== TypesContract::SERVICE) {\n            unset($this->extenders[$abstract]);\n\n            $this->bindings[$abstract][TypesContract::VALUE] = $resolved;\n        }\n    }", "target": 0, "target_options": ["no_match", "match"]}
{"input": "{@inheritdoc} [SEP] public function configure($name, array $options, array $metadata, FormConfigInterface $parentConfig)\n    {\n        if (!\\array_key_exists('label', $options) && \\array_key_exists('label', $metadata)) {\n            $options['label'] = $metadata['label'];\n        }\n\n        if (empty($options['translation_domain'])) {\n            $entityConfig = $this->configManager->getEntityConfig($parentConfig->getOption('entity'));\n\n            if (!empty($entityConfig['translation_domain'])) {\n                $options['translation_domain'] = $entityConfig['translation_domain'];\n            }\n        }\n\n        return $options;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "{@inheritdoc} [SEP] private static function checkDeprecatedOptions(string $configClass, array $deprecatedOptions, $config): void\n    {\n        foreach ($deprecatedOptions as $key => $deprecationMessage) {\n            if (\\is_array($deprecationMessage)) {\n                self::checkDeprecatedOptions($configClass, $deprecationMessage, $config[$key]);\n\n                continue;\n            }\n\n            if (\\is_int($key)) {\n                $key                = $deprecationMessage;\n                $deprecationMessage = 'The option [%s] is deprecated.';\n            }\n\n            if (! \\array_key_exists($key, (array) $config)) {\n                throw new InvalidArgumentException(\\sprintf(\n                    'Option [%s] cant be deprecated, because it does not exist, in [%s].',\n                    $key,\n                    $configClass\n                ));\n            }\n\n            if (! \\is_string($deprecationMessage)) {\n                throw new InvalidArgumentException(\\sprintf(\n                    'Invalid deprecation message value provided for [%s]; Expected [string], but got [%s], in [%s].',\n                    $key,\n                    (\\is_object($deprecationMessage) ? \\get_class($deprecationMessage) : \\gettype($deprecationMessage)),\n                    $configClass\n                ));\n            }\n\n            if (empty($deprecationMessage)) {\n                throw new InvalidArgumentException(\\sprintf(\n                    'Deprecation message cant be empty, for option [%s], in [%s].',\n                    $key,\n                    $configClass\n                ));\n            }\n\n            @\\trigger_error(\\sprintf($deprecationMessage, $key), \\E_USER_DEPRECATED);\n        }\n    }", "target": 0, "target_options": ["no_match", "match"]}
{"input": "Converts a SimpleXML object to an Array recursively\nensuring all sub-elements are arrays as well.\n\n@param string $sxml SimpleXML object\n@param array  $arr  Array into which to store results\n\n@return array [SEP] private static function _sxml2arr($sxml, array $arr = null)\n    {\n        foreach ((array) $sxml as $key => $value) {\n            if (is_object($value) || (is_array($value))) {\n                $arr[$key] = self::_sxml2arr($value);\n            } else {\n                $arr[$key] = $value;\n            }\n        }\n\n        return $arr;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a SimpleXML object to an Array recursively\nensuring all sub-elements are arrays as well.\n\n@param string $sxml SimpleXML object\n@param array  $arr  Array into which to store results\n\n@return array [SEP] public function insert($table, $columns)\n    {\n        $cmdPromise = $this->createCommand()->insert($table, $columns)->execute();\n        return $this->execPromise($cmdPromise, \"insert into $table\");\n    }", "target": 0, "target_options": ["no_match", "match"]}
{"input": "Fetches the row of database from $this->table with a primary key\nmatching $id.\n\n@param mixed|array|null $id One primary key or an array of primary keys\n\n@return array|object|null    The resulting row of data, or null. [SEP] public function find($id = null)\n\t{\n\t\t$builder = $this->builder();\n\n\t\tif ($this->tempUseSoftDeletes === true)\n\t\t{\n\t\t\t$builder->where($this->table . '.' . $this->deletedField, 0);\n\t\t}\n\n\t\tif (is_array($id))\n\t\t{\n\t\t\t$row = $builder->whereIn($this->table . '.' . $this->primaryKey, $id)\n\t\t\t\t\t->get();\n\t\t\t$row = $row->getResult($this->tempReturnType);\n\t\t}\n\t\telseif (is_numeric($id) || is_string($id))\n\t\t{\n\t\t\t$row = $builder->where($this->table . '.' . $this->primaryKey, $id)\n\t\t\t\t\t->get();\n\n\t\t\t$row = $row->getFirstRow($this->tempReturnType);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$row = $builder->get();\n\n\t\t\t$row = $row->getResult($this->tempReturnType);\n\t\t}\n\n\t\t$row = $this->trigger('afterFind', ['id' => $id, 'data' => $row]);\n\n\t\t$this->tempReturnType     = $this->returnType;\n\t\t$this->tempUseSoftDeletes = $this->useSoftDeletes;\n\n\t\treturn $row['data'];\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fetches the row of database from $this->table with a primary key\nmatching $id.\n\n@param mixed|array|null $id One primary key or an array of primary keys\n\n@return array|object|null    The resulting row of data, or null. [SEP] private static function _sxml2arr($sxml, array $arr = null)\n    {\n        foreach ((array) $sxml as $key => $value) {\n            if (is_object($value) || (is_array($value))) {\n                $arr[$key] = self::_sxml2arr($value);\n            } else {\n                $arr[$key] = $value;\n            }\n        }\n\n        return $arr;\n    }", "target": 0, "target_options": ["no_match", "match"]}
{"input": "解析where\n\n@param string|array $where\n@param array $params\n@return string\n@throws CoreException [SEP] public function parseWhere($where, array &$params)\n    {\n        if (!empty($where)) {\n            if (is_array($where)) {\n                if (isset($where[1])) {\n                    $where_str = $where[0];\n                    if (!is_array($where[1])) {\n                        $params[] = $where[1];\n                    } else {\n                        foreach ($where[1] as $w) {\n                            $params[] = $w;\n                        }\n                    }\n                } else {\n                    $where_str = $this->parseWhereFromHashMap($where, $params);\n                }\n            } else {\n                $where_str = $where;\n            }\n        } else {\n            $where_str = '1=1';\n        }\n        return $where_str;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "解析where\n\n@param string|array $where\n@param array $params\n@return string\n@throws CoreException [SEP] public function insert($table, $columns)\n    {\n        $cmdPromise = $this->createCommand()->insert($table, $columns)->execute();\n        return $this->execPromise($cmdPromise, \"insert into $table\");\n    }", "target": 0, "target_options": ["no_match", "match"]}
{"input": "Creates and executes an INSERT SQL statement.\nThe method will properly escape the column names, and bind the values to be inserted.\n@param string $table the table that new rows will be inserted into.\n@param array  $columns the column data (name => value) to be inserted into the table.\n@return LazyPromiseInterface [SEP] public function insert($table, $columns)\n    {\n        $cmdPromise = $this->createCommand()->insert($table, $columns)->execute();\n        return $this->execPromise($cmdPromise, \"insert into $table\");\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates and executes an INSERT SQL statement.\nThe method will properly escape the column names, and bind the values to be inserted.\n@param string $table the table that new rows will be inserted into.\n@param array  $columns the column data (name => value) to be inserted into the table.\n@return LazyPromiseInterface [SEP] protected function extendResolved($abstract, &$resolved): void\n    {\n        if (! isset($this->extenders[$abstract])) {\n            return;\n        }\n\n        $binding = $this->bindings[$abstract];\n\n        foreach ($this->extenders[$abstract] as $extender) {\n            $resolved = $this->extendConcrete($resolved, $extender);\n        }\n\n        if ($binding && $binding[TypesContract::BINDING_TYPE] !== TypesContract::SERVICE) {\n            unset($this->extenders[$abstract]);\n\n            $this->bindings[$abstract][TypesContract::VALUE] = $resolved;\n        }\n    }", "target": 0, "target_options": ["no_match", "match"]}
{"input": "Returns the response for the current page URI\n\nIf the current page URI was not found, the URI \"/NotFound/\" will be checked\n\n@return Response|NULL [SEP] public function getResponse()\n    {\n        $statusCode = 200;\n        $page = $this->getPage();\n        if (!$page) {\n            $statusCode = 404;\n            $page = $this->getNotFoundPage();\n        }\n\n        return new Response(\n            $page ? $page->getContent() : 'Not found',\n            $statusCode\n        );\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the response for the current page URI\n\nIf the current page URI was not found, the URI \"/NotFound/\" will be checked\n\n@return Response|NULL [SEP] public function find($id = null)\n\t{\n\t\t$builder = $this->builder();\n\n\t\tif ($this->tempUseSoftDeletes === true)\n\t\t{\n\t\t\t$builder->where($this->table . '.' . $this->deletedField, 0);\n\t\t}\n\n\t\tif (is_array($id))\n\t\t{\n\t\t\t$row = $builder->whereIn($this->table . '.' . $this->primaryKey, $id)\n\t\t\t\t\t->get();\n\t\t\t$row = $row->getResult($this->tempReturnType);\n\t\t}\n\t\telseif (is_numeric($id) || is_string($id))\n\t\t{\n\t\t\t$row = $builder->where($this->table . '.' . $this->primaryKey, $id)\n\t\t\t\t\t->get();\n\n\t\t\t$row = $row->getFirstRow($this->tempReturnType);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$row = $builder->get();\n\n\t\t\t$row = $row->getResult($this->tempReturnType);\n\t\t}\n\n\t\t$row = $this->trigger('afterFind', ['id' => $id, 'data' => $row]);\n\n\t\t$this->tempReturnType     = $this->returnType;\n\t\t$this->tempUseSoftDeletes = $this->useSoftDeletes;\n\n\t\treturn $row['data'];\n\t}", "target": 0, "target_options": ["no_match", "match"]}
{"input": "Extend a resolved subject.\n\n@param string $abstract\n@param mixed  $resolved\n\n@return void [SEP] protected function extendResolved($abstract, &$resolved): void\n    {\n        if (! isset($this->extenders[$abstract])) {\n            return;\n        }\n\n        $binding = $this->bindings[$abstract];\n\n        foreach ($this->extenders[$abstract] as $extender) {\n            $resolved = $this->extendConcrete($resolved, $extender);\n        }\n\n        if ($binding && $binding[TypesContract::BINDING_TYPE] !== TypesContract::SERVICE) {\n            unset($this->extenders[$abstract]);\n\n            $this->bindings[$abstract][TypesContract::VALUE] = $resolved;\n        }\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extend a resolved subject.\n\n@param string $abstract\n@param mixed  $resolved\n\n@return void [SEP] public function registerPostType()\n    {\n        $labels = array(\n            'name'                => $this->nameSingular,\n            'singular_name'       => $this->nameSingular,\n            'add_new'             => sprintf(__('Add new %s', 'event-manager'), $this->nameSingular),\n            'add_new_item'        => sprintf(__('Add new %s', 'event-manager'), $this->nameSingular),\n            'edit_item'           => sprintf(__('Edit %s', 'event-manager'), $this->nameSingular),\n            'new_item'            => sprintf(__('New %s', 'event-manager'), $this->nameSingular),\n            'view_item'           => sprintf(__('View %s', 'event-manager'), $this->nameSingular),\n            'search_items'        => sprintf(__('Search %s', 'event-manager'), $this->namePlural),\n            'not_found'           => sprintf(__('No %s found', 'event-manager'), $this->namePlural),\n            'not_found_in_trash'  => sprintf(__('No %s found in trash', 'event-manager'), $this->namePlural),\n            'parent_item_colon'   => sprintf(__('Parent %s:', 'event-manager'), $this->nameSingular),\n            'menu_name'           => $this->namePlural,\n        );\n\n        $this->args['labels'] = $labels;\n\n        register_post_type($this->slug, $this->args);\n\n        return $this->slug;\n    }", "target": 0, "target_options": ["no_match", "match"]}
