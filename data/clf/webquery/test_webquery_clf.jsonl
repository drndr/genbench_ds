{"input": "how to open a text file on python [SEP] def get_file_string(filepath):     \"\"\"Get string from file.\"\"\"     with open(os.path.abspath(filepath)) as f:         return f.read()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to open a text file on python [SEP] def unpunctuate(s, *, char_blacklist=string.punctuation):     \"\"\" Remove punctuation from string s. \"\"\"     # remove punctuation     s = \"\".join(c for c in s if c not in char_blacklist)     # remove consecutive spaces     return \" \".join(filter(None, s.split(\" \")))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to open a text file on python [SEP] def file_read(filename):     \"\"\"Read a file and close it.  Returns the file source.\"\"\"     fobj = open(filename,'r');     source = fobj.read();     fobj.close()     return source", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to open a text file on python [SEP] def safe_format(s, **kwargs):   \"\"\"   :type s str   \"\"\"   return string.Formatter().vformat(s, (), defaultdict(str, **kwargs))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to get count of rows in excel sheet python [SEP] def series_table_row_offset(self, series):         \"\"\"         Return the number of rows preceding the data table for *series* in         the Excel worksheet.         \"\"\"         title_and_spacer_rows = series.index * 2         data_point_rows = series.data_point_offset         return title_and_spacer_rows + data_point_rows", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to get count of rows in excel sheet python [SEP] def strip_accents(text):     \"\"\"     Strip agents from a string.     \"\"\"      normalized_str = unicodedata.normalize('NFD', text)      return ''.join([         c for c in normalized_str if unicodedata.category(c) != 'Mn'])", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to get count of rows in excel sheet python [SEP] def y_values_ref(self, series):         \"\"\"         The Excel worksheet reference to the Y values for this chart (not         including the column label).         \"\"\"         top_row = self.series_table_row_offset(series) + 2         bottom_row = top_row + len(series) - 1         return \"Sheet1!$B$%d:$B$%d\" % (top_row, bottom_row)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to get count of rows in excel sheet python [SEP] def replace(s, replace):     \"\"\"Replace multiple values in a string\"\"\"     for r in replace:         s = s.replace(*r)     return s", "target": 0, "target_options": ["no match", "match"]}
{"input": "python list delete elelment contain character [SEP] def clean(self, text):         \"\"\"Remove all unwanted characters from text.\"\"\"         return ''.join([c for c in text if c in self.alphabet])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python list delete elelment contain character [SEP] def intToBin(i):     \"\"\" Integer to two bytes \"\"\"     # divide in two parts (bytes)     i1 = i % 256     i2 = int(i / 256)     # make string (little endian)     return i.to_bytes(2, byteorder='little')", "target": 0, "target_options": ["no match", "match"]}
{"input": "python list delete elelment contain character [SEP] def is_break_tag(self, el):         \"\"\"Check if tag is an element we should break on.\"\"\"          name = el.name         return name in self.break_tags or name in self.user_break_tags", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python list delete elelment contain character [SEP] def find_geom(geom, geoms):     \"\"\"     Returns the index of a geometry in a list of geometries avoiding     expensive equality checks of `in` operator.     \"\"\"     for i, g in enumerate(geoms):         if g is geom:             return i", "target": 0, "target_options": ["no match", "match"]}
{"input": "remove all non numeric characters python [SEP] def _remove_invalid_char(s):     \"\"\"Remove invalid and dangerous characters from a string.\"\"\"      s = ''.join([i if ord(i) >= 32 and ord(i) < 127 else '' for i in s])     s = s.translate(dict.fromkeys(map(ord, \"_%~#\\\\{}\\\":\")))     return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove all non numeric characters python [SEP] def apply_operation(op_stack, out_stack):     \"\"\"     Apply operation to the first 2 items of the output queue      op_stack Deque (reference)     out_stack Deque (reference)     \"\"\"     out_stack.append(calc(out_stack.pop(), out_stack.pop(), op_stack.pop()))", "target": 0, "target_options": ["no match", "match"]}
{"input": "remove all non numeric characters python [SEP] def clean_text(text):     \"\"\"Clean text before parsing.\"\"\"     # Replace a few nasty unicode characters with their ASCII equivalent     maps = {u'×': u'x', u'–': u'-', u'−': '-'}     for element in maps:         text = text.replace(element, maps[element])      # Replace genitives     text = re.sub(r'(?<=\\w)\\'s\\b|(?<=\\w)s\\'(?!\\w)', '  ', text)      logging.debug(u'Clean text: \"%s\"', text)      return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove all non numeric characters python [SEP] def shutdown(self):         \"\"\"         Shutdown the cluster.         \"\"\"         self.stop = True         if self.stats:             self.stats.shutDownStats()         self.join()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python recieve push notifications [SEP] def notify(self, msgtype, method, params):         \"\"\"Handle an incoming notify request.\"\"\"         self.dispatch.call(method, params)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python recieve push notifications [SEP] def csvpretty(csvfile: csvfile=sys.stdin):     \"\"\" Pretty print a CSV file. \"\"\"     shellish.tabulate(csv.reader(csvfile))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python recieve push notifications [SEP] def write(self, data):         \"\"\"         Write the given data to the file.         \"\"\"                  # Do the write         self.backingStream.write(data)                  for listener in self.writeListeners:             # Send out notifications             listener(len(data))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python recieve push notifications [SEP] def unit_net_value(self):         \"\"\"         [float] 实时净值         \"\"\"         if self._units == 0:             return np.nan         return self.total_value / self._units", "target": 0, "target_options": ["no match", "match"]}
{"input": "python git get latest commit [SEP] def latest_commit(self) -> git.Commit:         \"\"\"         :return: latest commit         :rtype: git.Commit object         \"\"\"         latest_commit: git.Commit = self.repo.head.commit         LOGGER.debug('latest commit: %s', latest_commit)         return latest_commit", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python git get latest commit [SEP] def nas_server_ip_server_ip(self, **kwargs):         \"\"\"Auto Generated Code         \"\"\"         config = ET.Element(\"config\")         nas = ET.SubElement(config, \"nas\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")         server_ip = ET.SubElement(nas, \"server-ip\")         server_ip = ET.SubElement(server_ip, \"server-ip\")         server_ip.text = kwargs.pop('server_ip')          callback = kwargs.pop('callback', self._callback)         return callback(config)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python git get latest commit [SEP] def get_last_commit_line(git_path=None):     \"\"\"     Get one-line description of HEAD commit for repository in current dir.     \"\"\"     if git_path is None: git_path = GIT_PATH     output = check_output([git_path, \"log\", \"--pretty=format:'%ad %h %s'\",                            \"--date=short\", \"-n1\"])     return output.strip()[1:-1]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python git get latest commit [SEP] def S(self):         \"\"\":obj:`numpy.ndarray` : The 3x3 scaling matrix for this projection         \"\"\"         S = np.array([[self._plane_width / self._vol_width, 0, 0],                       [0, self._plane_height / self._vol_height, 0],                       [0, 0, self._depth_scale / self._vol_depth]])         return S", "target": 0, "target_options": ["no match", "match"]}
{"input": "can you remove letters in strings in python [SEP] def clean(self, text):         \"\"\"Remove all unwanted characters from text.\"\"\"         return ''.join([c for c in text if c in self.alphabet])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "can you remove letters in strings in python [SEP] def serialize(self, value, **kwargs):         \"\"\"Serialize every item of the list.\"\"\"         return [self.item_type.serialize(val, **kwargs) for val in value]", "target": 0, "target_options": ["no match", "match"]}
{"input": "can you remove letters in strings in python [SEP] def strip_accents(s):     \"\"\"     Strip accents to prepare for slugification.     \"\"\"     nfkd = unicodedata.normalize('NFKD', unicode(s))     return u''.join(ch for ch in nfkd if not unicodedata.combining(ch))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "can you remove letters in strings in python [SEP] def _try_decode_list(content):         \"\"\"Decode content of a list.          :param list|tuple content:         :return:         \"\"\"         result = list()         for value in content:             result.append(try_utf8_decode(value))         return result", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to make word into letter by letter in python [SEP] def casefold_with_i_dots(text):     \"\"\"     Convert capital I's and capital dotted İ's to lowercase in the way     that's appropriate for Turkish and related languages, then case-fold     the rest of the letters.     \"\"\"     text = unicodedata.normalize('NFC', text).replace('İ', 'i').replace('I', 'ı')     return text.casefold()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to make word into letter by letter in python [SEP] def is_break_tag(self, el):         \"\"\"Check if tag is an element we should break on.\"\"\"          name = el.name         return name in self.break_tags or name in self.user_break_tags", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to make word into letter by letter in python [SEP] def clean(self, text):         \"\"\"Remove all unwanted characters from text.\"\"\"         return ''.join([c for c in text if c in self.alphabet])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to make word into letter by letter in python [SEP] def quaternion_to_rotation_matrix(quaternion):     \"\"\"Compute the rotation matrix representated by the quaternion\"\"\"     c, x, y, z = quaternion     return np.array([         [c*c + x*x - y*y - z*z, 2*x*y - 2*c*z,         2*x*z + 2*c*y        ],         [2*x*y + 2*c*z,         c*c - x*x + y*y - z*z, 2*y*z - 2*c*x        ],         [2*x*z - 2*c*y,         2*y*z + 2*c*x,         c*c - x*x - y*y + z*z]     ], float)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python src folder convention [SEP] def examples(directory):     \"\"\"     Generate example strategies to target folder     \"\"\"     source_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), \"examples\")      try:         shutil.copytree(source_dir, os.path.join(directory, \"examples\"))     except OSError as e:         if e.errno == errno.EEXIST:             six.print_(\"Folder examples is exists.\")", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python src folder convention [SEP] def _compress_content(self, content):         \"\"\"Gzip a given string.\"\"\"         zbuf = StringIO()         zfile = GzipFile(mode='wb', compresslevel=6, fileobj=zbuf)         zfile.write(content.read())         zfile.close()         content.file = zbuf         return content", "target": 0, "target_options": ["no match", "match"]}
{"input": "python src folder convention [SEP] def normalize_path(filename):     \"\"\"Normalize a file/dir name for comparison purposes\"\"\"     return os.path.normcase(os.path.realpath(os.path.normpath(_cygwin_patch(filename))))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python src folder convention [SEP] def findMax(arr):     \"\"\"     in comparison to argrelmax() more simple and  reliable peak finder     \"\"\"     out = np.zeros(shape=arr.shape, dtype=bool)     _calcMax(arr, out)     return out", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to navigate folders in python [SEP] def listfolder(p):     \"\"\"     generator of list folder in the path.     folders only     \"\"\"     for entry in scandir.scandir(p):         if entry.is_dir():             yield entry.name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to navigate folders in python [SEP] def extend(a: dict, b: dict) -> dict:     \"\"\"Merge two dicts and return a new dict. Much like subclassing works.\"\"\"     res = a.copy()     res.update(b)     return res", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to navigate folders in python [SEP] def get_all_files(folder):     \"\"\"     Generator that loops through all absolute paths of the files within folder      Parameters     ----------     folder: str     Root folder start point for recursive search.      Yields     ------     fpath: str     Absolute path of one file in the folders     \"\"\"     for path, dirlist, filelist in os.walk(folder):         for fn in filelist:             yield op.join(path, fn)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to navigate folders in python [SEP] def clean_text(text):     \"\"\"Clean text before parsing.\"\"\"     # Replace a few nasty unicode characters with their ASCII equivalent     maps = {u'×': u'x', u'–': u'-', u'−': '-'}     for element in maps:         text = text.replace(element, maps[element])      # Replace genitives     text = re.sub(r'(?<=\\w)\\'s\\b|(?<=\\w)s\\'(?!\\w)', '  ', text)      logging.debug(u'Clean text: \"%s\"', text)      return text", "target": 0, "target_options": ["no match", "match"]}
{"input": "feed python variable for jinja template [SEP] def render_template(template_name, **context):     \"\"\"Render a template into a response.\"\"\"     tmpl = jinja_env.get_template(template_name)     context[\"url_for\"] = url_for     return Response(tmpl.render(context), mimetype=\"text/html\")", "target": 1, "target_options": ["no_match", "match"]}
{"input": "feed python variable for jinja template [SEP] def lowpass(data,filterSize=None):     \"\"\"     minimal complexity low-pass filtering.     Filter size is how \"wide\" the filter will be.     Sigma will be 1/10 of this filter width.     If filter size isn't given, it will be 1/10 of the data size.     \"\"\"     if filterSize is None:         filterSize=len(data)/10     kernel=kernel_gaussian(size=filterSize)     data=convolve(data,kernel) # do the convolution with padded edges     return data", "target": 0, "target_options": ["no match", "match"]}
{"input": "feed python variable for jinja template [SEP] def rstjinja(app, docname, source):     \"\"\"     Render our pages as a jinja template for fancy templating goodness.     \"\"\"     # Make sure we're outputting HTML     if app.builder.format != 'html':         return     src = source[0]     rendered = app.builder.templates.render_string(         src, app.config.html_context     )     source[0] = rendered", "target": 1, "target_options": ["no_match", "match"]}
{"input": "feed python variable for jinja template [SEP] def extendleft(self, iterable):         \"\"\"Extend the left side of this GeventDeque by appending         elements from the iterable argument.  Note, the series of left         appends results in reversing the order of elements in the         iterable argument.         \"\"\"         self._deque.extendleft(iterable)         if len(self._deque) > 0:             self.notEmpty.set()", "target": 0, "target_options": ["no match", "match"]}
{"input": "check whether a file exists on s3 full path using python [SEP] def check_bucket_exists(self, bucket: str) -> bool:         \"\"\"         Checks if bucket with specified name exists.         :param bucket: the bucket to be checked.         :return: true if specified bucket exists.         \"\"\"         exists = True         try:             self.s3_client.head_bucket(Bucket=bucket)         except botocore.exceptions.ClientError as e:             # If a client error is thrown, then check that it was a 404 error.             # If it was a 404 error, then the bucket does not exist.             error_code = int(e.response['Error']['Code'])             if error_code == 404:                 exists = False         return exists", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check whether a file exists on s3 full path using python [SEP] def strToBool(val):     \"\"\"     Helper function to turn a string representation of \"true\" into     boolean True.     \"\"\"     if isinstance(val, str):         val = val.lower()      return val in ['true', 'on', 'yes', True]", "target": 0, "target_options": ["no match", "match"]}
{"input": "check whether a file exists on s3 full path using python [SEP] def check_for_key(self, key, bucket_name=None):         \"\"\"         Checks if a key exists in a bucket          :param key: S3 key that will point to the file         :type key: str         :param bucket_name: Name of the bucket in which the file is stored         :type bucket_name: str         \"\"\"         if not bucket_name:             (bucket_name, key) = self.parse_s3_url(key)          try:             self.get_conn().head_object(Bucket=bucket_name, Key=key)             return True         except ClientError as e:             self.log.info(e.response[\"Error\"][\"Message\"])             return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check whether a file exists on s3 full path using python [SEP] def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value", "target": 0, "target_options": ["no match", "match"]}
{"input": "destroy an object in python [SEP] def cleanup(self):         \"\"\"Forcefully delete objects from memory          In an ideal world, this shouldn't be necessary. Garbage         collection guarantees that anything without reference         is automatically removed.          However, because this application is designed to be run         multiple times from the same interpreter process, extra         case must be taken to ensure there are no memory leaks.          Explicitly deleting objects shines a light on where objects         may still be referenced in the form of an error. No errors         means this was uneccesary, but that's ok.          \"\"\"          for instance in self.context:             del(instance)          for plugin in self.plugins:             del(plugin)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "destroy an object in python [SEP] def get_list_index(lst, index_or_name):     \"\"\"     Return the index of an element in the list.      Args:         lst (list): The list.         index_or_name (int or str): The value of the reference element, or directly its numeric index.      Returns:         (int) The index of the element in the list.     \"\"\"     if isinstance(index_or_name, six.integer_types):         return index_or_name      return lst.index(index_or_name)", "target": 0, "target_options": ["no match", "match"]}
{"input": "destroy an object in python [SEP] def detach(self):         \"\"\"         Detach the underlying LLVM resource without disposing of it.         \"\"\"         if not self._closed:             del self._as_parameter_             self._closed = True             self._ptr = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "destroy an object in python [SEP] def executeMethod(self, methodName, args):     \"\"\"Executes a method named ``methodName`` with the specified arguments.      This method is called when the user executes a command as defined in     the node spec. It provides a perfectly reasonble implementation     of the command mechanism. As a sub-class developer you just need to     implement a method for each command in the node spec. Note that due to     the command mechanism only unnamed argument are supported.      :param methodName: (string) the name of the method that correspond to a            command in the spec.     :param args: (list) of arguments that will be passed to the method     \"\"\"     if not hasattr(self, methodName):       raise Exception('Missing command method: ' + methodName)      m = getattr(self, methodName)     if not hasattr(m, '__call__'):       raise Exception('Command: ' + methodName + ' must be callable')      return m(*args)", "target": 0, "target_options": ["no match", "match"]}
{"input": "split on any whitespace python [SEP] def normalize_value(text):     \"\"\"     This removes newlines and multiple spaces from a string.     \"\"\"     result = text.replace('\\n', ' ')     result = re.subn('[ ]{2,}', ' ', result)[0]     return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "split on any whitespace python [SEP] def GeneralGuinier(q, G, Rg, s):     \"\"\"Generalized Guinier scattering      Inputs:     -------         ``q``: independent variable         ``G``: factor         ``Rg``: radius of gyration         ``s``: dimensionality parameter (can be 1, 2, 3)      Formula:     --------         ``G/q**(3-s)*exp(-(q^2*Rg^2)/s)``     \"\"\"     return G / q ** (3 - s) * np.exp(-(q * Rg) ** 2 / s)", "target": 0, "target_options": ["no match", "match"]}
{"input": "split on any whitespace python [SEP] def clean(s):   \"\"\"Removes trailing whitespace on each line.\"\"\"   lines = [l.rstrip() for l in s.split('\\n')]   return '\\n'.join(lines)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "split on any whitespace python [SEP] def calculate_bounding_box(data):     \"\"\"     Returns a 2 x m array indicating the min and max along each     dimension.     \"\"\"     mins = data.min(0)     maxes = data.max(0)     return mins, maxes", "target": 0, "target_options": ["no match", "match"]}
{"input": "check list in a string python [SEP] def chk_enum_arg(s):     \"\"\"Checks if the string `s` is a valid enum string.      Return True or False.\"\"\"      if len(s) == 0 or s[0].isspace() or s[-1].isspace():         return False     else:         return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check list in a string python [SEP] def _prune(self):         \"\"\"Primitive way to keep dict in sync with RB.\"\"\"         delkeys = [k for k in self.keys() if k not in self.__ringbuffer]         for k in delkeys:  # necessary because dict is changed during iterations             super(KRingbuffer,self).__delitem__(k)", "target": 0, "target_options": ["no match", "match"]}
{"input": "check list in a string python [SEP] def __is__(cls, s):         \"\"\"Test if string matches this argument's format.\"\"\"         return s.startswith(cls.delims()[0]) and s.endswith(cls.delims()[1])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check list in a string python [SEP] def column(self, i):          \"\"\"from right\"\"\"         return ''.join([str(digitat2(r,i)) for r in self])", "target": 0, "target_options": ["no match", "match"]}
{"input": "check if all elements in a list are in a list of list python [SEP] def valid (names):     \"\"\" Returns true iff all elements of names are valid features.     \"\"\"     if isinstance(names, str):         names = [names]         assert is_iterable_typed(names, basestring)      return all(name in __all_features for name in names)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check if all elements in a list are in a list of list python [SEP] def logger(message, level=10):     \"\"\"Handle logging.\"\"\"     logging.getLogger(__name__).log(level, str(message))", "target": 0, "target_options": ["no match", "match"]}
{"input": "check if all elements in a list are in a list of list python [SEP] def is_list_of_states(self, arg):         \"\"\"         A list of states example -         [('x1', 'easy'), ('x2', 'hard')]          Returns         -------         True, if arg is a list of states else False.          \"\"\"         return isinstance(arg, list) and all(isinstance(i, tuple) for i in arg)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check if all elements in a list are in a list of list python [SEP] def _handle_shell(self,cfg_file,*args,**options):         \"\"\"Command 'supervisord shell' runs the interactive command shell.\"\"\"         args = (\"--interactive\",) + args         return supervisorctl.main((\"-c\",cfg_file) + args)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to slice rows in a list python [SEP] def iget_list_column_slice(list_, start=None, stop=None, stride=None):     \"\"\" iterator version of get_list_column \"\"\"     if isinstance(start, slice):         slice_ = start     else:         slice_ = slice(start, stop, stride)     return (row[slice_] for row in list_)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to slice rows in a list python [SEP] def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to slice rows in a list python [SEP] def partition(list_, columns=2):     \"\"\"     Break a list into ``columns`` number of columns.     \"\"\"      iter_ = iter(list_)     columns = int(columns)     rows = []      while True:         row = []         for column_number in range(1, columns + 1):             try:                 value = six.next(iter_)             except StopIteration:                 pass             else:                 row.append(value)          if not row:             return rows         rows.append(row)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to slice rows in a list python [SEP] def to_list(self):         \"\"\"Convert this confusion matrix into a 2x2 plain list of values.\"\"\"         return [[int(self.table.cell_values[0][1]), int(self.table.cell_values[0][2])],                 [int(self.table.cell_values[1][1]), int(self.table.cell_values[1][2])]]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python move the last element to the first [SEP] def list_move_to_front(l,value='other'):     \"\"\"if the value is in the list, move it to the front and return it.\"\"\"     l=list(l)     if value in l:         l.remove(value)         l.insert(0,value)     return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python move the last element to the first [SEP] def _rotate(n, x, y, rx, ry):     \"\"\"Rotate and flip a quadrant appropriately      Based on the implementation here:         https://en.wikipedia.org/w/index.php?title=Hilbert_curve&oldid=797332503      \"\"\"     if ry == 0:         if rx == 1:             x = n - 1 - x             y = n - 1 - y         return y, x     return x, y", "target": 0, "target_options": ["no match", "match"]}
{"input": "python move the last element to the first [SEP] def extendleft(self, iterable):         \"\"\"Extend the left side of this GeventDeque by appending         elements from the iterable argument.  Note, the series of left         appends results in reversing the order of elements in the         iterable argument.         \"\"\"         self._deque.extendleft(iterable)         if len(self._deque) > 0:             self.notEmpty.set()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python move the last element to the first [SEP] def _is_bit(obj):     \"\"\"Determine if obj is a bit\"\"\"     # If there is a bit type this could be replaced by isinstance.     if isinstance(obj, tuple) and len(obj) == 2:         if isinstance(obj[0], Register) and isinstance(obj[1], int) and obj[1] < len(obj[0]):             return True     return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "iterate through unique elements python [SEP] def unique(iterable):     \"\"\"Filter out duplicate items from an iterable\"\"\"     seen = set()     for item in iterable:         if item not in seen:             seen.add(item)             yield item", "target": 1, "target_options": ["no_match", "match"]}
{"input": "iterate through unique elements python [SEP] def is_natural(x):     \"\"\"A non-negative integer.\"\"\"     try:         is_integer = int(x) == x     except (TypeError, ValueError):         return False     return is_integer and x >= 0", "target": 0, "target_options": ["no match", "match"]}
{"input": "iterate through unique elements python [SEP] def remove_duplicates(lst):     \"\"\"     Emulate what a Python ``set()`` does, but keeping the element's order.     \"\"\"     dset = set()     return [l for l in lst if l not in dset and not dset.add(l)]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "iterate through unique elements python [SEP] def _quit(self, *args):         \"\"\" quit crash \"\"\"         self.logger.warn('Bye!')         sys.exit(self.exit())", "target": 0, "target_options": ["no match", "match"]}
{"input": "get number of rows from 2d array python [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get number of rows from 2d array python [SEP] def set_time(filename, mod_time): \t\"\"\" \tSet the modified time of a file \t\"\"\" \tlog.debug('Setting modified time to %s', mod_time) \tmtime = calendar.timegm(mod_time.utctimetuple()) \t# utctimetuple discards microseconds, so restore it (for consistency) \tmtime += mod_time.microsecond / 1000000 \tatime = os.stat(filename).st_atime \tos.utime(filename, (atime, mtime))", "target": 0, "target_options": ["no match", "match"]}
{"input": "get number of rows from 2d array python [SEP] def length(self):         \"\"\"Array of vector lengths\"\"\"         return np.sqrt(np.sum(self**2, axis=1)).view(np.ndarray)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get number of rows from 2d array python [SEP] def timeout_thread_handler(timeout, stop_event):     \"\"\"A background thread to kill the process if it takes too long.      Args:         timeout (float): The number of seconds to wait before killing             the process.         stop_event (Event): An optional event to cleanly stop the background             thread if required during testing.     \"\"\"      stop_happened = stop_event.wait(timeout)     if stop_happened is False:         print(\"Killing program due to %f second timeout\" % timeout)      os._exit(2)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to take log of number python [SEP] def _factln(num):     # type: (int) -> float     \"\"\"     Computes logfactorial regularly for tractable numbers, uses Ramanujans approximation otherwise.     \"\"\"      if num < 20:         log_factorial = log(factorial(num))     else:         log_factorial = num * log(num) - num + log(num * (1 + 4 * num * (             1 + 2 * num))) / 6.0 + log(pi) / 2      return log_factorial", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to take log of number python [SEP] def S(self):         \"\"\":obj:`numpy.ndarray` : The 3x3 scaling matrix for this projection         \"\"\"         S = np.array([[self._plane_width / self._vol_width, 0, 0],                       [0, self._plane_height / self._vol_height, 0],                       [0, 0, self._depth_scale / self._vol_depth]])         return S", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to take log of number python [SEP] def one_over_x_like(x):     \"\"\"     returns -np.Inf if x<0, -np.log(x) otherwise.     \"\"\"     if np.any(x < 0):         return -np.Inf     else:         return -np.sum(np.log(x))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to take log of number python [SEP] def ismatch(text, pattern):     \"\"\"Test whether text contains string or matches regex.\"\"\"      if hasattr(pattern, 'search'):         return pattern.search(text) is not None     else:         return pattern in text if Config.options.case_sensitive \\             else pattern.lower() in text.lower()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python open url text file as string [SEP] def wget(url):     \"\"\"     Download the page into a string     \"\"\"     import urllib.parse     request = urllib.request.urlopen(url)     filestring = request.read()     return filestring", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python open url text file as string [SEP] def parse_command_args():     \"\"\"Command line parser.\"\"\"     parser = argparse.ArgumentParser(description='Register PB devices.')     parser.add_argument('num_pb', type=int,                         help='Number of PBs devices to register.')     return parser.parse_args()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python open url text file as string [SEP] def get_file_string(filepath):     \"\"\"Get string from file.\"\"\"     with open(os.path.abspath(filepath)) as f:         return f.read()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python open url text file as string [SEP] def Counter64(a, b, delta):     \"\"\"64bit counter aggregator with wrapping     \"\"\"     if b < a:         c = 18446744073709551615 - a         return (c + b) / float(delta)      return (b - a) / float(delta)", "target": 0, "target_options": ["no match", "match"]}
{"input": "removing all from a list python [SEP] def unique(list):     \"\"\" Returns a copy of the list without duplicates.     \"\"\"     unique = []; [unique.append(x) for x in list if x not in unique]     return unique", "target": 1, "target_options": ["no_match", "match"]}
{"input": "removing all from a list python [SEP] def write_color(string, name, style='normal', when='auto'):     \"\"\" Write the given colored string to standard out. \"\"\"     write(color(string, name, style, when))", "target": 0, "target_options": ["no match", "match"]}
{"input": "removing all from a list python [SEP] def dedup_list(l):     \"\"\"Given a list (l) will removing duplicates from the list,        preserving the original order of the list. Assumes that        the list entrie are hashable.\"\"\"     dedup = set()     return [ x for x in l if not (x in dedup or dedup.add(x))]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "removing all from a list python [SEP] def fix_header_comment(filename, timestamp):     \"\"\"Fixes the header-comment of the given file.\"\"\"     # Fix input file.     name = os.path.basename( filename )     for line in fileinput.input( filename, inplace=1, mode=\"rU\" ):         # If header-comment already contains anything for '$Id$', remove it.         line = re.sub(r'\\$Id:[^$]+\\$', r'$Id$', line.rstrip())         # Replace '$Id$' by a string containing the file's name (and a timestamp)!         line = re.sub(re.escape(r'$Id$'), r'$Id: ' + name + r' ' + timestamp.isoformat() + r' $', line.rstrip())         print(line)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python check if a number is n [SEP] def _nth_str(n):     \"\"\"Return posessive form of numeral `n`: 1st, 2nd, 3rd, etc.\"\"\"     if n % 10 == 1 and n % 100 != 11:         return \"%dst\" % n     if n % 10 == 2 and n % 100 != 12:         return \"%dnd\" % n     if n % 10 == 3 and n % 100 != 13:         return \"%drd\" % n     return \"%dth\" % n", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python check if a number is n [SEP] def set_scalebar_for_all(self, row_column_list=None,                              location='lower right'):         \"\"\"Show marker area scale for subplots.          :param row_column_list: a list containing (row, column) tuples to             specify the subplots, or None to indicate *all* subplots.         :param location: the location of the label inside the plot.  May             be one of 'center', 'upper right', 'lower right', 'upper             left', 'lower left'.          \"\"\"         if row_column_list is None:             for subplot in self.subplots:                 subplot.set_scalebar(location)         else:             for row, column in row_column_list:                 subplot = self.get_subplot_at(row, column)                 subplot.set_scalebar(location)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python check if a number is n [SEP] def IntGreaterThanZero(n):     \"\"\"If *n* is an integer > 0, returns it, otherwise an error.\"\"\"     try:         n = int(n)     except:         raise ValueError(\"%s is not an integer\" % n)     if n <= 0:         raise ValueError(\"%d is not > 0\" % n)     else:         return n", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python check if a number is n [SEP] def main(idle):     \"\"\"Any normal python logic which runs a loop. Can take arguments.\"\"\"     while True:          LOG.debug(\"Sleeping for {0} seconds.\".format(idle))         time.sleep(idle)", "target": 0, "target_options": ["no match", "match"]}
{"input": "remove first and last character in string python [SEP] def truncate(string, index):     \"\"\"Truncate a string at index and add ...\"\"\"     if len(string) > index and index > 0:         string = string[:index - 1] + u('…')     return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove first and last character in string python [SEP] def QA_util_to_json_from_pandas(data):     \"\"\"需要对于datetime 和date 进行转换, 以免直接被变成了时间戳\"\"\"     if 'datetime' in data.columns:         data.datetime = data.datetime.apply(str)     if 'date' in data.columns:         data.date = data.date.apply(str)     return json.loads(data.to_json(orient='records'))", "target": 0, "target_options": ["no match", "match"]}
{"input": "remove first and last character in string python [SEP] def strip_spaces(x):     \"\"\"     Strips spaces     :param x:     :return:     \"\"\"     x = x.replace(b' ', b'')     x = x.replace(b'\\t', b'')     return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove first and last character in string python [SEP] def make_regex(separator):     \"\"\"Utility function to create regexp for matching escaped separators     in strings.      \"\"\"     return re.compile(r'(?:' + re.escape(separator) + r')?((?:[^' +                       re.escape(separator) + r'\\\\]|\\\\.)+)')", "target": 0, "target_options": ["no match", "match"]}
{"input": "python tostring split by comma [SEP] def _str_to_list(s):     \"\"\"Converts a comma separated string to a list\"\"\"     _list = s.split(\",\")     return list(map(lambda i: i.lstrip(), _list))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python tostring split by comma [SEP] def safe_int_conv(number):     \"\"\"Safely convert a single number to integer.\"\"\"     try:         return int(np.array(number).astype(int, casting='safe'))     except TypeError:         raise ValueError('cannot safely convert {} to integer'.format(number))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python tostring split by comma [SEP] def split_elements(value):     \"\"\"Split a string with comma or space-separated elements into a list.\"\"\"     l = [v.strip() for v in value.split(',')]     if len(l) == 1:         l = value.split()     return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python tostring split by comma [SEP] def print_matrix(X, decimals=1):     \"\"\"Pretty printing for numpy matrix X\"\"\"     for row in np.round(X, decimals=decimals):         print(row)", "target": 0, "target_options": ["no match", "match"]}
{"input": "format array python string [SEP] def string_format_func(s): \t\"\"\" \tFunction used internally to format string data for output to XML. \tEscapes back-slashes and quotes, and wraps the resulting string in \tquotes. \t\"\"\" \treturn u\"\\\"%s\\\"\" % unicode(s).replace(u\"\\\\\", u\"\\\\\\\\\").replace(u\"\\\"\", u\"\\\\\\\"\")", "target": 1, "target_options": ["no_match", "match"]}
{"input": "format array python string [SEP] def load_data(url): \t\"\"\" \t\"\"\"  \t# http request \tr = requests.get(url)  \t# decode to json \tdata = r.json()  \treturn data", "target": 0, "target_options": ["no match", "match"]}
{"input": "format array python string [SEP] def safe_format(s, **kwargs):   \"\"\"   :type s str   \"\"\"   return string.Formatter().vformat(s, (), defaultdict(str, **kwargs))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "format array python string [SEP] def write_double(self, number):         \"\"\" Writes a double to the underlying output file as a 8-byte value. \"\"\"         buf = pack(self.byte_order + \"d\", number)         self.write(buf)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to append object in a specific index in list python [SEP] def append(self, item):         \"\"\" append item and print it to stdout \"\"\"         print(item)         super(MyList, self).append(item)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to append object in a specific index in list python [SEP] def _term(self, term):         \"\"\"Add a term to the query.          Arguments:             term (str): The term to add.          Returns:             SearchHelper: Self         \"\"\"         # All terms must be strings for Elasticsearch         term = str(term)         if term:             self.__query[\"q\"] += term         return self", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to append object in a specific index in list python [SEP] def insert(self, index, item):         \"\"\"Insert an item at the specified index.          Args:             index (int): Position to insert the item.             item: Item to be inserted.          Raises:             :exc:`~.exceptions.WrongListItemType`: If an item has a different                 type than the first item to be stored.          \"\"\"         if not self:             list.append(self, item)         elif item.__class__ == self[0].__class__:             list.insert(self, index, item)         else:             raise exceptions.WrongListItemType(item.__class__.__name__,                                                self[0].__class__.__name__)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to append object in a specific index in list python [SEP] def median_high(data):     \"\"\"Return the high median of data.      When the number of data points is odd, the middle value is returned.     When it is even, the larger of the two middle values is returned.      \"\"\"     data = sorted(data)     n = len(data)     if n == 0:         raise StatisticsError(\"no median for empty data\")     return data[n // 2]", "target": 0, "target_options": ["no match", "match"]}
{"input": "read from a string until newline in python [SEP] def get_line_ending(line):     \"\"\"Return line ending.\"\"\"     non_whitespace_index = len(line.rstrip()) - len(line)     if not non_whitespace_index:         return ''     else:         return line[non_whitespace_index:]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "read from a string until newline in python [SEP] def format_float(value): # not used     \"\"\"Modified form of the 'g' format specifier.     \"\"\"     string = \"{:g}\".format(value).replace(\"e+\", \"e\")     string = re.sub(\"e(-?)0*(\\d+)\", r\"e\\1\\2\", string)     return string", "target": 0, "target_options": ["no match", "match"]}
{"input": "read from a string until newline in python [SEP] def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:     \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"     for line in file_like:         line = line.rstrip('\\r\\n')         if line:             yield line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "read from a string until newline in python [SEP] def add_to_parser(self, parser):         \"\"\"         Adds the argument to an argparse.ArgumentParser instance          @param parser An argparse.ArgumentParser instance         \"\"\"         kwargs = self._get_kwargs()         args = self._get_args()         parser.add_argument(*args, **kwargs)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python detect any duplicate in list [SEP] def remove_duplicates(lst):     \"\"\"     Emulate what a Python ``set()`` does, but keeping the element's order.     \"\"\"     dset = set()     return [l for l in lst if l not in dset and not dset.add(l)]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python detect any duplicate in list [SEP] def transcript_sort_key(transcript):     \"\"\"     Key function used to sort transcripts. Taking the negative of     protein sequence length and nucleotide sequence length so that     the transcripts with longest sequences come first in the list. This couldn't     be accomplished with `reverse=True` since we're also sorting by     transcript name (which places TP53-001 before TP53-002).     \"\"\"     return (         -len(transcript.protein_sequence),         -len(transcript.sequence),         transcript.name     )", "target": 0, "target_options": ["no match", "match"]}
{"input": "python detect any duplicate in list [SEP] def remove_dups(seq):     \"\"\"remove duplicates from a sequence, preserving order\"\"\"     seen = set()     seen_add = seen.add     return [x for x in seq if not (x in seen or seen_add(x))]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python detect any duplicate in list [SEP] def strip_spaces(s):     \"\"\" Strip excess spaces from a string \"\"\"     return u\" \".join([c for c in s.split(u' ') if c])", "target": 0, "target_options": ["no match", "match"]}
{"input": "python delete attribute from instance [SEP] def address(self):         \"\"\"         Returns the name of the port that this motor is connected to.         \"\"\"         self._address, value = self.get_attr_string(self._address, 'address')         return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python delete attribute from instance [SEP] def dropna(self, subset=None):         \"\"\"Remove missing values according to Baloo's convention.          Parameters         ----------         subset : list of str, optional             Which columns to check for missing values in.          Returns         -------         DataFrame             DataFrame with no null values in columns.          \"\"\"         subset = check_and_obtain_subset_columns(subset, self)         not_nas = [v.notna() for v in self[subset]._iter()]         and_filter = reduce(lambda x, y: x & y, not_nas)          return self[and_filter]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python delete attribute from instance [SEP] def result(self):         \"\"\" Return the result of the AMP (as a string)\"\"\"         ret = self.get('result')         if ret is not None:             ret = u(ret)         return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python delete attribute from instance [SEP] def dims_intersect(self):         \"\"\"Dimensions of the arrays in this list that are used in all arrays         \"\"\"         return set.intersection(*map(             set, (getattr(arr, 'dims_intersect', arr.dims) for arr in self)))", "target": 0, "target_options": ["no match", "match"]}
{"input": "fetch month from date object python [SEP] def QA_util_datetime_to_strdate(dt):     \"\"\"     :param dt:  pythone datetime.datetime     :return:  1999-02-01 string type     \"\"\"     strdate = \"%04d-%02d-%02d\" % (dt.year, dt.month, dt.day)     return strdate", "target": 1, "target_options": ["no_match", "match"]}
{"input": "fetch month from date object python [SEP] def flatten_list(x: List[Any]) -> List[Any]:     \"\"\"     Converts a list of lists into a flat list.          Args:         x: list of lists       Returns:         flat list              As per     http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python      \"\"\"  # noqa     return [item for sublist in x for item in sublist]", "target": 0, "target_options": ["no match", "match"]}
{"input": "fetch month from date object python [SEP] def str_to_date(date: str) -> datetime.datetime:     \"\"\" Convert cbr.ru API date ste to python datetime      :param date: date from API response      :return: date like datetime     :rtype: datetime     \"\"\"     date = date.split('.')     date.reverse()     y, m, d = date     return datetime.datetime(int(y), int(m), int(d))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "fetch month from date object python [SEP] def out(self, output, newline=True):         \"\"\"Outputs a string to the console (stdout).\"\"\"         click.echo(output, nl=newline)", "target": 0, "target_options": ["no match", "match"]}
{"input": "get value of an index in list in python [SEP] def index(self, item):         \"\"\" Not recommended for use on large lists due to time             complexity, but it works              -> #int list index of @item         \"\"\"         for i, x in enumerate(self.iter()):             if x == item:                 return i         return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get value of an index in list in python [SEP] def is_dimension(self):         \"\"\"Return true if the colum is a dimension\"\"\"         from ambry.valuetype.core import ROLE         return self.role == ROLE.DIMENSION", "target": 0, "target_options": ["no match", "match"]}
{"input": "get value of an index in list in python [SEP] def find(self, name):         \"\"\"Return the index of the toc entry with name NAME.             Return -1 for failure.\"\"\"         for i, nm in enumerate(self.data):             if nm[-1] == name:                 return i         return -1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get value of an index in list in python [SEP] def standard_input():     \"\"\"Generator that yields lines from standard input.\"\"\"     with click.get_text_stream(\"stdin\") as stdin:         while stdin.readable():             line = stdin.readline()             if line:                 yield line.strip().encode(\"utf-8\")", "target": 0, "target_options": ["no match", "match"]}
{"input": "function returns index position of thing in list python [SEP] def index(self, item):         \"\"\" Not recommended for use on large lists due to time             complexity, but it works              -> #int list index of @item         \"\"\"         for i, x in enumerate(self.iter()):             if x == item:                 return i         return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "function returns index position of thing in list python [SEP] def pivot(self):         \"\"\"         transposes rows and columns         \"\"\"         self.op_data = [list(i) for i in zip(*self.ip_data)]", "target": 0, "target_options": ["no match", "match"]}
{"input": "function returns index position of thing in list python [SEP] def getIndex(predicateFn: Callable[[T], bool], items: List[T]) -> int:     \"\"\"     Finds the index of an item in list, which satisfies predicate     :param predicateFn: predicate function to run on items of list     :param items: list of tuples     :return: first index for which predicate function returns True     \"\"\"     try:         return next(i for i, v in enumerate(items) if predicateFn(v))     except StopIteration:         return -1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "function returns index position of thing in list python [SEP] def be_array_from_bytes(fmt, data):     \"\"\"     Reads an array from bytestring with big-endian data.     \"\"\"     arr = array.array(str(fmt), data)     return fix_byteorder(arr)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python split list into lists by lenth [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python split list into lists by lenth [SEP] def py(self, output):         \"\"\"Output data as a nicely-formatted python data structure\"\"\"         import pprint         pprint.pprint(output, stream=self.outfile)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python split list into lists by lenth [SEP] def flatten_list(x: List[Any]) -> List[Any]:     \"\"\"     Converts a list of lists into a flat list.          Args:         x: list of lists       Returns:         flat list              As per     http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python      \"\"\"  # noqa     return [item for sublist in x for item in sublist]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python split list into lists by lenth [SEP] def path_for_import(name):     \"\"\"     Returns the directory path for the given package or module.     \"\"\"     return os.path.dirname(os.path.abspath(import_module(name).__file__))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python three dimensional rotation matrix [SEP] def quaternion_to_rotation_matrix(quaternion):     \"\"\"Compute the rotation matrix representated by the quaternion\"\"\"     c, x, y, z = quaternion     return np.array([         [c*c + x*x - y*y - z*z, 2*x*y - 2*c*z,         2*x*z + 2*c*y        ],         [2*x*y + 2*c*z,         c*c - x*x + y*y - z*z, 2*y*z - 2*c*x        ],         [2*x*z - 2*c*y,         2*y*z + 2*c*x,         c*c - x*x - y*y + z*z]     ], float)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python three dimensional rotation matrix [SEP] def url_read_text(url, verbose=True):     r\"\"\"     Directly reads text data from url     \"\"\"     data = url_read(url, verbose)     text = data.decode('utf8')     return text", "target": 0, "target_options": ["no match", "match"]}
{"input": "python three dimensional rotation matrix [SEP] def Ry_matrix(theta):     \"\"\"Rotation matrix around the Y axis\"\"\"     return np.array([         [np.cos(theta), 0, np.sin(theta)],         [0, 1, 0],         [-np.sin(theta), 0, np.cos(theta)]     ])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python three dimensional rotation matrix [SEP] def isstring(value):     \"\"\"Report whether the given value is a byte or unicode string.\"\"\"     classes = (str, bytes) if pyutils.PY3 else basestring  # noqa: F821     return isinstance(value, classes)", "target": 0, "target_options": ["no match", "match"]}
{"input": "validating network design with python [SEP] def firmware_download_input_rbridge_id(self, **kwargs):         \"\"\"Auto Generated Code         \"\"\"         config = ET.Element(\"config\")         firmware_download = ET.Element(\"firmware_download\")         config = firmware_download         input = ET.SubElement(firmware_download, \"input\")         rbridge_id = ET.SubElement(input, \"rbridge-id\")         rbridge_id.text = kwargs.pop('rbridge_id')          callback = kwargs.pop('callback', self._callback)         return callback(config)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "validating network design with python [SEP] def strToBool(val):     \"\"\"     Helper function to turn a string representation of \"true\" into     boolean True.     \"\"\"     if isinstance(val, str):         val = val.lower()      return val in ['true', 'on', 'yes', True]", "target": 0, "target_options": ["no match", "match"]}
{"input": "validating network design with python [SEP] def nas_server_ip_server_ip(self, **kwargs):         \"\"\"Auto Generated Code         \"\"\"         config = ET.Element(\"config\")         nas = ET.SubElement(config, \"nas\", xmlns=\"urn:brocade.com:mgmt:brocade-qos\")         server_ip = ET.SubElement(nas, \"server-ip\")         server_ip = ET.SubElement(server_ip, \"server-ip\")         server_ip.text = kwargs.pop('server_ip')          callback = kwargs.pop('callback', self._callback)         return callback(config)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "validating network design with python [SEP] def contains_empty(features):     \"\"\"Check features data are not empty      :param features: The features data to check.     :type features: list of numpy arrays.      :return: True if one of the array is empty, False else.      \"\"\"     if not features:         return True     for feature in features:         if feature.shape[0] == 0:             return True     return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to multiply with floats in python [SEP] def convert(self, value, units, newunits):         \"\"\"         Converts a value expressed in certain *units* to a new units.         \"\"\"         return value * self._units[units] / self._units[newunits]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to multiply with floats in python [SEP] def unpunctuate(s, *, char_blacklist=string.punctuation):     \"\"\" Remove punctuation from string s. \"\"\"     # remove punctuation     s = \"\".join(c for c in s if c not in char_blacklist)     # remove consecutive spaces     return \" \".join(filter(None, s.split(\" \")))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to multiply with floats in python [SEP] def unit_net_value(self):         \"\"\"         [float] 实时净值         \"\"\"         if self._units == 0:             return np.nan         return self.total_value / self._units", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to multiply with floats in python [SEP] def skip_connection_distance(a, b):     \"\"\"The distance between two skip-connections.\"\"\"     if a[2] != b[2]:         return 1.0     len_a = abs(a[1] - a[0])     len_b = abs(b[1] - b[0])     return (abs(a[0] - b[0]) + abs(len_a - len_b)) / (max(a[0], b[0]) + max(len_a, len_b))", "target": 0, "target_options": ["no match", "match"]}
{"input": "return the value of the diaganol matrix python [SEP] def lengths( self ):         \"\"\"         The cell lengths.          Args:             None          Returns:             (np.array(a,b,c)): The cell lengths.         \"\"\"         return( np.array( [ math.sqrt( sum( row**2 ) ) for row in self.matrix ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return the value of the diaganol matrix python [SEP] def safe_delete(filename):   \"\"\"Delete a file safely. If it's not present, no-op.\"\"\"   try:     os.unlink(filename)   except OSError as e:     if e.errno != errno.ENOENT:       raise", "target": 0, "target_options": ["no match", "match"]}
{"input": "return the value of the diaganol matrix python [SEP] def get_magnitude_squared(self):         \"\"\"Returns the square of the magnitude of this vector.\"\"\"         return self.x*self.x + self.y*self.y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return the value of the diaganol matrix python [SEP] def get_list_index(lst, index_or_name):     \"\"\"     Return the index of an element in the list.      Args:         lst (list): The list.         index_or_name (int or str): The value of the reference element, or directly its numeric index.      Returns:         (int) The index of the element in the list.     \"\"\"     if isinstance(index_or_name, six.integer_types):         return index_or_name      return lst.index(index_or_name)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python file exists in directory [SEP] def _pip_exists(self):         \"\"\"Returns True if pip exists inside the virtual environment. Can be         used as a naive way to verify that the environment is installed.\"\"\"         return os.path.isfile(os.path.join(self.path, 'bin', 'pip'))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python file exists in directory [SEP] def ytickvals(self, values, index=1):         \"\"\"Set the tick values.          Parameters         ----------         values : array-like          Returns         -------         Chart          \"\"\"         self.layout['yaxis' + str(index)]['tickvals'] = values         return self", "target": 0, "target_options": ["no match", "match"]}
{"input": "python file exists in directory [SEP] def is_executable(path):   \"\"\"Returns whether a path names an existing executable file.\"\"\"   return os.path.isfile(path) and os.access(path, os.X_OK)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python file exists in directory [SEP] def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:     \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"     for line in file_like:         line = line.rstrip('\\r\\n')         if line:             yield line", "target": 0, "target_options": ["no match", "match"]}
{"input": "python dict to yaml [SEP] def print_yaml(o):     \"\"\"Pretty print an object as YAML.\"\"\"     print(yaml.dump(o, default_flow_style=False, indent=4, encoding='utf-8'))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python dict to yaml [SEP] def test(*args):     \"\"\"     Run unit tests.     \"\"\"     subprocess.call([\"py.test-2.7\"] + list(args))     subprocess.call([\"py.test-3.4\"] + list(args))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python dict to yaml [SEP] def yaml_to_param(obj, name): \t\"\"\" \tReturn the top-level element of a document sub-tree containing the \tYAML serialization of a Python object. \t\"\"\" \treturn from_pyvalue(u\"yaml:%s\" % name, unicode(yaml.dump(obj)))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python dict to yaml [SEP] def check_auth(email, password):     \"\"\"Check if a username/password combination is valid.     \"\"\"     try:         user = User.get(User.email == email)     except User.DoesNotExist:         return False     return password == user.password", "target": 0, "target_options": ["no match", "match"]}
{"input": "remove key/value from dict python [SEP] def _remove_dict_keys_with_value(dict_, val):   \"\"\"Removes `dict` keys which have have `self` as value.\"\"\"   return {k: v for k, v in dict_.items() if v is not val}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove key/value from dict python [SEP] def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value", "target": 0, "target_options": ["no match", "match"]}
{"input": "remove key/value from dict python [SEP] def rm_keys_from_dict(d, keys):     \"\"\"     Given a dictionary and a key list, remove any data in the dictionary with the given keys.      :param dict d: Metadata     :param list keys: Keys to be removed     :return dict d: Metadata     \"\"\"     # Loop for each key given     for key in keys:         # Is the key in the dictionary?         if key in d:             try:                 d.pop(key, None)             except KeyError:                 # Not concerned with an error. Keep going.                 pass     return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove key/value from dict python [SEP] def sflow_sample_rate(self, **kwargs):         \"\"\"Auto Generated Code         \"\"\"         config = ET.Element(\"config\")         sflow = ET.SubElement(config, \"sflow\", xmlns=\"urn:brocade.com:mgmt:brocade-sflow\")         sample_rate = ET.SubElement(sflow, \"sample-rate\")         sample_rate.text = kwargs.pop('sample_rate')          callback = kwargs.pop('callback', self._callback)         return callback(config)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python hyphen in forlder names [SEP] def classnameify(s):   \"\"\"   Makes a classname   \"\"\"   return ''.join(w if w in ACRONYMS else w.title() for w in s.split('_'))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python hyphen in forlder names [SEP] def remove(self, item):         \"\"\"Remove the first occurence of an item, the caseless way.\"\"\"         for entry in self:             if item.lower() == entry.lower():                 list.remove(self, entry)                 return         raise ValueError(': list.remove(x): x not in list')", "target": 0, "target_options": ["no match", "match"]}
{"input": "python hyphen in forlder names [SEP] def to_pascal_case(s):     \"\"\"Transform underscore separated string to pascal case      \"\"\"     return re.sub(r'(?!^)_([a-zA-Z])', lambda m: m.group(1).upper(), s.capitalize())", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python hyphen in forlder names [SEP] def lowpass(data,filterSize=None):     \"\"\"     minimal complexity low-pass filtering.     Filter size is how \"wide\" the filter will be.     Sigma will be 1/10 of this filter width.     If filter size isn't given, it will be 1/10 of the data size.     \"\"\"     if filterSize is None:         filterSize=len(data)/10     kernel=kernel_gaussian(size=filterSize)     data=convolve(data,kernel) # do the convolution with padded edges     return data", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to change delimiter in big csv file python [SEP] def csvpretty(csvfile: csvfile=sys.stdin):     \"\"\" Pretty print a CSV file. \"\"\"     shellish.tabulate(csv.reader(csvfile))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to change delimiter in big csv file python [SEP] def sflow_sample_rate(self, **kwargs):         \"\"\"Auto Generated Code         \"\"\"         config = ET.Element(\"config\")         sflow = ET.SubElement(config, \"sflow\", xmlns=\"urn:brocade.com:mgmt:brocade-sflow\")         sample_rate = ET.SubElement(sflow, \"sample-rate\")         sample_rate.text = kwargs.pop('sample_rate')          callback = kwargs.pop('callback', self._callback)         return callback(config)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to change delimiter in big csv file python [SEP] def csv_dict_writer(f, fieldnames, **kwargs):     \"\"\"Equivalent of csv.DictWriter, but allows `delimiter` to be a unicode string on Py2.\"\"\"     import csv     if \"delimiter\" in kwargs:         kwargs[\"delimiter\"] = str(kwargs[\"delimiter\"])     return csv.DictWriter(f, fieldnames, **kwargs)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to change delimiter in big csv file python [SEP] def addSubparser(subparsers, subcommand, description):     \"\"\"     Add a subparser with subcommand to the subparsers object     \"\"\"     parser = subparsers.add_parser(         subcommand, description=description, help=description)     return parser", "target": 0, "target_options": ["no match", "match"]}
{"input": "python write out hex values [SEP] def hex_to_rgb(h):     \"\"\" Returns 0 to 1 rgb from a hex list or tuple \"\"\"     h = h.lstrip('#')     return tuple(int(h[i:i+2], 16)/255. for i in (0, 2 ,4))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python write out hex values [SEP] def timespan(start_time):     \"\"\"Return time in milliseconds from start_time\"\"\"      timespan = datetime.datetime.now() - start_time     timespan_ms = timespan.total_seconds() * 1000     return timespan_ms", "target": 0, "target_options": ["no match", "match"]}
{"input": "python write out hex values [SEP] def hex2rgb(value):     \"\"\"Converts a hexadeximal color string to an RGB 3-tuple      EXAMPLE     -------     >>> hex2rgb('#0000FF')     (0, 0, 255)     \"\"\"     value = value.lstrip('#')     lv = len(value)     return tuple(int(value[i:i+lv//3], 16) for i in range(0, lv, lv//3))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python write out hex values [SEP] def size(self):         \"\"\"Total number of grid points.\"\"\"         # Since np.prod(()) == 1.0 we need to handle that by ourselves         return (0 if self.shape == () else                 int(np.prod(self.shape, dtype='int64')))", "target": 0, "target_options": ["no match", "match"]}
{"input": "graph a line between two points python [SEP] def _linepoint(self, t, x0, y0, x1, y1):         \"\"\" Returns coordinates for point at t on the line.             Calculates the coordinates of x and y for a point at t on a straight line.             The t parameter is a number between 0.0 and 1.0,             x0 and y0 define the starting point of the line,             x1 and y1 the ending point of the line.         \"\"\"         # Originally from nodebox-gl         out_x = x0 + t * (x1 - x0)         out_y = y0 + t * (y1 - y0)         return (out_x, out_y)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "graph a line between two points python [SEP] def url_read_text(url, verbose=True):     r\"\"\"     Directly reads text data from url     \"\"\"     data = url_read(url, verbose)     text = data.decode('utf8')     return text", "target": 0, "target_options": ["no match", "match"]}
{"input": "graph a line between two points python [SEP] def spline_interpolate(x1, y1, x2):     \"\"\"     Given a function at a set of points (x1, y1), interpolate to     evaluate it at points x2.     \"\"\"     sp = Spline(x1, y1)     return sp(x2)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "graph a line between two points python [SEP] def __isListOfTexts(self, docs):         \"\"\" Checks whether the input is a list of strings or Text-s;          \"\"\"         return isinstance(docs, list) and \\                all(isinstance(d, (basestring, Text)) for d in docs)", "target": 0, "target_options": ["no match", "match"]}
{"input": "read values from a file in a two dimensional array python [SEP] def ReadTif(tifFile):         \"\"\"Reads a tif file to a 2D NumPy array\"\"\"         img = Image.open(tifFile)         img = np.array(img)         return img", "target": 1, "target_options": ["no_match", "match"]}
{"input": "read values from a file in a two dimensional array python [SEP] def _linepoint(self, t, x0, y0, x1, y1):         \"\"\" Returns coordinates for point at t on the line.             Calculates the coordinates of x and y for a point at t on a straight line.             The t parameter is a number between 0.0 and 1.0,             x0 and y0 define the starting point of the line,             x1 and y1 the ending point of the line.         \"\"\"         # Originally from nodebox-gl         out_x = x0 + t * (x1 - x0)         out_y = y0 + t * (y1 - y0)         return (out_x, out_y)", "target": 0, "target_options": ["no match", "match"]}
{"input": "read values from a file in a two dimensional array python [SEP] def read_mm_header(fd, byte_order, dtype, count):     \"\"\"Read MM_HEADER tag from file and return as numpy.rec.array.\"\"\"     return numpy.rec.fromfile(fd, MM_HEADER, 1, byteorder=byte_order)[0]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "read values from a file in a two dimensional array python [SEP] def remove_dups(seq):     \"\"\"remove duplicates from a sequence, preserving order\"\"\"     seen = set()     seen_add = seen.add     return [x for x in seq if not (x in seen or seen_add(x))]", "target": 0, "target_options": ["no match", "match"]}
{"input": "length of two dimensional array python [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "length of two dimensional array python [SEP] def _timed_process(self, *args, **kwargs):         \"\"\"Track Processor execution time for benchmarking.\"\"\"         for processor in self._processors:             start_time = _time.process_time()             processor.process(*args, **kwargs)             process_time = int(round((_time.process_time() - start_time) * 1000, 2))             self.process_times[processor.__class__.__name__] = process_time", "target": 0, "target_options": ["no match", "match"]}
{"input": "length of two dimensional array python [SEP] def length(self):         \"\"\"Array of vector lengths\"\"\"         return np.sqrt(np.sum(self**2, axis=1)).view(np.ndarray)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "length of two dimensional array python [SEP] def basic():     \"\"\"Set up a basic stereonet and plot the same data each time.\"\"\"     fig, ax = mplstereonet.subplots()      strike, dip = 315, 30     ax.plane(strike, dip, color='lightblue')     ax.pole(strike, dip, color='green', markersize=15)     ax.rake(strike, dip, 40, marker='*', markersize=20, color='green')      # Make a bit of room for the title...     fig.subplots_adjust(top=0.8)      return ax", "target": 0, "target_options": ["no match", "match"]}
{"input": "enforcing input length in python [SEP] def length(length):     \"\"\"Checks value for minimum length using len().\"\"\"     def min_len(value):         if not len(value) >= length:             raise ValueError(                 \"Minimum length is {0} but value is {1}\".format(length, len(value))             )         return True      return min_len", "target": 1, "target_options": ["no_match", "match"]}
{"input": "enforcing input length in python [SEP] def _stdin_(p):     \"\"\"Takes input from user. Works for Python 2 and 3.\"\"\"     _v = sys.version[0]     return input(p) if _v is '3' else raw_input(p)", "target": 0, "target_options": ["no match", "match"]}
{"input": "enforcing input length in python [SEP] def __len__(self):         \"\"\" This will equal 124 for the V1 database. \"\"\"         length = 0         for typ, siz, _ in self.format:             length += siz         return length", "target": 1, "target_options": ["no_match", "match"]}
{"input": "enforcing input length in python [SEP] def __contains__(self, key):         \"\"\" Tests if a key is contained in the store.              May test againsts self.defaults              :param str value: Value         \"\"\"         if self._haveKey(key) or key in self.defaults:             return True         else:             return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to compare the percentage of matches of two datasets python [SEP] def tanimoto_set_similarity(x: Iterable[X], y: Iterable[X]) -> float:     \"\"\"Calculate the tanimoto set similarity.\"\"\"     a, b = set(x), set(y)     union = a | b      if not union:         return 0.0      return len(a & b) / len(union)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to compare the percentage of matches of two datasets python [SEP] def stringify_dict_contents(dct):     \"\"\"Turn dict keys and values into native strings.\"\"\"     return {         str_if_nested_or_str(k): str_if_nested_or_str(v)         for k, v in dct.items()     }", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to compare the percentage of matches of two datasets python [SEP] def _sim_colour(r1, r2):     \"\"\"         calculate the sum of histogram intersection of colour     \"\"\"     return sum([min(a, b) for a, b in zip(r1[\"hist_c\"], r2[\"hist_c\"])])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to compare the percentage of matches of two datasets python [SEP] def sub(name, func,**kwarg):     \"\"\" Add subparser      \"\"\"     sp = subparsers.add_parser(name, **kwarg)     sp.set_defaults(func=func)     sp.arg = sp.add_argument     return sp", "target": 0, "target_options": ["no match", "match"]}
{"input": "python rotation matrix from axis angle 3d [SEP] def rotate_2D(angle):     \"\"\"     Returns a 2x2 transformation matrix to rotate     by an angle in two dimensions     \"\"\"     return N.array([[N.cos(angle),-N.sin(angle)],                     [N.sin(angle),N.cos(angle)]])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python rotation matrix from axis angle 3d [SEP] def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value", "target": 0, "target_options": ["no match", "match"]}
{"input": "python rotation matrix from axis angle 3d [SEP] def create_rot2d(angle):     \"\"\"Create 2D rotation matrix\"\"\"     ca = math.cos(angle)     sa = math.sin(angle)     return np.array([[ca, -sa], [sa, ca]])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python rotation matrix from axis angle 3d [SEP] def gpp(argv=None):     \"\"\"Shortcut function for running the previewing command.\"\"\"     if argv is None:         argv = sys.argv[1:]     argv.insert(0, 'preview')     return main(argv)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to combine 2 lists and make 1 list in python [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to combine 2 lists and make 1 list in python [SEP] def normalize(data):     \"\"\"     Function to normalize data to have mean 0 and unity standard deviation     (also called z-transform)               Parameters     ----------     data : numpy.ndarray               Returns     -------     numpy.ndarray         z-transform of input array          \"\"\"     data = data.astype(float)     data -= data.mean()          return data / data.std()", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to combine 2 lists and make 1 list in python [SEP] def _fill_array_from_list(the_list, the_array):         \"\"\"Fill an `array` from a `list`\"\"\"         for i, val in enumerate(the_list):             the_array[i] = val         return the_array", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to combine 2 lists and make 1 list in python [SEP] def normalize_path(filename):     \"\"\"Normalize a file/dir name for comparison purposes\"\"\"     return os.path.normcase(os.path.realpath(os.path.normpath(_cygwin_patch(filename))))", "target": 0, "target_options": ["no match", "match"]}
{"input": "using variance for 2d array in python [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "using variance for 2d array in python [SEP] def pivot(self):         \"\"\"         transposes rows and columns         \"\"\"         self.op_data = [list(i) for i in zip(*self.ip_data)]", "target": 0, "target_options": ["no match", "match"]}
{"input": "using variance for 2d array in python [SEP] def torecarray(*args, **kwargs):     \"\"\"     Convenient shorthand for ``toarray(*args, **kwargs).view(np.recarray)``.      \"\"\"      import numpy as np     return toarray(*args, **kwargs).view(np.recarray)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "using variance for 2d array in python [SEP] def fit(self, X):         \"\"\" Apply KMeans Clustering               X: dataset with feature vectors         \"\"\"         self.centers_, self.labels_, self.sse_arr_, self.n_iter_ = \\               _kmeans(X, self.n_clusters, self.max_iter, self.n_trials, self.tol)", "target": 0, "target_options": ["no match", "match"]}
{"input": "check that all of the elements in an array are greater than zero python nympy [SEP] def is_square_matrix(mat):     \"\"\"Test if an array is a square matrix.\"\"\"     mat = np.array(mat)     if mat.ndim != 2:         return False     shape = mat.shape     return shape[0] == shape[1]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check that all of the elements in an array are greater than zero python nympy [SEP] def show_help(self):         \"\"\"Prints to stdout help on how to answer properly\"\"\"         print(\"Sorry, not well understood.\")         print(\"- use\", str(self.yes_input), \"to answer 'YES'\")         print(\"- use\", str(self.no_input), \"to answer 'NO'\")", "target": 0, "target_options": ["no match", "match"]}
{"input": "check that all of the elements in an array are greater than zero python nympy [SEP] def is_bool_matrix(l):     r\"\"\"Checks if l is a 2D numpy array of bools      \"\"\"     if isinstance(l, np.ndarray):         if l.ndim == 2 and (l.dtype == bool):             return True     return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check that all of the elements in an array are greater than zero python nympy [SEP] def rgba_bytes_tuple(self, x):         \"\"\"Provides the color corresponding to value `x` in the         form of a tuple (R,G,B,A) with int values between 0 and 255.         \"\"\"         return tuple(int(u*255.9999) for u in self.rgba_floats_tuple(x))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python randomely divide a dataset into 5 [SEP] def __split_every_n(self, n, data):         \"\"\"         \"\"\"         return [data[i:i+n] for i in range(0, len(data), n)]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python randomely divide a dataset into 5 [SEP] def register_logging_factories(loader):     \"\"\"     Registers default factories for logging standard package.      :param loader: Loader where you want register default logging factories     \"\"\"     loader.register_factory(logging.Logger, LoggerFactory)     loader.register_factory(logging.Handler, LoggingHandlerFactory)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python randomely divide a dataset into 5 [SEP] def chunked(iterable, n):     \"\"\"Break an iterable into lists of a given length::          >>> list(chunked([1, 2, 3, 4, 5, 6, 7], 3))         [[1, 2, 3], [4, 5, 6], [7]]      If the length of ``iterable`` is not evenly divisible by ``n``, the last     returned list will be shorter.      This is useful for splitting up a computation on a large number of keys     into batches, to be pickled and sent off to worker processes. One example     is operations on rows in MySQL, which does not implement server-side     cursors properly and would otherwise load the entire dataset into RAM on     the client.          Taken from more_itertools      \"\"\"     return iter(functools.partial(take, n, iter(iterable)), [])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python randomely divide a dataset into 5 [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 0, "target_options": ["no match", "match"]}
{"input": "stackoverflow python how to read text file and print without \\n [SEP] def lint_file(in_file, out_file=None):     \"\"\"Helps remove extraneous whitespace from the lines of a file      :param file in_file: A readable file or file-like     :param file out_file: A writable file or file-like     \"\"\"     for line in in_file:         print(line.strip(), file=out_file)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "stackoverflow python how to read text file and print without \\n [SEP] def divide(x: LispNumber, y: LispNumber) -> LispNumber:     \"\"\"Division reducer. If both arguments are integers, return a Fraction.     Otherwise, return the true division of x and y.\"\"\"     if isinstance(x, int) and isinstance(y, int):         return Fraction(x, y)     return x / y", "target": 0, "target_options": ["no match", "match"]}
{"input": "stackoverflow python how to read text file and print without \\n [SEP] def stdout_display():     \"\"\" Print results straight to stdout \"\"\"     if sys.version_info[0] == 2:         yield SmartBuffer(sys.stdout)     else:         yield SmartBuffer(sys.stdout.buffer)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "stackoverflow python how to read text file and print without \\n [SEP] def is_bool_matrix(l):     r\"\"\"Checks if l is a 2D numpy array of bools      \"\"\"     if isinstance(l, np.ndarray):         if l.ndim == 2 and (l.dtype == bool):             return True     return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "union of two dictionaries in python [SEP] def dict_merge(set1, set2):     \"\"\"Joins two dictionaries.\"\"\"     return dict(list(set1.items()) + list(set2.items()))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "union of two dictionaries in python [SEP] def Counter64(a, b, delta):     \"\"\"64bit counter aggregator with wrapping     \"\"\"     if b < a:         c = 18446744073709551615 - a         return (c + b) / float(delta)      return (b - a) / float(delta)", "target": 0, "target_options": ["no match", "match"]}
{"input": "union of two dictionaries in python [SEP] def union(self, other):         \"\"\"produce a 'union' of this dict and another (at the key level).          values in the second dict take precedence over that of the first\"\"\"         x = SetLikeDict(**self)         x.update(other)         return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "union of two dictionaries in python [SEP] def get_indexes(self, schema, **kwargs):         \"\"\"         get all the indexes          schema -- Schema()          return -- dict -- the indexes in {indexname: fields} format         \"\"\"         with self.connection(**kwargs) as connection:             kwargs['connection'] = connection             return self._get_indexes(schema, **kwargs)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python multiply all elements of list [SEP] def flatten_list(x: List[Any]) -> List[Any]:     \"\"\"     Converts a list of lists into a flat list.          Args:         x: list of lists       Returns:         flat list              As per     http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python      \"\"\"  # noqa     return [item for sublist in x for item in sublist]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python multiply all elements of list [SEP] def close(self):         \"\"\"Close the file and restore the channel.\"\"\"         self.flush()         setattr(sys, self.channel, self.ostream)         self.file.close()         self._closed = True", "target": 0, "target_options": ["no match", "match"]}
{"input": "python multiply all elements of list [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python multiply all elements of list [SEP] def get_value_tuple(self):         \"\"\"         Returns a tuple of the color's values (in order). For example,         an LabColor object will return (lab_l, lab_a, lab_b), where each         member of the tuple is the float value for said variable.         \"\"\"         retval = tuple()         for val in self.VALUES:             retval += (getattr(self, val),)         return retval", "target": 0, "target_options": ["no match", "match"]}
{"input": "latitude longitude height azimuth pitch distance python [SEP] def theta(v):     \"\"\"Neutrino direction in polar coordinates.      Downgoing event: theta = 180deg     Horizont: 90deg     Upgoing: theta = 0      Angles in radians.     \"\"\"     v = np.atleast_2d(v)     dir_z = v[:, 2]     return theta_separg(dir_z)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "latitude longitude height azimuth pitch distance python [SEP] def length(length):     \"\"\"Checks value for minimum length using len().\"\"\"     def min_len(value):         if not len(value) >= length:             raise ValueError(                 \"Minimum length is {0} but value is {1}\".format(length, len(value))             )         return True      return min_len", "target": 0, "target_options": ["no match", "match"]}
{"input": "latitude longitude height azimuth pitch distance python [SEP] def _num2deg(self, tile):         \"\"\" Taken from http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#Python \"\"\"         n = 2.0 ** tile.zoom         lon_deg = tile.x / n * 360.0 - 180.0         lat_rad = mod_math.atan(mod_math.sinh(mod_math.pi * (1 - 2 * tile.y / n)))         lat_deg = mod_math.degrees(lat_rad)         return (lat_deg, lon_deg)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "latitude longitude height azimuth pitch distance python [SEP] def terminate_pool(self):         \"\"\"Terminate and close the multiprocessing pool if necessary.\"\"\"          if self.pool is not None:             self.pool.terminate()             self.pool.join()             del(self.pool)             self.pool = None", "target": 0, "target_options": ["no match", "match"]}
{"input": "python split string on comma sometimes space [SEP] def _str_to_list(s):     \"\"\"Converts a comma separated string to a list\"\"\"     _list = s.split(\",\")     return list(map(lambda i: i.lstrip(), _list))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python split string on comma sometimes space [SEP] def dict_merge(set1, set2):     \"\"\"Joins two dictionaries.\"\"\"     return dict(list(set1.items()) + list(set2.items()))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python split string on comma sometimes space [SEP] def string_to_list(string, sep=\",\", filter_empty=False):     \"\"\"Transforma una string con elementos separados por `sep` en una lista.\"\"\"     return [value.strip() for value in string.split(sep)             if (not filter_empty or value)]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python split string on comma sometimes space [SEP] def column_stack_2d(data):     \"\"\"Perform column-stacking on a list of 2d data blocks.\"\"\"     return list(list(itt.chain.from_iterable(_)) for _ in zip(*data))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to remove integers from string python [SEP] def str2int(string_with_int):     \"\"\" Collect digits from a string \"\"\"     return int(\"\".join([char for char in string_with_int if char in string.digits]) or 0)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to remove integers from string python [SEP] def flushed_print(*args, **kwargs):     \"\"\"     Use to replace print(*args, flush=True) that doesn't exist for python<3.3     \"\"\"     print(*args, **kwargs)     file = kwargs.get('file', sys.stdout)     file.flush() if file is not None else sys.stdout.flush()", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to remove integers from string python [SEP] def get_numbers(s):     \"\"\"Extracts all integers from a string an return them in a list\"\"\"      result = map(int, re.findall(r'[0-9]+', unicode(s)))     return result + [1] * (2 - len(result))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to remove integers from string python [SEP] def flatten_list(x: List[Any]) -> List[Any]:     \"\"\"     Converts a list of lists into a flat list.          Args:         x: list of lists       Returns:         flat list              As per     http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python      \"\"\"  # noqa     return [item for sublist in x for item in sublist]", "target": 0, "target_options": ["no match", "match"]}
{"input": "with open file python automatic close [SEP] def close(self):         \"\"\"Close the file and restore the channel.\"\"\"         self.flush()         setattr(sys, self.channel, self.ostream)         self.file.close()         self._closed = True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "with open file python automatic close [SEP] def kill_mprocess(process):     \"\"\"kill process     Args:         process - Popen object for process     \"\"\"     if process and proc_alive(process):         process.terminate()         process.communicate()     return not proc_alive(process)", "target": 0, "target_options": ["no match", "match"]}
{"input": "with open file python automatic close [SEP] def __exit__(self, type, value, traceback):         \"\"\"When the `with` statement ends.\"\"\"          if not self.asarfile:             return          self.asarfile.close()         self.asarfile = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "with open file python automatic close [SEP] def Counter64(a, b, delta):     \"\"\"64bit counter aggregator with wrapping     \"\"\"     if b < a:         c = 18446744073709551615 - a         return (c + b) / float(delta)      return (b - a) / float(delta)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python check file permission in windows [SEP] def add_exec_permission_to(target_file):     \"\"\"Add executable permissions to the file      :param target_file: the target file whose permission to be changed     \"\"\"     mode = os.stat(target_file).st_mode     os.chmod(target_file, mode | stat.S_IXUSR)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python check file permission in windows [SEP] def argument_search(self):         \"\"\"             Uses the command line arguments to fill the search function and call it.         \"\"\"         arguments, _ = self.argparser.parse_known_args()         return self.search(**vars(arguments))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python check file permission in windows [SEP] def chmod_add_excute(filename):         \"\"\"         Adds execute permission to file.         :param filename:         :return:         \"\"\"         st = os.stat(filename)         os.chmod(filename, st.st_mode | stat.S_IEXEC)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python check file permission in windows [SEP] def strip_non_ascii(s):     \"\"\"     Returns the string without non-ASCII characters.      Parameters     ----------     string : string         A string that may contain non-ASCII characters.      Returns     -------     clean_string : string         A string that does not contain non-ASCII characters.      \"\"\"     stripped = (c for c in s if 0 < ord(c) < 127)     clean_string = u''.join(stripped)     return clean_string", "target": 0, "target_options": ["no match", "match"]}
{"input": "if a number is true python [SEP] def is_natural(x):     \"\"\"A non-negative integer.\"\"\"     try:         is_integer = int(x) == x     except (TypeError, ValueError):         return False     return is_integer and x >= 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "if a number is true python [SEP] def fit(self, X):         \"\"\" Apply KMeans Clustering               X: dataset with feature vectors         \"\"\"         self.centers_, self.labels_, self.sse_arr_, self.n_iter_ = \\               _kmeans(X, self.n_clusters, self.max_iter, self.n_trials, self.tol)", "target": 0, "target_options": ["no match", "match"]}
{"input": "if a number is true python [SEP] def is_int(value):     \"\"\"Return `True` if ``value`` is an integer.\"\"\"     if isinstance(value, bool):         return False     try:         int(value)         return True     except (ValueError, TypeError):         return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "if a number is true python [SEP] def length(self):         \"\"\"Array of vector lengths\"\"\"         return np.sqrt(np.sum(self**2, axis=1)).view(np.ndarray)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python draw kmean graph [SEP] def kernel_shap_1000_meanref(model, data):     \"\"\" Kernel SHAP 1000 mean ref.     color = red_blue_circle(0.5)     linestyle = solid     \"\"\"     return lambda X: KernelExplainer(model.predict, kmeans(data, 1)).shap_values(X, nsamples=1000, l1_reg=0)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python draw kmean graph [SEP] def to_pascal_case(s):     \"\"\"Transform underscore separated string to pascal case      \"\"\"     return re.sub(r'(?!^)_([a-zA-Z])', lambda m: m.group(1).upper(), s.capitalize())", "target": 0, "target_options": ["no match", "match"]}
{"input": "python draw kmean graph [SEP] def fit(self, X):         \"\"\" Apply KMeans Clustering               X: dataset with feature vectors         \"\"\"         self.centers_, self.labels_, self.sse_arr_, self.n_iter_ = \\               _kmeans(X, self.n_clusters, self.max_iter, self.n_trials, self.tol)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python draw kmean graph [SEP] def resize(src, size, interpolation=cv2.INTER_LINEAR):     \"\"\"Decode image from str buffer.     Wrapper for cv2.imresize that uses mx.nd.NDArray      Parameters     ----------     src : NDArray         image in (width, height, channels)     size : tuple         target size in (width, height)     interpolation : int         same as interpolation for cv2.imresize      Returns     -------     img : NDArray         resized image     \"\"\"     hdl = NDArrayHandle()     check_call(_LIB.MXCVResize(src.handle, mx_uint(size[0]), mx_uint(size[1]),                                interpolation, ctypes.byref(hdl)))     return mx.nd.NDArray(hdl)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python turn a datetime object into naiv [SEP] def timestamp_to_datetime(timestamp):     \"\"\"Convert an ARF timestamp to a datetime.datetime object (naive local time)\"\"\"     from datetime import datetime, timedelta     obj = datetime.fromtimestamp(timestamp[0])     return obj + timedelta(microseconds=int(timestamp[1]))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python turn a datetime object into naiv [SEP] def end(self):         \"\"\"Generate the closing part\"\"\"         for depth in xrange(len(self.names) - 1, -1, -1):             self.out_f.write('{0}}}\\n'.format(self.prefix(depth)))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python turn a datetime object into naiv [SEP] def convert_timestamp(timestamp):     \"\"\"     Converts bokehJS timestamp to datetime64.     \"\"\"     datetime = dt.datetime.utcfromtimestamp(timestamp/1000.)     return np.datetime64(datetime.replace(tzinfo=None))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python turn a datetime object into naiv [SEP] def reduce_multiline(string):     \"\"\"     reduces a multiline string to a single line of text.       args:         string: the text to reduce     \"\"\"     string = str(string)     return \" \".join([item.strip()                      for item in string.split(\"\\n\")                      if item.strip()])", "target": 0, "target_options": ["no match", "match"]}
{"input": "python iterate throguh list of strings [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python iterate throguh list of strings [SEP] def extent(self):          \"\"\"         return range of 2D data         \"\"\"          return [min(self.x), max(self.x), min(self.y), max(self.y)]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python iterate throguh list of strings [SEP] def _str_to_list(s):     \"\"\"Converts a comma separated string to a list\"\"\"     _list = s.split(\",\")     return list(map(lambda i: i.lstrip(), _list))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python iterate throguh list of strings [SEP] def unpunctuate(s, *, char_blacklist=string.punctuation):     \"\"\" Remove punctuation from string s. \"\"\"     # remove punctuation     s = \"\".join(c for c in s if c not in char_blacklist)     # remove consecutive spaces     return \" \".join(filter(None, s.split(\" \")))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python 2 compare float to str [SEP] def _tofloat(obj):     \"\"\"Convert to float if object is a float string.\"\"\"     if \"inf\" in obj.lower().strip():         return obj     try:         return int(obj)     except ValueError:         try:             return float(obj)         except ValueError:             return obj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python 2 compare float to str [SEP] def clean(s):   \"\"\"Removes trailing whitespace on each line.\"\"\"   lines = [l.rstrip() for l in s.split('\\n')]   return '\\n'.join(lines)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python 2 compare float to str [SEP] def try_convert(value):         \"\"\"Convert value to a numeric value or raise a ValueError         if that isn't possible.          \"\"\"         convertible = ForceNumeric.is_convertible(value)         if not convertible or isinstance(value, bool):             raise ValueError         if isinstance(str(value), str):             return ForceNumeric.str_to_num(value)         return float(value)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python 2 compare float to str [SEP] def to_int(self):         \"\"\"Convert vector to an integer, if possible.          This is only useful for arrays filled with zero/one entries.         \"\"\"         num = self.to_uint()         if num and self._items[-1].unbox():             return num - (1 << self.size)         else:             return num", "target": 0, "target_options": ["no match", "match"]}
{"input": "python determine if an object is bytes or string [SEP] def is_string(obj):     \"\"\"Is this a string.      :param object obj:     :rtype: bool     \"\"\"     if PYTHON3:         str_type = (bytes, str)     else:         str_type = (bytes, str, unicode)     return isinstance(obj, str_type)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python determine if an object is bytes or string [SEP] def sliced(seq, n):     \"\"\"Yield slices of length *n* from the sequence *seq*.          >>> list(sliced((1, 2, 3, 4, 5, 6), 3))         [(1, 2, 3), (4, 5, 6)]      If the length of the sequence is not divisible by the requested slice     length, the last slice will be shorter.          >>> list(sliced((1, 2, 3, 4, 5, 6, 7, 8), 3))         [(1, 2, 3), (4, 5, 6), (7, 8)]      This function will only work for iterables that support slicing.     For non-sliceable iterables, see :func:`chunked`.      \"\"\"     return takewhile(bool, (seq[i: i + n] for i in count(0, n)))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python determine if an object is bytes or string [SEP] def isstring(value):     \"\"\"Report whether the given value is a byte or unicode string.\"\"\"     classes = (str, bytes) if pyutils.PY3 else basestring  # noqa: F821     return isinstance(value, classes)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python determine if an object is bytes or string [SEP] def downloadImg(url, tofile=None):     \"\"\"     \"\"\"     r = urllib2.Request(url)     img_data = urllib2.urlopen(r).read()     img_buffer = StringIO.StringIO(img_data)     img = Image.open(img_buffer)     if FILE.make and tofile is not None:         img.save(FILE.dir + tofile)     return img", "target": 0, "target_options": ["no match", "match"]}
{"input": "replace charter in file python [SEP] def replace_all(filepath, searchExp, replaceExp):     \"\"\"     Replace all the ocurrences (in a file) of a string with another value.     \"\"\"     for line in fileinput.input(filepath, inplace=1):         if searchExp in line:             line = line.replace(searchExp, replaceExp)         sys.stdout.write(line)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "replace charter in file python [SEP] def hex_to_rgb(h):     \"\"\" Returns 0 to 1 rgb from a hex list or tuple \"\"\"     h = h.lstrip('#')     return tuple(int(h[i:i+2], 16)/255. for i in (0, 2 ,4))", "target": 0, "target_options": ["no match", "match"]}
{"input": "replace charter in file python [SEP] def fix_header_comment(filename, timestamp):     \"\"\"Fixes the header-comment of the given file.\"\"\"     # Fix input file.     name = os.path.basename( filename )     for line in fileinput.input( filename, inplace=1, mode=\"rU\" ):         # If header-comment already contains anything for '$Id$', remove it.         line = re.sub(r'\\$Id:[^$]+\\$', r'$Id$', line.rstrip())         # Replace '$Id$' by a string containing the file's name (and a timestamp)!         line = re.sub(re.escape(r'$Id$'), r'$Id: ' + name + r' ' + timestamp.isoformat() + r' $', line.rstrip())         print(line)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "replace charter in file python [SEP] def load_file(self, input_file):         \"\"\" Loads data array from file (result of this converter)          Tries to import, load and replace files' data.         It will overwirte previously added items with #add_file or #load_file.          :param input_file         :type str or unicode         \"\"\"         pyimg = imp.load_source('image2py_taf', input_file)         self.files = pyimg.data         self.set_template(templates.templateByName(pyimg.template))", "target": 0, "target_options": ["no match", "match"]}
{"input": "turn list of string of numbers to in python [SEP] def int2str(num, radix=10, alphabet=BASE85):     \"\"\"helper function for quick base conversions from integers to strings\"\"\"     return NumConv(radix, alphabet).int2str(num)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "turn list of string of numbers to in python [SEP] def print_yaml(o):     \"\"\"Pretty print an object as YAML.\"\"\"     print(yaml.dump(o, default_flow_style=False, indent=4, encoding='utf-8'))", "target": 0, "target_options": ["no match", "match"]}
{"input": "turn list of string of numbers to in python [SEP] def try_cast_int(s):     \"\"\"(str) -> int     All the digits in a given string are concatenated and converted into a single number.     \"\"\"     try:         temp = re.findall('\\d', str(s))         temp = ''.join(temp)         return int(temp)     except:         return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "turn list of string of numbers to in python [SEP] def unique(list):     \"\"\" Returns a copy of the list without duplicates.     \"\"\"     unique = []; [unique.append(x) for x in list if x not in unique]     return unique", "target": 0, "target_options": ["no match", "match"]}
{"input": "python 3 read binary file 16 bytes at a time and finding eof [SEP] def eof(fd):     \"\"\"Determine if end-of-file is reached for file fd.\"\"\"     b = fd.read(1)     end = len(b) == 0     if not end:         curpos = fd.tell()         fd.seek(curpos - 1)     return end", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python 3 read binary file 16 bytes at a time and finding eof [SEP] def quaternion_to_rotation_matrix(quaternion):     \"\"\"Compute the rotation matrix representated by the quaternion\"\"\"     c, x, y, z = quaternion     return np.array([         [c*c + x*x - y*y - z*z, 2*x*y - 2*c*z,         2*x*z + 2*c*y        ],         [2*x*y + 2*c*z,         c*c - x*x + y*y - z*z, 2*y*z - 2*c*x        ],         [2*x*z - 2*c*y,         2*y*z + 2*c*x,         c*c - x*x - y*y + z*z]     ], float)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python 3 read binary file 16 bytes at a time and finding eof [SEP] def read_string(buff, byteorder='big'):     \"\"\"Read a string from a file-like object.\"\"\"     length = read_numeric(USHORT, buff, byteorder)     return buff.read(length).decode('utf-8')", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python 3 read binary file 16 bytes at a time and finding eof [SEP] def Join(self):     \"\"\"Waits until all outstanding tasks are completed.\"\"\"      for _ in range(self.JOIN_TIMEOUT_DECISECONDS):       if self._queue.empty() and not self.busy_threads:         return       time.sleep(0.1)      raise ValueError(\"Timeout during Join() for threadpool %s.\" % self.name)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to get index of maximum element in list in python [SEP] def MultiArgMax(x):   \"\"\"   Get tuple (actually a generator) of indices where the max value of   array x occurs. Requires that x have a max() method, as x.max()   (in the case of NumPy) is much faster than max(x).   For a simpler, faster argmax when there is only a single maximum entry,   or when knowing only the first index where the maximum occurs,   call argmax() on a NumPy array.    :param x: Any sequence that has a max() method.   :returns: Generator with the indices where the max value occurs.   \"\"\"   m = x.max()   return (i for i, v in enumerate(x) if v == m)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to get index of maximum element in list in python [SEP] def create_message(self, channel_id, text):         \"\"\"         Sends a message to a Discord channel or user via REST API          Args:             channel_id (string): ID of destingation Discord channel             text (string): Content of message         \"\"\"          baseurl = self.rest_baseurl + \\             '/channels/{}/messages'.format(channel_id)         requests.post(baseurl,                       headers=self.headers,                       data=json.dumps({'content': text}))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to get index of maximum element in list in python [SEP] def get_longest_orf(orfs):     \"\"\"Find longest ORF from the given list of ORFs.\"\"\"     sorted_orf = sorted(orfs, key=lambda x: len(x['sequence']), reverse=True)[0]     return sorted_orf", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to get index of maximum element in list in python [SEP] def is_dimension(self):         \"\"\"Return true if the colum is a dimension\"\"\"         from ambry.valuetype.core import ROLE         return self.role == ROLE.DIMENSION", "target": 0, "target_options": ["no match", "match"]}
{"input": "testing efficeny in python tonget the time of programs completion [SEP] def test3():     \"\"\"Test the multiprocess     \"\"\"     import time          p = MVisionProcess()     p.start()     time.sleep(5)     p.stop()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "testing efficeny in python tonget the time of programs completion [SEP] def forget_coords(self):         \"\"\"Forget all loaded coordinates.\"\"\"         self.w.ntotal.set_text('0')         self.coords_dict.clear()         self.redo()", "target": 0, "target_options": ["no match", "match"]}
{"input": "testing efficeny in python tonget the time of programs completion [SEP] def speedtest(func, *args, **kwargs):     \"\"\" Test the speed of a function. \"\"\"     n = 100     start = time.time()     for i in range(n): func(*args,**kwargs)     end = time.time()     return (end-start)/n", "target": 1, "target_options": ["no_match", "match"]}
{"input": "testing efficeny in python tonget the time of programs completion [SEP] def __init__(self, db):         \"\"\"         Connect to the Salesforce API.         \"\"\"         self.db = db         self.query = None         self.session = db.sf_session         self.rowcount = None         self.first_row = None         self.lastrowid = None  # not moved to driver because INSERT is implemented here         self.cursor = self.db.connection.cursor()", "target": 0, "target_options": ["no match", "match"]}
{"input": "create a dictionary from two list python [SEP] def list2dict(list_of_options):     \"\"\"Transforms a list of 2 element tuples to a dictionary\"\"\"     d = {}     for key, value in list_of_options:         d[key] = value     return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "create a dictionary from two list python [SEP] def as_dictionary(self):         \"\"\"         Convert this object to a dictionary with formatting appropriate for a PIF.          :returns: Dictionary with the content of this object formatted for a PIF.         \"\"\"         return {to_camel_case(i): Serializable._convert_to_dictionary(self.__dict__[i])                 for i in self.__dict__ if self.__dict__[i] is not None}", "target": 0, "target_options": ["no match", "match"]}
{"input": "create a dictionary from two list python [SEP] def list_of_lists_to_dict(l):     \"\"\" Convert list of key,value lists to dict      [['id', 1], ['id', 2], ['id', 3], ['foo': 4]]     {'id': [1, 2, 3], 'foo': [4]}     \"\"\"     d = {}     for key, val in l:         d.setdefault(key, []).append(val)     return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "create a dictionary from two list python [SEP] def split_into_sentences(s):   \"\"\"Split text into list of sentences.\"\"\"   s = re.sub(r\"\\s+\", \" \", s)   s = re.sub(r\"[\\\\.\\\\?\\\\!]\", \"\\n\", s)   return s.split(\"\\n\")", "target": 0, "target_options": ["no match", "match"]}
{"input": "determine number of columns in python [SEP] def size(self):         \"\"\"Total number of grid points.\"\"\"         # Since np.prod(()) == 1.0 we need to handle that by ourselves         return (0 if self.shape == () else                 int(np.prod(self.shape, dtype='int64')))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "determine number of columns in python [SEP] def frange(start, stop, step, precision):     \"\"\"A generator that will generate a range of floats.\"\"\"     value = start     while round(value, precision) < stop:         yield round(value, precision)         value += step", "target": 0, "target_options": ["no match", "match"]}
{"input": "determine number of columns in python [SEP] def shape(self):         \"\"\"Compute the shape of the dataset as (rows, cols).\"\"\"         if not self.data:             return (0, 0)         return (len(self.data), len(self.dimensions))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "determine number of columns in python [SEP] def series_table_row_offset(self, series):         \"\"\"         Return the number of rows preceding the data table for *series* in         the Excel worksheet.         \"\"\"         title_and_spacer_rows = series.index * 2         data_point_rows = series.data_point_offset         return title_and_spacer_rows + data_point_rows", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to check the status of table widget in python [SEP] def is_installable(self, model_index):         \"\"\" \"\"\"         row = model_index.row()         status = self._rows[row][C.COL_STATUS]         return status == C.NOT_INSTALLED", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to check the status of table widget in python [SEP] def partition(list_, columns=2):     \"\"\"     Break a list into ``columns`` number of columns.     \"\"\"      iter_ = iter(list_)     columns = int(columns)     rows = []      while True:         row = []         for column_number in range(1, columns + 1):             try:                 value = six.next(iter_)             except StopIteration:                 pass             else:                 row.append(value)          if not row:             return rows         rows.append(row)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to check the status of table widget in python [SEP] def autofit(self):         \"\"\"         Return |False| if there is a ``<w:tblLayout>`` child with ``w:type``         attribute set to ``'fixed'``. Otherwise return |True|.         \"\"\"         tblLayout = self.tblLayout         if tblLayout is None:             return True         return False if tblLayout.type == 'fixed' else True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to check the status of table widget in python [SEP] def post_sea_resource(url, body):     \"\"\"     Get the requested resource using the Seattle account     :returns: http response with content in json     \"\"\"     response = None     response = TrumbaSea_DAO().postURL(         url,         {\"Content-Type\": \"application/json\"},         body)     _log_json_resp(\"Seattle\", url, body, response)     return response", "target": 0, "target_options": ["no match", "match"]}
{"input": "filter number in string python [SEP] def split(s):   \"\"\"Uses dynamic programming to infer the location of spaces in a string without spaces.\"\"\"   l = [_split(x) for x in _SPLIT_RE.split(s)]   return [item for sublist in l for item in sublist]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "filter number in string python [SEP] def torecarray(*args, **kwargs):     \"\"\"     Convenient shorthand for ``toarray(*args, **kwargs).view(np.recarray)``.      \"\"\"      import numpy as np     return toarray(*args, **kwargs).view(np.recarray)", "target": 0, "target_options": ["no match", "match"]}
{"input": "filter number in string python [SEP] def valid_substitution(strlen, index):     \"\"\"     skip performing substitutions that are outside the bounds of the string     \"\"\"     values = index[0]     return all([strlen > i for i in values])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "filter number in string python [SEP] def C_dict2array(C):     \"\"\"Convert an OrderedDict containing C values to a 1D array.\"\"\"     return np.hstack([np.asarray(C[k]).ravel() for k in C_keys])", "target": 0, "target_options": ["no match", "match"]}
{"input": "python functions return an integer from a boolean [SEP] def _cast_boolean(value):     \"\"\"     Helper to convert config values to boolean as ConfigParser do.     \"\"\"     _BOOLEANS = {'1': True, 'yes': True, 'true': True, 'on': True,                  '0': False, 'no': False, 'false': False, 'off': False, '': False}     value = str(value)     if value.lower() not in _BOOLEANS:         raise ValueError('Not a boolean: %s' % value)      return _BOOLEANS[value.lower()]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python functions return an integer from a boolean [SEP] def parse_prefix(identifier):     \"\"\"     Parse identifier such as a|c|le|d|li|re|or|AT4G00480.1 and return     tuple of prefix string (separated at '|') and suffix (AGI identifier)     \"\"\"     pf, id = (), identifier     if \"|\" in identifier:         pf, id = tuple(identifier.split('|')[:-1]), identifier.split('|')[-1]      return pf, id", "target": 0, "target_options": ["no match", "match"]}
{"input": "python functions return an integer from a boolean [SEP] def convertToNative(self, aVal):         \"\"\" Convert to native bool; interpret certain strings. \"\"\"         if aVal is None:             return None         if isinstance(aVal, bool): return aVal         # otherwise interpret strings         return str(aVal).lower() in ('1','on','yes','true')", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python functions return an integer from a boolean [SEP] def parent_directory(self):         \"\"\"Change working directory to parent directory\"\"\"         self.chdir(os.path.join(getcwd_or_home(), os.path.pardir))", "target": 0, "target_options": ["no match", "match"]}
{"input": "get double valuye datetime python [SEP] def date_to_timestamp(date):     \"\"\"         date to unix timestamp in milliseconds     \"\"\"     date_tuple = date.timetuple()     timestamp = calendar.timegm(date_tuple) * 1000     return timestamp", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get double valuye datetime python [SEP] def S(self):         \"\"\":obj:`numpy.ndarray` : The 3x3 scaling matrix for this projection         \"\"\"         S = np.array([[self._plane_width / self._vol_width, 0, 0],                       [0, self._plane_height / self._vol_height, 0],                       [0, 0, self._depth_scale / self._vol_depth]])         return S", "target": 0, "target_options": ["no match", "match"]}
{"input": "get double valuye datetime python [SEP] def timestamp_to_datetime(timestamp):     \"\"\"Convert an ARF timestamp to a datetime.datetime object (naive local time)\"\"\"     from datetime import datetime, timedelta     obj = datetime.fromtimestamp(timestamp[0])     return obj + timedelta(microseconds=int(timestamp[1]))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get double valuye datetime python [SEP] def valuesToInts(values):     \"\"\"     Iterable of values to ints (nonvalid = None)     \"\"\"     res = []     append = res.append     for d in values:         if isinstance(d, int):             append(d)         else:             append(valToInt(d))     return res", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to delete text values python [SEP] def remove_bad(string):     \"\"\"     remove problem characters from string     \"\"\"     remove = [':', ',', '(', ')', ' ', '|', ';', '\\'']     for c in remove:         string = string.replace(c, '_')     return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to delete text values python [SEP] def C_dict2array(C):     \"\"\"Convert an OrderedDict containing C values to a 1D array.\"\"\"     return np.hstack([np.asarray(C[k]).ravel() for k in C_keys])", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to delete text values python [SEP] def drop_bad_characters(text):     \"\"\"Takes a text and drops all non-printable and non-ascii characters and     also any whitespace characters that aren't space.      :arg str text: the text to fix      :returns: text with all bad characters dropped      \"\"\"     # Strip all non-ascii and non-printable characters     text = ''.join([c for c in text if c in ALLOWED_CHARS])     return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to delete text values python [SEP] def _unichr(i):     \"\"\"     Helper function for taking a Unicode scalar value and returning a Unicode character.      :param s: Unicode scalar value to convert.     :return: Unicode character     \"\"\"     if not isinstance(i, int):         raise TypeError     try:         return six.unichr(i)     except ValueError:         # Workaround the error \"ValueError: unichr() arg not in range(0x10000) (narrow Python build)\"         return struct.pack(\"i\", i).decode(\"utf-32\")", "target": 0, "target_options": ["no match", "match"]}
{"input": "python clean html remove css script [SEP] def strip_html(string, keep_tag_content=False):     \"\"\"     Remove html code contained into the given string.      :param string: String to manipulate.     :type string: str     :param keep_tag_content: True to preserve tag content, False to remove tag and its content too (default).     :type keep_tag_content: bool     :return: String with html removed.     :rtype: str     \"\"\"     r = HTML_TAG_ONLY_RE if keep_tag_content else HTML_RE     return r.sub('', string)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python clean html remove css script [SEP] def dump_dict_to_file(dictionary, filepath):     \"\"\"Dump @dictionary as a line to @filepath.\"\"\"     create_dirs(         os.path.dirname(filepath)     )      with open(filepath, 'a') as outfile:         json.dump(dictionary, outfile)         outfile.write('\\n')", "target": 0, "target_options": ["no match", "match"]}
{"input": "python clean html remove css script [SEP] def convert_html_subscripts_to_latex(text):     \"\"\"Convert some HTML tags to latex equivalents.\"\"\"     text = re.sub(\"<sub>(.*?)</sub>\", r\"$_{\\1}$\", text)     text = re.sub(\"<sup>(.*?)</sup>\", r\"$^{\\1}$\", text)     return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python clean html remove css script [SEP] def relative_path(path):     \"\"\"     Return the given path relative to this file.     \"\"\"     return os.path.join(os.path.dirname(__file__), path)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python insert a variable string [SEP] def getSystemVariable(self, remote, name):         \"\"\"Get single system variable from CCU / Homegear\"\"\"         if self._server is not None:             return self._server.getSystemVariable(remote, name)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python insert a variable string [SEP] def inFocus(self):         \"\"\"Set GUI on-top flag\"\"\"         previous_flags = self.window.flags()         self.window.setFlags(previous_flags |                              QtCore.Qt.WindowStaysOnTopHint)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python insert a variable string [SEP] def _station(self) -> str:         \"\"\"Extract station name.\"\"\"         return str(self.obj.SBRes.SBReq.Start.Station.HafasName.Text.pyval)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python insert a variable string [SEP] def isin(elems, line):     \"\"\"Check if an element from a list is in a string.      :type elems: list     :type line: str      \"\"\"     found = False     for e in elems:         if e in line.lower():             found = True             break     return found", "target": 0, "target_options": ["no match", "match"]}
{"input": "python rename stdout log file name [SEP] def log_no_newline(self, msg):       \"\"\" print the message to the predefined log file without newline \"\"\"       self.print2file(self.logfile, False, False, msg)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python rename stdout log file name [SEP] def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value", "target": 0, "target_options": ["no match", "match"]}
{"input": "python rename stdout log file name [SEP] def pstd(self, *args, **kwargs):         \"\"\" Console to STDOUT \"\"\"         kwargs['file'] = self.out         self.print(*args, **kwargs)         sys.stdout.flush()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python rename stdout log file name [SEP] def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value", "target": 0, "target_options": ["no match", "match"]}
{"input": "python opencv read image size inverted [SEP] def read_img(path):     \"\"\" Reads image specified by path into numpy.ndarray\"\"\"     img = cv2.resize(cv2.imread(path, 0), (80, 30)).astype(np.float32) / 255     img = np.expand_dims(img.transpose(1, 0), 0)     return img", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python opencv read image size inverted [SEP] def firmware_download_input_rbridge_id(self, **kwargs):         \"\"\"Auto Generated Code         \"\"\"         config = ET.Element(\"config\")         firmware_download = ET.Element(\"firmware_download\")         config = firmware_download         input = ET.SubElement(firmware_download, \"input\")         rbridge_id = ET.SubElement(input, \"rbridge-id\")         rbridge_id.text = kwargs.pop('rbridge_id')          callback = kwargs.pop('callback', self._callback)         return callback(config)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python opencv read image size inverted [SEP] def resize(src, size, interpolation=cv2.INTER_LINEAR):     \"\"\"Decode image from str buffer.     Wrapper for cv2.imresize that uses mx.nd.NDArray      Parameters     ----------     src : NDArray         image in (width, height, channels)     size : tuple         target size in (width, height)     interpolation : int         same as interpolation for cv2.imresize      Returns     -------     img : NDArray         resized image     \"\"\"     hdl = NDArrayHandle()     check_call(_LIB.MXCVResize(src.handle, mx_uint(size[0]), mx_uint(size[1]),                                interpolation, ctypes.byref(hdl)))     return mx.nd.NDArray(hdl)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python opencv read image size inverted [SEP] def strip_spaces(value, sep=None, join=True):     \"\"\"Cleans trailing whitespaces and replaces also multiple whitespaces with a single space.\"\"\"     value = value.strip()     value = [v.strip() for v in value.split(sep)]     join_sep = sep or ' '     return join_sep.join(value) if join else value", "target": 0, "target_options": ["no match", "match"]}
{"input": "csv format to 2d array in python [SEP] def _array2cstr(arr):     \"\"\" Serializes a numpy array to a compressed base64 string \"\"\"     out = StringIO()     np.save(out, arr)     return b64encode(out.getvalue())", "target": 1, "target_options": ["no_match", "match"]}
{"input": "csv format to 2d array in python [SEP] def from_dict(cls, d):         \"\"\"         Makes XcFunc obey the general json interface used in pymatgen for easier serialization.         \"\"\"         return cls(xc=d.get(\"xc\"), x=d.get(\"x\"), c=d.get(\"c\"))", "target": 0, "target_options": ["no match", "match"]}
{"input": "csv format to 2d array in python [SEP] def C_dict2array(C):     \"\"\"Convert an OrderedDict containing C values to a 1D array.\"\"\"     return np.hstack([np.asarray(C[k]).ravel() for k in C_keys])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "csv format to 2d array in python [SEP] def get_numbers(s):     \"\"\"Extracts all integers from a string an return them in a list\"\"\"      result = map(int, re.findall(r'[0-9]+', unicode(s)))     return result + [1] * (2 - len(result))", "target": 0, "target_options": ["no match", "match"]}
{"input": "corrolation plot code python [SEP] def show_correlation_matrix(self, correlation_matrix):         \"\"\"Shows the given correlation matrix as image          :param correlation_matrix: Correlation matrix of features         \"\"\"         cr_plot.create_correlation_matrix_plot(             correlation_matrix, self.title, self.headers_to_test         )         pyplot.show()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "corrolation plot code python [SEP] def convert_array(array):     \"\"\"     Converts an ARRAY string stored in the database back into a Numpy array.      Parameters     ----------     array: ARRAY         The array object to be converted back into a Numpy array.      Returns     -------     array             The converted Numpy array.      \"\"\"     out = io.BytesIO(array)     out.seek(0)     return np.load(out)", "target": 0, "target_options": ["no match", "match"]}
{"input": "corrolation plot code python [SEP] def plot_target(target, ax):     \"\"\"Ajoute la target au plot\"\"\"     ax.scatter(target[0], target[1], target[2], c=\"red\", s=80)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "corrolation plot code python [SEP] def make_lex_dict(self):         \"\"\"         Convert lexicon file to a dictionary         \"\"\"         lex_dict = {}         for line in self.lexicon_full_filepath.split('\\n'):             (word, measure) = line.strip().split('\\t')[0:2]             lex_dict[word] = float(measure)         return lex_dict", "target": 0, "target_options": ["no match", "match"]}
{"input": "python xml utf8 tostring [SEP] def safe_unicode(string):     \"\"\"If Python 2, replace non-ascii characters and return encoded string.\"\"\"     if not PY3:         uni = string.replace(u'\\u2019', \"'\")         return uni.encode('utf-8')              return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python xml utf8 tostring [SEP] def _sim_colour(r1, r2):     \"\"\"         calculate the sum of histogram intersection of colour     \"\"\"     return sum([min(a, b) for a, b in zip(r1[\"hist_c\"], r2[\"hist_c\"])])", "target": 0, "target_options": ["no match", "match"]}
{"input": "python xml utf8 tostring [SEP] def b2u(string):     \"\"\" bytes to unicode \"\"\"     if (isinstance(string, bytes) or         (PY2 and isinstance(string, str))):         return string.decode('utf-8')     return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python xml utf8 tostring [SEP] def _uniquify(_list):     \"\"\"Remove duplicates in a list.\"\"\"     seen = set()     result = []     for x in _list:         if x not in seen:             result.append(x)             seen.add(x)     return result", "target": 0, "target_options": ["no match", "match"]}
{"input": "python ascii int to char [SEP] def _unichr(i):     \"\"\"     Helper function for taking a Unicode scalar value and returning a Unicode character.      :param s: Unicode scalar value to convert.     :return: Unicode character     \"\"\"     if not isinstance(i, int):         raise TypeError     try:         return six.unichr(i)     except ValueError:         # Workaround the error \"ValueError: unichr() arg not in range(0x10000) (narrow Python build)\"         return struct.pack(\"i\", i).decode(\"utf-32\")", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python ascii int to char [SEP] def create_rot2d(angle):     \"\"\"Create 2D rotation matrix\"\"\"     ca = math.cos(angle)     sa = math.sin(angle)     return np.array([[ca, -sa], [sa, ca]])", "target": 0, "target_options": ["no match", "match"]}
{"input": "python ascii int to char [SEP] def c_str(string):     \"\"\"\"Convert a python string to C string.\"\"\"     if not isinstance(string, str):         string = string.decode('ascii')     return ctypes.c_char_p(string.encode('utf-8'))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python ascii int to char [SEP] def remove_duplicates(lst):     \"\"\"     Emulate what a Python ``set()`` does, but keeping the element's order.     \"\"\"     dset = set()     return [l for l in lst if l not in dset and not dset.add(l)]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python and replace multerble charaters in string [SEP] def _sanitize(text):     \"\"\"Return sanitized Eidos text field for human readability.\"\"\"     d = {'-LRB-': '(', '-RRB-': ')'}     return re.sub('|'.join(d.keys()), lambda m: d[m.group(0)], text)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python and replace multerble charaters in string [SEP] def wait_until_exit(self):         \"\"\" Wait until thread exit              Used for testing purpose only         \"\"\"          if self._timeout is None:             raise Exception(\"Thread will never exit. Use stop or specify timeout when starting it!\")          self._thread.join()         self.stop()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python and replace multerble charaters in string [SEP] def dashrepl(value):     \"\"\"     Replace any non-word characters with a dash.     \"\"\"     patt = re.compile(r'\\W', re.UNICODE)     return re.sub(patt, '-', value)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python and replace multerble charaters in string [SEP] def gtype_to_python(gtype):         \"\"\"Map a gtype to the name of the Python type we use to represent it.          \"\"\"          fundamental = gobject_lib.g_type_fundamental(gtype)          if gtype in GValue._gtype_to_python:             return GValue._gtype_to_python[gtype]         if fundamental in GValue._gtype_to_python:             return GValue._gtype_to_python[fundamental]         return '<unknown type>'", "target": 0, "target_options": ["no match", "match"]}
{"input": "number of repeated elements in list python [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "number of repeated elements in list python [SEP] def _get_result_files_base(self, temp_dir):         \"\"\"Given the temp directory that is created for each run, return the path to the directory         where files created by the tool are stored.\"\"\"         if not self._use_namespaces:             return super(ContainerExecutor, self)._get_result_files_base(temp_dir)         else:             return os.path.join(temp_dir, \"temp\")", "target": 0, "target_options": ["no match", "match"]}
{"input": "number of repeated elements in list python [SEP] def count_list(the_list):     \"\"\"     Generates a count of the number of times each unique item appears in a list     \"\"\"     count = the_list.count     result = [(item, count(item)) for item in set(the_list)]     result.sort()     return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "number of repeated elements in list python [SEP] def get_all_files(folder):     \"\"\"     Generator that loops through all absolute paths of the files within folder      Parameters     ----------     folder: str     Root folder start point for recursive search.      Yields     ------     fpath: str     Absolute path of one file in the folders     \"\"\"     for path, dirlist, filelist in os.walk(folder):         for fn in filelist:             yield op.join(path, fn)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python listen to socket continuously [SEP] def begin_stream_loop(stream, poll_interval):     \"\"\"Start and maintain the streaming connection...\"\"\"     while should_continue():         try:             stream.start_polling(poll_interval)         except Exception as e:             # Infinite restart             logger.error(\"Exception while polling. Restarting in 1 second.\", exc_info=True)             time.sleep(1)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python listen to socket continuously [SEP] def _css_select(soup, css_selector):         \"\"\" Returns the content of the element pointed by the CSS selector,         or an empty string if not found \"\"\"         selection = soup.select(css_selector)         if len(selection) > 0:             if hasattr(selection[0], 'text'):                 retour = selection[0].text.strip()             else:                 retour = \"\"         else:             retour = \"\"         return retour", "target": 0, "target_options": ["no match", "match"]}
{"input": "python listen to socket continuously [SEP] def public_broadcaster():     \"\"\"     Thread which runs in parallel and constantly checks for new messages     in the public pipe and broadcasts them publicly to all connected clients.     \"\"\"     while __websocket_server_running__:         pipein = open(PUBLIC_PIPE, 'r')         line = pipein.readline().replace('\\n', '').replace('\\r', '')         if line != '':             WebSocketHandler.broadcast(line)             print line                          remaining_lines = pipein.read()             pipein.close()             pipeout = open(PUBLIC_PIPE, 'w')             pipeout.write(remaining_lines)             pipeout.close()         else:             pipein.close()                  time.sleep(0.05)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python listen to socket continuously [SEP] def clean(self, text):         \"\"\"Remove all unwanted characters from text.\"\"\"         return ''.join([c for c in text if c in self.alphabet])", "target": 0, "target_options": ["no match", "match"]}
{"input": "finding the python path [SEP] def path_for_import(name):     \"\"\"     Returns the directory path for the given package or module.     \"\"\"     return os.path.dirname(os.path.abspath(import_module(name).__file__))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "finding the python path [SEP] def draw_header(self, stream, header):         \"\"\"Draw header with underline\"\"\"         stream.writeln('=' * (len(header) + 4))         stream.writeln('| ' + header + ' |')         stream.writeln('=' * (len(header) + 4))         stream.writeln()", "target": 0, "target_options": ["no match", "match"]}
{"input": "finding the python path [SEP] def get_module_path(module):     \"\"\"return a directory path to a module\"\"\"     return pathlib.Path(         os.path.dirname(os.path.abspath(inspect.getfile(module))))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "finding the python path [SEP] def __len__(self):         \"\"\" This will equal 124 for the V1 database. \"\"\"         length = 0         for typ, siz, _ in self.format:             length += siz         return length", "target": 0, "target_options": ["no match", "match"]}
{"input": "python script to shutdown computer os independent [SEP] def shutdown(self):         \"\"\"         Shutdown the cluster.         \"\"\"         self.stop = True         if self.stats:             self.stats.shutDownStats()         self.join()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python script to shutdown computer os independent [SEP] def Slice(a, begin, size):     \"\"\"     Slicing op.     \"\"\"     return np.copy(a)[[slice(*tpl) for tpl in zip(begin, begin+size)]],", "target": 0, "target_options": ["no match", "match"]}
{"input": "python script to shutdown computer os independent [SEP] def _shutdown(self):     \"\"\"Terminate the sub-process.\"\"\"     if self._proc:       ret = _shutdown_proc(self._proc, 3)       logging.info(\"Shutdown with return code: %s\", ret)       self._proc = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python script to shutdown computer os independent [SEP] def median_high(data):     \"\"\"Return the high median of data.      When the number of data points is odd, the middle value is returned.     When it is even, the larger of the two middle values is returned.      \"\"\"     data = sorted(data)     n = len(data)     if n == 0:         raise StatisticsError(\"no median for empty data\")     return data[n // 2]", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to fill the color in python [SEP] def write_color(string, name, style='normal', when='auto'):     \"\"\" Write the given colored string to standard out. \"\"\"     write(color(string, name, style, when))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to fill the color in python [SEP] def sflow_sample_rate(self, **kwargs):         \"\"\"Auto Generated Code         \"\"\"         config = ET.Element(\"config\")         sflow = ET.SubElement(config, \"sflow\", xmlns=\"urn:brocade.com:mgmt:brocade-sflow\")         sample_rate = ET.SubElement(sflow, \"sample-rate\")         sample_rate.text = kwargs.pop('sample_rate')          callback = kwargs.pop('callback', self._callback)         return callback(config)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to fill the color in python [SEP] def ansi(color, text):     \"\"\"Wrap text in an ansi escape sequence\"\"\"     code = COLOR_CODES[color]     return '\\033[1;{0}m{1}{2}'.format(code, text, RESET_TERM)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to fill the color in python [SEP] def floor(self):     \"\"\"Round `x` and `y` down to integers.\"\"\"     return Point(int(math.floor(self.x)), int(math.floor(self.y)))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python matplotlib choose what goes in your legend [SEP] def finish_plot():     \"\"\"Helper for plotting.\"\"\"     plt.legend()     plt.grid(color='0.7')     plt.xlabel('x')     plt.ylabel('y')     plt.show()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python matplotlib choose what goes in your legend [SEP] def _check_elements_equal(lst):     \"\"\"     Returns true if all of the elements in the list are equal.     \"\"\"     assert isinstance(lst, list), \"Input value must be a list.\"     return not lst or lst.count(lst[0]) == len(lst)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python matplotlib choose what goes in your legend [SEP] def plot(self):         \"\"\"Plot the empirical histogram versus best-fit distribution's PDF.\"\"\"         plt.plot(self.bin_edges, self.hist, self.bin_edges, self.best_pdf)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python matplotlib choose what goes in your legend [SEP] def check_new_version_available(this_version):     \"\"\"     Checks if a newer version of Zappa is available.      Returns True is updateable, else False.      \"\"\"     import requests      pypi_url = 'https://pypi.python.org/pypi/Zappa/json'     resp = requests.get(pypi_url, timeout=1.5)     top_version = resp.json()['info']['version']      return this_version != top_version", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to separate plots in python [SEP] def basic():     \"\"\"Set up a basic stereonet and plot the same data each time.\"\"\"     fig, ax = mplstereonet.subplots()      strike, dip = 315, 30     ax.plane(strike, dip, color='lightblue')     ax.pole(strike, dip, color='green', markersize=15)     ax.rake(strike, dip, 40, marker='*', markersize=20, color='green')      # Make a bit of room for the title...     fig.subplots_adjust(top=0.8)      return ax", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to separate plots in python [SEP] def norm_vec(vector):     \"\"\"Normalize the length of a vector to one\"\"\"     assert len(vector) == 3     v = np.array(vector)     return v/np.sqrt(np.sum(v**2))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to separate plots in python [SEP] def plot_target(target, ax):     \"\"\"Ajoute la target au plot\"\"\"     ax.scatter(target[0], target[1], target[2], c=\"red\", s=80)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to separate plots in python [SEP] def WalkChildren(elem): \t\"\"\" \tWalk the XML tree of children below elem, returning each in order. \t\"\"\" \tfor child in elem.childNodes: \t\tyield child \t\tfor elem in WalkChildren(child): \t\t\tyield elem", "target": 0, "target_options": ["no match", "match"]}
{"input": "python os get pid [SEP] def generate_unique_host_id():     \"\"\"Generate a unique ID, that is somewhat guaranteed to be unique among all     instances running at the same time.\"\"\"     host = \".\".join(reversed(socket.gethostname().split(\".\")))     pid = os.getpid()     return \"%s.%d\" % (host, pid)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python os get pid [SEP] def read(*p):     \"\"\"Build a file path from paths and return the contents.\"\"\"     with open(os.path.join(*p), 'r') as fi:         return fi.read()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python os get pid [SEP] def _write_pidfile(pidfile):     \"\"\" Write file with current process ID.     \"\"\"     pid = str(os.getpid())     handle = open(pidfile, 'w')     try:         handle.write(\"%s\\n\" % pid)     finally:         handle.close()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python os get pid [SEP] def flatten_list(x: List[Any]) -> List[Any]:     \"\"\"     Converts a list of lists into a flat list.          Args:         x: list of lists       Returns:         flat list              As per     http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python      \"\"\"  # noqa     return [item for sublist in x for item in sublist]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python test if a list is all none [SEP] def _not_none(items):     \"\"\"Whether the item is a placeholder or contains a placeholder.\"\"\"     if not isinstance(items, (tuple, list)):         items = (items,)     return all(item is not _none for item in items)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python test if a list is all none [SEP] def _build_url(self, shorten=True):         \"\"\"Build the url for a cable ratings page\"\"\"         self.url = URL_FORMAT.format(*self._get_url_params(shorten=shorten))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python test if a list is all none [SEP] def contains_empty(features):     \"\"\"Check features data are not empty      :param features: The features data to check.     :type features: list of numpy arrays.      :return: True if one of the array is empty, False else.      \"\"\"     if not features:         return True     for feature in features:         if feature.shape[0] == 0:             return True     return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python test if a list is all none [SEP] def normalize_path(filename):     \"\"\"Normalize a file/dir name for comparison purposes\"\"\"     return os.path.normcase(os.path.realpath(os.path.normpath(_cygwin_patch(filename))))", "target": 0, "target_options": ["no match", "match"]}
{"input": "removine item from a list python [SEP] def unique_element(ll):     \"\"\" returns unique elements from a list preserving the original order \"\"\"     seen = {}     result = []     for item in ll:         if item in seen:             continue         seen[item] = 1         result.append(item)     return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "removine item from a list python [SEP] def local_accuracy(X_train, y_train, X_test, y_test, attr_test, model_generator, metric, trained_model):     \"\"\" The how well do the features plus a constant base rate sum up to the model output.     \"\"\"      X_train, X_test = to_array(X_train, X_test)      # how many features to mask     assert X_train.shape[1] == X_test.shape[1]      # keep nkeep top features and re-train the model for each test explanation     yp_test = trained_model.predict(X_test)      return metric(yp_test, strip_list(attr_test).sum(1))", "target": 0, "target_options": ["no match", "match"]}
{"input": "removine item from a list python [SEP] def ziptake(items_list, indexes_list):     \"\"\"     SeeAlso:         vt.ziptake     \"\"\"     return [take(list_, index_list)             for list_, index_list in zip(items_list, indexes_list)]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "removine item from a list python [SEP] def Tmatrix(X):     \"\"\"     gets the orientation matrix (T) from data in X     \"\"\"     T = [[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]]     for row in X:         for k in range(3):             for l in range(3):                 T[k][l] += row[k] * row[l]     return T", "target": 0, "target_options": ["no match", "match"]}
{"input": "python check if array is true [SEP] def is_bool_matrix(l):     r\"\"\"Checks if l is a 2D numpy array of bools      \"\"\"     if isinstance(l, np.ndarray):         if l.ndim == 2 and (l.dtype == bool):             return True     return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python check if array is true [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python check if array is true [SEP] def is_iterable(value):     \"\"\"must be an iterable (list, array, tuple)\"\"\"     return isinstance(value, np.ndarray) or isinstance(value, list) or isinstance(value, tuple), value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python check if array is true [SEP] def divide(x: LispNumber, y: LispNumber) -> LispNumber:     \"\"\"Division reducer. If both arguments are integers, return a Fraction.     Otherwise, return the true division of x and y.\"\"\"     if isinstance(x, int) and isinstance(y, int):         return Fraction(x, y)     return x / y", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to access 3d array pythong [SEP] def _transform_triple_numpy(x):     \"\"\"Transform triple index into a 1-D numpy array.\"\"\"     return np.array([x.head, x.relation, x.tail], dtype=np.int64)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to access 3d array pythong [SEP] def fopenat(base_fd, path):     \"\"\"     Does openat read-only, then does fdopen to get a file object     \"\"\"      return os.fdopen(openat(base_fd, path, os.O_RDONLY), 'rb')", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to access 3d array pythong [SEP] def S(self):         \"\"\":obj:`numpy.ndarray` : The 3x3 scaling matrix for this projection         \"\"\"         S = np.array([[self._plane_width / self._vol_width, 0, 0],                       [0, self._plane_height / self._vol_height, 0],                       [0, 0, self._depth_scale / self._vol_depth]])         return S", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to access 3d array pythong [SEP] def index(self, item):         \"\"\" Not recommended for use on large lists due to time             complexity, but it works              -> #int list index of @item         \"\"\"         for i, x in enumerate(self.iter()):             if x == item:                 return i         return None", "target": 0, "target_options": ["no match", "match"]}
{"input": "get element of a matrix in python' [SEP] def load_data(filename):     \"\"\"     :rtype : numpy matrix     \"\"\"     data = pandas.read_csv(filename, header=None, delimiter='\\t', skiprows=9)     return data.as_matrix()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get element of a matrix in python' [SEP] def downcaseTokens(s,l,t):     \"\"\"Helper parse action to convert tokens to lower case.\"\"\"     return [ tt.lower() for tt in map(_ustr,t) ]", "target": 0, "target_options": ["no match", "match"]}
{"input": "get element of a matrix in python' [SEP] def csv_to_matrix(csv_file_path):     \"\"\"Load a CSV file into a Python matrix of strings.      Args:         csv_file_path: Full path to a valid CSV file (e.g. c:/ladybug/test.csv)     \"\"\"     mtx = []     with open(csv_file_path) as csv_data_file:         for row in csv_data_file:             mtx.append(row.split(','))     return mtx", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get element of a matrix in python' [SEP] def dump_dict_to_file(dictionary, filepath):     \"\"\"Dump @dictionary as a line to @filepath.\"\"\"     create_dirs(         os.path.dirname(filepath)     )      with open(filepath, 'a') as outfile:         json.dump(dictionary, outfile)         outfile.write('\\n')", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to only accept intigers as inputs [SEP] def safe_int_conv(number):     \"\"\"Safely convert a single number to integer.\"\"\"     try:         return int(np.array(number).astype(int, casting='safe'))     except TypeError:         raise ValueError('cannot safely convert {} to integer'.format(number))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to only accept intigers as inputs [SEP] def insert_slash(string, every=2):     \"\"\"insert_slash insert / every 2 char\"\"\"     return os.path.join(string[i:i+every] for i in xrange(0, len(string), every))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to only accept intigers as inputs [SEP] def robust_int(v):     \"\"\"Parse an int robustly, ignoring commas and other cruft. \"\"\"      if isinstance(v, int):         return v      if isinstance(v, float):         return int(v)      v = str(v).replace(',', '')      if not v:         return None      return int(v)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to only accept intigers as inputs [SEP] def print_yaml(o):     \"\"\"Pretty print an object as YAML.\"\"\"     print(yaml.dump(o, default_flow_style=False, indent=4, encoding='utf-8'))", "target": 0, "target_options": ["no match", "match"]}
{"input": "filter out nans in python data frame [SEP] def dropna(self, subset=None):         \"\"\"Remove missing values according to Baloo's convention.          Parameters         ----------         subset : list of str, optional             Which columns to check for missing values in.          Returns         -------         DataFrame             DataFrame with no null values in columns.          \"\"\"         subset = check_and_obtain_subset_columns(subset, self)         not_nas = [v.notna() for v in self[subset]._iter()]         and_filter = reduce(lambda x, y: x & y, not_nas)          return self[and_filter]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "filter out nans in python data frame [SEP] def intround(value):     \"\"\"Given a float returns a rounded int. Should give the same result on     both Py2/3     \"\"\"      return int(decimal.Decimal.from_float(         value).to_integral_value(decimal.ROUND_HALF_EVEN))", "target": 0, "target_options": ["no match", "match"]}
{"input": "filter out nans in python data frame [SEP] def clean_with_zeros(self,x):         \"\"\" set nan and inf rows from x to zero\"\"\"         x[~np.any(np.isnan(x) | np.isinf(x),axis=1)] = 0         return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "filter out nans in python data frame [SEP] def stringify_dict_contents(dct):     \"\"\"Turn dict keys and values into native strings.\"\"\"     return {         str_if_nested_or_str(k): str_if_nested_or_str(v)         for k, v in dct.items()     }", "target": 0, "target_options": ["no match", "match"]}
{"input": "python functions that compute the l1 and l2 distances between x and y [SEP] def difference(ydata1, ydata2):     \"\"\"      Returns the number you should add to ydata1 to make it line up with ydata2      \"\"\"      y1 = _n.array(ydata1)     y2 = _n.array(ydata2)      return(sum(y2-y1)/len(ydata1))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python functions that compute the l1 and l2 distances between x and y [SEP] def shutdown(self):         \"\"\"         Shutdown the client and all of its managed resources:          - the workers         - the scheduler threads          :return: None         \"\"\"         self._storage.clear()         self._scheduler.shutdown(wait=False)         self._workers.shutdown(wait=False)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python functions that compute the l1 and l2 distances between x and y [SEP] def skip_connection_distance(a, b):     \"\"\"The distance between two skip-connections.\"\"\"     if a[2] != b[2]:         return 1.0     len_a = abs(a[1] - a[0])     len_b = abs(b[1] - b[0])     return (abs(a[0] - b[0]) + abs(len_a - len_b)) / (max(a[0], b[0]) + max(len_a, len_b))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python functions that compute the l1 and l2 distances between x and y [SEP] def drop_bad_characters(text):     \"\"\"Takes a text and drops all non-printable and non-ascii characters and     also any whitespace characters that aren't space.      :arg str text: the text to fix      :returns: text with all bad characters dropped      \"\"\"     # Strip all non-ascii and non-printable characters     text = ''.join([c for c in text if c in ALLOWED_CHARS])     return text", "target": 0, "target_options": ["no match", "match"]}
{"input": "appending data into data frame python [SEP] def to_dataframe(products):         \"\"\"Return the products from a query response as a Pandas DataFrame         with the values in their appropriate Python types.         \"\"\"         try:             import pandas as pd         except ImportError:             raise ImportError(\"to_dataframe requires the optional dependency Pandas.\")          return pd.DataFrame.from_dict(products, orient='index')", "target": 1, "target_options": ["no_match", "match"]}
{"input": "appending data into data frame python [SEP] def is_installable(self, model_index):         \"\"\" \"\"\"         row = model_index.row()         status = self._rows[row][C.COL_STATUS]         return status == C.NOT_INSTALLED", "target": 0, "target_options": ["no match", "match"]}
{"input": "appending data into data frame python [SEP] def QA_util_to_json_from_pandas(data):     \"\"\"需要对于datetime 和date 进行转换, 以免直接被变成了时间戳\"\"\"     if 'datetime' in data.columns:         data.datetime = data.datetime.apply(str)     if 'date' in data.columns:         data.date = data.date.apply(str)     return json.loads(data.to_json(orient='records'))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "appending data into data frame python [SEP] def pack_triples_numpy(triples):     \"\"\"Packs a list of triple indexes into a 2D numpy array.\"\"\"     if len(triples) == 0:         return np.array([], dtype=np.int64)     return np.stack(list(map(_transform_triple_numpy, triples)), axis=0)", "target": 0, "target_options": ["no match", "match"]}
{"input": "dynamic password changer python [SEP] def sflow_sample_rate(self, **kwargs):         \"\"\"Auto Generated Code         \"\"\"         config = ET.Element(\"config\")         sflow = ET.SubElement(config, \"sflow\", xmlns=\"urn:brocade.com:mgmt:brocade-sflow\")         sample_rate = ET.SubElement(sflow, \"sample-rate\")         sample_rate.text = kwargs.pop('sample_rate')          callback = kwargs.pop('callback', self._callback)         return callback(config)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "dynamic password changer python [SEP] def main(idle):     \"\"\"Any normal python logic which runs a loop. Can take arguments.\"\"\"     while True:          LOG.debug(\"Sleeping for {0} seconds.\".format(idle))         time.sleep(idle)", "target": 0, "target_options": ["no match", "match"]}
{"input": "dynamic password changer python [SEP] def dot1x_enable(self, **kwargs):         \"\"\"Auto Generated Code         \"\"\"         config = ET.Element(\"config\")         dot1x = ET.SubElement(config, \"dot1x\", xmlns=\"urn:brocade.com:mgmt:brocade-dot1x\")         enable = ET.SubElement(dot1x, \"enable\")          callback = kwargs.pop('callback', self._callback)         return callback(config)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "dynamic password changer python [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to apply oop to fuction in python [SEP] def __init__(self,                  post_clean_up: Callable[[Sequence[ops.Operation]], ops.OP_TREE                                 ] = lambda op_list: op_list                  ) -> None:         \"\"\"         Args:             post_clean_up: This function is called on each set of optimized                 operations before they are put into the circuit to replace the                 old operations.         \"\"\"         self.post_clean_up = post_clean_up", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to apply oop to fuction in python [SEP] def obj_in_list_always(target_list, obj):     \"\"\"     >>> l = [1,1,1]     >>> obj_in_list_always(l, 1)     True     >>> l.append(2)     >>> obj_in_list_always(l, 1)     False     \"\"\"     for item in set(target_list):         if item is not obj:             return False     return True", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to apply oop to fuction in python [SEP] def apply_operation(op_stack, out_stack):     \"\"\"     Apply operation to the first 2 items of the output queue      op_stack Deque (reference)     out_stack Deque (reference)     \"\"\"     out_stack.append(calc(out_stack.pop(), out_stack.pop(), op_stack.pop()))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to apply oop to fuction in python [SEP] def split(s):   \"\"\"Uses dynamic programming to infer the location of spaces in a string without spaces.\"\"\"   l = [_split(x) for x in _SPLIT_RE.split(s)]   return [item for sublist in l for item in sublist]", "target": 0, "target_options": ["no match", "match"]}
{"input": "ad number from list python [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "ad number from list python [SEP] def _stdin_(p):     \"\"\"Takes input from user. Works for Python 2 and 3.\"\"\"     _v = sys.version[0]     return input(p) if _v is '3' else raw_input(p)", "target": 0, "target_options": ["no match", "match"]}
{"input": "ad number from list python [SEP] def flatten(l, types=(list, float)):     \"\"\"     Flat nested list of lists into a single list.     \"\"\"     l = [item if isinstance(item, types) else [item] for item in l]     return [item for sublist in l for item in sublist]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "ad number from list python [SEP] def ResetConsoleColor() -> bool:     \"\"\"     Reset to the default text color on console window.     Return bool, True if succeed otherwise False.     \"\"\"     if sys.stdout:         sys.stdout.flush()     bool(ctypes.windll.kernel32.SetConsoleTextAttribute(_ConsoleOutputHandle, _DefaultConsoleColor))", "target": 0, "target_options": ["no match", "match"]}
{"input": "disable python requests logging [SEP] def should_skip_logging(func):     \"\"\"     Should we skip logging for this handler?      \"\"\"     disabled = strtobool(request.headers.get(\"x-request-nolog\", \"false\"))     return disabled or getattr(func, SKIP_LOGGING, False)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "disable python requests logging [SEP] def call_out(command):   \"\"\"   Run the given command (with shell=False) and return a tuple of   (int returncode, str output). Strip the output of enclosing whitespace.   \"\"\"   # start external command process   p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)    # get outputs   out, _ = p.communicate()    return p.returncode, out.strip()", "target": 0, "target_options": ["no match", "match"]}
{"input": "disable python requests logging [SEP] def logger(message, level=10):     \"\"\"Handle logging.\"\"\"     logging.getLogger(__name__).log(level, str(message))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "disable python requests logging [SEP] def is_square_matrix(mat):     \"\"\"Test if an array is a square matrix.\"\"\"     mat = np.array(mat)     if mat.ndim != 2:         return False     shape = mat.shape     return shape[0] == shape[1]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python subprocess popen non blocking [SEP] def disown(cmd):     \"\"\"Call a system command in the background,        disown it and hide it's output.\"\"\"     subprocess.Popen(cmd,                      stdout=subprocess.DEVNULL,                      stderr=subprocess.DEVNULL)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python subprocess popen non blocking [SEP] def short_repr(obj, max_len=40):   \"\"\"Returns a short, term-friendly string representation of the object.    Args:     obj: An object for which to return a string representation.     max_len: Maximum length of the returned string. Longer reprs will be turned         into a brief descriptive string giving the type and length of obj.   \"\"\"   obj_repr = repr(obj)   if len(obj_repr) <= max_len:     return obj_repr   return '<{} of length {}>'.format(type(obj).__name__, len(obj_repr))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python subprocess popen non blocking [SEP] def correspond(text):     \"\"\"Communicate with the child process without closing stdin.\"\"\"     if text:         subproc.stdin.write(text)     subproc.stdin.flush()     return get_lines()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python subprocess popen non blocking [SEP] def dedup_list(l):     \"\"\"Given a list (l) will removing duplicates from the list,        preserving the original order of the list. Assumes that        the list entrie are hashable.\"\"\"     dedup = set()     return [ x for x in l if not (x in dedup or dedup.add(x))]", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to make sure only letters are inputted python [SEP] def _stdin_(p):     \"\"\"Takes input from user. Works for Python 2 and 3.\"\"\"     _v = sys.version[0]     return input(p) if _v is '3' else raw_input(p)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to make sure only letters are inputted python [SEP] def c_str(string):     \"\"\"\"Convert a python string to C string.\"\"\"     if not isinstance(string, str):         string = string.decode('ascii')     return ctypes.c_char_p(string.encode('utf-8'))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to make sure only letters are inputted python [SEP] def return_letters_from_string(text):     \"\"\"Get letters from string only.\"\"\"     out = \"\"     for letter in text:         if letter.isalpha():             out += letter     return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to make sure only letters are inputted python [SEP] def show(self, title=''):         \"\"\"         Display Bloch sphere and corresponding data sets.         \"\"\"         self.render(title=title)         if self.fig:             plt.show(self.fig)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to for loop the value of dict in python [SEP] def printdict(adict):     \"\"\"printdict\"\"\"     dlist = list(adict.keys())     dlist.sort()     for i in range(0, len(dlist)):         print(dlist[i], adict[dlist[i]])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to for loop the value of dict in python [SEP] def C_dict2array(C):     \"\"\"Convert an OrderedDict containing C values to a 1D array.\"\"\"     return np.hstack([np.asarray(C[k]).ravel() for k in C_keys])", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to for loop the value of dict in python [SEP] def dmap(fn, record):     \"\"\"map for a directory\"\"\"     values = (fn(v) for k, v in record.items())     return dict(itertools.izip(record, values))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to for loop the value of dict in python [SEP] def send_test_message(messenger_id, to=None):     \"\"\"Sends a test message using the given messenger.      :param str|unicode messenger_id: Messenger alias.     :param str|unicode to: Recipient address (if applicable).      \"\"\"     messenger_obj = get_registered_messenger_object(messenger_id)     return messenger_obj.send_test_message(to=to, text='Test message from sitemessages.')", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to check if a specific index in a list is empty in python [SEP] def isin(value, values):     \"\"\" Check that value is in values \"\"\"     for i, v in enumerate(value):         if v not in np.array(values)[:, i]:             return False     return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to check if a specific index in a list is empty in python [SEP] def cumsum(inlist):     \"\"\" Returns a list consisting of the cumulative sum of the items in the passed list.  Usage:   lcumsum(inlist) \"\"\"     newlist = copy.deepcopy(inlist)     for i in range(1, len(newlist)):         newlist[i] = newlist[i] + newlist[i - 1]     return newlist", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to check if a specific index in a list is empty in python [SEP] def _check_elements_equal(lst):     \"\"\"     Returns true if all of the elements in the list are equal.     \"\"\"     assert isinstance(lst, list), \"Input value must be a list.\"     return not lst or lst.count(lst[0]) == len(lst)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to check if a specific index in a list is empty in python [SEP] def stop_process(self, process, timeout=None):         \"\"\" Initiates a graceful stop of one process \"\"\"          process[\"terminate\"] = True         if timeout is not None:             process[\"terminate_at\"] = time.time() + timeout         process[\"subprocess\"].send_signal(signal.SIGINT)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python str replace punctuation marks with a space [SEP] def unpunctuate(s, *, char_blacklist=string.punctuation):     \"\"\" Remove punctuation from string s. \"\"\"     # remove punctuation     s = \"\".join(c for c in s if c not in char_blacklist)     # remove consecutive spaces     return \" \".join(filter(None, s.split(\" \")))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python str replace punctuation marks with a space [SEP] def _stdin_(p):     \"\"\"Takes input from user. Works for Python 2 and 3.\"\"\"     _v = sys.version[0]     return input(p) if _v is '3' else raw_input(p)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python str replace punctuation marks with a space [SEP] def unaccentuate(s):     \"\"\" Replace accentuated chars in string by their non accentuated equivalent. \"\"\"     return \"\".join(c for c in unicodedata.normalize(\"NFKD\", s) if not unicodedata.combining(c))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python str replace punctuation marks with a space [SEP] def csvpretty(csvfile: csvfile=sys.stdin):     \"\"\" Pretty print a CSV file. \"\"\"     shellish.tabulate(csv.reader(csvfile))", "target": 0, "target_options": ["no match", "match"]}
{"input": "populate a tuple python [SEP] def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "populate a tuple python [SEP] def boolean(value):     \"\"\"     Configuration-friendly boolean type converter.      Supports both boolean-valued and string-valued inputs (e.g. from env vars).      \"\"\"     if isinstance(value, bool):         return value      if value == \"\":         return False      return strtobool(value)", "target": 0, "target_options": ["no match", "match"]}
{"input": "populate a tuple python [SEP] def compose_all(tups):   \"\"\"Compose all given tuples together.\"\"\"   from . import ast  # I weep for humanity   return functools.reduce(lambda x, y: x.compose(y), map(ast.make_tuple, tups), ast.make_tuple({}))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "populate a tuple python [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to write a 2d array into file python [SEP] def adapt_array(arr):     \"\"\"     Adapts a Numpy array into an ARRAY string to put into the database.      Parameters     ----------     arr: array         The Numpy array to be adapted into an ARRAY type that can be inserted into a SQL file.      Returns     -------     ARRAY             The adapted array object      \"\"\"     out = io.BytesIO()     np.save(out, arr), out.seek(0)     return buffer(out.read())", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to write a 2d array into file python [SEP] def pstd(self, *args, **kwargs):         \"\"\" Console to STDOUT \"\"\"         kwargs['file'] = self.out         self.print(*args, **kwargs)         sys.stdout.flush()", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to write a 2d array into file python [SEP] def bitsToString(arr):   \"\"\"Returns a string representing a numpy array of 0's and 1's\"\"\"   s = array('c','.'*len(arr))   for i in xrange(len(arr)):     if arr[i] == 1:       s[i]='*'   return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to write a 2d array into file python [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python killo float formating [SEP] def _saferound(value, decimal_places):     \"\"\"     Rounds a float value off to the desired precision     \"\"\"     try:         f = float(value)     except ValueError:         return ''     format = '%%.%df' % decimal_places     return format % f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python killo float formating [SEP] def is_third_friday(day=None):     \"\"\" check if day is month's 3rd friday \"\"\"     day = day if day is not None else datetime.datetime.now()     defacto_friday = (day.weekday() == 4) or (         day.weekday() == 3 and day.hour() >= 17)     return defacto_friday and 14 < day.day < 22", "target": 0, "target_options": ["no match", "match"]}
{"input": "python killo float formating [SEP] def round_float(f, digits, rounding=ROUND_HALF_UP):     \"\"\"     Accurate float rounding from http://stackoverflow.com/a/15398691.     \"\"\"     return Decimal(str(f)).quantize(Decimal(10) ** (-1 * digits),                                     rounding=rounding)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python killo float formating [SEP] def as_csv(self):         \"\"\"Return a CSV representation as a string\"\"\"          from io import StringIO          s = StringIO()         w = csv.writer(s)         for row in self.rows:             w.writerow(row)          return s.getvalue()", "target": 0, "target_options": ["no match", "match"]}
{"input": "how do i repeat a string in python [SEP] def insert_slash(string, every=2):     \"\"\"insert_slash insert / every 2 char\"\"\"     return os.path.join(string[i:i+every] for i in xrange(0, len(string), every))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how do i repeat a string in python [SEP] def bitsToString(arr):   \"\"\"Returns a string representing a numpy array of 0's and 1's\"\"\"   s = array('c','.'*len(arr))   for i in xrange(len(arr)):     if arr[i] == 1:       s[i]='*'   return s", "target": 0, "target_options": ["no match", "match"]}
{"input": "how do i repeat a string in python [SEP] def column(self, i):          \"\"\"from right\"\"\"         return ''.join([str(digitat2(r,i)) for r in self])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how do i repeat a string in python [SEP] def unique(list):     \"\"\" Returns a copy of the list without duplicates.     \"\"\"     unique = []; [unique.append(x) for x in list if x not in unique]     return unique", "target": 0, "target_options": ["no match", "match"]}
{"input": "check s3 file existance using python [SEP] def file_exists(original_file):     \"\"\"     Check to make sure the original file exists     \"\"\"     if original_file.startswith(\"s3://\"):         from filesystem import s3         return s3.file_exists(original_file)     else:         if not os.path.exists(original_file):             return False         if not os.path.isfile(original_file):             return False     return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check s3 file existance using python [SEP] def get_jsonparsed_data(url):     \"\"\"Receive the content of ``url``, parse it as JSON and return the        object.     \"\"\"     response = urlopen(url)     data = response.read().decode('utf-8')     return json.loads(data)", "target": 0, "target_options": ["no match", "match"]}
{"input": "check s3 file existance using python [SEP] def _exists(self, path):         \"\"\"S3 directory is not S3Ojbect.         \"\"\"         if path.endswith('/'):             return True         return self.storage.exists(path)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check s3 file existance using python [SEP] def __contains__(self, item):         \"\"\"(dpid, key) in <ConfSwitchSet instance>\"\"\"         (dpid, key) = item         return dpid in self.confs and key in self.confs[dpid]", "target": 0, "target_options": ["no match", "match"]}
{"input": "append items to list on new lines python [SEP] def write_tsv_line_from_list(linelist, outfp):     \"\"\"Utility method to convert list to tsv line with carriage return\"\"\"     line = '\\t'.join(linelist)     outfp.write(line)     outfp.write('\\n')", "target": 1, "target_options": ["no_match", "match"]}
{"input": "append items to list on new lines python [SEP] def any_contains_any(strings, candidates):     \"\"\"Whether any of the strings contains any of the candidates.\"\"\"     for string in strings:         for c in candidates:             if c in string:                 return True", "target": 0, "target_options": ["no match", "match"]}
{"input": "append items to list on new lines python [SEP] def add_lines(self, txt, indent=0):         \"\"\"Adds a list of lines.          The list can be indented with the optional argument 'indent'.         \"\"\"         for line in txt:             self.add_line(line, indent)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "append items to list on new lines python [SEP] def constant(times: np.ndarray, amp: complex) -> np.ndarray:     \"\"\"Continuous constant pulse.      Args:         times: Times to output pulse for.         amp: Complex pulse amplitude.     \"\"\"     return np.full(len(times), amp, dtype=np.complex_)", "target": 0, "target_options": ["no match", "match"]}
{"input": "check list of points and see if any are collinear python [SEP] def is_colliding(self, other):         \"\"\"Check to see if two AABoundingBoxes are colliding.\"\"\"         if isinstance(other, AABoundingBox):             if self.rect.colliderect(other.rect):                 return True             return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check list of points and see if any are collinear python [SEP] def clean(s):   \"\"\"Removes trailing whitespace on each line.\"\"\"   lines = [l.rstrip() for l in s.split('\\n')]   return '\\n'.join(lines)", "target": 0, "target_options": ["no match", "match"]}
{"input": "check list of points and see if any are collinear python [SEP] def intersects(self, other_grid_coordinates):         \"\"\" returns True if the GC's overlap. \"\"\"         ogc = other_grid_coordinates  # alias         # for explanation: http://stackoverflow.com/questions/306316/determine-if-two-rectangles-overlap-each-other         # Note the flipped y-coord in this coord system.         ax1, ay1, ax2, ay2 = self.ULC.lon, self.ULC.lat, self.LRC.lon, self.LRC.lat         bx1, by1, bx2, by2 = ogc.ULC.lon, ogc.ULC.lat, ogc.LRC.lon, ogc.LRC.lat         if ((ax1 <= bx2) and (ax2 >= bx1) and (ay1 >= by2) and (ay2 <= by1)):             return True         else:             return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check list of points and see if any are collinear python [SEP] async def load_unicode(reader):     \"\"\"     Loads UTF8 string     :param reader:     :return:     \"\"\"     ivalue = await load_uvarint(reader)     fvalue = bytearray(ivalue)     await reader.areadinto(fvalue)     return str(fvalue, 'utf8')", "target": 0, "target_options": ["no match", "match"]}
{"input": "input degrees and give out sin python [SEP] def get_input(input_func, input_str):     \"\"\"     Get input from the user given an input function and an input string     \"\"\"     val = input_func(\"Please enter your {0}: \".format(input_str))     while not val or not len(val.strip()):         val = input_func(\"You didn't enter a valid {0}, please try again: \".format(input_str))     return val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "input degrees and give out sin python [SEP] def lowstrip(term):     \"\"\"Convert to lowercase and strip spaces\"\"\"     term = re.sub('\\s+', ' ', term)     term = term.lower()     return term", "target": 0, "target_options": ["no match", "match"]}
{"input": "input degrees and give out sin python [SEP] def main(arguments=None):     \"\"\"Main command line entry point.\"\"\"      if not arguments:         arguments = sys.argv[1:]      wordlist, sowpods, by_length, start, end = argument_parser(arguments)     for word in wordlist:         pretty_print(             word,             anagrams_in_word(word, sowpods, start, end),             by_length,         )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "input degrees and give out sin python [SEP] def convert_to_output_format(param):     \"\"\"     Helper function to convert parameters to a valid string, that can be used in a column name.     Does the opposite which is used in the from_columns function.      The parameters are sorted by their name and written out in the form         <param name>_<param value>__<param name>_<param value>__ ...      If a <param_value> is a string, this method will wrap it with parenthesis \", so \"<param_value>\"      :param param: The dictionary of parameters to write out     :type param: dict      :return: The string of parsed parameters     :rtype: str     \"\"\"      def add_parenthesis_if_string_value(x):         if isinstance(x, string_types):             return '\"' + str(x) + '\"'         else:             return str(x)      return \"__\".join(str(key) + \"_\" + add_parenthesis_if_string_value(param[key]) for key in sorted(param.keys()))", "target": 0, "target_options": ["no match", "match"]}
{"input": "check if file is present in directory python [SEP] def contained_in(filename, directory):     \"\"\"Test if a file is located within the given directory.\"\"\"     filename = os.path.normcase(os.path.abspath(filename))     directory = os.path.normcase(os.path.abspath(directory))     return os.path.commonprefix([filename, directory]) == directory", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check if file is present in directory python [SEP] def full_like(array, value, dtype=None):     \"\"\" Create a shared memory array with the same shape and type as a given array, filled with `value`.     \"\"\"     shared = empty_like(array, dtype)     shared[:] = value     return shared", "target": 0, "target_options": ["no match", "match"]}
{"input": "check if file is present in directory python [SEP] def is_executable(path):   \"\"\"Returns whether a path names an existing executable file.\"\"\"   return os.path.isfile(path) and os.access(path, os.X_OK)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check if file is present in directory python [SEP] def str_to_date(date: str) -> datetime.datetime:     \"\"\" Convert cbr.ru API date ste to python datetime      :param date: date from API response      :return: date like datetime     :rtype: datetime     \"\"\"     date = date.split('.')     date.reverse()     y, m, d = date     return datetime.datetime(int(y), int(m), int(d))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python code get and set methods to set values in file' [SEP] def set(self, mutagen_file, value):         \"\"\"Assign the value for the field using this style.         \"\"\"         self.store(mutagen_file, self.serialize(value))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python code get and set methods to set values in file' [SEP] def _display(self, layout):         \"\"\"launch layouts display\"\"\"         print(file=self.out)         TextWriter().format(layout, self.out)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python code get and set methods to set values in file' [SEP] def SaveDataToFD(self, raw_data, fd):     \"\"\"Merge the raw data with the config file and store it.\"\"\"     for key, value in iteritems(raw_data):       # TODO(hanuszczak): Incorrect type specification for `set`.       # pytype: disable=wrong-arg-types       self.set(\"\", key, value=value)       # pytype: enable=wrong-arg-types      self.write(fd)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python code get and set methods to set values in file' [SEP] def clean_with_zeros(self,x):         \"\"\" set nan and inf rows from x to zero\"\"\"         x[~np.any(np.isnan(x) | np.isinf(x),axis=1)] = 0         return x", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to write a string in a file python [SEP] def write_text(filename: str, text: str) -> None:     \"\"\"     Writes text to a file.     \"\"\"     with open(filename, 'w') as f:  # type: TextIO         print(text, file=f)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to write a string in a file python [SEP] def uniqued(iterable):     \"\"\"Return unique list of ``iterable`` items preserving order.      >>> uniqued('spameggs')     ['s', 'p', 'a', 'm', 'e', 'g']     \"\"\"     seen = set()     return [item for item in iterable if item not in seen and not seen.add(item)]", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to write a string in a file python [SEP] def write(file_name, data):     \"\"\"Encode and write a Hip file.\"\"\"     with open(file_name, 'w') as f:         f.write(encode(data))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to write a string in a file python [SEP] def imt2tup(string):     \"\"\"     >>> imt2tup('PGA')     ('PGA',)     >>> imt2tup('SA(1.0)')     ('SA', 1.0)     >>> imt2tup('SA(1)')     ('SA', 1.0)     \"\"\"     s = string.strip()     if not s.endswith(')'):         # no parenthesis, PGA is considered the same as PGA()         return (s,)     name, rest = s.split('(', 1)     return (name,) + tuple(float(x) for x in ast.literal_eval(rest[:-1] + ','))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python split on any whitespace [SEP] def clean(s):   \"\"\"Removes trailing whitespace on each line.\"\"\"   lines = [l.rstrip() for l in s.split('\\n')]   return '\\n'.join(lines)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python split on any whitespace [SEP] def normalize_dictionary(data_dict):     \"\"\"     Converts all the keys in \"data_dict\" to strings. The keys must be     convertible using str().     \"\"\"     for key, value in data_dict.items():         if not isinstance(key, str):             del data_dict[key]             data_dict[str(key)] = value     return data_dict", "target": 0, "target_options": ["no match", "match"]}
{"input": "python split on any whitespace [SEP] def normalize_value(text):     \"\"\"     This removes newlines and multiple spaces from a string.     \"\"\"     result = text.replace('\\n', ' ')     result = re.subn('[ ]{2,}', ' ', result)[0]     return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python split on any whitespace [SEP] def get_object_info(self):         \"\"\"         Returns object info in following form <module.class object at address>         \"\"\"         objectinfo = str(self.__class__).replace(\">\", \"\")         objectinfo = objectinfo.replace(\"class \", \"\")         objectinfo = objectinfo.replace(\"'\", \"\")         objectinfo += \" object at 0x%x>\" % id(self)         return objectinfo", "target": 0, "target_options": ["no match", "match"]}
{"input": "python program to login using the password sent through mail [SEP] def send_password_reset_link(self, username):         \"\"\"Sends the user a password reset link (by email)          Args:             username: The account username.          Returns:             True: Succeeded             False: If unsuccessful         \"\"\"          response = self._post(self.rest_url + \"/user/mail/password\",                               params={\"username\": username})          if response.ok:             return True          return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python program to login using the password sent through mail [SEP] def check_for_key(self, key, bucket_name=None):         \"\"\"         Checks if a key exists in a bucket          :param key: S3 key that will point to the file         :type key: str         :param bucket_name: Name of the bucket in which the file is stored         :type bucket_name: str         \"\"\"         if not bucket_name:             (bucket_name, key) = self.parse_s3_url(key)          try:             self.get_conn().head_object(Bucket=bucket_name, Key=key)             return True         except ClientError as e:             self.log.info(e.response[\"Error\"][\"Message\"])             return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "python program to login using the password sent through mail [SEP] def authenticate(self, username=\"\", password=\"\", **kwargs):         \"\"\"Allow users to log in with their email address.\"\"\"         try:             user = get_user_model().objects.filter(email__iexact=username)[0]             if check_password(password, user.password):                 return user             else:                 return None         except IndexError:             # No user was found, return None - triggers default login failed             return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python program to login using the password sent through mail [SEP] def make_regex(separator):     \"\"\"Utility function to create regexp for matching escaped separators     in strings.      \"\"\"     return re.compile(r'(?:' + re.escape(separator) + r')?((?:[^' +                       re.escape(separator) + r'\\\\]|\\\\.)+)')", "target": 0, "target_options": ["no match", "match"]}
{"input": "change letter into number in python [SEP] def safe_int_conv(number):     \"\"\"Safely convert a single number to integer.\"\"\"     try:         return int(np.array(number).astype(int, casting='safe'))     except TypeError:         raise ValueError('cannot safely convert {} to integer'.format(number))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "change letter into number in python [SEP] def csvpretty(csvfile: csvfile=sys.stdin):     \"\"\" Pretty print a CSV file. \"\"\"     shellish.tabulate(csv.reader(csvfile))", "target": 0, "target_options": ["no match", "match"]}
{"input": "change letter into number in python [SEP] def round_to_int(number, precision):     \"\"\"Round a number to a precision\"\"\"     precision = int(precision)     rounded = (int(number) + precision / 2) // precision * precision     return rounded", "target": 1, "target_options": ["no_match", "match"]}
{"input": "change letter into number in python [SEP] def shape(self):         \"\"\"Compute the shape of the dataset as (rows, cols).\"\"\"         if not self.data:             return (0, 0)         return (len(self.data), len(self.dimensions))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python modify certain elements in list [SEP] def unique_element(ll):     \"\"\" returns unique elements from a list preserving the original order \"\"\"     seen = {}     result = []     for item in ll:         if item in seen:             continue         seen[item] = 1         result.append(item)     return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python modify certain elements in list [SEP] def _css_select(soup, css_selector):         \"\"\" Returns the content of the element pointed by the CSS selector,         or an empty string if not found \"\"\"         selection = soup.select(css_selector)         if len(selection) > 0:             if hasattr(selection[0], 'text'):                 retour = selection[0].text.strip()             else:                 retour = \"\"         else:             retour = \"\"         return retour", "target": 0, "target_options": ["no match", "match"]}
{"input": "python modify certain elements in list [SEP] def unique(input_list):     \"\"\"     Return a list of unique items (similar to set functionality).      Parameters     ----------     input_list : list         A list containg some items that can occur more than once.      Returns     -------     list         A list with only unique occurances of an item.      \"\"\"     output = []     for item in input_list:         if item not in output:             output.append(item)     return output", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python modify certain elements in list [SEP] def _has(self, key, exact=0):          \"\"\"Returns false if key is not found or is ambiguous\"\"\"          if not exact:             try:                 key = self.getfullkey(key)                 return 1             except KeyError:                 return 0         else:             return key in self.data", "target": 0, "target_options": ["no match", "match"]}
{"input": "validation for numbers in python [SEP] def normalize_unitnumber(unit_number):     \"\"\"Returns a normalized unit number, i.e. integers     Raises exception X10InvalidUnitNumber if unit number appears to be invalid     \"\"\"     try:         try:             unit_number = int(unit_number)         except ValueError:             raise X10InvalidUnitNumber('%r not a valid unit number' % unit_number)     except TypeError:         raise X10InvalidUnitNumber('%r not a valid unit number' % unit_number)     if not (1 <= unit_number <= 16):         raise X10InvalidUnitNumber('%r not a valid unit number' % unit_number)     return unit_number", "target": 1, "target_options": ["no_match", "match"]}
{"input": "validation for numbers in python [SEP] def get_memory_usage():     \"\"\"Gets RAM memory usage      :return: MB of memory used by this process     \"\"\"     process = psutil.Process(os.getpid())     mem = process.memory_info().rss     return mem / (1024 * 1024)", "target": 0, "target_options": ["no match", "match"]}
{"input": "validation for numbers in python [SEP] def is_valid(number):     \"\"\"determines whether the card number is valid.\"\"\"     n = str(number)     if not n.isdigit():         return False     return int(n[-1]) == get_check_digit(n[:-1])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "validation for numbers in python [SEP] def convertToNative(self, aVal):         \"\"\" Convert to native bool; interpret certain strings. \"\"\"         if aVal is None:             return None         if isinstance(aVal, bool): return aVal         # otherwise interpret strings         return str(aVal).lower() in ('1','on','yes','true')", "target": 0, "target_options": ["no match", "match"]}
{"input": "python opencv how to change black and white in binary image [SEP] def gray2bgr(img):     \"\"\"Convert a grayscale image to BGR image.      Args:         img (ndarray or str): The input image.      Returns:         ndarray: The converted BGR image.     \"\"\"     img = img[..., None] if img.ndim == 2 else img     out_img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)     return out_img", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python opencv how to change black and white in binary image [SEP] def dict_merge(set1, set2):     \"\"\"Joins two dictionaries.\"\"\"     return dict(list(set1.items()) + list(set2.items()))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python opencv how to change black and white in binary image [SEP] def lighting(im, b, c):     \"\"\" Adjust image balance and contrast \"\"\"     if b==0 and c==1: return im     mu = np.average(im)     return np.clip((im-mu)*c+mu+b,0.,1.).astype(np.float32)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python opencv how to change black and white in binary image [SEP] def compare(a, b):     \"\"\"      Compare items in 2 arrays. Returns sum(abs(a(i)-b(i)))     \"\"\"     s=0     for i in range(len(a)):         s=s+abs(a[i]-b[i])     return s", "target": 0, "target_options": ["no match", "match"]}
{"input": "python test if variable is not null [SEP] def get(self):         \"\"\"         \"\"\"          if self.saved_list is None and self.null is False:             self.saved_list = []          return self.saved_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python test if variable is not null [SEP] def datetime_to_ms(dt):     \"\"\"     Converts a datetime to a millisecond accuracy timestamp     \"\"\"     seconds = calendar.timegm(dt.utctimetuple())     return seconds * 1000 + int(dt.microsecond / 1000)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python test if variable is not null [SEP] def is_all_field_none(self):         \"\"\"         :rtype: bool         \"\"\"          if self._type_ is not None:             return False          if self._value is not None:             return False          if self._name is not None:             return False          return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python test if variable is not null [SEP] def round_to_int(number, precision):     \"\"\"Round a number to a precision\"\"\"     precision = int(precision)     rounded = (int(number) + precision / 2) // precision * precision     return rounded", "target": 0, "target_options": ["no match", "match"]}
{"input": "bokeh python showing legend [SEP] def finish_plot():     \"\"\"Helper for plotting.\"\"\"     plt.legend()     plt.grid(color='0.7')     plt.xlabel('x')     plt.ylabel('y')     plt.show()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "bokeh python showing legend [SEP] def slugify(s):     \"\"\"     Converts the given string to a URL slug.     \"\"\"     s = strip_accents(s.replace(\"'\", '').lower())     return re.sub('[^a-z0-9]+', ' ', s).strip().replace(' ', '-')", "target": 0, "target_options": ["no match", "match"]}
{"input": "bokeh python showing legend [SEP] def show(self, title=''):         \"\"\"         Display Bloch sphere and corresponding data sets.         \"\"\"         self.render(title=title)         if self.fig:             plt.show(self.fig)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "bokeh python showing legend [SEP] def url_read_text(url, verbose=True):     r\"\"\"     Directly reads text data from url     \"\"\"     data = url_read(url, verbose)     text = data.decode('utf8')     return text", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to append text in python text box [SEP] def _new_output_char(self, char):         \"\"\" insert in text field \"\"\"         self.text.config(state=tkinter.NORMAL)         self.text.insert(\"end\", char)         self.text.see(\"end\")         self.text.config(state=tkinter.DISABLED)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to append text in python text box [SEP] def __contains__(self, key):         \"\"\"         Invoked when determining whether a specific key is in the dictionary         using `key in d`.          The key is looked up case-insensitively.         \"\"\"         k = self._real_key(key)         return k in self._data", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to append text in python text box [SEP] def set_value(self, text):         \"\"\"Sets the text content.          Args:             text (str): The string content that have to be appended as standard child identified by the key 'text'         \"\"\"         if self.single_line:             text = text.replace('\\n', '')         self.set_text(text)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to append text in python text box [SEP] def dims_intersect(self):         \"\"\"Dimensions of the arrays in this list that are used in all arrays         \"\"\"         return set.intersection(*map(             set, (getattr(arr, 'dims_intersect', arr.dims) for arr in self)))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python write to file ascii [SEP] def writeFile(filename, data): \t\t\"\"\" \t\tWrites data to a file \t\t\"\"\" \t\twith open(filename, 'wb') as f: \t\t\tf.write(data.encode('utf-8'))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python write to file ascii [SEP] def readTuple(self, line, n=3):         \"\"\" Reads a tuple of numbers. e.g. vertices, normals or teture coords.         \"\"\"         numbers = [num for num in line.split(' ') if num]         return [float(num) for num in numbers[1:n + 1]]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python write to file ascii [SEP] def items2file(items, filename, encoding='utf-8', modifier='w'):     \"\"\"         json array to file, canonical json format     \"\"\"     with codecs.open(filename, modifier, encoding=encoding) as f:         for item in items:             f.write(u\"{}\\n\".format(json.dumps(                 item, ensure_ascii=False, sort_keys=True)))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python write to file ascii [SEP] def text_remove_empty_lines(text):     \"\"\"     Whitespace normalization:        - Strip empty lines       - Strip trailing whitespace     \"\"\"     lines = [ line.rstrip()  for line in text.splitlines()  if line.strip() ]     return \"\\n\".join(lines)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to remove /n in the end of string in python [SEP] def replaceNewlines(string, newlineChar): \t\"\"\"There's probably a way to do this with string functions but I was lazy. \t\tReplace all instances of \\r or \\n in a string with something else.\"\"\" \tif newlineChar in string: \t\tsegments = string.split(newlineChar) \t\tstring = \"\" \t\tfor segment in segments: \t\t\tstring += segment \treturn string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to remove /n in the end of string in python [SEP] async def disconnect(self):         \"\"\" Disconnect from target. \"\"\"         if not self.connected:             return          self.writer.close()         self.reader = None         self.writer = None", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to remove /n in the end of string in python [SEP] def normalize_value(text):     \"\"\"     This removes newlines and multiple spaces from a string.     \"\"\"     result = text.replace('\\n', ' ')     result = re.subn('[ ]{2,}', ' ', result)[0]     return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to remove /n in the end of string in python [SEP] def print_with_header(header, message, color, indent=0):     \"\"\"     Use one of the functions below for printing, not this one.     \"\"\"     print()     padding = ' ' * indent     print(padding + color + BOLD + header + ENDC + color + message + ENDC)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to keep 4 digit python [SEP] def py3round(number):     \"\"\"Unified rounding in all python versions.\"\"\"     if abs(round(number) - number) == 0.5:         return int(2.0 * round(number / 2.0))      return int(round(number))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to keep 4 digit python [SEP] def kernel_shap_1000_meanref(model, data):     \"\"\" Kernel SHAP 1000 mean ref.     color = red_blue_circle(0.5)     linestyle = solid     \"\"\"     return lambda X: KernelExplainer(model.predict, kmeans(data, 1)).shap_values(X, nsamples=1000, l1_reg=0)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to keep 4 digit python [SEP] def round_to_x_digits(number, digits):     \"\"\"     Returns 'number' rounded to 'digits' digits.     \"\"\"     return round(number * math.pow(10, digits)) / math.pow(10, digits)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to keep 4 digit python [SEP] def imt2tup(string):     \"\"\"     >>> imt2tup('PGA')     ('PGA',)     >>> imt2tup('SA(1.0)')     ('SA', 1.0)     >>> imt2tup('SA(1)')     ('SA', 1.0)     \"\"\"     s = string.strip()     if not s.endswith(')'):         # no parenthesis, PGA is considered the same as PGA()         return (s,)     name, rest = s.split('(', 1)     return (name,) + tuple(float(x) for x in ast.literal_eval(rest[:-1] + ','))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to get alist as input in python [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to get alist as input in python [SEP] def check_max_filesize(chosen_file, max_size):     \"\"\"     Checks file sizes for host     \"\"\"     if os.path.getsize(chosen_file) > max_size:         return False     else:         return True", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to get alist as input in python [SEP] def _import_string(names):     \"\"\"return a list of (name, asname) formatted as a string\"\"\"     _names = []     for name, asname in names:         if asname is not None:             _names.append(\"%s as %s\" % (name, asname))         else:             _names.append(name)     return \", \".join(_names)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to get alist as input in python [SEP] def build_suite(args):     \"\"\"Build a test suite by loading TAP files or a TAP stream.\"\"\"     loader = Loader()     if len(args.files) == 0 or args.files[0] == \"-\":         suite = loader.load_suite_from_stdin()     else:         suite = loader.load(args.files)     return suite", "target": 0, "target_options": ["no match", "match"]}
{"input": "load gif images in python [SEP] def ReadTif(tifFile):         \"\"\"Reads a tif file to a 2D NumPy array\"\"\"         img = Image.open(tifFile)         img = np.array(img)         return img", "target": 1, "target_options": ["no_match", "match"]}
{"input": "load gif images in python [SEP] def skip_connection_distance(a, b):     \"\"\"The distance between two skip-connections.\"\"\"     if a[2] != b[2]:         return 1.0     len_a = abs(a[1] - a[0])     len_b = abs(b[1] - b[0])     return (abs(a[0] - b[0]) + abs(len_a - len_b)) / (max(a[0], b[0]) + max(len_a, len_b))", "target": 0, "target_options": ["no match", "match"]}
{"input": "load gif images in python [SEP] def load_file(self, input_file):         \"\"\" Loads data array from file (result of this converter)          Tries to import, load and replace files' data.         It will overwirte previously added items with #add_file or #load_file.          :param input_file         :type str or unicode         \"\"\"         pyimg = imp.load_source('image2py_taf', input_file)         self.files = pyimg.data         self.set_template(templates.templateByName(pyimg.template))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "load gif images in python [SEP] def data(fname):     \"\"\"Return the contents of a data file of ours.\"\"\"     data_file = open(data_filename(fname))     try:         return data_file.read()     finally:         data_file.close()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python multiprocessing to increase cpu usage [SEP] def _timed_process(self, *args, **kwargs):         \"\"\"Track Processor execution time for benchmarking.\"\"\"         for processor in self._processors:             start_time = _time.process_time()             processor.process(*args, **kwargs)             process_time = int(round((_time.process_time() - start_time) * 1000, 2))             self.process_times[processor.__class__.__name__] = process_time", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python multiprocessing to increase cpu usage [SEP] def is_dec(ip):     \"\"\"Return true if the IP address is in decimal notation.\"\"\"     try:         dec = int(str(ip))     except ValueError:         return False     if dec > 4294967295 or dec < 0:         return False     return True", "target": 0, "target_options": ["no match", "match"]}
{"input": "python multiprocessing to increase cpu usage [SEP] def get_memory_usage():     \"\"\"Gets RAM memory usage      :return: MB of memory used by this process     \"\"\"     process = psutil.Process(os.getpid())     mem = process.memory_info().rss     return mem / (1024 * 1024)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python multiprocessing to increase cpu usage [SEP] def get_basket_items(request):     \"\"\"     Get all items in the basket     \"\"\"     bid = basket_id(request)     return BasketItem.objects.filter(basket_id=bid), bid", "target": 0, "target_options": ["no match", "match"]}
{"input": "save image in a path in python [SEP] def relative_path(path):     \"\"\"     Return the given path relative to this file.     \"\"\"     return os.path.join(os.path.dirname(__file__), path)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "save image in a path in python [SEP] def replace(s, replace):     \"\"\"Replace multiple values in a string\"\"\"     for r in replace:         s = s.replace(*r)     return s", "target": 0, "target_options": ["no match", "match"]}
{"input": "save image in a path in python [SEP] def get_cache_path(filename): \t\"\"\" get file path \"\"\" \tcwd = os.path.dirname(os.path.realpath(__file__)) \treturn os.path.join(cwd, filename)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "save image in a path in python [SEP] def __init__(self, baken_file=None):         \"\"\"Initialise a new `Bakens` object.\"\"\"         super(Bakens, self).__init__()         if baken_file:             self.import_locations(baken_file)", "target": 0, "target_options": ["no match", "match"]}
{"input": "make deep copy of list python [SEP] def unique(list):     \"\"\" Returns a copy of the list without duplicates.     \"\"\"     unique = []; [unique.append(x) for x in list if x not in unique]     return unique", "target": 1, "target_options": ["no_match", "match"]}
{"input": "make deep copy of list python [SEP] def get_value_tuple(self):         \"\"\"         Returns a tuple of the color's values (in order). For example,         an LabColor object will return (lab_l, lab_a, lab_b), where each         member of the tuple is the float value for said variable.         \"\"\"         retval = tuple()         for val in self.VALUES:             retval += (getattr(self, val),)         return retval", "target": 0, "target_options": ["no match", "match"]}
{"input": "make deep copy of list python [SEP] def copy(self):         \"\"\"Return a copy of this list with each element copied to new memory         \"\"\"         out = type(self)()         for series in self:             out.append(series.copy())         return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "make deep copy of list python [SEP] def draw(self, mode=\"triangles\"):         \"\"\" Draw collection \"\"\"          gl.glDepthMask(0)         Collection.draw(self, mode)         gl.glDepthMask(1)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python split two delimiter [SEP] def make_regex(separator):     \"\"\"Utility function to create regexp for matching escaped separators     in strings.      \"\"\"     return re.compile(r'(?:' + re.escape(separator) + r')?((?:[^' +                       re.escape(separator) + r'\\\\]|\\\\.)+)')", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python split two delimiter [SEP] def _check_and_convert_bools(self):         \"\"\"Replace boolean variables by the characters 'F'/'T'         \"\"\"         replacements = {             True: 'T',             False: 'F',         }          for key in self.bools:             if isinstance(self[key], bool):                 self[key] = replacements[self[key]]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python split two delimiter [SEP] def parse_prefix(identifier):     \"\"\"     Parse identifier such as a|c|le|d|li|re|or|AT4G00480.1 and return     tuple of prefix string (separated at '|') and suffix (AGI identifier)     \"\"\"     pf, id = (), identifier     if \"|\" in identifier:         pf, id = tuple(identifier.split('|')[:-1]), identifier.split('|')[-1]      return pf, id", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python split two delimiter [SEP] def valid_file(path: str) -> bool:     \"\"\"     Verifies that a string path actually exists and is a file      :param path: The path to verify     :return: **True** if path exist and is a file     \"\"\"     path = Path(path).expanduser()     log.debug(\"checking if %s is a valid file\", path)     return path.exists() and path.is_file()", "target": 0, "target_options": ["no match", "match"]}
{"input": "finding the index of an element in a list python [SEP] def binSearch(arr, val):   \"\"\"    Function for running binary search on a sorted list.    :param arr: (list) a sorted list of integers to search   :param val: (int)  a integer to search for in the sorted array   :returns: (int) the index of the element if it is found and -1 otherwise.   \"\"\"   i = bisect_left(arr, val)   if i != len(arr) and arr[i] == val:     return i   return -1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "finding the index of an element in a list python [SEP] def draw_image(self, ax, image):         \"\"\"Process a matplotlib image object and call renderer.draw_image\"\"\"         self.renderer.draw_image(imdata=utils.image_to_base64(image),                                  extent=image.get_extent(),                                  coordinates=\"data\",                                  style={\"alpha\": image.get_alpha(),                                         \"zorder\": image.get_zorder()},                                  mplobj=image)", "target": 0, "target_options": ["no match", "match"]}
{"input": "finding the index of an element in a list python [SEP] def find_geom(geom, geoms):     \"\"\"     Returns the index of a geometry in a list of geometries avoiding     expensive equality checks of `in` operator.     \"\"\"     for i, g in enumerate(geoms):         if g is geom:             return i", "target": 1, "target_options": ["no_match", "match"]}
{"input": "finding the index of an element in a list python [SEP] def onscreen_len(s):     \"\"\"     Calculate the length of a unicode string on screen,     accounting for double-width characters      \"\"\"      if sys.version_info < (3, 0) and isinstance(s, str):         return len(s)      length = 0     for ch in s:         length += 2 if unicodedata.east_asian_width(ch) == 'W' else 1      return length", "target": 0, "target_options": ["no match", "match"]}
{"input": "python dont break line [SEP] def scroll_down(lines=1, file=sys.stdout):     \"\"\" Scroll the whole page down a number of lines, new lines are added to         the top.          Esc[<lines>T     \"\"\"     scroll.down(lines).write(file=file)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python dont break line [SEP] def _timed_process(self, *args, **kwargs):         \"\"\"Track Processor execution time for benchmarking.\"\"\"         for processor in self._processors:             start_time = _time.process_time()             processor.process(*args, **kwargs)             process_time = int(round((_time.process_time() - start_time) * 1000, 2))             self.process_times[processor.__class__.__name__] = process_time", "target": 0, "target_options": ["no match", "match"]}
{"input": "python dont break line [SEP] def normalize_multiline(line):     \"\"\"Normalize multiline-related code that will cause syntax error.      This is for purposes of checking syntax.      \"\"\"     if line.startswith('def ') and line.rstrip().endswith(':'):         return line + ' pass'     elif line.startswith('return '):         return 'def _(): ' + line     elif line.startswith('@'):         return line + 'def _(): pass'     elif line.startswith('class '):         return line + ' pass'     elif line.startswith(('if ', 'elif ', 'for ', 'while ')):         return line + ' pass'     else:         return line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python dont break line [SEP] def is_executable(path):   \"\"\"Returns whether a path names an existing executable file.\"\"\"   return os.path.isfile(path) and os.access(path, os.X_OK)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to check time stamp of file python [SEP] def get_time(filename): \t\"\"\" \tGet the modified time for a file as a datetime instance \t\"\"\" \tts = os.stat(filename).st_mtime \treturn datetime.datetime.utcfromtimestamp(ts)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to check time stamp of file python [SEP] def _handle_shell(self,cfg_file,*args,**options):         \"\"\"Command 'supervisord shell' runs the interactive command shell.\"\"\"         args = (\"--interactive\",) + args         return supervisorctl.main((\"-c\",cfg_file) + args)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to check time stamp of file python [SEP] def set_time(filename, mod_time): \t\"\"\" \tSet the modified time of a file \t\"\"\" \tlog.debug('Setting modified time to %s', mod_time) \tmtime = calendar.timegm(mod_time.utctimetuple()) \t# utctimetuple discards microseconds, so restore it (for consistency) \tmtime += mod_time.microsecond / 1000000 \tatime = os.stat(filename).st_atime \tos.utime(filename, (atime, mtime))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to check time stamp of file python [SEP] async def login(         username: str, password: str, brand: str,         websession: ClientSession = None) -> API:     \"\"\"Log in to the API.\"\"\"     api = API(brand, websession)     await api.authenticate(username, password)     return api", "target": 0, "target_options": ["no match", "match"]}
{"input": "python fromfile size limit [SEP] def check_max_filesize(chosen_file, max_size):     \"\"\"     Checks file sizes for host     \"\"\"     if os.path.getsize(chosen_file) > max_size:         return False     else:         return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python fromfile size limit [SEP] def dot_product(self, other):         \"\"\" Return the dot product of the given vectors. \"\"\"         return self.x * other.x + self.y * other.y", "target": 0, "target_options": ["no match", "match"]}
{"input": "python fromfile size limit [SEP] def _increase_file_handle_limit():     \"\"\"Raise the open file handles permitted by the Dusty daemon process     and its child processes. The number we choose here needs to be within     the OS X default kernel hard limit, which is 10240.\"\"\"     logging.info('Increasing file handle limit to {}'.format(constants.FILE_HANDLE_LIMIT))     resource.setrlimit(resource.RLIMIT_NOFILE,                        (constants.FILE_HANDLE_LIMIT, resource.RLIM_INFINITY))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python fromfile size limit [SEP] def _str_to_list(s):     \"\"\"Converts a comma separated string to a list\"\"\"     _list = s.split(\",\")     return list(map(lambda i: i.lstrip(), _list))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python does slicing return a new list [SEP] def Slice(a, begin, size):     \"\"\"     Slicing op.     \"\"\"     return np.copy(a)[[slice(*tpl) for tpl in zip(begin, begin+size)]],", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python does slicing return a new list [SEP] def _remove_duplicates(objects):     \"\"\"Removes duplicate objects.      http://www.peterbe.com/plog/uniqifiers-benchmark.     \"\"\"     seen, uniq = set(), []     for obj in objects:         obj_id = id(obj)         if obj_id in seen:             continue         seen.add(obj_id)         uniq.append(obj)     return uniq", "target": 0, "target_options": ["no match", "match"]}
{"input": "python does slicing return a new list [SEP] def sliced(seq, n):     \"\"\"Yield slices of length *n* from the sequence *seq*.          >>> list(sliced((1, 2, 3, 4, 5, 6), 3))         [(1, 2, 3), (4, 5, 6)]      If the length of the sequence is not divisible by the requested slice     length, the last slice will be shorter.          >>> list(sliced((1, 2, 3, 4, 5, 6, 7, 8), 3))         [(1, 2, 3), (4, 5, 6), (7, 8)]      This function will only work for iterables that support slicing.     For non-sliceable iterables, see :func:`chunked`.      \"\"\"     return takewhile(bool, (seq[i: i + n] for i in count(0, n)))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python does slicing return a new list [SEP] def add_newlines(tree):     \"\"\"     Add a newline character to the end of each <br> element.     \"\"\"     for br in tree.xpath(\"*//br\"):         br.tail = u\"\\n\" + br.tail if br.tail else u\"\\n\"", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to set number boundaries in python [SEP] def _numbers_units(N):     \"\"\"     >>> _numbers_units(45)     '123456789012345678901234567890123456789012345'     \"\"\"     lst = range(1, N + 1)     return \"\".join(list(map(lambda i: str(i % 10), lst)))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to set number boundaries in python [SEP] def dump_dict_to_file(dictionary, filepath):     \"\"\"Dump @dictionary as a line to @filepath.\"\"\"     create_dirs(         os.path.dirname(filepath)     )      with open(filepath, 'a') as outfile:         json.dump(dictionary, outfile)         outfile.write('\\n')", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to set number boundaries in python [SEP] def pp(i, base=1024):     \"\"\"     Pretty-print the integer `i` as a human-readable size representation.     \"\"\"     degree = 0     pattern = \"%4d     %s\"     while i > base:         pattern = \"%7.2f %s\"         i = i / float(base)         degree += 1     scales = ['B', 'KB', 'MB', 'GB', 'TB', 'EB']     return pattern % (i, scales[degree])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to set number boundaries in python [SEP] def start(self):         \"\"\"Start the import thread.\"\"\"         self.t = threading.Thread(target=self._run, name=\"ray_import_thread\")         # Making the thread a daemon causes it to exit         # when the main thread exits.         self.t.daemon = True         self.t.start()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python subtract array from each row [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python subtract array from each row [SEP] def is_published(self):         \"\"\"stub\"\"\"         if 'published' not in self.my_osid_object._my_map:             return False         return bool(self.my_osid_object._my_map['published'])", "target": 0, "target_options": ["no match", "match"]}
{"input": "python subtract array from each row [SEP] def recarray(self):         \"\"\"Returns data as :class:`numpy.recarray`.\"\"\"         return numpy.rec.fromrecords(self.records, names=self.names)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python subtract array from each row [SEP] def url_to_image(url, flag=cv2.IMREAD_COLOR):     \"\"\" download the image, convert it to a NumPy array, and then read     it into OpenCV format \"\"\"     resp = urlopen(url)     image = np.asarray(bytearray(resp.read()), dtype=\"uint8\")     image = cv2.imdecode(image, flag)     return image", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to match letter in list python [SEP] def isin(elems, line):     \"\"\"Check if an element from a list is in a string.      :type elems: list     :type line: str      \"\"\"     found = False     for e in elems:         if e in line.lower():             found = True             break     return found", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to match letter in list python [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to match letter in list python [SEP] def match_all_in(self, matches, item):         \"\"\"Matches all matches to elements of item.\"\"\"         for i, match in enumerate(matches):             self.match(match, item + \"[\" + str(i) + \"]\")", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to match letter in list python [SEP] def _station(self) -> str:         \"\"\"Extract station name.\"\"\"         return str(self.obj.SBRes.SBReq.Start.Station.HafasName.Text.pyval)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python string check if char is letter [SEP] def isthaichar(ch: str) -> bool:     \"\"\"     Check if a character is Thai     เป็นอักษรไทยหรือไม่      :param str ch: input character     :return: True or False     \"\"\"     ch_val = ord(ch)     if ch_val >= 3584 and ch_val <= 3711:         return True     return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python string check if char is letter [SEP] def is_string(obj):     \"\"\"Is this a string.      :param object obj:     :rtype: bool     \"\"\"     if PYTHON3:         str_type = (bytes, str)     else:         str_type = (bytes, str, unicode)     return isinstance(obj, str_type)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python string check if char is letter [SEP] def isAlphanum(c):     \"\"\"return true if the character is a letter, digit, underscore,            dollar sign, or non-ASCII character.     \"\"\"     return ((c >= 'a' and c <= 'z') or (c >= '0' and c <= '9') or             (c >= 'A' and c <= 'Z') or c == '_' or c == '$' or c == '\\\\' or (c is not None and ord(c) > 126));", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python string check if char is letter [SEP] def str2int(string_with_int):     \"\"\" Collect digits from a string \"\"\"     return int(\"\".join([char for char in string_with_int if char in string.digits]) or 0)", "target": 0, "target_options": ["no match", "match"]}
{"input": "write a dict to a file in python [SEP] def _write_json(file, contents):     \"\"\"Write a dict to a JSON file.\"\"\"     with open(file, 'w') as f:         return json.dump(contents, f, indent=2, sort_keys=True)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "write a dict to a file in python [SEP] def list_of_lists_to_dict(l):     \"\"\" Convert list of key,value lists to dict      [['id', 1], ['id', 2], ['id', 3], ['foo': 4]]     {'id': [1, 2, 3], 'foo': [4]}     \"\"\"     d = {}     for key, val in l:         d.setdefault(key, []).append(val)     return d", "target": 0, "target_options": ["no match", "match"]}
{"input": "write a dict to a file in python [SEP] def dump_dict_to_file(dictionary, filepath):     \"\"\"Dump @dictionary as a line to @filepath.\"\"\"     create_dirs(         os.path.dirname(filepath)     )      with open(filepath, 'a') as outfile:         json.dump(dictionary, outfile)         outfile.write('\\n')", "target": 1, "target_options": ["no_match", "match"]}
{"input": "write a dict to a file in python [SEP] def im2mat(I):     \"\"\"Converts and image to matrix (one pixel per line)\"\"\"     return I.reshape((I.shape[0] * I.shape[1], I.shape[2]))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to put comma in number then right alignment in python [SEP] def add_colons(s):     \"\"\"Add colons after every second digit.      This function is used in functions to prettify serials.      >>> add_colons('teststring')     'te:st:st:ri:ng'     \"\"\"     return ':'.join([s[i:i + 2] for i in range(0, len(s), 2)])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to put comma in number then right alignment in python [SEP] def convert_array(array):     \"\"\"     Converts an ARRAY string stored in the database back into a Numpy array.      Parameters     ----------     array: ARRAY         The array object to be converted back into a Numpy array.      Returns     -------     array             The converted Numpy array.      \"\"\"     out = io.BytesIO(array)     out.seek(0)     return np.load(out)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to put comma in number then right alignment in python [SEP] def draw_header(self, stream, header):         \"\"\"Draw header with underline\"\"\"         stream.writeln('=' * (len(header) + 4))         stream.writeln('| ' + header + ' |')         stream.writeln('=' * (len(header) + 4))         stream.writeln()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to put comma in number then right alignment in python [SEP] def sing(a, b, c=False, name='yetone'):     \"\"\"sing a song     hehe      :param a: I'm a     :param b: I'm b     :param c: I'm c     :param name: I'm name     \"\"\"     print('test0.sing: <a: {}, b: {}, c: {}> by {}'.format(a, b, c, name))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python urllib how to save image use [SEP] def url_to_image(url):     \"\"\"     Fetch an image from url and convert it into a Pillow Image object     \"\"\"     r = requests.get(url)     image = StringIO(r.content)     return image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python urllib how to save image use [SEP] def detach(self):         \"\"\"         Detach the underlying LLVM resource without disposing of it.         \"\"\"         if not self._closed:             del self._as_parameter_             self._closed = True             self._ptr = None", "target": 0, "target_options": ["no match", "match"]}
{"input": "python urllib how to save image use [SEP] def downloadImg(url, tofile=None):     \"\"\"     \"\"\"     r = urllib2.Request(url)     img_data = urllib2.urlopen(r).read()     img_buffer = StringIO.StringIO(img_data)     img = Image.open(img_buffer)     if FILE.make and tofile is not None:         img.save(FILE.dir + tofile)     return img", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python urllib how to save image use [SEP] def convert_array(array):     \"\"\"     Converts an ARRAY string stored in the database back into a Numpy array.      Parameters     ----------     array: ARRAY         The array object to be converted back into a Numpy array.      Returns     -------     array             The converted Numpy array.      \"\"\"     out = io.BytesIO(array)     out.seek(0)     return np.load(out)", "target": 0, "target_options": ["no match", "match"]}
{"input": "for loop comment line python [SEP] def sflow_sample_rate(self, **kwargs):         \"\"\"Auto Generated Code         \"\"\"         config = ET.Element(\"config\")         sflow = ET.SubElement(config, \"sflow\", xmlns=\"urn:brocade.com:mgmt:brocade-sflow\")         sample_rate = ET.SubElement(sflow, \"sample-rate\")         sample_rate.text = kwargs.pop('sample_rate')          callback = kwargs.pop('callback', self._callback)         return callback(config)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "for loop comment line python [SEP] def shape(self):         \"\"\"Compute the shape of the dataset as (rows, cols).\"\"\"         if not self.data:             return (0, 0)         return (len(self.data), len(self.dimensions))", "target": 0, "target_options": ["no match", "match"]}
{"input": "for loop comment line python [SEP] def firmware_download_input_rbridge_id(self, **kwargs):         \"\"\"Auto Generated Code         \"\"\"         config = ET.Element(\"config\")         firmware_download = ET.Element(\"firmware_download\")         config = firmware_download         input = ET.SubElement(firmware_download, \"input\")         rbridge_id = ET.SubElement(input, \"rbridge-id\")         rbridge_id.text = kwargs.pop('rbridge_id')          callback = kwargs.pop('callback', self._callback)         return callback(config)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "for loop comment line python [SEP] def _is_bit(obj):     \"\"\"Determine if obj is a bit\"\"\"     # If there is a bit type this could be replaced by isinstance.     if isinstance(obj, tuple) and len(obj) == 2:         if isinstance(obj[0], Register) and isinstance(obj[1], int) and obj[1] < len(obj[0]):             return True     return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "python not character, continue [SEP] def backward_char(self, e): # (C-b)         u\"\"\"Move back a character. \"\"\"         self.l_buffer.backward_char(self.argument_reset)         self.finalize()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python not character, continue [SEP] def _column(arr, indexes):     \"\"\" Returns a column with given indexes from a deep array      For example, if the array is a matrix and indexes is a single int, will     return arr[:,indexes]. If the array is an order 3 tensor and indexes is a     pair of ints, will return arr[:,indexes[0],indexes[1]], etc.      \"\"\"     if arr.ndim == 2 and types.is_int(indexes):         return arr[:, indexes]     elif arr.ndim == 3 and len(indexes) == 2:         return arr[:, indexes[0], indexes[1]]     else:         raise NotImplementedError('Only supporting arrays of dimension 2 and 3 as yet.')", "target": 0, "target_options": ["no match", "match"]}
{"input": "python not character, continue [SEP] def backward_char_extend_selection(self, e): #         u\"\"\"Move back a character. \"\"\"         self.l_buffer.backward_char_extend_selection(self.argument_reset)         self.finalize()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python not character, continue [SEP] def color_text_boxes(ax, labels, colors, color_arrow=True):     \"\"\"Color text boxes.      Instead of this function, one can pass annotate_kwargs and plot_kwargs to     plot_line_ids function.     \"\"\"     assert len(labels) == len(colors), \\         \"Equal no. of colors and lables must be given\"     boxes = ax.findobj(mpl.text.Annotation)     box_labels = lineid_plot.unique_labels(labels)     for box in boxes:         l = box.get_label()         try:             loc = box_labels.index(l)         except ValueError:             continue  # No changes for this box         box.set_color(colors[loc])         if color_arrow:             box.arrow_patch.set_color(colors[loc])      ax.figure.canvas.draw()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to delete lines [SEP] def cleanLines(source, lineSep=os.linesep):     \"\"\"     :param source: some iterable source (list, file, etc)     :param lineSep: string of separators (chars) that must be removed     :return: list of non empty lines with removed separators     \"\"\"     stripped = (line.strip(lineSep) for line in source)     return (line for line in stripped if len(line) != 0)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to delete lines [SEP] def rstjinja(app, docname, source):     \"\"\"     Render our pages as a jinja template for fancy templating goodness.     \"\"\"     # Make sure we're outputting HTML     if app.builder.format != 'html':         return     src = source[0]     rendered = app.builder.templates.render_string(         src, app.config.html_context     )     source[0] = rendered", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to delete lines [SEP] def _ignore_comments(lines_enum):     \"\"\"     Strips comments and filter empty lines.     \"\"\"     for line_number, line in lines_enum:         line = COMMENT_RE.sub('', line)         line = line.strip()         if line:             yield line_number, line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to delete lines [SEP] def post_sea_resource(url, body):     \"\"\"     Get the requested resource using the Seattle account     :returns: http response with content in json     \"\"\"     response = None     response = TrumbaSea_DAO().postURL(         url,         {\"Content-Type\": \"application/json\"},         body)     _log_json_resp(\"Seattle\", url, body, response)     return response", "target": 0, "target_options": ["no match", "match"]}
{"input": "datetime extract week fo year in python [SEP] def biweekly(date=datetime.date.today()):     \"\"\"     Every two weeks.     \"\"\"     return datetime.date(date.year, date.month, 1 if date.day < 15 else 15)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "datetime extract week fo year in python [SEP] def write(self, data):         \"\"\"         Write the given data to the file.         \"\"\"                  # Do the write         self.backingStream.write(data)                  for listener in self.writeListeners:             # Send out notifications             listener(len(data))", "target": 0, "target_options": ["no match", "match"]}
{"input": "datetime extract week fo year in python [SEP] def week_number(date):     \"\"\"     Return the Python week number of a date.     The django \\|date:\"W\" returns incompatible value     with the view implementation.     \"\"\"     week_number = date.strftime('%W')     if int(week_number) < 10:         week_number = week_number[-1]     return week_number", "target": 1, "target_options": ["no_match", "match"]}
{"input": "datetime extract week fo year in python [SEP] def lowstrip(term):     \"\"\"Convert to lowercase and strip spaces\"\"\"     term = re.sub('\\s+', ' ', term)     term = term.lower()     return term", "target": 0, "target_options": ["no match", "match"]}
{"input": "python are inputs string by default [SEP] def _stdin_(p):     \"\"\"Takes input from user. Works for Python 2 and 3.\"\"\"     _v = sys.version[0]     return input(p) if _v is '3' else raw_input(p)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python are inputs string by default [SEP] def send_test_message(messenger_id, to=None):     \"\"\"Sends a test message using the given messenger.      :param str|unicode messenger_id: Messenger alias.     :param str|unicode to: Recipient address (if applicable).      \"\"\"     messenger_obj = get_registered_messenger_object(messenger_id)     return messenger_obj.send_test_message(to=to, text='Test message from sitemessages.')", "target": 0, "target_options": ["no match", "match"]}
{"input": "python are inputs string by default [SEP] def get_input(input_func, input_str):     \"\"\"     Get input from the user given an input function and an input string     \"\"\"     val = input_func(\"Please enter your {0}: \".format(input_str))     while not val or not len(val.strip()):         val = input_func(\"You didn't enter a valid {0}, please try again: \".format(input_str))     return val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python are inputs string by default [SEP] def main(idle):     \"\"\"Any normal python logic which runs a loop. Can take arguments.\"\"\"     while True:          LOG.debug(\"Sleeping for {0} seconds.\".format(idle))         time.sleep(idle)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to check lenght of matrix in python [SEP] def is_square_matrix(mat):     \"\"\"Test if an array is a square matrix.\"\"\"     mat = np.array(mat)     if mat.ndim != 2:         return False     shape = mat.shape     return shape[0] == shape[1]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to check lenght of matrix in python [SEP] def is_break_tag(self, el):         \"\"\"Check if tag is an element we should break on.\"\"\"          name = el.name         return name in self.break_tags or name in self.user_break_tags", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to check lenght of matrix in python [SEP] def _rectangular(n):     \"\"\"Checks to see if a 2D list is a valid 2D matrix\"\"\"     for i in n:         if len(i) != len(n[0]):             return False     return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to check lenght of matrix in python [SEP] def union(self, other):         \"\"\"produce a 'union' of this dict and another (at the key level).          values in the second dict take precedence over that of the first\"\"\"         x = SetLikeDict(**self)         x.update(other)         return x", "target": 0, "target_options": ["no match", "match"]}
{"input": "python hw to check if string is integer [SEP] def _isint(string):     \"\"\"     >>> _isint(\"123\")     True     >>> _isint(\"123.45\")     False     \"\"\"     return type(string) is int or \\            (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\            _isconvertible(int, string)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python hw to check if string is integer [SEP] def split(s):   \"\"\"Uses dynamic programming to infer the location of spaces in a string without spaces.\"\"\"   l = [_split(x) for x in _SPLIT_RE.split(s)]   return [item for sublist in l for item in sublist]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python hw to check if string is integer [SEP] def str2int(string_with_int):     \"\"\" Collect digits from a string \"\"\"     return int(\"\".join([char for char in string_with_int if char in string.digits]) or 0)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python hw to check if string is integer [SEP] def slugify(value):     \"\"\"Simple Slugify.\"\"\"     s1 = first_cap_re.sub(r'\\1_\\2', value)     s2 = all_cap_re.sub(r'\\1_\\2', s1)     return s2.lower().replace(' _', '_').replace(' ', '_')", "target": 0, "target_options": ["no match", "match"]}
{"input": "python data from multiple columns dumping into one column [SEP] def join_cols(cols):     \"\"\"Join list of columns into a string for a SQL query\"\"\"     return \", \".join([i for i in cols]) if isinstance(cols, (list, tuple, set)) else cols", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python data from multiple columns dumping into one column [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python data from multiple columns dumping into one column [SEP] def convert_to_output_format(param):     \"\"\"     Helper function to convert parameters to a valid string, that can be used in a column name.     Does the opposite which is used in the from_columns function.      The parameters are sorted by their name and written out in the form         <param name>_<param value>__<param name>_<param value>__ ...      If a <param_value> is a string, this method will wrap it with parenthesis \", so \"<param_value>\"      :param param: The dictionary of parameters to write out     :type param: dict      :return: The string of parsed parameters     :rtype: str     \"\"\"      def add_parenthesis_if_string_value(x):         if isinstance(x, string_types):             return '\"' + str(x) + '\"'         else:             return str(x)      return \"__\".join(str(key) + \"_\" + add_parenthesis_if_string_value(param[key]) for key in sorted(param.keys()))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python data from multiple columns dumping into one column [SEP] def __contains__(self, char):  # noqa: D105         \"\"\"Implement the `in` keyword, searches the sequence.         \"\"\"         return len(char) <= len(self) and char in str(self.seq) * 2", "target": 0, "target_options": ["no match", "match"]}
{"input": "pythong concatenate sting and int [SEP] def concat_padded(base, *args):     \"\"\"     Concatenate string and zero-padded 4 digit number     \"\"\"     ret = base     for n in args:         if is_string(n):             ret = \"%s_%s\" % (ret, n)         else:             ret = \"%s_%04i\"  % (ret, n + 1)     return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "pythong concatenate sting and int [SEP] def convert_timestamp(timestamp):     \"\"\"     Converts bokehJS timestamp to datetime64.     \"\"\"     datetime = dt.datetime.utcfromtimestamp(timestamp/1000.)     return np.datetime64(datetime.replace(tzinfo=None))", "target": 0, "target_options": ["no match", "match"]}
{"input": "pythong concatenate sting and int [SEP] def _naturalize_numbers(self, string):         \"\"\"         Makes any integers into very zero-padded numbers.         e.g. '1' becomes '00000001'.         \"\"\"          def naturalize_int_match(match):             return '%08d' % (int(match.group(0)),)          string = re.sub(r'\\d+', naturalize_int_match, string)          return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "pythong concatenate sting and int [SEP] def __contains__(self, item):         \"\"\"(dpid, key) in <ConfSwitchSet instance>\"\"\"         (dpid, key) = item         return dpid in self.confs and key in self.confs[dpid]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python list comprehension to reverse order [SEP] def rvalues(self):         \"\"\"          in reversed order         \"\"\"         tmp = self         while tmp is not None:             yield tmp.data             tmp = tmp.prev", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python list comprehension to reverse order [SEP] def Unpack(a, num, axis):     \"\"\"     Unpack op.     \"\"\"     return tuple(np.squeeze(b, axis=axis) for b in np.split(a, num, axis=axis))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python list comprehension to reverse order [SEP] def get_order(self, codes):         \"\"\"Return evidence codes in order shown in code2name.\"\"\"         return sorted(codes, key=lambda e: [self.ev2idx.get(e)])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python list comprehension to reverse order [SEP] def floor(self):     \"\"\"Round `x` and `y` down to integers.\"\"\"     return Point(int(math.floor(self.x)), int(math.floor(self.y)))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python stringmethods to check exact equality [SEP] def hard_equals(a, b):     \"\"\"Implements the '===' operator.\"\"\"     if type(a) != type(b):         return False     return a == b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python stringmethods to check exact equality [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python stringmethods to check exact equality [SEP] def __eq__(self, other):         \"\"\"         Returns +true+ if the other object is a MIME::Type and the content         types match.         \"\"\"         return isinstance(other, self.__class__) and cmp(self, other) == 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python stringmethods to check exact equality [SEP] def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value", "target": 0, "target_options": ["no match", "match"]}
{"input": "iterate throug list of lists python [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "iterate throug list of lists python [SEP] def _z(self, x):     \"\"\"Standardize input `x` to a unit normal.\"\"\"     with tf.name_scope(\"standardize\"):       return (x - self.loc) / self.scale", "target": 0, "target_options": ["no match", "match"]}
{"input": "iterate throug list of lists python [SEP] def column_stack_2d(data):     \"\"\"Perform column-stacking on a list of 2d data blocks.\"\"\"     return list(list(itt.chain.from_iterable(_)) for _ in zip(*data))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "iterate throug list of lists python [SEP] def list2dict(lst):     \"\"\"Takes a list of (key,value) pairs and turns it into a dict.\"\"\"      dic = {}     for k,v in lst: dic[k] = v     return dic", "target": 0, "target_options": ["no match", "match"]}
{"input": "nested for loop with list coprehension python [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "nested for loop with list coprehension python [SEP] def isworkday(self, date):         \"\"\"         Check if a given date is a work date, ignoring holidays.          Args:             date (date, datetime or str): Date to be checked.          Returns:             bool: True if the date is a work date, False otherwise.         \"\"\"         date = parsefun(date)         return self.weekdaymap[date.weekday()].isworkday", "target": 0, "target_options": ["no match", "match"]}
{"input": "nested for loop with list coprehension python [SEP] def flatten_list(x: List[Any]) -> List[Any]:     \"\"\"     Converts a list of lists into a flat list.          Args:         x: list of lists       Returns:         flat list              As per     http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python      \"\"\"  # noqa     return [item for sublist in x for item in sublist]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "nested for loop with list coprehension python [SEP] def lengths( self ):         \"\"\"         The cell lengths.          Args:             None          Returns:             (np.array(a,b,c)): The cell lengths.         \"\"\"         return( np.array( [ math.sqrt( sum( row**2 ) ) for row in self.matrix ] ) )", "target": 0, "target_options": ["no match", "match"]}
{"input": "python dump json pretty each element in new line [SEP] def prt_js(js, sort_keys=True, indent=4):     \"\"\"Print Json in pretty format.     There's a standard module pprint, can pretty print python dict and list.     But it doesn't support sorted key. That why we need this func.      Usage::          >>> from weatherlab.lib.dataIO.js import prt_js         >>> prt_js({\"a\": 1, \"b\": 2})         {             \"a\": 1,             \"b\": 2         }      **中文文档**      以人类可读的方式打印可Json化的Python对象。     \"\"\"     print(js2str(js, sort_keys, indent))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python dump json pretty each element in new line [SEP] def files_have_same_point_format_id(las_files):     \"\"\" Returns true if all the files have the same points format id     \"\"\"     point_format_found = {las.header.point_format_id for las in las_files}     return len(point_format_found) == 1", "target": 0, "target_options": ["no match", "match"]}
{"input": "python dump json pretty each element in new line [SEP] def pretty_dict_str(d, indent=2):     \"\"\"shows JSON indented representation of d\"\"\"     b = StringIO()     write_pretty_dict_str(b, d, indent=indent)     return b.getvalue()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python dump json pretty each element in new line [SEP] def safe_int_conv(number):     \"\"\"Safely convert a single number to integer.\"\"\"     try:         return int(np.array(number).astype(int, casting='safe'))     except TypeError:         raise ValueError('cannot safely convert {} to integer'.format(number))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to say \"anything else\" in python [SEP] def show_help(self):         \"\"\"Prints to stdout help on how to answer properly\"\"\"         print(\"Sorry, not well understood.\")         print(\"- use\", str(self.yes_input), \"to answer 'YES'\")         print(\"- use\", str(self.no_input), \"to answer 'NO'\")", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to say \"anything else\" in python [SEP] def get_object_info(self):         \"\"\"         Returns object info in following form <module.class object at address>         \"\"\"         objectinfo = str(self.__class__).replace(\">\", \"\")         objectinfo = objectinfo.replace(\"class \", \"\")         objectinfo = objectinfo.replace(\"'\", \"\")         objectinfo += \" object at 0x%x>\" % id(self)         return objectinfo", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to say \"anything else\" in python [SEP] def pause(msg=\"Press Enter to Continue...\"):     \"\"\"press to continue\"\"\"     print('\\n' + Fore.YELLOW + msg + Fore.RESET, end='')     input()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to say \"anything else\" in python [SEP] def lowstrip(term):     \"\"\"Convert to lowercase and strip spaces\"\"\"     term = re.sub('\\s+', ' ', term)     term = term.lower()     return term", "target": 0, "target_options": ["no match", "match"]}
{"input": "get index if there are repeats python [SEP] def remove_dups(seq):     \"\"\"remove duplicates from a sequence, preserving order\"\"\"     seen = set()     seen_add = seen.add     return [x for x in seq if not (x in seen or seen_add(x))]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get index if there are repeats python [SEP] def add_lines(self, txt, indent=0):         \"\"\"Adds a list of lines.          The list can be indented with the optional argument 'indent'.         \"\"\"         for line in txt:             self.add_line(line, indent)", "target": 0, "target_options": ["no match", "match"]}
{"input": "get index if there are repeats python [SEP] def unduplicate_field_names(field_names):     \"\"\"Append a number to duplicate field names to make them unique. \"\"\"     res = []     for k in field_names:         if k in res:             i = 1             while k + '_' + str(i) in res:                 i += 1             k += '_' + str(i)         res.append(k)     return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get index if there are repeats python [SEP] def normalize_path(filename):     \"\"\"Normalize a file/dir name for comparison purposes\"\"\"     return os.path.normcase(os.path.realpath(os.path.normpath(_cygwin_patch(filename))))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python program for probabolity density and guassian distribution function [SEP] def GeneralGuinier(q, G, Rg, s):     \"\"\"Generalized Guinier scattering      Inputs:     -------         ``q``: independent variable         ``G``: factor         ``Rg``: radius of gyration         ``s``: dimensionality parameter (can be 1, 2, 3)      Formula:     --------         ``G/q**(3-s)*exp(-(q^2*Rg^2)/s)``     \"\"\"     return G / q ** (3 - s) * np.exp(-(q * Rg) ** 2 / s)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python program for probabolity density and guassian distribution function [SEP] def stub_main():     \"\"\"setuptools blah: it still can't run a module as a script entry_point\"\"\"     from google.apputils import run_script_module     import butcher.main     run_script_module.RunScriptModule(butcher.main)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python program for probabolity density and guassian distribution function [SEP] def predictive_probability_multistate(M_c, X_L_list, X_D_list, Y, Q):     \"\"\"     Returns the predictive probability, averaged over each sample.     \"\"\"     logprobs = [float(predictive_probability(M_c, X_L, X_D, Y, Q))         for X_L, X_D in zip(X_L_list, X_D_list)]     return logmeanexp(logprobs)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python program for probabolity density and guassian distribution function [SEP] def stop(self) -> None:         \"\"\"Stops the analysis as soon as possible.\"\"\"         if self._stop and not self._posted_kork:             self._stop()             self._stop = None", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to stop program running in python idle [SEP] def do_exit(self, arg):         \"\"\"Exit the shell session.\"\"\"          if self.current:             self.current.close()         self.resource_manager.close()         del self.resource_manager         return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to stop program running in python idle [SEP] def register_logging_factories(loader):     \"\"\"     Registers default factories for logging standard package.      :param loader: Loader where you want register default logging factories     \"\"\"     loader.register_factory(logging.Logger, LoggerFactory)     loader.register_factory(logging.Handler, LoggingHandlerFactory)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to stop program running in python idle [SEP] def stop_process(self, process, timeout=None):         \"\"\" Initiates a graceful stop of one process \"\"\"          process[\"terminate\"] = True         if timeout is not None:             process[\"terminate_at\"] = time.time() + timeout         process[\"subprocess\"].send_signal(signal.SIGINT)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to stop program running in python idle [SEP] def out(self, output, newline=True):         \"\"\"Outputs a string to the console (stdout).\"\"\"         click.echo(output, nl=newline)", "target": 0, "target_options": ["no match", "match"]}
{"input": "turn index to boolean python [SEP] def strToBool(val):     \"\"\"     Helper function to turn a string representation of \"true\" into     boolean True.     \"\"\"     if isinstance(val, str):         val = val.lower()      return val in ['true', 'on', 'yes', True]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "turn index to boolean python [SEP] def _isint(string):     \"\"\"     >>> _isint(\"123\")     True     >>> _isint(\"123.45\")     False     \"\"\"     return type(string) is int or \\            (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\            _isconvertible(int, string)", "target": 0, "target_options": ["no match", "match"]}
{"input": "turn index to boolean python [SEP] def boolean(value):     \"\"\"     Configuration-friendly boolean type converter.      Supports both boolean-valued and string-valued inputs (e.g. from env vars).      \"\"\"     if isinstance(value, bool):         return value      if value == \"\":         return False      return strtobool(value)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "turn index to boolean python [SEP] def __exit__(self, type, value, traceback):         \"\"\"When the `with` statement ends.\"\"\"          if not self.asarfile:             return          self.asarfile.close()         self.asarfile = None", "target": 0, "target_options": ["no match", "match"]}
{"input": "python print float don't use scientific [SEP] def _format_bf(bf, precision=3, trim='0'):     \"\"\"Format BF10 to floating point or scientific notation.     \"\"\"     if bf >= 1e4 or bf <= 1e-4:         out = np.format_float_scientific(bf, precision=precision, trim=trim)     else:         out = np.format_float_positional(bf, precision=precision, trim=trim)     return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python print float don't use scientific [SEP] def stylize(text, styles, reset=True):     \"\"\"conveniently styles your text as and resets ANSI codes at its end.\"\"\"     terminator = attr(\"reset\") if reset else \"\"     return \"{}{}{}\".format(\"\".join(styles), text, terminator)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python print float don't use scientific [SEP] def _saferound(value, decimal_places):     \"\"\"     Rounds a float value off to the desired precision     \"\"\"     try:         f = float(value)     except ValueError:         return ''     format = '%%.%df' % decimal_places     return format % f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python print float don't use scientific [SEP] def isdir(s):     \"\"\"Return true if the pathname refers to an existing directory.\"\"\"     try:         st = os.stat(s)     except os.error:         return False     return stat.S_ISDIR(st.st_mode)", "target": 0, "target_options": ["no match", "match"]}
{"input": "write to csv as strings python [SEP] def as_csv(self):         \"\"\"Return a CSV representation as a string\"\"\"          from io import StringIO          s = StringIO()         w = csv.writer(s)         for row in self.rows:             w.writerow(row)          return s.getvalue()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "write to csv as strings python [SEP] def qth_pw(self, q):         \"\"\"         returns the qth most probable element in the dawg.         \"\"\"         return heapq.nlargest(q + 2, self._T.iteritems(),                               key=operator.itemgetter(1))[-1]", "target": 0, "target_options": ["no match", "match"]}
{"input": "write to csv as strings python [SEP] def write_tsv_line_from_list(linelist, outfp):     \"\"\"Utility method to convert list to tsv line with carriage return\"\"\"     line = '\\t'.join(linelist)     outfp.write(line)     outfp.write('\\n')", "target": 1, "target_options": ["no_match", "match"]}
{"input": "write to csv as strings python [SEP] def tsv_escape(x: Any) -> str:     \"\"\"     Escape data for tab-separated value (TSV) format.     \"\"\"     if x is None:         return \"\"     x = str(x)     return x.replace(\"\\t\", \"\\\\t\").replace(\"\\n\", \"\\\\n\")", "target": 0, "target_options": ["no match", "match"]}
{"input": "simple file input code python [SEP] def _stdin_(p):     \"\"\"Takes input from user. Works for Python 2 and 3.\"\"\"     _v = sys.version[0]     return input(p) if _v is '3' else raw_input(p)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "simple file input code python [SEP] def valid (names):     \"\"\" Returns true iff all elements of names are valid features.     \"\"\"     if isinstance(names, str):         names = [names]         assert is_iterable_typed(names, basestring)      return all(name in __all_features for name in names)", "target": 0, "target_options": ["no match", "match"]}
{"input": "simple file input code python [SEP] def get_input(input_func, input_str):     \"\"\"     Get input from the user given an input function and an input string     \"\"\"     val = input_func(\"Please enter your {0}: \".format(input_str))     while not val or not len(val.strip()):         val = input_func(\"You didn't enter a valid {0}, please try again: \".format(input_str))     return val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "simple file input code python [SEP] def as_csv(self):         \"\"\"Return a CSV representation as a string\"\"\"          from io import StringIO          s = StringIO()         w = csv.writer(s)         for row in self.rows:             w.writerow(row)          return s.getvalue()", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to open a file creation in python [SEP] def fopenat(base_fd, path):     \"\"\"     Does openat read-only, then does fdopen to get a file object     \"\"\"      return os.fdopen(openat(base_fd, path, os.O_RDONLY), 'rb')", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to open a file creation in python [SEP] def _str_to_list(s):     \"\"\"Converts a comma separated string to a list\"\"\"     _list = s.split(\",\")     return list(map(lambda i: i.lstrip(), _list))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to open a file creation in python [SEP] def file_read(filename):     \"\"\"Read a file and close it.  Returns the file source.\"\"\"     fobj = open(filename,'r');     source = fobj.read();     fobj.close()     return source", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to open a file creation in python [SEP] def get_randomized_guid_sample(self, item_count):         \"\"\" Fetch a subset of randomzied GUIDs from the whitelist \"\"\"         dataset = self.get_whitelist()         random.shuffle(dataset)         return dataset[:item_count]", "target": 0, "target_options": ["no match", "match"]}
{"input": "write a loop for different outputs python [SEP] def build_output(self, fout):         \"\"\"Squash self.out into string.          Join every line in self.out with a new line and write the         result to the output file.         \"\"\"         fout.write('\\n'.join([s for s in self.out]))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "write a loop for different outputs python [SEP] def background_thread():     \"\"\"Example of how to send server generated events to clients.\"\"\"     count = 0     while True:         socketio.sleep(10)         count += 1         socketio.emit('my_response',                       {'data': 'Server generated event', 'count': count},                       namespace='/test')", "target": 0, "target_options": ["no match", "match"]}
{"input": "write a loop for different outputs python [SEP] def end(self):         \"\"\"Generate the closing part\"\"\"         for depth in xrange(len(self.names) - 1, -1, -1):             self.out_f.write('{0}}}\\n'.format(self.prefix(depth)))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "write a loop for different outputs python [SEP] def indented_show(text, howmany=1):         \"\"\"Print a formatted indented text.         \"\"\"         print(StrTemplate.pad_indent(text=text, howmany=howmany))", "target": 0, "target_options": ["no match", "match"]}
{"input": "delete specifi item from a list in python [SEP] def dedup_list(l):     \"\"\"Given a list (l) will removing duplicates from the list,        preserving the original order of the list. Assumes that        the list entrie are hashable.\"\"\"     dedup = set()     return [ x for x in l if not (x in dedup or dedup.add(x))]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "delete specifi item from a list in python [SEP] def stdoutwriteline(*args):     \"\"\"     @type args: tuple     @return: None     \"\"\"     s = \"\"      for i in args:         s += str(i) + \" \"      s = s.strip()     sys.stdout.write(str(s) + \"\\n\")     sys.stdout.flush()      return s", "target": 0, "target_options": ["no match", "match"]}
{"input": "delete specifi item from a list in python [SEP] def unique(list):     \"\"\" Returns a copy of the list without duplicates.     \"\"\"     unique = []; [unique.append(x) for x in list if x not in unique]     return unique", "target": 1, "target_options": ["no_match", "match"]}
{"input": "delete specifi item from a list in python [SEP] def _is_bit(obj):     \"\"\"Determine if obj is a bit\"\"\"     # If there is a bit type this could be replaced by isinstance.     if isinstance(obj, tuple) and len(obj) == 2:         if isinstance(obj[0], Register) and isinstance(obj[1], int) and obj[1] < len(obj[0]):             return True     return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to make a random 9 digit number [SEP] def uniqueID(size=6, chars=string.ascii_uppercase + string.digits):     \"\"\"A quick and dirty way to get a unique string\"\"\"     return ''.join(random.choice(chars) for x in xrange(size))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to make a random 9 digit number [SEP] def _css_select(soup, css_selector):         \"\"\" Returns the content of the element pointed by the CSS selector,         or an empty string if not found \"\"\"         selection = soup.select(css_selector)         if len(selection) > 0:             if hasattr(selection[0], 'text'):                 retour = selection[0].text.strip()             else:                 retour = \"\"         else:             retour = \"\"         return retour", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to make a random 9 digit number [SEP] def random_id(length):     \"\"\"Generates a random ID of given length\"\"\"      def char():         \"\"\"Generate single random char\"\"\"          return random.choice(string.ascii_letters + string.digits)      return \"\".join(char() for _ in range(length))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to make a random 9 digit number [SEP] def make_lex_dict(self):         \"\"\"         Convert lexicon file to a dictionary         \"\"\"         lex_dict = {}         for line in self.lexicon_full_filepath.split('\\n'):             (word, measure) = line.strip().split('\\t')[0:2]             lex_dict[word] = float(measure)         return lex_dict", "target": 0, "target_options": ["no match", "match"]}
{"input": "if input is a number python [SEP] def is_number(obj):     \"\"\"     Helper function to determine numbers     across Python 2.x and 3.x     \"\"\"     try:         from numbers import Number     except ImportError:         from operator import isNumberType         return isNumberType(obj)     else:         return isinstance(obj, Number)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "if input is a number python [SEP] def DynamicConvFilter(inputs, filters, out_channel,                       kernel_shape,                       stride=1,                       padding='SAME'):     \"\"\" see \"Dynamic Filter Networks\" (NIPS 2016)         by Bert De Brabandere*, Xu Jia*, Tinne Tuytelaars and Luc Van Gool      Remarks:         This is the convolution version of a dynamic filter.      Args:         inputs : unfiltered input [b, h, w, 1] only grayscale images.         filters : learned filters of [b, k, k, 1] (dynamically generated by the network).         out_channel (int): number of output channel.         kernel_shape: (h, w) tuple or a int.         stride: (h, w) tuple or a int.         padding (str): 'valid' or 'same'. Case insensitive.      Returns         tf.Tensor named ``output``.     \"\"\"      # tf.unstack only works with known batch_size :-(     batch_size, h, w, in_channel = inputs.get_shape().as_list()     stride = shape4d(stride)      inputs = tf.unstack(inputs)     filters = tf.reshape(filters, [batch_size] + shape2d(kernel_shape) + [in_channel, out_channel])     filters = tf.unstack(filters)      # this is ok as TF uses the cuda stream context     rsl = [tf.nn.conv2d(tf.reshape(d, [1, h, w, in_channel]),                         tf.reshape(k, [kernel_shape, kernel_shape, in_channel, out_channel]),                         stride, padding=\"SAME\") for d, k in zip(inputs, filters)]     rsl = tf.concat(rsl, axis=0, name='output')     return rsl", "target": 0, "target_options": ["no match", "match"]}
{"input": "if input is a number python [SEP] def type_converter(text):     \"\"\" I convert strings into integers, floats, and strings! \"\"\"     if text.isdigit():         return int(text), int      try:         return float(text), float     except ValueError:         return text, STRING_TYPE", "target": 1, "target_options": ["no_match", "match"]}
{"input": "if input is a number python [SEP] def difference(ydata1, ydata2):     \"\"\"      Returns the number you should add to ydata1 to make it line up with ydata2      \"\"\"      y1 = _n.array(ydata1)     y2 = _n.array(ydata2)      return(sum(y2-y1)/len(ydata1))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python write list of list to file in rows [SEP] def write_tsv_line_from_list(linelist, outfp):     \"\"\"Utility method to convert list to tsv line with carriage return\"\"\"     line = '\\t'.join(linelist)     outfp.write(line)     outfp.write('\\n')", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python write list of list to file in rows [SEP] def valid (names):     \"\"\" Returns true iff all elements of names are valid features.     \"\"\"     if isinstance(names, str):         names = [names]         assert is_iterable_typed(names, basestring)      return all(name in __all_features for name in names)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python write list of list to file in rows [SEP] def list_to_csv(my_list, csv_file):     \"\"\"     Save a matrix (list of lists) to a file as a CSV      .. code:: python          my_list = [[\"Name\", \"Location\"],                    [\"Chris\", \"South Pole\"],                    [\"Harry\", \"Depth of Winter\"],                    [\"Bob\", \"Skull\"]]          reusables.list_to_csv(my_list, \"example.csv\")      example.csv      .. code:: csv          \"Name\",\"Location\"         \"Chris\",\"South Pole\"         \"Harry\",\"Depth of Winter\"         \"Bob\",\"Skull\"      :param my_list: list of lists to save to CSV     :param csv_file: File to save data to     \"\"\"     if PY3:         csv_handler = open(csv_file, 'w', newline='')     else:         csv_handler = open(csv_file, 'wb')      try:         writer = csv.writer(csv_handler, delimiter=',', quoting=csv.QUOTE_ALL)         writer.writerows(my_list)     finally:         csv_handler.close()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python write list of list to file in rows [SEP] def is_dimension(self):         \"\"\"Return true if the colum is a dimension\"\"\"         from ambry.valuetype.core import ROLE         return self.role == ROLE.DIMENSION", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to remove first item from list [SEP] def turn(self):         \"\"\"Turn the ring for a single position.         For example, [a, b, c, d] becomes [b, c, d, a].\"\"\"         first = self._data.pop(0)         self._data.append(first)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to remove first item from list [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to remove first item from list [SEP] def remove(self, item):         \"\"\"Remove the first occurence of an item, the caseless way.\"\"\"         for entry in self:             if item.lower() == entry.lower():                 list.remove(self, entry)                 return         raise ValueError(': list.remove(x): x not in list')", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to remove first item from list [SEP] def add_suffix(fullname, suffix):     \"\"\" Add suffix to a full file name\"\"\"     name, ext = os.path.splitext(fullname)     return name + '_' + suffix + ext", "target": 0, "target_options": ["no match", "match"]}
{"input": "gdb check python support [SEP] def get_complete_version(version=None):     \"\"\"Returns a tuple of the graphene version. If version argument is non-empty,     then checks for correctness of the tuple provided.     \"\"\"     if version is None:         from graphene import VERSION as version     else:         assert len(version) == 5         assert version[3] in (\"alpha\", \"beta\", \"rc\", \"final\")      return version", "target": 1, "target_options": ["no_match", "match"]}
{"input": "gdb check python support [SEP] def _num2deg(self, tile):         \"\"\" Taken from http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#Python \"\"\"         n = 2.0 ** tile.zoom         lon_deg = tile.x / n * 360.0 - 180.0         lat_rad = mod_math.atan(mod_math.sinh(mod_math.pi * (1 - 2 * tile.y / n)))         lat_deg = mod_math.degrees(lat_rad)         return (lat_deg, lon_deg)", "target": 0, "target_options": ["no match", "match"]}
{"input": "gdb check python support [SEP] def gtype_to_python(gtype):         \"\"\"Map a gtype to the name of the Python type we use to represent it.          \"\"\"          fundamental = gobject_lib.g_type_fundamental(gtype)          if gtype in GValue._gtype_to_python:             return GValue._gtype_to_python[gtype]         if fundamental in GValue._gtype_to_python:             return GValue._gtype_to_python[fundamental]         return '<unknown type>'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "gdb check python support [SEP] def extent(self):          \"\"\"         return range of 2D data         \"\"\"          return [min(self.x), max(self.x), min(self.y), max(self.y)]", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to see if a list is a list in python [SEP] def is_iter_non_string(obj):     \"\"\"test if object is a list or tuple\"\"\"     if isinstance(obj, list) or isinstance(obj, tuple):         return True     return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to see if a list is a list in python [SEP] def imt2tup(string):     \"\"\"     >>> imt2tup('PGA')     ('PGA',)     >>> imt2tup('SA(1.0)')     ('SA', 1.0)     >>> imt2tup('SA(1)')     ('SA', 1.0)     \"\"\"     s = string.strip()     if not s.endswith(')'):         # no parenthesis, PGA is considered the same as PGA()         return (s,)     name, rest = s.split('(', 1)     return (name,) + tuple(float(x) for x in ast.literal_eval(rest[:-1] + ','))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to see if a list is a list in python [SEP] def __isListOfTexts(self, docs):         \"\"\" Checks whether the input is a list of strings or Text-s;          \"\"\"         return isinstance(docs, list) and \\                all(isinstance(d, (basestring, Text)) for d in docs)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to see if a list is a list in python [SEP] def is_empty(self):         \"\"\"Checks for an empty image.         \"\"\"         if(((self.channels == []) and (not self.shape == (0, 0))) or            ((not self.channels == []) and (self.shape == (0, 0)))):             raise RuntimeError(\"Channels-shape mismatch.\")         return self.channels == [] and self.shape == (0, 0)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to change from list to tuple in python [SEP] def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to change from list to tuple in python [SEP] def _stdin_(p):     \"\"\"Takes input from user. Works for Python 2 and 3.\"\"\"     _v = sys.version[0]     return input(p) if _v is '3' else raw_input(p)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to change from list to tuple in python [SEP] def compose_all(tups):   \"\"\"Compose all given tuples together.\"\"\"   from . import ast  # I weep for humanity   return functools.reduce(lambda x, y: x.compose(y), map(ast.make_tuple, tups), ast.make_tuple({}))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to change from list to tuple in python [SEP] def get_pants_configdir():   \"\"\"Return the pants global config directory.\"\"\"   # Follow the unix XDB base spec: http://standards.freedesktop.org/basedir-spec/latest/index.html.   config_home = os.environ.get('XDG_CONFIG_HOME')   if not config_home:     config_home = '~/.config'   return os.path.expanduser(os.path.join(config_home, 'pants'))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python send print to logger [SEP] def debug(self, text): \t\t\"\"\" Ajout d'un message de log de type DEBUG \"\"\" \t\tself.logger.debug(\"{}{}\".format(self.message_prefix, text))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python send print to logger [SEP] def _transform_triple_numpy(x):     \"\"\"Transform triple index into a 1-D numpy array.\"\"\"     return np.array([x.head, x.relation, x.tail], dtype=np.int64)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python send print to logger [SEP] def info(self, text): \t\t\"\"\" Ajout d'un message de log de type INFO \"\"\" \t\tself.logger.info(\"{}{}\".format(self.message_prefix, text))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python send print to logger [SEP] def _pip_exists(self):         \"\"\"Returns True if pip exists inside the virtual environment. Can be         used as a naive way to verify that the environment is installed.\"\"\"         return os.path.isfile(os.path.join(self.path, 'bin', 'pip'))", "target": 0, "target_options": ["no match", "match"]}
{"input": "default python executables directory [SEP] def _get_result_files_base(self, temp_dir):         \"\"\"Given the temp directory that is created for each run, return the path to the directory         where files created by the tool are stored.\"\"\"         if not self._use_namespaces:             return super(ContainerExecutor, self)._get_result_files_base(temp_dir)         else:             return os.path.join(temp_dir, \"temp\")", "target": 1, "target_options": ["no_match", "match"]}
{"input": "default python executables directory [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 0, "target_options": ["no match", "match"]}
{"input": "default python executables directory [SEP] def get_pants_configdir():   \"\"\"Return the pants global config directory.\"\"\"   # Follow the unix XDB base spec: http://standards.freedesktop.org/basedir-spec/latest/index.html.   config_home = os.environ.get('XDG_CONFIG_HOME')   if not config_home:     config_home = '~/.config'   return os.path.expanduser(os.path.join(config_home, 'pants'))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "default python executables directory [SEP] def unique(self, values):         \"\"\"Place each entry in a table, while asserting that each entry occurs once\"\"\"         _, count = self.count()         if not np.array_equiv(count, 1):             raise ValueError(\"Not every entry in the table is assigned a unique value\")         return self.sum(values)", "target": 0, "target_options": ["no match", "match"]}
{"input": "check if an elements exists in list python [SEP] def __contains__(self, item):         \"\"\"(dpid, key) in <ConfSwitchSet instance>\"\"\"         (dpid, key) = item         return dpid in self.confs and key in self.confs[dpid]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check if an elements exists in list python [SEP] def clean(self, text):         \"\"\"Remove all unwanted characters from text.\"\"\"         return ''.join([c for c in text if c in self.alphabet])", "target": 0, "target_options": ["no match", "match"]}
{"input": "check if an elements exists in list python [SEP] def any_contains_any(strings, candidates):     \"\"\"Whether any of the strings contains any of the candidates.\"\"\"     for string in strings:         for c in candidates:             if c in string:                 return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check if an elements exists in list python [SEP] def stylize(text, styles, reset=True):     \"\"\"conveniently styles your text as and resets ANSI codes at its end.\"\"\"     terminator = attr(\"reset\") if reset else \"\"     return \"{}{}{}\".format(\"\".join(styles), text, terminator)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to not have spaces between variables python print [SEP] def _display(self, layout):         \"\"\"launch layouts display\"\"\"         print(file=self.out)         TextWriter().format(layout, self.out)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to not have spaces between variables python print [SEP] def run(self, forever=True):         \"\"\"start the bot\"\"\"         loop = self.create_connection()         self.add_signal_handlers()         if forever:             loop.run_forever()", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to not have spaces between variables python print [SEP] def sing(a, b, c=False, name='yetone'):     \"\"\"sing a song     hehe      :param a: I'm a     :param b: I'm b     :param c: I'm c     :param name: I'm name     \"\"\"     print('test0.sing: <a: {}, b: {}, c: {}> by {}'.format(a, b, c, name))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to not have spaces between variables python print [SEP] def unique(seq):     \"\"\"Helper function to include only unique monomials in a basis.\"\"\"     seen = {}     result = []     for item in seq:         marker = item         if marker in seen:             continue         seen[marker] = 1         result.append(item)     return result", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to mention newline in python [SEP] def csvpretty(csvfile: csvfile=sys.stdin):     \"\"\" Pretty print a CSV file. \"\"\"     shellish.tabulate(csv.reader(csvfile))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to mention newline in python [SEP] def get_pants_configdir():   \"\"\"Return the pants global config directory.\"\"\"   # Follow the unix XDB base spec: http://standards.freedesktop.org/basedir-spec/latest/index.html.   config_home = os.environ.get('XDG_CONFIG_HOME')   if not config_home:     config_home = '~/.config'   return os.path.expanduser(os.path.join(config_home, 'pants'))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to mention newline in python [SEP] def replaceNewlines(string, newlineChar): \t\"\"\"There's probably a way to do this with string functions but I was lazy. \t\tReplace all instances of \\r or \\n in a string with something else.\"\"\" \tif newlineChar in string: \t\tsegments = string.split(newlineChar) \t\tstring = \"\" \t\tfor segment in segments: \t\t\tstring += segment \treturn string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to mention newline in python [SEP] def check_auth(email, password):     \"\"\"Check if a username/password combination is valid.     \"\"\"     try:         user = User.get(User.email == email)     except User.DoesNotExist:         return False     return password == user.password", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to get the median in python [SEP] def getMedian(numericValues):     \"\"\"     Gets the median of a list of values     Returns a float/int     \"\"\"     theValues = sorted(numericValues)      if len(theValues) % 2 == 1:         return theValues[(len(theValues) + 1) / 2 - 1]     else:         lower = theValues[len(theValues) / 2 - 1]         upper = theValues[len(theValues) / 2]          return (float(lower + upper)) / 2", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to get the median in python [SEP] def count_list(the_list):     \"\"\"     Generates a count of the number of times each unique item appears in a list     \"\"\"     count = the_list.count     result = [(item, count(item)) for item in set(the_list)]     result.sort()     return result", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to get the median in python [SEP] def median_high(data):     \"\"\"Return the high median of data.      When the number of data points is odd, the middle value is returned.     When it is even, the larger of the two middle values is returned.      \"\"\"     data = sorted(data)     n = len(data)     if n == 0:         raise StatisticsError(\"no median for empty data\")     return data[n // 2]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to get the median in python [SEP] def strip_accents(s):     \"\"\"     Strip accents to prepare for slugification.     \"\"\"     nfkd = unicodedata.normalize('NFKD', unicode(s))     return u''.join(ch for ch in nfkd if not unicodedata.combining(ch))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python elementtree line break after element [SEP] def add_newlines(tree):     \"\"\"     Add a newline character to the end of each <br> element.     \"\"\"     for br in tree.xpath(\"*//br\"):         br.tail = u\"\\n\" + br.tail if br.tail else u\"\\n\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python elementtree line break after element [SEP] def C_dict2array(C):     \"\"\"Convert an OrderedDict containing C values to a 1D array.\"\"\"     return np.hstack([np.asarray(C[k]).ravel() for k in C_keys])", "target": 0, "target_options": ["no match", "match"]}
{"input": "python elementtree line break after element [SEP] def walk_tree(root):     \"\"\"Pre-order depth-first\"\"\"     yield root      for child in root.children:         for el in walk_tree(child):             yield el", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python elementtree line break after element [SEP] def clean_url(url):     \"\"\"     Remove params, query and fragment parts from URL so that `os.path.basename`     and `os.path.splitext` can work correctly.      @param url: URL to clean.     @type url: str      @return: Cleaned URL.     @rtype: str     \"\"\"     parsed = urlparse(url.strip())     reconstructed = ParseResult(         parsed.scheme, parsed.netloc, parsed.path,         params='', query='', fragment='')     return reconstructed.geturl()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python extract one list from multidimension list [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python extract one list from multidimension list [SEP] def rgba_bytes_tuple(self, x):         \"\"\"Provides the color corresponding to value `x` in the         form of a tuple (R,G,B,A) with int values between 0 and 255.         \"\"\"         return tuple(int(u*255.9999) for u in self.rgba_floats_tuple(x))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python extract one list from multidimension list [SEP] def flatten(l, types=(list, float)):     \"\"\"     Flat nested list of lists into a single list.     \"\"\"     l = [item if isinstance(item, types) else [item] for item in l]     return [item for sublist in l for item in sublist]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python extract one list from multidimension list [SEP] def clean_with_zeros(self,x):         \"\"\" set nan and inf rows from x to zero\"\"\"         x[~np.any(np.isnan(x) | np.isinf(x),axis=1)] = 0         return x", "target": 0, "target_options": ["no match", "match"]}
{"input": "python check if entry exists in dict [SEP] def __contains__(self, key):         \"\"\"         Invoked when determining whether a specific key is in the dictionary         using `key in d`.          The key is looked up case-insensitively.         \"\"\"         k = self._real_key(key)         return k in self._data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python check if entry exists in dict [SEP] def difference(ydata1, ydata2):     \"\"\"      Returns the number you should add to ydata1 to make it line up with ydata2      \"\"\"      y1 = _n.array(ydata1)     y2 = _n.array(ydata2)      return(sum(y2-y1)/len(ydata1))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python check if entry exists in dict [SEP] def get_case_insensitive_dict_key(d: Dict, k: str) -> Optional[str]:     \"\"\"     Within the dictionary ``d``, find a key that matches (in case-insensitive     fashion) the key ``k``, and return it (or ``None`` if there isn't one).     \"\"\"     for key in d.keys():         if k.lower() == key.lower():             return key     return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python check if entry exists in dict [SEP] def is_int(value):     \"\"\"Return `True` if ``value`` is an integer.\"\"\"     if isinstance(value, bool):         return False     try:         int(value)         return True     except (ValueError, TypeError):         return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "extract color feature from image in python cv2 [SEP] def url_to_image(url, flag=cv2.IMREAD_COLOR):     \"\"\" download the image, convert it to a NumPy array, and then read     it into OpenCV format \"\"\"     resp = urlopen(url)     image = np.asarray(bytearray(resp.read()), dtype=\"uint8\")     image = cv2.imdecode(image, flag)     return image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "extract color feature from image in python cv2 [SEP] def wget(url):     \"\"\"     Download the page into a string     \"\"\"     import urllib.parse     request = urllib.request.urlopen(url)     filestring = request.read()     return filestring", "target": 0, "target_options": ["no match", "match"]}
{"input": "extract color feature from image in python cv2 [SEP] def imdecode(image_path):     \"\"\"Return BGR image read by opencv\"\"\"     import os     assert os.path.exists(image_path), image_path + ' not found'     im = cv2.imread(image_path)     return im", "target": 1, "target_options": ["no_match", "match"]}
{"input": "extract color feature from image in python cv2 [SEP] def floor(self):     \"\"\"Round `x` and `y` down to integers.\"\"\"     return Point(int(math.floor(self.x)), int(math.floor(self.y)))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to put one quote in python print [SEP] def out(self, output, newline=True):         \"\"\"Outputs a string to the console (stdout).\"\"\"         click.echo(output, nl=newline)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to put one quote in python print [SEP] def path_for_import(name):     \"\"\"     Returns the directory path for the given package or module.     \"\"\"     return os.path.dirname(os.path.abspath(import_module(name).__file__))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to put one quote in python print [SEP] def print_yaml(o):     \"\"\"Pretty print an object as YAML.\"\"\"     print(yaml.dump(o, default_flow_style=False, indent=4, encoding='utf-8'))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to put one quote in python print [SEP] async def login(         username: str, password: str, brand: str,         websession: ClientSession = None) -> API:     \"\"\"Log in to the API.\"\"\"     api = API(brand, websession)     await api.authenticate(username, password)     return api", "target": 0, "target_options": ["no match", "match"]}
{"input": "connect python to an api [SEP] async def login(         username: str, password: str, brand: str,         websession: ClientSession = None) -> API:     \"\"\"Log in to the API.\"\"\"     api = API(brand, websession)     await api.authenticate(username, password)     return api", "target": 1, "target_options": ["no_match", "match"]}
{"input": "connect python to an api [SEP] def split_strings_in_list_retain_spaces(orig_list):     \"\"\"     Function to split every line in a list, and retain spaces for a rejoin     :param orig_list: Original list     :return:         A List with split lines      \"\"\"     temp_list = list()     for line in orig_list:         line_split = __re.split(r'(\\s+)', line)         temp_list.append(line_split)      return temp_list", "target": 0, "target_options": ["no match", "match"]}
{"input": "connect python to an api [SEP] def post_sea_resource(url, body):     \"\"\"     Get the requested resource using the Seattle account     :returns: http response with content in json     \"\"\"     response = None     response = TrumbaSea_DAO().postURL(         url,         {\"Content-Type\": \"application/json\"},         body)     _log_json_resp(\"Seattle\", url, body, response)     return response", "target": 1, "target_options": ["no_match", "match"]}
{"input": "connect python to an api [SEP] def log_gen() -> Iterator[int]:     \"\"\"Logarithmic generator.     \"\"\"     y = 1     while True:         adder = max(1, math.pow(10, int(math.log10(y))))         yield int(y)         y = y + int(adder)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python get a specific column in matrix [SEP] def get_column(self, X, column):         \"\"\"Return a column of the given matrix.          Args:             X: `numpy.ndarray` or `pandas.DataFrame`.             column: `int` or `str`.          Returns:             np.ndarray: Selected column.         \"\"\"         if isinstance(X, pd.DataFrame):             return X[column].values          return X[:, column]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python get a specific column in matrix [SEP] def create_message(username, message):     \"\"\" Creates a standard message from a given user with the message          Replaces newline with html break \"\"\"     message = message.replace('\\n', '<br/>')     return '{{\"service\":1, \"data\":{{\"message\":\"{mes}\", \"username\":\"{user}\"}} }}'.format(mes=message, user=username)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python get a specific column in matrix [SEP] def _column(arr, indexes):     \"\"\" Returns a column with given indexes from a deep array      For example, if the array is a matrix and indexes is a single int, will     return arr[:,indexes]. If the array is an order 3 tensor and indexes is a     pair of ints, will return arr[:,indexes[0],indexes[1]], etc.      \"\"\"     if arr.ndim == 2 and types.is_int(indexes):         return arr[:, indexes]     elif arr.ndim == 3 and len(indexes) == 2:         return arr[:, indexes[0], indexes[1]]     else:         raise NotImplementedError('Only supporting arrays of dimension 2 and 3 as yet.')", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python get a specific column in matrix [SEP] def column(self, i):          \"\"\"from right\"\"\"         return ''.join([str(digitat2(r,i)) for r in self])", "target": 0, "target_options": ["no match", "match"]}
{"input": "python create a lot of empty lists [SEP] def unique(list):     \"\"\" Returns a copy of the list without duplicates.     \"\"\"     unique = []; [unique.append(x) for x in list if x not in unique]     return unique", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python create a lot of empty lists [SEP] def listfolder(p):     \"\"\"     generator of list folder in the path.     folders only     \"\"\"     for entry in scandir.scandir(p):         if entry.is_dir():             yield entry.name", "target": 0, "target_options": ["no match", "match"]}
{"input": "python create a lot of empty lists [SEP] def dedupe_list(l):     \"\"\"Remove duplicates from a list preserving the order.      We might be tempted to use the list(set(l)) idiom, but it doesn't preserve     the order, which hinders testability and does not work for lists with     unhashable elements.     \"\"\"     result = []      for el in l:         if el not in result:             result.append(el)      return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python create a lot of empty lists [SEP] def downloadImg(url, tofile=None):     \"\"\"     \"\"\"     r = urllib2.Request(url)     img_data = urllib2.urlopen(r).read()     img_buffer = StringIO.StringIO(img_data)     img = Image.open(img_buffer)     if FILE.make and tofile is not None:         img.save(FILE.dir + tofile)     return img", "target": 0, "target_options": ["no match", "match"]}
{"input": "change to lowercase in list in python [SEP] def downcaseTokens(s,l,t):     \"\"\"Helper parse action to convert tokens to lower case.\"\"\"     return [ tt.lower() for tt in map(_ustr,t) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "change to lowercase in list in python [SEP] def is_all_field_none(self):         \"\"\"         :rtype: bool         \"\"\"          if self._type_ is not None:             return False          if self._value is not None:             return False          if self._name is not None:             return False          return True", "target": 0, "target_options": ["no match", "match"]}
{"input": "change to lowercase in list in python [SEP] def upcaseTokens(s,l,t):     \"\"\"Helper parse action to convert tokens to upper case.\"\"\"     return [ tt.upper() for tt in map(_ustr,t) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "change to lowercase in list in python [SEP] def get(self):         \"\"\"         \"\"\"          if self.saved_list is None and self.null is False:             self.saved_list = []          return self.saved_list", "target": 0, "target_options": ["no match", "match"]}
{"input": "replace word in a file python [SEP] def replace_all(filepath, searchExp, replaceExp):     \"\"\"     Replace all the ocurrences (in a file) of a string with another value.     \"\"\"     for line in fileinput.input(filepath, inplace=1):         if searchExp in line:             line = line.replace(searchExp, replaceExp)         sys.stdout.write(line)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "replace word in a file python [SEP] def plot_curves_z(data, name, title=None):     \"\"\"Generates a simple plot of the quasiparticle weight decay curves given        data object with doping setup\"\"\"      plt.figure()     for zet, c in zip(data['zeta'], data['doping']):         plt.plot(data['u_int'], zet[:, 0], label='$n={}$'.format(str(c)))     if title != None:         plt.title(title)     label_saves(name+'.png')", "target": 0, "target_options": ["no match", "match"]}
{"input": "replace word in a file python [SEP] def fix_header_comment(filename, timestamp):     \"\"\"Fixes the header-comment of the given file.\"\"\"     # Fix input file.     name = os.path.basename( filename )     for line in fileinput.input( filename, inplace=1, mode=\"rU\" ):         # If header-comment already contains anything for '$Id$', remove it.         line = re.sub(r'\\$Id:[^$]+\\$', r'$Id$', line.rstrip())         # Replace '$Id$' by a string containing the file's name (and a timestamp)!         line = re.sub(re.escape(r'$Id$'), r'$Id: ' + name + r' ' + timestamp.isoformat() + r' $', line.rstrip())         print(line)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "replace word in a file python [SEP] def rvalues(self):         \"\"\"          in reversed order         \"\"\"         tmp = self         while tmp is not None:             yield tmp.data             tmp = tmp.prev", "target": 0, "target_options": ["no match", "match"]}
{"input": "python dictionary key present or not [SEP] def _has(self, key, exact=0):          \"\"\"Returns false if key is not found or is ambiguous\"\"\"          if not exact:             try:                 key = self.getfullkey(key)                 return 1             except KeyError:                 return 0         else:             return key in self.data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python dictionary key present or not [SEP] def print_item_with_children(ac, classes, level):     \"\"\" Print the given item and all children items \"\"\"     print_row(ac.id, ac.name, f\"{ac.allocation:,.2f}\", level)     print_children_recursively(classes, ac, level + 1)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python dictionary key present or not [SEP] def __contains__(self, key):         \"\"\" Tests if a key is contained in the store.              May test againsts self.defaults              :param str value: Value         \"\"\"         if self._haveKey(key) or key in self.defaults:             return True         else:             return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python dictionary key present or not [SEP] def read(*p):     \"\"\"Build a file path from paths and return the contents.\"\"\"     with open(os.path.join(*p), 'r') as fi:         return fi.read()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python count instances of one array element in another array [SEP] def dims_intersect(self):         \"\"\"Dimensions of the arrays in this list that are used in all arrays         \"\"\"         return set.intersection(*map(             set, (getattr(arr, 'dims_intersect', arr.dims) for arr in self)))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python count instances of one array element in another array [SEP] def clean_strings(iterable):     \"\"\"     Take a list of strings and clear whitespace      on each one. If a value in the list is not a      string pass it through untouched.      Args:         iterable: mixed list      Returns:          mixed list     \"\"\"     retval = []     for val in iterable:         try:             retval.append(val.strip())         except(AttributeError):             retval.append(val)     return retval", "target": 0, "target_options": ["no match", "match"]}
{"input": "python count instances of one array element in another array [SEP] def __and__(self, other): \t\t\"\"\" \t\tReturn a Cache containing the entries of self that are also in other. \t\t\"\"\" \t\treturn self.__class__([elem for elem in self if elem in other])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python count instances of one array element in another array [SEP] def insert(self, index, item):         \"\"\"Insert an item at the specified index.          Args:             index (int): Position to insert the item.             item: Item to be inserted.          Raises:             :exc:`~.exceptions.WrongListItemType`: If an item has a different                 type than the first item to be stored.          \"\"\"         if not self:             list.append(self, item)         elif item.__class__ == self[0].__class__:             list.insert(self, index, item)         else:             raise exceptions.WrongListItemType(item.__class__.__name__,                                                self[0].__class__.__name__)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python script to check website for changes [SEP] def needs_check(self):         \"\"\"         Check if enough time has elapsed to perform a check().          If this time has elapsed, a state change check through         has_state_changed() should be performed and eventually a sync().          :rtype: boolean         \"\"\"         if self.lastcheck is None:             return True         return time.time() - self.lastcheck >= self.ipchangedetection_sleep", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python script to check website for changes [SEP] def split_on(s, sep=\" \"):     \"\"\"Split s by sep, unless it's inside a quote.\"\"\"     pattern = '''((?:[^%s\"']|\"[^\"]*\"|'[^']*')+)''' % sep      return [_strip_speechmarks(t) for t in re.split(pattern, s)[1::2]]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python script to check website for changes [SEP] def check_new_version_available(this_version):     \"\"\"     Checks if a newer version of Zappa is available.      Returns True is updateable, else False.      \"\"\"     import requests      pypi_url = 'https://pypi.python.org/pypi/Zappa/json'     resp = requests.get(pypi_url, timeout=1.5)     top_version = resp.json()['info']['version']      return this_version != top_version", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python script to check website for changes [SEP] def imt2tup(string):     \"\"\"     >>> imt2tup('PGA')     ('PGA',)     >>> imt2tup('SA(1.0)')     ('SA', 1.0)     >>> imt2tup('SA(1)')     ('SA', 1.0)     \"\"\"     s = string.strip()     if not s.endswith(')'):         # no parenthesis, PGA is considered the same as PGA()         return (s,)     name, rest = s.split('(', 1)     return (name,) + tuple(float(x) for x in ast.literal_eval(rest[:-1] + ','))", "target": 0, "target_options": ["no match", "match"]}
{"input": "common elements in 2 array python [SEP] def compare(a, b):     \"\"\"      Compare items in 2 arrays. Returns sum(abs(a(i)-b(i)))     \"\"\"     s=0     for i in range(len(a)):         s=s+abs(a[i]-b[i])     return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "common elements in 2 array python [SEP] def _remove_invalid_char(s):     \"\"\"Remove invalid and dangerous characters from a string.\"\"\"      s = ''.join([i if ord(i) >= 32 and ord(i) < 127 else '' for i in s])     s = s.translate(dict.fromkeys(map(ord, \"_%~#\\\\{}\\\":\")))     return s", "target": 0, "target_options": ["no match", "match"]}
{"input": "common elements in 2 array python [SEP] def full_like(array, value, dtype=None):     \"\"\" Create a shared memory array with the same shape and type as a given array, filled with `value`.     \"\"\"     shared = empty_like(array, dtype)     shared[:] = value     return shared", "target": 1, "target_options": ["no_match", "match"]}
{"input": "common elements in 2 array python [SEP] def list2string (inlist,delimit=' '):     \"\"\" Converts a 1D list to a single long string for file output, using the string.join function.  Usage:   list2string (inlist,delimit=' ') Returns: the string created from inlist \"\"\"     stringlist = [makestr(_) for _ in inlist]     return string.join(stringlist,delimit)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python stop server thread [SEP] def background_thread():     \"\"\"Example of how to send server generated events to clients.\"\"\"     count = 0     while True:         socketio.sleep(10)         count += 1         socketio.emit('my_response',                       {'data': 'Server generated event', 'count': count},                       namespace='/test')", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python stop server thread [SEP] def pack_triples_numpy(triples):     \"\"\"Packs a list of triple indexes into a 2D numpy array.\"\"\"     if len(triples) == 0:         return np.array([], dtype=np.int64)     return np.stack(list(map(_transform_triple_numpy, triples)), axis=0)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python stop server thread [SEP] def server(port):     \"\"\"Start the Django dev server.\"\"\"     args = ['python', 'manage.py', 'runserver']     if port:         args.append(port)     run.main(args)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python stop server thread [SEP] def _check_and_convert_bools(self):         \"\"\"Replace boolean variables by the characters 'F'/'T'         \"\"\"         replacements = {             True: 'T',             False: 'F',         }          for key in self.bools:             if isinstance(self[key], bool):                 self[key] = replacements[self[key]]", "target": 0, "target_options": ["no match", "match"]}
{"input": "check if multiple variables are not none python [SEP] def _one_exists(input_files):     \"\"\"     at least one file must exist for multiqc to run properly     \"\"\"     for f in input_files:         if os.path.exists(f):             return True     return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check if multiple variables are not none python [SEP] def get_file_string(filepath):     \"\"\"Get string from file.\"\"\"     with open(os.path.abspath(filepath)) as f:         return f.read()", "target": 0, "target_options": ["no match", "match"]}
{"input": "check if multiple variables are not none python [SEP] def files_have_same_point_format_id(las_files):     \"\"\" Returns true if all the files have the same points format id     \"\"\"     point_format_found = {las.header.point_format_id for las in las_files}     return len(point_format_found) == 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check if multiple variables are not none python [SEP] def read_bytes(fo, writer_schema=None, reader_schema=None):     \"\"\"Bytes are encoded as a long followed by that many bytes of data.\"\"\"     size = read_long(fo)     return fo.read(size)", "target": 0, "target_options": ["no match", "match"]}
{"input": "cast to int from string python [SEP] def get_number(s, cast=int):     \"\"\"     Try to get a number out of a string, and cast it.     \"\"\"     import string     d = \"\".join(x for x in str(s) if x in string.digits)     return cast(d)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "cast to int from string python [SEP] def is_executable(path):   \"\"\"Returns whether a path names an existing executable file.\"\"\"   return os.path.isfile(path) and os.access(path, os.X_OK)", "target": 0, "target_options": ["no match", "match"]}
{"input": "cast to int from string python [SEP] def _from_bytes(bytes, byteorder=\"big\", signed=False):     \"\"\"This is the same functionality as ``int.from_bytes`` in python 3\"\"\"     return int.from_bytes(bytes, byteorder=byteorder, signed=signed)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "cast to int from string python [SEP] def strToBool(val):     \"\"\"     Helper function to turn a string representation of \"true\" into     boolean True.     \"\"\"     if isinstance(val, str):         val = val.lower()      return val in ['true', 'on', 'yes', True]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python zlib compress string [SEP] def zlib_compress(data):     \"\"\"     Compress things in a py2/3 safe fashion     >>> json_str = '{\"test\": 1}'     >>> blob = zlib_compress(json_str)     \"\"\"     if PY3K:         if isinstance(data, str):             return zlib.compress(bytes(data, 'utf-8'))         return zlib.compress(data)     return zlib.compress(data)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python zlib compress string [SEP] def local_accuracy(X_train, y_train, X_test, y_test, attr_test, model_generator, metric, trained_model):     \"\"\" The how well do the features plus a constant base rate sum up to the model output.     \"\"\"      X_train, X_test = to_array(X_train, X_test)      # how many features to mask     assert X_train.shape[1] == X_test.shape[1]      # keep nkeep top features and re-train the model for each test explanation     yp_test = trained_model.predict(X_test)      return metric(yp_test, strip_list(attr_test).sum(1))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python zlib compress string [SEP] def _compress_content(self, content):         \"\"\"Gzip a given string.\"\"\"         zbuf = StringIO()         zfile = GzipFile(mode='wb', compresslevel=6, fileobj=zbuf)         zfile.write(content.read())         zfile.close()         content.file = zbuf         return content", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python zlib compress string [SEP] def downloadImg(url, tofile=None):     \"\"\"     \"\"\"     r = urllib2.Request(url)     img_data = urllib2.urlopen(r).read()     img_buffer = StringIO.StringIO(img_data)     img = Image.open(img_buffer)     if FILE.make and tofile is not None:         img.save(FILE.dir + tofile)     return img", "target": 0, "target_options": ["no match", "match"]}
{"input": "for loop printing a dictionary python [SEP] def printdict(adict):     \"\"\"printdict\"\"\"     dlist = list(adict.keys())     dlist.sort()     for i in range(0, len(dlist)):         print(dlist[i], adict[dlist[i]])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "for loop printing a dictionary python [SEP] def unaccentuate(s):     \"\"\" Replace accentuated chars in string by their non accentuated equivalent. \"\"\"     return \"\".join(c for c in unicodedata.normalize(\"NFKD\", s) if not unicodedata.combining(c))", "target": 0, "target_options": ["no match", "match"]}
{"input": "for loop printing a dictionary python [SEP] def stringify_dict_contents(dct):     \"\"\"Turn dict keys and values into native strings.\"\"\"     return {         str_if_nested_or_str(k): str_if_nested_or_str(v)         for k, v in dct.items()     }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "for loop printing a dictionary python [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 0, "target_options": ["no match", "match"]}
{"input": "using a list to capture a split in python [SEP] def split_elements(value):     \"\"\"Split a string with comma or space-separated elements into a list.\"\"\"     items = [v.strip() for v in value.split(',')]     if len(items) == 1:         items = value.split()     return items", "target": 1, "target_options": ["no_match", "match"]}
{"input": "using a list to capture a split in python [SEP] def C_dict2array(C):     \"\"\"Convert an OrderedDict containing C values to a 1D array.\"\"\"     return np.hstack([np.asarray(C[k]).ravel() for k in C_keys])", "target": 0, "target_options": ["no match", "match"]}
{"input": "using a list to capture a split in python [SEP] def trimmed_split(s, seps=(\";\", \",\")):     \"\"\"Given a string s, split is by one of one of the seps.\"\"\"     for sep in seps:         if sep not in s:             continue         data = [item.strip() for item in s.strip().split(sep)]         return data     return [s]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "using a list to capture a split in python [SEP] def imdecode(image_path):     \"\"\"Return BGR image read by opencv\"\"\"     import os     assert os.path.exists(image_path), image_path + ' not found'     im = cv2.imread(image_path)     return im", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to check if a link is valid python [SEP] def looks_like_url(url):     \"\"\" Simplified check to see if the text appears to be a URL.      Similar to `urlparse` but much more basic.      Returns:       True if the url str appears to be valid.       False otherwise.      >>> url = looks_like_url(\"totalgood.org\")     >>> bool(url)     True     \"\"\"     if not isinstance(url, basestring):         return False     if not isinstance(url, basestring) or len(url) >= 1024 or not cre_url.match(url):         return False     return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to check if a link is valid python [SEP] def csv_to_matrix(csv_file_path):     \"\"\"Load a CSV file into a Python matrix of strings.      Args:         csv_file_path: Full path to a valid CSV file (e.g. c:/ladybug/test.csv)     \"\"\"     mtx = []     with open(csv_file_path) as csv_data_file:         for row in csv_data_file:             mtx.append(row.split(','))     return mtx", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to check if a link is valid python [SEP] def applies_to(self, url_data):         \"\"\"Check validity, scheme, extern and url_connection.\"\"\"         return url_data.valid and url_data.scheme == 'https' and \\           not url_data.extern[0] and url_data.url_connection is not None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to check if a link is valid python [SEP] def file_lines(bblfile:str) -> iter:     \"\"\"Yield lines found in given file\"\"\"     with open(bblfile) as fd:         yield from (line.rstrip() for line in fd if line.rstrip())", "target": 0, "target_options": ["no match", "match"]}
{"input": "python typecast single precision [SEP] def round_to_int(number, precision):     \"\"\"Round a number to a precision\"\"\"     precision = int(precision)     rounded = (int(number) + precision / 2) // precision * precision     return rounded", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python typecast single precision [SEP] def dedup_list(l):     \"\"\"Given a list (l) will removing duplicates from the list,        preserving the original order of the list. Assumes that        the list entrie are hashable.\"\"\"     dedup = set()     return [ x for x in l if not (x in dedup or dedup.add(x))]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python typecast single precision [SEP] def round_to_float(number, precision):     \"\"\"Round a float to a precision\"\"\"     rounded = Decimal(str(floor((number + precision / 2) // precision))                       ) * Decimal(str(precision))     return float(rounded)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python typecast single precision [SEP] def load_b26_file(file_name):     \"\"\"     loads a .b26 file into a dictionary      Args:         file_name:      Returns: dictionary with keys instrument, scripts, probes      \"\"\"     # file_name = \"Z:\\Lab\\Cantilever\\Measurements\\\\tmp_\\\\a\"      assert os.path.exists(file_name)      with open(file_name, 'r') as infile:         data = yaml.safe_load(infile)     return data", "target": 0, "target_options": ["no match", "match"]}
{"input": "python integer as a 4 byte hex [SEP] def tob32(val):     \"\"\"Return provided 32 bit value as a string of four bytes.\"\"\"     ret = bytearray(4)     ret[0] = (val>>24)&M8     ret[1] = (val>>16)&M8     ret[2] = (val>>8)&M8     ret[3] = val&M8     return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python integer as a 4 byte hex [SEP] def rgba_bytes_tuple(self, x):         \"\"\"Provides the color corresponding to value `x` in the         form of a tuple (R,G,B,A) with int values between 0 and 255.         \"\"\"         return tuple(int(u*255.9999) for u in self.rgba_floats_tuple(x))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python integer as a 4 byte hex [SEP] def byte2bit_string(data):     \"\"\"     >>> byte2bit_string(\"H\")     '00010010'      >>> byte2bit_string(0x55)     '10101010'     \"\"\"     if isinstance(data, basestring):         assert len(data) == 1         data = ord(data)      bits = '{0:08b}'.format(data)     bits = bits[::-1]     return bits", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python integer as a 4 byte hex [SEP] def unique(input_list):     \"\"\"     Return a list of unique items (similar to set functionality).      Parameters     ----------     input_list : list         A list containg some items that can occur more than once.      Returns     -------     list         A list with only unique occurances of an item.      \"\"\"     output = []     for item in input_list:         if item not in output:             output.append(item)     return output", "target": 0, "target_options": ["no match", "match"]}
{"input": "python range with fixed increments [SEP] def frange(start, stop, step, precision):     \"\"\"A generator that will generate a range of floats.\"\"\"     value = start     while round(value, precision) < stop:         yield round(value, precision)         value += step", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python range with fixed increments [SEP] def _check_elements_equal(lst):     \"\"\"     Returns true if all of the elements in the list are equal.     \"\"\"     assert isinstance(lst, list), \"Input value must be a list.\"     return not lst or lst.count(lst[0]) == len(lst)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python range with fixed increments [SEP] def Counter64(a, b, delta):     \"\"\"64bit counter aggregator with wrapping     \"\"\"     if b < a:         c = 18446744073709551615 - a         return (c + b) / float(delta)      return (b - a) / float(delta)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python range with fixed increments [SEP] def _get_pretty_string(obj):     \"\"\"Return a prettier version of obj      Parameters     ----------     obj : object         Object to pretty print      Returns     -------     s : str         Pretty print object repr     \"\"\"     sio = StringIO()     pprint.pprint(obj, stream=sio)     return sio.getvalue()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to make string isdigit print out the digits [SEP] def ishex(obj):     \"\"\"     Test if the argument is a string representing a valid hexadecimal digit.      :param obj: Object     :type  obj: any      :rtype: boolean     \"\"\"     return isinstance(obj, str) and (len(obj) == 1) and (obj in string.hexdigits)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to make string isdigit print out the digits [SEP] def remove_dups(seq):     \"\"\"remove duplicates from a sequence, preserving order\"\"\"     seen = set()     seen_add = seen.add     return [x for x in seq if not (x in seen or seen_add(x))]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to make string isdigit print out the digits [SEP] def is_dec(ip):     \"\"\"Return true if the IP address is in decimal notation.\"\"\"     try:         dec = int(str(ip))     except ValueError:         return False     if dec > 4294967295 or dec < 0:         return False     return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to make string isdigit print out the digits [SEP] def finish_plot():     \"\"\"Helper for plotting.\"\"\"     plt.legend()     plt.grid(color='0.7')     plt.xlabel('x')     plt.ylabel('y')     plt.show()", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to select top exam scores in python [SEP] def highest(self):         \"\"\"Return the items with the higest score.          If this ScoreSet is empty, returns None.         \"\"\"         scores = self.scores()         if not scores:             return None         maxscore = max(map(score, scores))         return filter(lambda x: score(x) == maxscore, scores)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to select top exam scores in python [SEP] def extract(self):         \"\"\"         Creates a copy of this tabarray in the form of a numpy ndarray.          Useful if you want to do math on array elements, e.g. if you have a          subset of the columns that are all numerical, you can construct a          numerical matrix and do matrix operations.          \"\"\"         return np.vstack([self[r] for r in self.dtype.names]).T.squeeze()", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to select top exam scores in python [SEP] def print_report(self):         \"\"\"         Print Compare report.          :return: None         \"\"\"         report = compare_report_print(             self.sorted, self.scores, self.best_name)         print(report)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to select top exam scores in python [SEP] def _dict_values_sorted_by_key(dictionary):     # This should be a yield from instead.     \"\"\"Internal helper to return the values of a dictionary, sorted by key.     \"\"\"     for _, value in sorted(dictionary.iteritems(), key=operator.itemgetter(0)):         yield value", "target": 0, "target_options": ["no match", "match"]}
{"input": "python create path folders [SEP] def abspath(*path):     \"\"\"A method to determine absolute path for a given relative path to the     directory where this setup.py script is located\"\"\"     setup_dir = os.path.dirname(os.path.abspath(__file__))     return os.path.join(setup_dir, *path)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python create path folders [SEP] def get_order(self, codes):         \"\"\"Return evidence codes in order shown in code2name.\"\"\"         return sorted(codes, key=lambda e: [self.ev2idx.get(e)])", "target": 0, "target_options": ["no match", "match"]}
{"input": "python create path folders [SEP] def get_module_path(modname):     \"\"\"Return module *modname* base path\"\"\"     return osp.abspath(osp.dirname(sys.modules[modname].__file__))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python create path folders [SEP] def _to_array(value):     \"\"\"As a convenience, turn Python lists and tuples into NumPy arrays.\"\"\"     if isinstance(value, (tuple, list)):         return array(value)     elif isinstance(value, (float, int)):         return np.float64(value)     else:         return value", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to return the file to dict [SEP] def make_lex_dict(self):         \"\"\"         Convert lexicon file to a dictionary         \"\"\"         lex_dict = {}         for line in self.lexicon_full_filepath.split('\\n'):             (word, measure) = line.strip().split('\\t')[0:2]             lex_dict[word] = float(measure)         return lex_dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to return the file to dict [SEP] def strToBool(val):     \"\"\"     Helper function to turn a string representation of \"true\" into     boolean True.     \"\"\"     if isinstance(val, str):         val = val.lower()      return val in ['true', 'on', 'yes', True]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to return the file to dict [SEP] def load_b26_file(file_name):     \"\"\"     loads a .b26 file into a dictionary      Args:         file_name:      Returns: dictionary with keys instrument, scripts, probes      \"\"\"     # file_name = \"Z:\\Lab\\Cantilever\\Measurements\\\\tmp_\\\\a\"      assert os.path.exists(file_name)      with open(file_name, 'r') as infile:         data = yaml.safe_load(infile)     return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to return the file to dict [SEP] def truncate(string, index):     \"\"\"Truncate a string at index and add ...\"\"\"     if len(string) > index and index > 0:         string = string[:index - 1] + u('…')     return string", "target": 0, "target_options": ["no match", "match"]}
{"input": "python string match variable [SEP] def _vars_match(self):         \"\"\"Regular expression to match playbook variable.\"\"\"         return re.compile(             r'#([A-Za-z]+)'  # match literal (#App) at beginning of String             r':([\\d]+)'  # app id (:7979)             r':([A-Za-z0-9_\\.\\-\\[\\]]+)'  # variable name (:variable_name)             r'!(StringArray|BinaryArray|KeyValueArray'  # variable type (array)             r'|TCEntityArray|TCEnhancedEntityArray'  # variable type (array)             r'|String|Binary|KeyValue|TCEntity|TCEnhancedEntity'  # variable type             r'|(?:(?!String)(?!Binary)(?!KeyValue)'  # non matching for custom             r'(?!TCEntity)(?!TCEnhancedEntity)'  # non matching for custom             r'[A-Za-z0-9_-]+))'  # variable type (custom)         )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python string match variable [SEP] def dump_dict_to_file(dictionary, filepath):     \"\"\"Dump @dictionary as a line to @filepath.\"\"\"     create_dirs(         os.path.dirname(filepath)     )      with open(filepath, 'a') as outfile:         json.dump(dictionary, outfile)         outfile.write('\\n')", "target": 0, "target_options": ["no match", "match"]}
{"input": "python string match variable [SEP] def get_value_matched_by_regex(field_name, regex_matches, string):     \"\"\"Ensure value stored in regex group exists.\"\"\"     try:         value = regex_matches.group(field_name)         if value is not None:             return value     except IndexError:         pass      raise MissingFieldError(string, field_name)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python string match variable [SEP] def tob32(val):     \"\"\"Return provided 32 bit value as a string of four bytes.\"\"\"     ret = bytearray(4)     ret[0] = (val>>24)&M8     ret[1] = (val>>16)&M8     ret[2] = (val>>8)&M8     ret[3] = val&M8     return ret", "target": 0, "target_options": ["no match", "match"]}
{"input": "parse array of json objects python [SEP] def _read_json_file(self, json_file):         \"\"\" Helper function to read JSON file as OrderedDict \"\"\"          self.log.debug(\"Reading '%s' JSON file...\" % json_file)          with open(json_file, 'r') as f:             return json.load(f, object_pairs_hook=OrderedDict)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "parse array of json objects python [SEP] def py3round(number):     \"\"\"Unified rounding in all python versions.\"\"\"     if abs(round(number) - number) == 0.5:         return int(2.0 * round(number / 2.0))      return int(round(number))", "target": 0, "target_options": ["no match", "match"]}
{"input": "parse array of json objects python [SEP] def get_jsonparsed_data(url):     \"\"\"Receive the content of ``url``, parse it as JSON and return the        object.     \"\"\"     response = urlopen(url)     data = response.read().decode('utf-8')     return json.loads(data)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "parse array of json objects python [SEP] def backward_char(self, e): # (C-b)         u\"\"\"Move back a character. \"\"\"         self.l_buffer.backward_char(self.argument_reset)         self.finalize()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python create dictionary of 0s from list [SEP] def list2dict(lst):     \"\"\"Takes a list of (key,value) pairs and turns it into a dict.\"\"\"      dic = {}     for k,v in lst: dic[k] = v     return dic", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python create dictionary of 0s from list [SEP] def machine_info():     \"\"\"Retrieve core and memory information for the current machine.     \"\"\"     import psutil     BYTES_IN_GIG = 1073741824.0     free_bytes = psutil.virtual_memory().total     return [{\"memory\": float(\"%.1f\" % (free_bytes / BYTES_IN_GIG)), \"cores\": multiprocessing.cpu_count(),              \"name\": socket.gethostname()}]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python create dictionary of 0s from list [SEP] def remove_falsy_values(counter: Mapping[Any, int]) -> Mapping[Any, int]:     \"\"\"Remove all values that are zero.\"\"\"     return {         label: count         for label, count in counter.items()         if count     }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python create dictionary of 0s from list [SEP] def info(self, text): \t\t\"\"\" Ajout d'un message de log de type INFO \"\"\" \t\tself.logger.info(\"{}{}\".format(self.message_prefix, text))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python code to read data from next row and paste to previous cell [SEP] def wr_row_mergeall(self, worksheet, txtstr, fmt, row_idx):         \"\"\"Merge all columns and place text string in widened cell.\"\"\"         hdridxval = len(self.hdrs) - 1         worksheet.merge_range(row_idx, 0, row_idx, hdridxval, txtstr, fmt)         return row_idx + 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python code to read data from next row and paste to previous cell [SEP] def join_cols(cols):     \"\"\"Join list of columns into a string for a SQL query\"\"\"     return \", \".join([i for i in cols]) if isinstance(cols, (list, tuple, set)) else cols", "target": 0, "target_options": ["no match", "match"]}
{"input": "python code to read data from next row and paste to previous cell [SEP] def next_row(self):         \"\"\"Move to next row from currently selected row.\"\"\"         row = self.currentIndex().row()         rows = self.source_model.rowCount()         if row + 1 == rows:             row = -1         self.selectRow(row + 1)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python code to read data from next row and paste to previous cell [SEP] def main(ctx, connection):     \"\"\"Command line interface for PyBEL.\"\"\"     ctx.obj = Manager(connection=connection)     ctx.obj.bind()", "target": 0, "target_options": ["no match", "match"]}
{"input": "send a variable to a file in python [SEP] def write_text(filename: str, text: str) -> None:     \"\"\"     Writes text to a file.     \"\"\"     with open(filename, 'w') as f:  # type: TextIO         print(text, file=f)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "send a variable to a file in python [SEP] def pairwise(iterable):     \"\"\"From itertools cookbook. [a, b, c, ...] -> (a, b), (b, c), ...\"\"\"     first, second = tee(iterable)     next(second, None)     return zip(first, second)", "target": 0, "target_options": ["no match", "match"]}
{"input": "send a variable to a file in python [SEP] def write(file_name, data):     \"\"\"Encode and write a Hip file.\"\"\"     with open(file_name, 'w') as f:         f.write(encode(data))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "send a variable to a file in python [SEP] def _poplast(self):         \"\"\"For avoiding lock during inserting to keep maxlen\"\"\"          try:             tup = self.data.pop()         except IndexError as ex:             ex.args = ('DEPQ is already empty',)             raise          self_items = self.items          try:             self_items[tup[0]] -= 1             if self_items[tup[0]] == 0:                 del self_items[tup[0]]         except TypeError:             r = repr(tup[0])             self_items[r] -= 1             if self_items[r] == 0:                 del self_items[r]          return tup", "target": 0, "target_options": ["no match", "match"]}
{"input": "python string of ascii of printable characters [SEP] def strip_non_ascii(s):     \"\"\"     Returns the string without non-ASCII characters.      Parameters     ----------     string : string         A string that may contain non-ASCII characters.      Returns     -------     clean_string : string         A string that does not contain non-ASCII characters.      \"\"\"     stripped = (c for c in s if 0 < ord(c) < 127)     clean_string = u''.join(stripped)     return clean_string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python string of ascii of printable characters [SEP] def dedupe_list(l):     \"\"\"Remove duplicates from a list preserving the order.      We might be tempted to use the list(set(l)) idiom, but it doesn't preserve     the order, which hinders testability and does not work for lists with     unhashable elements.     \"\"\"     result = []      for el in l:         if el not in result:             result.append(el)      return result", "target": 0, "target_options": ["no match", "match"]}
{"input": "python string of ascii of printable characters [SEP] def strip_accents(s, encoding= 'utf-8'):     \"\"\"Strip characters with diacritics and return a flat ascii representation\"\"\"     if sys.version < '3':         if isinstance(s,unicode):            return unicodedata.normalize('NFKD', s).encode('ASCII', 'ignore')         else:            return unicodedata.normalize('NFKD', unicode(s,encoding)).encode('ASCII', 'ignore')     else:         if isinstance(s,bytes): s = str(s,encoding)         return str(unicodedata.normalize('NFKD', s).encode('ASCII', 'ignore'),'ascii')", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python string of ascii of printable characters [SEP] def _fix_index(self, index):         \"\"\"         :param slice index:         \"\"\"         stop, start = index.stop, index.start         if start is None:             start = 0         if stop is None:             stop = len(self)         return start, stop", "target": 0, "target_options": ["no match", "match"]}
{"input": "python replace a symbol by space [SEP] def split(s):   \"\"\"Uses dynamic programming to infer the location of spaces in a string without spaces.\"\"\"   l = [_split(x) for x in _SPLIT_RE.split(s)]   return [item for sublist in l for item in sublist]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python replace a symbol by space [SEP] def list_move_to_front(l,value='other'):     \"\"\"if the value is in the list, move it to the front and return it.\"\"\"     l=list(l)     if value in l:         l.remove(value)         l.insert(0,value)     return l", "target": 0, "target_options": ["no match", "match"]}
{"input": "python replace a symbol by space [SEP] def is_identifier(string):     \"\"\"Check if string could be a valid python identifier      :param string: string to be tested     :returns: True if string can be a python identifier, False otherwise     :rtype: bool     \"\"\"     matched = PYTHON_IDENTIFIER_RE.match(string)     return bool(matched) and not keyword.iskeyword(string)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python replace a symbol by space [SEP] def firmware_download_input_rbridge_id(self, **kwargs):         \"\"\"Auto Generated Code         \"\"\"         config = ET.Element(\"config\")         firmware_download = ET.Element(\"firmware_download\")         config = firmware_download         input = ET.SubElement(firmware_download, \"input\")         rbridge_id = ET.SubElement(input, \"rbridge-id\")         rbridge_id.text = kwargs.pop('rbridge_id')          callback = kwargs.pop('callback', self._callback)         return callback(config)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python get items in a list [SEP] def flatten_list(x: List[Any]) -> List[Any]:     \"\"\"     Converts a list of lists into a flat list.          Args:         x: list of lists       Returns:         flat list              As per     http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python      \"\"\"  # noqa     return [item for sublist in x for item in sublist]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python get items in a list [SEP] def pivot(self):         \"\"\"         transposes rows and columns         \"\"\"         self.op_data = [list(i) for i in zip(*self.ip_data)]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python get items in a list [SEP] def serialize(self, value, **kwargs):         \"\"\"Serialize every item of the list.\"\"\"         return [self.item_type.serialize(val, **kwargs) for val in value]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python get items in a list [SEP] def get_file_string(filepath):     \"\"\"Get string from file.\"\"\"     with open(os.path.abspath(filepath)) as f:         return f.read()", "target": 0, "target_options": ["no match", "match"]}
{"input": "integer to binary string python [SEP] def string_to_int( s ):   \"\"\"Convert a string of bytes into an integer, as per X9.62.\"\"\"   result = 0   for c in s:     if not isinstance(c, int): c = ord( c )     result = 256 * result + c   return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "integer to binary string python [SEP] def format(self):         \"\"\"         Return a well formatted list. Basicaly, it's sort a list and remove duplicate.          :return: A sorted, without duplicate, list.         :rtype: list         \"\"\"          try:             return sorted(list(set(self.main_list)), key=str.lower)          except TypeError:  # pragma: no cover             return self.main_list", "target": 0, "target_options": ["no match", "match"]}
{"input": "integer to binary string python [SEP] def intToBin(i):     \"\"\" Integer to two bytes \"\"\"     # divide in two parts (bytes)     i1 = i % 256     i2 = int(i / 256)     # make string (little endian)     return i.to_bytes(2, byteorder='little')", "target": 1, "target_options": ["no_match", "match"]}
{"input": "integer to binary string python [SEP] def check_auth(username, pwd):     \"\"\"This function is called to check if a username /     password combination is valid.     \"\"\"     cfg = get_current_config()     return username == cfg[\"dashboard_httpauth\"].split(         \":\")[0] and pwd == cfg[\"dashboard_httpauth\"].split(\":\")[1]", "target": 0, "target_options": ["no match", "match"]}
{"input": "flatten a 2d matrix to 1d matrix python [SEP] def im2mat(I):     \"\"\"Converts and image to matrix (one pixel per line)\"\"\"     return I.reshape((I.shape[0] * I.shape[1], I.shape[2]))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "flatten a 2d matrix to 1d matrix python [SEP] def is_square_matrix(mat):     \"\"\"Test if an array is a square matrix.\"\"\"     mat = np.array(mat)     if mat.ndim != 2:         return False     shape = mat.shape     return shape[0] == shape[1]", "target": 0, "target_options": ["no match", "match"]}
{"input": "flatten a 2d matrix to 1d matrix python [SEP] def transpose(table):     \"\"\"     transpose matrix     \"\"\"     t = []     for i in range(0, len(table[0])):         t.append([row[i] for row in table])     return t", "target": 1, "target_options": ["no_match", "match"]}
{"input": "flatten a 2d matrix to 1d matrix python [SEP] def unit_net_value(self):         \"\"\"         [float] 实时净值         \"\"\"         if self._units == 0:             return np.nan         return self.total_value / self._units", "target": 0, "target_options": ["no match", "match"]}
{"input": "python flask image is empty [SEP] def is_empty(self):         \"\"\"Checks for an empty image.         \"\"\"         if(((self.channels == []) and (not self.shape == (0, 0))) or            ((not self.channels == []) and (self.shape == (0, 0)))):             raise RuntimeError(\"Channels-shape mismatch.\")         return self.channels == [] and self.shape == (0, 0)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python flask image is empty [SEP] def _dt_to_float_ordinal(dt):     \"\"\"     Convert :mod:`datetime` to the Gregorian date as UTC float days,     preserving hours, minutes, seconds and microseconds.  Return value     is a :func:`float`.     \"\"\"     if (isinstance(dt, (np.ndarray, Index, ABCSeries)                    ) and is_datetime64_ns_dtype(dt)):         base = dates.epoch2num(dt.asi8 / 1.0E9)     else:         base = dates.date2num(dt)     return base", "target": 0, "target_options": ["no match", "match"]}
{"input": "python flask image is empty [SEP] def set_empty_text(self):         \"\"\"Display the empty text         \"\"\"         self.buffer.insert_with_tags_by_name(             self.buffer.get_start_iter(),             self.empty_text, 'empty-text')", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python flask image is empty [SEP] def get_single_item(d):     \"\"\"Get an item from a dict which contains just one item.\"\"\"     assert len(d) == 1, 'Single-item dict must have just one item, not %d.' % len(d)     return next(six.iteritems(d))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python get windows bounding box [SEP] def calculate_bounding_box(data):     \"\"\"     Returns a 2 x m array indicating the min and max along each     dimension.     \"\"\"     mins = data.min(0)     maxes = data.max(0)     return mins, maxes", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python get windows bounding box [SEP] def toposort_flatten(data, sort=True):     \"\"\"Returns a single list of dependencies. For any set returned by toposort(), those items are sorted and appended to the result (just to make the results deterministic).\"\"\"      result = []     for d in toposort(data):         try:             result.extend((sorted if sort else list)(d))         except TypeError as e:             result.extend(list(d))     return result", "target": 0, "target_options": ["no match", "match"]}
{"input": "python get windows bounding box [SEP] def calculate_bbox_area(bbox, rows, cols):     \"\"\"Calculate the area of a bounding box in pixels.\"\"\"     bbox = denormalize_bbox(bbox, rows, cols)     x_min, y_min, x_max, y_max = bbox[:4]     area = (x_max - x_min) * (y_max - y_min)     return area", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python get windows bounding box [SEP] def _ReturnConnection(self): \t\t\"\"\" \t\tReturns a connection back to the pool \t\t \t\t@author: Nick Verbeck \t\t@since: 9/7/2008 \t\t\"\"\" \t\tif self.conn is not None: \t\t\tif self.connInfo.commitOnEnd is True or self.commitOnEnd is True: \t\t\t\tself.conn.Commit() \t\t\t\t\t \t\t\tPool().returnConnection(self.conn) \t\t\tself.conn = None", "target": 0, "target_options": ["no match", "match"]}
{"input": "merge two dictionary with the same key python [SEP] def dict_merge(set1, set2):     \"\"\"Joins two dictionaries.\"\"\"     return dict(list(set1.items()) + list(set2.items()))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "merge two dictionary with the same key python [SEP] def skip_connection_distance(a, b):     \"\"\"The distance between two skip-connections.\"\"\"     if a[2] != b[2]:         return 1.0     len_a = abs(a[1] - a[0])     len_b = abs(b[1] - b[0])     return (abs(a[0] - b[0]) + abs(len_a - len_b)) / (max(a[0], b[0]) + max(len_a, len_b))", "target": 0, "target_options": ["no match", "match"]}
{"input": "merge two dictionary with the same key python [SEP] def extend(a: dict, b: dict) -> dict:     \"\"\"Merge two dicts and return a new dict. Much like subclassing works.\"\"\"     res = a.copy()     res.update(b)     return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "merge two dictionary with the same key python [SEP] def parse_command_args():     \"\"\"Command line parser.\"\"\"     parser = argparse.ArgumentParser(description='Register PB devices.')     parser.add_argument('num_pb', type=int,                         help='Number of PBs devices to register.')     return parser.parse_args()", "target": 0, "target_options": ["no match", "match"]}
{"input": "show contents of a file in python [SEP] def get_file_string(filepath):     \"\"\"Get string from file.\"\"\"     with open(os.path.abspath(filepath)) as f:         return f.read()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "show contents of a file in python [SEP] def contains_empty(features):     \"\"\"Check features data are not empty      :param features: The features data to check.     :type features: list of numpy arrays.      :return: True if one of the array is empty, False else.      \"\"\"     if not features:         return True     for feature in features:         if feature.shape[0] == 0:             return True     return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "show contents of a file in python [SEP] def str_from_file(path):     \"\"\"     Return file contents as string.      \"\"\"     with open(path) as f:         s = f.read().strip()     return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "show contents of a file in python [SEP] def __init__(self, args, loop):         \"\"\"Initialize a new instance of GlobalCommands.\"\"\"         self.args = args         self.loop = loop", "target": 0, "target_options": ["no match", "match"]}
{"input": "file exists but not opening python [SEP] def file_read(filename):     \"\"\"Read a file and close it.  Returns the file source.\"\"\"     fobj = open(filename,'r');     source = fobj.read();     fobj.close()     return source", "target": 1, "target_options": ["no_match", "match"]}
{"input": "file exists but not opening python [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 0, "target_options": ["no match", "match"]}
{"input": "file exists but not opening python [SEP] def get_data_table(filename):   \"\"\"Returns a DataTable instance built from either the filename, or STDIN if filename is None.\"\"\"   with get_file_object(filename, \"r\") as rf:     return DataTable(list(csv.reader(rf)))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "file exists but not opening python [SEP] def lighting(im, b, c):     \"\"\" Adjust image balance and contrast \"\"\"     if b==0 and c==1: return im     mu = np.average(im)     return np.clip((im-mu)*c+mu+b,0.,1.).astype(np.float32)", "target": 0, "target_options": ["no match", "match"]}
{"input": "time delta of one month python [SEP] def last_midnight():     \"\"\"     return a datetime of last mid-night     \"\"\"     now = datetime.now()     return datetime(now.year, now.month, now.day)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "time delta of one month python [SEP] def __split_every_n(self, n, data):         \"\"\"         \"\"\"         return [data[i:i+n] for i in range(0, len(data), n)]", "target": 0, "target_options": ["no match", "match"]}
{"input": "time delta of one month python [SEP] def test3():     \"\"\"Test the multiprocess     \"\"\"     import time          p = MVisionProcess()     p.start()     time.sleep(5)     p.stop()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "time delta of one month python [SEP] def replaceNewlines(string, newlineChar): \t\"\"\"There's probably a way to do this with string functions but I was lazy. \t\tReplace all instances of \\r or \\n in a string with something else.\"\"\" \tif newlineChar in string: \t\tsegments = string.split(newlineChar) \t\tstring = \"\" \t\tfor segment in segments: \t\t\tstring += segment \treturn string", "target": 0, "target_options": ["no match", "match"]}
{"input": "configparser python escape % [SEP] def _escape(self, s):         \"\"\"Escape bad characters for regular expressions.          Similar to `re.escape` but allows '%' to pass through.          \"\"\"         for ch, r_ch in self.ESCAPE_SETS:             s = s.replace(ch, r_ch)         return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "configparser python escape % [SEP] def relative_path(path):     \"\"\"     Return the given path relative to this file.     \"\"\"     return os.path.join(os.path.dirname(__file__), path)", "target": 0, "target_options": ["no match", "match"]}
{"input": "configparser python escape % [SEP] def quote(self, s):         \"\"\"Return a shell-escaped version of the string s.\"\"\"          if six.PY2:             from pipes import quote         else:             from shlex import quote          return quote(s)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "configparser python escape % [SEP] def split_on(s, sep=\" \"):     \"\"\"Split s by sep, unless it's inside a quote.\"\"\"     pattern = '''((?:[^%s\"']|\"[^\"]*\"|'[^']*')+)''' % sep      return [_strip_speechmarks(t) for t in re.split(pattern, s)[1::2]]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python create list from lists [SEP] def flatten_list(x: List[Any]) -> List[Any]:     \"\"\"     Converts a list of lists into a flat list.          Args:         x: list of lists       Returns:         flat list              As per     http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python      \"\"\"  # noqa     return [item for sublist in x for item in sublist]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python create list from lists [SEP] def flatten(l, types=(list, float)):     \"\"\"     Flat nested list of lists into a single list.     \"\"\"     l = [item if isinstance(item, types) else [item] for item in l]     return [item for sublist in l for item in sublist]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python create list from lists [SEP] def _str_to_list(s):     \"\"\"Converts a comma separated string to a list\"\"\"     _list = s.split(\",\")     return list(map(lambda i: i.lstrip(), _list))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python create list from lists [SEP] def _increase_file_handle_limit():     \"\"\"Raise the open file handles permitted by the Dusty daemon process     and its child processes. The number we choose here needs to be within     the OS X default kernel hard limit, which is 10240.\"\"\"     logging.info('Increasing file handle limit to {}'.format(constants.FILE_HANDLE_LIMIT))     resource.setrlimit(resource.RLIMIT_NOFILE,                        (constants.FILE_HANDLE_LIMIT, resource.RLIM_INFINITY))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python multiprocessing pool join time out [SEP] def Join(self):     \"\"\"Waits until all outstanding tasks are completed.\"\"\"      for _ in range(self.JOIN_TIMEOUT_DECISECONDS):       if self._queue.empty() and not self.busy_threads:         return       time.sleep(0.1)      raise ValueError(\"Timeout during Join() for threadpool %s.\" % self.name)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python multiprocessing pool join time out [SEP] def adapt_array(arr):     \"\"\"     Adapts a Numpy array into an ARRAY string to put into the database.      Parameters     ----------     arr: array         The Numpy array to be adapted into an ARRAY type that can be inserted into a SQL file.      Returns     -------     ARRAY             The adapted array object      \"\"\"     out = io.BytesIO()     np.save(out, arr), out.seek(0)     return buffer(out.read())", "target": 0, "target_options": ["no match", "match"]}
{"input": "python multiprocessing pool join time out [SEP] def terminate_pool(self):         \"\"\"Terminate and close the multiprocessing pool if necessary.\"\"\"          if self.pool is not None:             self.pool.terminate()             self.pool.join()             del(self.pool)             self.pool = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python multiprocessing pool join time out [SEP] def addValue(self, _, value):     \"\"\"Adds a value from the given source.\"\"\"     self.total += self._dataFormat.getValue(value)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to add a vaiable to a url [SEP] def url_fix_common_typos (url):     \"\"\"Fix common typos in given URL like forgotten colon.\"\"\"     if url.startswith(\"http//\"):         url = \"http://\" + url[6:]     elif url.startswith(\"https//\"):         url = \"https://\" + url[7:]     return url", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to add a vaiable to a url [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to add a vaiable to a url [SEP] def _build_url(self, shorten=True):         \"\"\"Build the url for a cable ratings page\"\"\"         self.url = URL_FORMAT.format(*self._get_url_params(shorten=shorten))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to add a vaiable to a url [SEP] def full_like(array, value, dtype=None):     \"\"\" Create a shared memory array with the same shape and type as a given array, filled with `value`.     \"\"\"     shared = empty_like(array, dtype)     shared[:] = value     return shared", "target": 0, "target_options": ["no match", "match"]}
{"input": "element wise product in python [SEP] def dotproduct(X, Y):     \"\"\"Return the sum of the element-wise product of vectors x and y.     >>> dotproduct([1, 2, 3], [1000, 100, 10])     1230     \"\"\"     return sum([x * y for x, y in zip(X, Y)])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "element wise product in python [SEP] def equal(list1, list2):     \"\"\" takes flags returns indexes of True values \"\"\"     return [item1 == item2 for item1, item2 in broadcast_zip(list1, list2)]", "target": 0, "target_options": ["no match", "match"]}
{"input": "element wise product in python [SEP] def dot_product(self, other):         \"\"\" Return the dot product of the given vectors. \"\"\"         return self.x * other.x + self.y * other.y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "element wise product in python [SEP] def convert_html_subscripts_to_latex(text):     \"\"\"Convert some HTML tags to latex equivalents.\"\"\"     text = re.sub(\"<sub>(.*?)</sub>\", r\"$_{\\1}$\", text)     text = re.sub(\"<sup>(.*?)</sup>\", r\"$^{\\1}$\", text)     return text", "target": 0, "target_options": ["no match", "match"]}
{"input": "in python how to sort a string without using inbuilt sort [SEP] def natural_sort(list_to_sort: Iterable[str]) -> List[str]:     \"\"\"     Sorts a list of strings case insensitively as well as numerically.      For example: ['a1', 'A2', 'a3', 'A11', 'a22']      To sort a list in place, don't call this method, which makes a copy. Instead, do this:      my_list.sort(key=natural_keys)      :param list_to_sort: the list being sorted     :return: the list sorted naturally     \"\"\"     return sorted(list_to_sort, key=natural_keys)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "in python how to sort a string without using inbuilt sort [SEP] def append(self, item):         \"\"\" append item and print it to stdout \"\"\"         print(item)         super(MyList, self).append(item)", "target": 0, "target_options": ["no match", "match"]}
{"input": "in python how to sort a string without using inbuilt sort [SEP] def transcript_sort_key(transcript):     \"\"\"     Key function used to sort transcripts. Taking the negative of     protein sequence length and nucleotide sequence length so that     the transcripts with longest sequences come first in the list. This couldn't     be accomplished with `reverse=True` since we're also sorting by     transcript name (which places TP53-001 before TP53-002).     \"\"\"     return (         -len(transcript.protein_sequence),         -len(transcript.sequence),         transcript.name     )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "in python how to sort a string without using inbuilt sort [SEP] def add_lines(self, txt, indent=0):         \"\"\"Adds a list of lines.          The list can be indented with the optional argument 'indent'.         \"\"\"         for line in txt:             self.add_line(line, indent)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to decode a list utf inpython [SEP] def _try_decode_list(content):         \"\"\"Decode content of a list.          :param list|tuple content:         :return:         \"\"\"         result = list()         for value in content:             result.append(try_utf8_decode(value))         return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to decode a list utf inpython [SEP] def match_all_in(self, matches, item):         \"\"\"Matches all matches to elements of item.\"\"\"         for i, match in enumerate(matches):             self.match(match, item + \"[\" + str(i) + \"]\")", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to decode a list utf inpython [SEP] async def load_unicode(reader):     \"\"\"     Loads UTF8 string     :param reader:     :return:     \"\"\"     ivalue = await load_uvarint(reader)     fvalue = bytearray(ivalue)     await reader.areadinto(fvalue)     return str(fvalue, 'utf8')", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to decode a list utf inpython [SEP] def _ReturnConnection(self): \t\t\"\"\" \t\tReturns a connection back to the pool \t\t \t\t@author: Nick Verbeck \t\t@since: 9/7/2008 \t\t\"\"\" \t\tif self.conn is not None: \t\t\tif self.connInfo.commitOnEnd is True or self.commitOnEnd is True: \t\t\t\tself.conn.Commit() \t\t\t\t\t \t\t\tPool().returnConnection(self.conn) \t\t\tself.conn = None", "target": 0, "target_options": ["no match", "match"]}
{"input": "command in python to get to server [SEP] def __send_request(self, url, params=None):         \"\"\"Send request\"\"\"          r = self.fetch(url, payload=params)         return r.text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "command in python to get to server [SEP] def _vars_match(self):         \"\"\"Regular expression to match playbook variable.\"\"\"         return re.compile(             r'#([A-Za-z]+)'  # match literal (#App) at beginning of String             r':([\\d]+)'  # app id (:7979)             r':([A-Za-z0-9_\\.\\-\\[\\]]+)'  # variable name (:variable_name)             r'!(StringArray|BinaryArray|KeyValueArray'  # variable type (array)             r'|TCEntityArray|TCEnhancedEntityArray'  # variable type (array)             r'|String|Binary|KeyValue|TCEntity|TCEnhancedEntity'  # variable type             r'|(?:(?!String)(?!Binary)(?!KeyValue)'  # non matching for custom             r'(?!TCEntity)(?!TCEnhancedEntity)'  # non matching for custom             r'[A-Za-z0-9_-]+))'  # variable type (custom)         )", "target": 0, "target_options": ["no match", "match"]}
{"input": "command in python to get to server [SEP] def web(host, port):     \"\"\"Start web application\"\"\"     from .webserver.web import get_app     get_app().run(host=host, port=port)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "command in python to get to server [SEP] def _ReturnConnection(self): \t\t\"\"\" \t\tReturns a connection back to the pool \t\t \t\t@author: Nick Verbeck \t\t@since: 9/7/2008 \t\t\"\"\" \t\tif self.conn is not None: \t\t\tif self.connInfo.commitOnEnd is True or self.commitOnEnd is True: \t\t\t\tself.conn.Commit() \t\t\t\t\t \t\t\tPool().returnConnection(self.conn) \t\t\tself.conn = None", "target": 0, "target_options": ["no match", "match"]}
{"input": "distance formula in python speed time [SEP] def skip_connection_distance(a, b):     \"\"\"The distance between two skip-connections.\"\"\"     if a[2] != b[2]:         return 1.0     len_a = abs(a[1] - a[0])     len_b = abs(b[1] - b[0])     return (abs(a[0] - b[0]) + abs(len_a - len_b)) / (max(a[0], b[0]) + max(len_a, len_b))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "distance formula in python speed time [SEP] def write(self, data):         \"\"\"         Write the given data to the file.         \"\"\"                  # Do the write         self.backingStream.write(data)                  for listener in self.writeListeners:             # Send out notifications             listener(len(data))", "target": 0, "target_options": ["no match", "match"]}
{"input": "distance formula in python speed time [SEP] def vector_distance(a, b):     \"\"\"The Euclidean distance between two vectors.\"\"\"     a = np.array(a)     b = np.array(b)     return np.linalg.norm(a - b)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "distance formula in python speed time [SEP] def pause(msg=\"Press Enter to Continue...\"):     \"\"\"press to continue\"\"\"     print('\\n' + Fore.YELLOW + msg + Fore.RESET, end='')     input()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python get item in list with most [SEP] def _most_common(iterable):     \"\"\"Returns the most common element in `iterable`.\"\"\"     data = Counter(iterable)     return max(data, key=data.__getitem__)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python get item in list with most [SEP] def get_value_matched_by_regex(field_name, regex_matches, string):     \"\"\"Ensure value stored in regex group exists.\"\"\"     try:         value = regex_matches.group(field_name)         if value is not None:             return value     except IndexError:         pass      raise MissingFieldError(string, field_name)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python get item in list with most [SEP] def unique_element(ll):     \"\"\" returns unique elements from a list preserving the original order \"\"\"     seen = {}     result = []     for item in ll:         if item in seen:             continue         seen[item] = 1         result.append(item)     return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python get item in list with most [SEP] def data(fname):     \"\"\"Return the contents of a data file of ours.\"\"\"     data_file = open(data_filename(fname))     try:         return data_file.read()     finally:         data_file.close()", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to pick the top 3 values in a table python [SEP] def qth_pw(self, q):         \"\"\"         returns the qth most probable element in the dawg.         \"\"\"         return heapq.nlargest(q + 2, self._T.iteritems(),                               key=operator.itemgetter(1))[-1]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to pick the top 3 values in a table python [SEP] def SaveDataToFD(self, raw_data, fd):     \"\"\"Merge the raw data with the config file and store it.\"\"\"     for key, value in iteritems(raw_data):       # TODO(hanuszczak): Incorrect type specification for `set`.       # pytype: disable=wrong-arg-types       self.set(\"\", key, value=value)       # pytype: enable=wrong-arg-types      self.write(fd)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to pick the top 3 values in a table python [SEP] def nameTuple(s: Influence) -> Tuple[str, str]:     \"\"\" Returns a 2-tuple consisting of the top groundings of the subj and obj     of an Influence statement. \"\"\"     return top_grounding(s.subj), top_grounding(s.obj)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to pick the top 3 values in a table python [SEP] def read_string(buff, byteorder='big'):     \"\"\"Read a string from a file-like object.\"\"\"     length = read_numeric(USHORT, buff, byteorder)     return buff.read(length).decode('utf-8')", "target": 0, "target_options": ["no match", "match"]}
{"input": "select items by indexes in list python [SEP] def equal(list1, list2):     \"\"\" takes flags returns indexes of True values \"\"\"     return [item1 == item2 for item1, item2 in broadcast_zip(list1, list2)]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "select items by indexes in list python [SEP] def get_cache_path(filename): \t\"\"\" get file path \"\"\" \tcwd = os.path.dirname(os.path.realpath(__file__)) \treturn os.path.join(cwd, filename)", "target": 0, "target_options": ["no match", "match"]}
{"input": "select items by indexes in list python [SEP] def get_feature_order(dataset, features):     \"\"\" Returns a list with the order that features requested appear in     dataset \"\"\"     all_features = dataset.get_feature_names()      i = [all_features.index(f) for f in features]      return i", "target": 1, "target_options": ["no_match", "match"]}
{"input": "select items by indexes in list python [SEP] def url_to_image(url, flag=cv2.IMREAD_COLOR):     \"\"\" download the image, convert it to a NumPy array, and then read     it into OpenCV format \"\"\"     resp = urlopen(url)     image = np.asarray(bytearray(resp.read()), dtype=\"uint8\")     image = cv2.imdecode(image, flag)     return image", "target": 0, "target_options": ["no match", "match"]}
{"input": "draw a circle in python pygame [SEP] def draw_circle(self, color, world_loc, world_radius, thickness=0):     \"\"\"Draw a circle using world coordinates and radius.\"\"\"     if world_radius > 0:       center = self.world_to_surf.fwd_pt(world_loc).round()       radius = max(1, int(self.world_to_surf.fwd_dist(world_radius)))       pygame.draw.circle(self.surf, color, center, radius,                          thickness if thickness < radius else 0)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "draw a circle in python pygame [SEP] def needs_check(self):         \"\"\"         Check if enough time has elapsed to perform a check().          If this time has elapsed, a state change check through         has_state_changed() should be performed and eventually a sync().          :rtype: boolean         \"\"\"         if self.lastcheck is None:             return True         return time.time() - self.lastcheck >= self.ipchangedetection_sleep", "target": 0, "target_options": ["no match", "match"]}
{"input": "draw a circle in python pygame [SEP] def arc_negative(self, x, y, radius, start_angle, end_angle):         \"\"\"draw arc going clockwise from start_angle to end_angle\"\"\"         self._add_instruction(\"arc_negative\", x, y, radius, start_angle, end_angle)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "draw a circle in python pygame [SEP] def call_out(command):   \"\"\"   Run the given command (with shell=False) and return a tuple of   (int returncode, str output). Strip the output of enclosing whitespace.   \"\"\"   # start external command process   p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)    # get outputs   out, _ = p.communicate()    return p.returncode, out.strip()", "target": 0, "target_options": ["no match", "match"]}
{"input": "replace values in python string [SEP] def myreplace(astr, thefind, thereplace):     \"\"\"in string astr replace all occurences of thefind with thereplace\"\"\"     alist = astr.split(thefind)     new_s = alist.split(thereplace)     return new_s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "replace values in python string [SEP] def isworkday(self, date):         \"\"\"         Check if a given date is a work date, ignoring holidays.          Args:             date (date, datetime or str): Date to be checked.          Returns:             bool: True if the date is a work date, False otherwise.         \"\"\"         date = parsefun(date)         return self.weekdaymap[date.weekday()].isworkday", "target": 0, "target_options": ["no match", "match"]}
{"input": "replace values in python string [SEP] def replace(s, replace):     \"\"\"Replace multiple values in a string\"\"\"     for r in replace:         s = s.replace(*r)     return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "replace values in python string [SEP] def is_all_field_none(self):         \"\"\"         :rtype: bool         \"\"\"          if self._type_ is not None:             return False          if self._value is not None:             return False          if self._name is not None:             return False          return True", "target": 0, "target_options": ["no match", "match"]}
{"input": "python return string with first letter of each word in lower case [SEP] def to_pascal_case(s):     \"\"\"Transform underscore separated string to pascal case      \"\"\"     return re.sub(r'(?!^)_([a-zA-Z])', lambda m: m.group(1).upper(), s.capitalize())", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python return string with first letter of each word in lower case [SEP] def prt_js(js, sort_keys=True, indent=4):     \"\"\"Print Json in pretty format.     There's a standard module pprint, can pretty print python dict and list.     But it doesn't support sorted key. That why we need this func.      Usage::          >>> from weatherlab.lib.dataIO.js import prt_js         >>> prt_js({\"a\": 1, \"b\": 2})         {             \"a\": 1,             \"b\": 2         }      **中文文档**      以人类可读的方式打印可Json化的Python对象。     \"\"\"     print(js2str(js, sort_keys, indent))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python return string with first letter of each word in lower case [SEP] def to_capitalized_camel_case(snake_case_string):     \"\"\"     Convert a string from snake case to camel case with the first letter capitalized. For example, \"some_var\"     would become \"SomeVar\".      :param snake_case_string: Snake-cased string to convert to camel case.     :returns: Camel-cased version of snake_case_string.     \"\"\"     parts = snake_case_string.split('_')     return ''.join([i.title() for i in parts])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python return string with first letter of each word in lower case [SEP] def _tuple_repr(data):     \"\"\"Return a repr() for a list/tuple\"\"\"     if len(data) == 1:         return \"(%s,)\" % rpr(data[0])     else:         return \"(%s)\" % \", \".join([rpr(x) for x in data])", "target": 0, "target_options": ["no match", "match"]}
{"input": "make sure two dictionaries are same python [SEP] def dict_merge(set1, set2):     \"\"\"Joins two dictionaries.\"\"\"     return dict(list(set1.items()) + list(set2.items()))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "make sure two dictionaries are same python [SEP] def prt_js(js, sort_keys=True, indent=4):     \"\"\"Print Json in pretty format.     There's a standard module pprint, can pretty print python dict and list.     But it doesn't support sorted key. That why we need this func.      Usage::          >>> from weatherlab.lib.dataIO.js import prt_js         >>> prt_js({\"a\": 1, \"b\": 2})         {             \"a\": 1,             \"b\": 2         }      **中文文档**      以人类可读的方式打印可Json化的Python对象。     \"\"\"     print(js2str(js, sort_keys, indent))", "target": 0, "target_options": ["no match", "match"]}
{"input": "make sure two dictionaries are same python [SEP] def intersect(d1, d2):     \"\"\"Intersect dictionaries d1 and d2 by key *and* value.\"\"\"     return dict((k, d1[k]) for k in d1 if k in d2 and d1[k] == d2[k])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "make sure two dictionaries are same python [SEP] def clean_dataframe(df):     \"\"\"Fill NaNs with the previous value, the next value or if all are NaN then 1.0\"\"\"     df = df.fillna(method='ffill')     df = df.fillna(0.0)     return df", "target": 0, "target_options": ["no match", "match"]}
{"input": "delete rows with null in python [SEP] def safe_delete(filename):   \"\"\"Delete a file safely. If it's not present, no-op.\"\"\"   try:     os.unlink(filename)   except OSError as e:     if e.errno != errno.ENOENT:       raise", "target": 1, "target_options": ["no_match", "match"]}
{"input": "delete rows with null in python [SEP] def _has(self, key, exact=0):          \"\"\"Returns false if key is not found or is ambiguous\"\"\"          if not exact:             try:                 key = self.getfullkey(key)                 return 1             except KeyError:                 return 0         else:             return key in self.data", "target": 0, "target_options": ["no match", "match"]}
{"input": "delete rows with null in python [SEP] def remove_if_exists(filename):     \"\"\" Remove file.      This is like :func:`os.remove` (or :func:`os.unlink`), except that no     error is raised if the file does not exist.      \"\"\"     try:         os.unlink(filename)     except OSError as ex:         if ex.errno != errno.ENOENT:             raise", "target": 1, "target_options": ["no_match", "match"]}
{"input": "delete rows with null in python [SEP] def _z(self, x):     \"\"\"Standardize input `x` to a unit normal.\"\"\"     with tf.name_scope(\"standardize\"):       return (x - self.loc) / self.scale", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to print with printf python [SEP] def good(txt):     \"\"\"Print, emphasized 'good', the given 'txt' message\"\"\"      print(\"%s# %s%s%s\" % (PR_GOOD_CC, get_time_stamp(), txt, PR_NC))     sys.stdout.flush()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to print with printf python [SEP] def C_dict2array(C):     \"\"\"Convert an OrderedDict containing C values to a 1D array.\"\"\"     return np.hstack([np.asarray(C[k]).ravel() for k in C_keys])", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to print with printf python [SEP] def out(self, output, newline=True):         \"\"\"Outputs a string to the console (stdout).\"\"\"         click.echo(output, nl=newline)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to print with printf python [SEP] def file_read(filename):     \"\"\"Read a file and close it.  Returns the file source.\"\"\"     fobj = open(filename,'r');     source = fobj.read();     fobj.close()     return source", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to set the axis in the scatter python [SEP] def set_scalebar_for_all(self, row_column_list=None,                              location='lower right'):         \"\"\"Show marker area scale for subplots.          :param row_column_list: a list containing (row, column) tuples to             specify the subplots, or None to indicate *all* subplots.         :param location: the location of the label inside the plot.  May             be one of 'center', 'upper right', 'lower right', 'upper             left', 'lower left'.          \"\"\"         if row_column_list is None:             for subplot in self.subplots:                 subplot.set_scalebar(location)         else:             for row, column in row_column_list:                 subplot = self.get_subplot_at(row, column)                 subplot.set_scalebar(location)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to set the axis in the scatter python [SEP] def main(arguments=None):     \"\"\"Main command line entry point.\"\"\"      if not arguments:         arguments = sys.argv[1:]      wordlist, sowpods, by_length, start, end = argument_parser(arguments)     for word in wordlist:         pretty_print(             word,             anagrams_in_word(word, sowpods, start, end),             by_length,         )", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to set the axis in the scatter python [SEP] def ytickvals(self, values, index=1):         \"\"\"Set the tick values.          Parameters         ----------         values : array-like          Returns         -------         Chart          \"\"\"         self.layout['yaxis' + str(index)]['tickvals'] = values         return self", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to set the axis in the scatter python [SEP] def try_cast_int(s):     \"\"\"(str) -> int     All the digits in a given string are concatenated and converted into a single number.     \"\"\"     try:         temp = re.findall('\\d', str(s))         temp = ''.join(temp)         return int(temp)     except:         return s", "target": 0, "target_options": ["no match", "match"]}
{"input": "read 2 bytes data in python [SEP] def read_bytes(fo, writer_schema=None, reader_schema=None):     \"\"\"Bytes are encoded as a long followed by that many bytes of data.\"\"\"     size = read_long(fo)     return fo.read(size)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "read 2 bytes data in python [SEP] def last_midnight():     \"\"\"     return a datetime of last mid-night     \"\"\"     now = datetime.now()     return datetime(now.year, now.month, now.day)", "target": 0, "target_options": ["no match", "match"]}
{"input": "read 2 bytes data in python [SEP] def be_array_from_bytes(fmt, data):     \"\"\"     Reads an array from bytestring with big-endian data.     \"\"\"     arr = array.array(str(fmt), data)     return fix_byteorder(arr)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "read 2 bytes data in python [SEP] def get_column(self, X, column):         \"\"\"Return a column of the given matrix.          Args:             X: `numpy.ndarray` or `pandas.DataFrame`.             column: `int` or `str`.          Returns:             np.ndarray: Selected column.         \"\"\"         if isinstance(X, pd.DataFrame):             return X[column].values          return X[:, column]", "target": 0, "target_options": ["no match", "match"]}
{"input": "change png pil image to white background stackoverflow python [SEP] def hflip(img):     \"\"\"Horizontally flip the given PIL Image.      Args:         img (PIL Image): Image to be flipped.      Returns:         PIL Image:  Horizontall flipped image.     \"\"\"     if not _is_pil_image(img):         raise TypeError('img should be PIL Image. Got {}'.format(type(img)))      return img.transpose(Image.FLIP_LEFT_RIGHT)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "change png pil image to white background stackoverflow python [SEP] def eof(fd):     \"\"\"Determine if end-of-file is reached for file fd.\"\"\"     b = fd.read(1)     end = len(b) == 0     if not end:         curpos = fd.tell()         fd.seek(curpos - 1)     return end", "target": 0, "target_options": ["no match", "match"]}
{"input": "change png pil image to white background stackoverflow python [SEP] def add_bg(img, padding, color=COL_WHITE):     \"\"\"     Adds a padding to the given image as background of specified color      :param img: Input image.     :param padding: constant padding around the image.     :param color: background color that needs to filled for the newly padded region.     :return: New image with background.     \"\"\"     img = gray3(img)     h, w, d = img.shape     new_img = np.ones((h + 2*padding, w + 2*padding, d)) * color[:d]     new_img = new_img.astype(np.uint8)     set_img_box(new_img, (padding, padding, w, h), img)     return new_img", "target": 1, "target_options": ["no_match", "match"]}
{"input": "change png pil image to white background stackoverflow python [SEP] def getSystemVariable(self, remote, name):         \"\"\"Get single system variable from CCU / Homegear\"\"\"         if self._server is not None:             return self._server.getSystemVariable(remote, name)", "target": 0, "target_options": ["no match", "match"]}
{"input": "current time in python django [SEP] def get_basket_items(request):     \"\"\"     Get all items in the basket     \"\"\"     bid = basket_id(request)     return BasketItem.objects.filter(basket_id=bid), bid", "target": 1, "target_options": ["no_match", "match"]}
{"input": "current time in python django [SEP] def write(file_name, data):     \"\"\"Encode and write a Hip file.\"\"\"     with open(file_name, 'w') as f:         f.write(encode(data))", "target": 0, "target_options": ["no match", "match"]}
{"input": "current time in python django [SEP] def getDjangoObjects(context):     \"\"\"     Returns a reference to the C{django_objects} on the context. If it doesn't     exist then it is created.      @rtype: Instance of L{DjangoReferenceCollection}     @since: 0.5     \"\"\"     c = context.extra     k = 'django_objects'      try:         return c[k]     except KeyError:         c[k] = DjangoReferenceCollection()      return c[k]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "current time in python django [SEP] def unique(list):     \"\"\" Returns a copy of the list without duplicates.     \"\"\"     unique = []; [unique.append(x) for x in list if x not in unique]     return unique", "target": 0, "target_options": ["no match", "match"]}
{"input": "python3 how to delete repeat from list [SEP] def unique(list):     \"\"\" Returns a copy of the list without duplicates.     \"\"\"     unique = []; [unique.append(x) for x in list if x not in unique]     return unique", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python3 how to delete repeat from list [SEP] def prt_js(js, sort_keys=True, indent=4):     \"\"\"Print Json in pretty format.     There's a standard module pprint, can pretty print python dict and list.     But it doesn't support sorted key. That why we need this func.      Usage::          >>> from weatherlab.lib.dataIO.js import prt_js         >>> prt_js({\"a\": 1, \"b\": 2})         {             \"a\": 1,             \"b\": 2         }      **中文文档**      以人类可读的方式打印可Json化的Python对象。     \"\"\"     print(js2str(js, sort_keys, indent))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python3 how to delete repeat from list [SEP] def remove_list_duplicates(lista, unique=False):     \"\"\"     Remove duplicated elements in a list.     Args:         lista: List with elements to clean duplicates.     \"\"\"     result = []     allready = []      for elem in lista:         if elem not in result:             result.append(elem)         else:             allready.append(elem)      if unique:         for elem in allready:             result = list(filter((elem).__ne__, result))      return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python3 how to delete repeat from list [SEP] def list2string (inlist,delimit=' '):     \"\"\" Converts a 1D list to a single long string for file output, using the string.join function.  Usage:   list2string (inlist,delimit=' ') Returns: the string created from inlist \"\"\"     stringlist = [makestr(_) for _ in inlist]     return string.join(stringlist,delimit)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python excel add values to column [SEP] def addValue(self, _, value):     \"\"\"Adds a value from the given source.\"\"\"     self.total += self._dataFormat.getValue(value)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python excel add values to column [SEP] def notin(arg, values):     \"\"\"     Like isin, but checks whether this expression's value(s) are not     contained in the passed values. See isin docs for full usage.     \"\"\"     op = ops.NotContains(arg, values)     return op.to_expr()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python excel add values to column [SEP] def unique(self, values):         \"\"\"Place each entry in a table, while asserting that each entry occurs once\"\"\"         _, count = self.count()         if not np.array_equiv(count, 1):             raise ValueError(\"Not every entry in the table is assigned a unique value\")         return self.sum(values)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python excel add values to column [SEP] def abspath(*path):     \"\"\"A method to determine absolute path for a given relative path to the     directory where this setup.py script is located\"\"\"     setup_dir = os.path.dirname(os.path.abspath(__file__))     return os.path.join(setup_dir, *path)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python split with any of multiple delimitrs [SEP] def make_regex(separator):     \"\"\"Utility function to create regexp for matching escaped separators     in strings.      \"\"\"     return re.compile(r'(?:' + re.escape(separator) + r')?((?:[^' +                       re.escape(separator) + r'\\\\]|\\\\.)+)')", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python split with any of multiple delimitrs [SEP] def strip_accents(text):     \"\"\"     Strip agents from a string.     \"\"\"      normalized_str = unicodedata.normalize('NFD', text)      return ''.join([         c for c in normalized_str if unicodedata.category(c) != 'Mn'])", "target": 0, "target_options": ["no match", "match"]}
{"input": "python split with any of multiple delimitrs [SEP] def split_on(s, sep=\" \"):     \"\"\"Split s by sep, unless it's inside a quote.\"\"\"     pattern = '''((?:[^%s\"']|\"[^\"]*\"|'[^']*')+)''' % sep      return [_strip_speechmarks(t) for t in re.split(pattern, s)[1::2]]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python split with any of multiple delimitrs [SEP] def inFocus(self):         \"\"\"Set GUI on-top flag\"\"\"         previous_flags = self.window.flags()         self.window.setFlags(previous_flags |                              QtCore.Qt.WindowStaysOnTopHint)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to revert a timestamp back to a string in python [SEP] def timestamp_to_datetime(cls, dt, dt_format=DATETIME_FORMAT):         \"\"\"Convert unix timestamp to human readable date/time string\"\"\"         return cls.convert_datetime(cls.get_datetime(dt), dt_format=dt_format)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to revert a timestamp back to a string in python [SEP] def is_iterable(value):     \"\"\"must be an iterable (list, array, tuple)\"\"\"     return isinstance(value, np.ndarray) or isinstance(value, list) or isinstance(value, tuple), value", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to revert a timestamp back to a string in python [SEP] def ms_to_datetime(ms):     \"\"\"     Converts a millisecond accuracy timestamp to a datetime     \"\"\"     dt = datetime.datetime.utcfromtimestamp(ms / 1000)     return dt.replace(microsecond=(ms % 1000) * 1000).replace(tzinfo=pytz.utc)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to revert a timestamp back to a string in python [SEP] def log_gen() -> Iterator[int]:     \"\"\"Logarithmic generator.     \"\"\"     y = 1     while True:         adder = max(1, math.pow(10, int(math.log10(y))))         yield int(y)         y = y + int(adder)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python run command and close it [SEP] def close( self ):         \"\"\"         Close the db and release memory         \"\"\"         if self.db is not None:             self.db.commit()             self.db.close()             self.db = None          return", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python run command and close it [SEP] def uniqued(iterable):     \"\"\"Return unique list of ``iterable`` items preserving order.      >>> uniqued('spameggs')     ['s', 'p', 'a', 'm', 'e', 'g']     \"\"\"     seen = set()     return [item for item in iterable if item not in seen and not seen.add(item)]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python run command and close it [SEP] def kill_mprocess(process):     \"\"\"kill process     Args:         process - Popen object for process     \"\"\"     if process and proc_alive(process):         process.terminate()         process.communicate()     return not proc_alive(process)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python run command and close it [SEP] def clean_with_zeros(self,x):         \"\"\" set nan and inf rows from x to zero\"\"\"         x[~np.any(np.isnan(x) | np.isinf(x),axis=1)] = 0         return x", "target": 0, "target_options": ["no match", "match"]}
{"input": "python add dictionary key to a list [SEP] def list2dict(lst):     \"\"\"Takes a list of (key,value) pairs and turns it into a dict.\"\"\"      dic = {}     for k,v in lst: dic[k] = v     return dic", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python add dictionary key to a list [SEP] def readTuple(self, line, n=3):         \"\"\" Reads a tuple of numbers. e.g. vertices, normals or teture coords.         \"\"\"         numbers = [num for num in line.split(' ') if num]         return [float(num) for num in numbers[1:n + 1]]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python add dictionary key to a list [SEP] def list_of_lists_to_dict(l):     \"\"\" Convert list of key,value lists to dict      [['id', 1], ['id', 2], ['id', 3], ['foo': 4]]     {'id': [1, 2, 3], 'foo': [4]}     \"\"\"     d = {}     for key, val in l:         d.setdefault(key, []).append(val)     return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python add dictionary key to a list [SEP] def list2string (inlist,delimit=' '):     \"\"\" Converts a 1D list to a single long string for file output, using the string.join function.  Usage:   list2string (inlist,delimit=' ') Returns: the string created from inlist \"\"\"     stringlist = [makestr(_) for _ in inlist]     return string.join(stringlist,delimit)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to keep calling a function forever in python [SEP] def main(idle):     \"\"\"Any normal python logic which runs a loop. Can take arguments.\"\"\"     while True:          LOG.debug(\"Sleeping for {0} seconds.\".format(idle))         time.sleep(idle)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to keep calling a function forever in python [SEP] def format(self):         \"\"\"         Return a well formatted list. Basicaly, it's sort a list and remove duplicate.          :return: A sorted, without duplicate, list.         :rtype: list         \"\"\"          try:             return sorted(list(set(self.main_list)), key=str.lower)          except TypeError:  # pragma: no cover             return self.main_list", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to keep calling a function forever in python [SEP] def seconds(num):     \"\"\"     Pause for this many seconds     \"\"\"     now = pytime.time()     end = now + num     until(end)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to keep calling a function forever in python [SEP] def _is_bit(obj):     \"\"\"Determine if obj is a bit\"\"\"     # If there is a bit type this could be replaced by isinstance.     if isinstance(obj, tuple) and len(obj) == 2:         if isinstance(obj[0], Register) and isinstance(obj[1], int) and obj[1] < len(obj[0]):             return True     return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "check type in list python [SEP] def isin(value, values):     \"\"\" Check that value is in values \"\"\"     for i, v in enumerate(value):         if v not in np.array(values)[:, i]:             return False     return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check type in list python [SEP] def parent_directory(self):         \"\"\"Change working directory to parent directory\"\"\"         self.chdir(os.path.join(getcwd_or_home(), os.path.pardir))", "target": 0, "target_options": ["no match", "match"]}
{"input": "check type in list python [SEP] def isin(elems, line):     \"\"\"Check if an element from a list is in a string.      :type elems: list     :type line: str      \"\"\"     found = False     for e in elems:         if e in line.lower():             found = True             break     return found", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check type in list python [SEP] def stylize(text, styles, reset=True):     \"\"\"conveniently styles your text as and resets ANSI codes at its end.\"\"\"     terminator = attr(\"reset\") if reset else \"\"     return \"{}{}{}\".format(\"\".join(styles), text, terminator)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to transform a list into a dictionary python [SEP] def list2dict(lst):     \"\"\"Takes a list of (key,value) pairs and turns it into a dict.\"\"\"      dic = {}     for k,v in lst: dic[k] = v     return dic", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to transform a list into a dictionary python [SEP] def _get_pretty_string(obj):     \"\"\"Return a prettier version of obj      Parameters     ----------     obj : object         Object to pretty print      Returns     -------     s : str         Pretty print object repr     \"\"\"     sio = StringIO()     pprint.pprint(obj, stream=sio)     return sio.getvalue()", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to transform a list into a dictionary python [SEP] def list_of_lists_to_dict(l):     \"\"\" Convert list of key,value lists to dict      [['id', 1], ['id', 2], ['id', 3], ['foo': 4]]     {'id': [1, 2, 3], 'foo': [4]}     \"\"\"     d = {}     for key, val in l:         d.setdefault(key, []).append(val)     return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to transform a list into a dictionary python [SEP] def string_to_int( s ):   \"\"\"Convert a string of bytes into an integer, as per X9.62.\"\"\"   result = 0   for c in s:     if not isinstance(c, int): c = ord( c )     result = 256 * result + c   return result", "target": 0, "target_options": ["no match", "match"]}
{"input": "python3 requests response text [SEP] async def json_or_text(response):     \"\"\"Turns response into a properly formatted json or text object\"\"\"     text = await response.text()     if response.headers['Content-Type'] == 'application/json; charset=utf-8':         return json.loads(text)     return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python3 requests response text [SEP] def get_memory_usage():     \"\"\"Gets RAM memory usage      :return: MB of memory used by this process     \"\"\"     process = psutil.Process(os.getpid())     mem = process.memory_info().rss     return mem / (1024 * 1024)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python3 requests response text [SEP] def url_read_text(url, verbose=True):     r\"\"\"     Directly reads text data from url     \"\"\"     data = url_read(url, verbose)     text = data.decode('utf8')     return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python3 requests response text [SEP] def frange(start, stop, step, precision):     \"\"\"A generator that will generate a range of floats.\"\"\"     value = start     while round(value, precision) < stop:         yield round(value, precision)         value += step", "target": 0, "target_options": ["no match", "match"]}
{"input": "subplots python show labelling [SEP] def finish_plot():     \"\"\"Helper for plotting.\"\"\"     plt.legend()     plt.grid(color='0.7')     plt.xlabel('x')     plt.ylabel('y')     plt.show()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "subplots python show labelling [SEP] def remove_falsy_values(counter: Mapping[Any, int]) -> Mapping[Any, int]:     \"\"\"Remove all values that are zero.\"\"\"     return {         label: count         for label, count in counter.items()         if count     }", "target": 0, "target_options": ["no match", "match"]}
{"input": "subplots python show labelling [SEP] def show(self, title=''):         \"\"\"         Display Bloch sphere and corresponding data sets.         \"\"\"         self.render(title=title)         if self.fig:             plt.show(self.fig)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "subplots python show labelling [SEP] def check_for_key(self, key, bucket_name=None):         \"\"\"         Checks if a key exists in a bucket          :param key: S3 key that will point to the file         :type key: str         :param bucket_name: Name of the bucket in which the file is stored         :type bucket_name: str         \"\"\"         if not bucket_name:             (bucket_name, key) = self.parse_s3_url(key)          try:             self.get_conn().head_object(Bucket=bucket_name, Key=key)             return True         except ClientError as e:             self.log.info(e.response[\"Error\"][\"Message\"])             return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "calclulate hash of a zip file python [SEP] def generate_hash(filepath):     \"\"\"Public function that reads a local file and generates a SHA256 hash digest for it\"\"\"     fr = FileReader(filepath)     data = fr.read_bin()     return _calculate_sha256(data)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "calclulate hash of a zip file python [SEP] def clean(s):   \"\"\"Removes trailing whitespace on each line.\"\"\"   lines = [l.rstrip() for l in s.split('\\n')]   return '\\n'.join(lines)", "target": 0, "target_options": ["no match", "match"]}
{"input": "calclulate hash of a zip file python [SEP] def acc_hash(filepath: str, hasher):     \"\"\"Accumulate content of file at `filepath` in `hasher`.\"\"\"     with open(filepath, 'rb') as f:         while True:             chunk = f.read(_BUF_SIZE)             if not chunk:                 break             hasher.update(chunk)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "calclulate hash of a zip file python [SEP] def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value", "target": 0, "target_options": ["no match", "match"]}
{"input": "turn string to list in python [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "turn string to list in python [SEP] def get_inputs_from_cm(index, cm):     \"\"\"Return indices of inputs to the node with the given index.\"\"\"     return tuple(i for i in range(cm.shape[0]) if cm[i][index])", "target": 0, "target_options": ["no match", "match"]}
{"input": "turn string to list in python [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "turn string to list in python [SEP] def i2b(self, pkt, x):         \"\"\"Convert internal value to internal value\"\"\"         if type(x) is str:           x = bytes([ ord(i) for i in x ])         return x", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to check if none is passed in python [SEP] def get_text_or_url(args):     \"\"\"Determine if we need text or url output\"\"\"     redirect_mode = args.bang or args.search or args.lucky     if redirect_mode or args.url:         return 'url'     else:         return 'text'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to check if none is passed in python [SEP] def int2str(num, radix=10, alphabet=BASE85):     \"\"\"helper function for quick base conversions from integers to strings\"\"\"     return NumConv(radix, alphabet).int2str(num)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to check if none is passed in python [SEP] def none_of(value, *args):     \"\"\" None of the items in value should match \"\"\"      if len(args):         value = (value,) + args      return ExpectationNone(value)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to check if none is passed in python [SEP] def transform(foci, mat):     \"\"\" Convert coordinates from one space to another using provided     transformation matrix. \"\"\"     t = linalg.pinv(mat)     foci = np.hstack((foci, np.ones((foci.shape[0], 1))))     return np.dot(foci, t)[:, 0:3]", "target": 0, "target_options": ["no match", "match"]}
{"input": "using ordereddict in python on empty dictionary [SEP] def stringify_dict_contents(dct):     \"\"\"Turn dict keys and values into native strings.\"\"\"     return {         str_if_nested_or_str(k): str_if_nested_or_str(v)         for k, v in dct.items()     }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "using ordereddict in python on empty dictionary [SEP] def __init__(self, baken_file=None):         \"\"\"Initialise a new `Bakens` object.\"\"\"         super(Bakens, self).__init__()         if baken_file:             self.import_locations(baken_file)", "target": 0, "target_options": ["no match", "match"]}
{"input": "using ordereddict in python on empty dictionary [SEP] def str_dict(some_dict):     \"\"\"Convert dict of ascii str/unicode to dict of str, if necessary\"\"\"     return {str(k): str(v) for k, v in some_dict.items()}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "using ordereddict in python on empty dictionary [SEP] def get_longest_orf(orfs):     \"\"\"Find longest ORF from the given list of ORFs.\"\"\"     sorted_orf = sorted(orfs, key=lambda x: len(x['sequence']), reverse=True)[0]     return sorted_orf", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to test if somethings type string in python [SEP] def isString(s):     \"\"\"Convenience method that works with all 2.x versions of Python     to determine whether or not something is stringlike.\"\"\"     try:         return isinstance(s, unicode) or isinstance(s, basestring)     except NameError:         return isinstance(s, str)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to test if somethings type string in python [SEP] def round_to_x_digits(number, digits):     \"\"\"     Returns 'number' rounded to 'digits' digits.     \"\"\"     return round(number * math.pow(10, digits)) / math.pow(10, digits)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to test if somethings type string in python [SEP] def is_string(obj):     \"\"\"Is this a string.      :param object obj:     :rtype: bool     \"\"\"     if PYTHON3:         str_type = (bytes, str)     else:         str_type = (bytes, str, unicode)     return isinstance(obj, str_type)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to test if somethings type string in python [SEP] def week_number(date):     \"\"\"     Return the Python week number of a date.     The django \\|date:\"W\" returns incompatible value     with the view implementation.     \"\"\"     week_number = date.strftime('%W')     if int(week_number) < 10:         week_number = week_number[-1]     return week_number", "target": 0, "target_options": ["no match", "match"]}
{"input": "python is the list is not empty [SEP] def _check_elements_equal(lst):     \"\"\"     Returns true if all of the elements in the list are equal.     \"\"\"     assert isinstance(lst, list), \"Input value must be a list.\"     return not lst or lst.count(lst[0]) == len(lst)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python is the list is not empty [SEP] def pairwise(iterable):     \"\"\"From itertools cookbook. [a, b, c, ...] -> (a, b), (b, c), ...\"\"\"     first, second = tee(iterable)     next(second, None)     return zip(first, second)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python is the list is not empty [SEP] def obj_in_list_always(target_list, obj):     \"\"\"     >>> l = [1,1,1]     >>> obj_in_list_always(l, 1)     True     >>> l.append(2)     >>> obj_in_list_always(l, 1)     False     \"\"\"     for item in set(target_list):         if item is not obj:             return False     return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python is the list is not empty [SEP] def write(self, writer):         \"\"\"         Writes an XML representation of this node (including descendants) to the specified file-like object.          :param writer: An :class:`XmlWriter` instance to write this node to         \"\"\"         multiline = bool(self._children)         newline_start = multiline and not bool(self.data)         writer.start(self.tagname, self.attrs, newline=newline_start)         if self.data:             writer.data(self.data, newline=bool(self._children))         for c in self._children:             c.write(writer)         writer.end(self.tagname, indent=multiline)", "target": 0, "target_options": ["no match", "match"]}
{"input": "read write in the same file python [SEP] def file_read(filename):     \"\"\"Read a file and close it.  Returns the file source.\"\"\"     fobj = open(filename,'r');     source = fobj.read();     fobj.close()     return source", "target": 1, "target_options": ["no_match", "match"]}
{"input": "read write in the same file python [SEP] def notify(self, msgtype, method, params):         \"\"\"Handle an incoming notify request.\"\"\"         self.dispatch.call(method, params)", "target": 0, "target_options": ["no match", "match"]}
{"input": "read write in the same file python [SEP] def data(fname):     \"\"\"Return the contents of a data file of ours.\"\"\"     data_file = open(data_filename(fname))     try:         return data_file.read()     finally:         data_file.close()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "read write in the same file python [SEP] def format_name(text):     \"\"\"Format a comic name.\"\"\"     name = unescape(text)     name = asciify(name.replace(u'&', u'And').replace(u'@', u'At'))     name = capfirst(name)     return name", "target": 0, "target_options": ["no match", "match"]}
{"input": "python monkeyptach database conenctiona nd results exmaples [SEP] def quote_names(db, names):     \"\"\"psycopg2 doesn't know how to quote identifier names, so we ask the server\"\"\"     c = db.cursor()     c.execute(\"SELECT pg_catalog.quote_ident(n) FROM pg_catalog.unnest(%s::text[]) n\", [list(names)])     return [name for (name,) in c]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python monkeyptach database conenctiona nd results exmaples [SEP] def timestamp_to_datetime(timestamp):     \"\"\"Convert an ARF timestamp to a datetime.datetime object (naive local time)\"\"\"     from datetime import datetime, timedelta     obj = datetime.fromtimestamp(timestamp[0])     return obj + timedelta(microseconds=int(timestamp[1]))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python monkeyptach database conenctiona nd results exmaples [SEP] def __init__(self, db):         \"\"\"         Connect to the Salesforce API.         \"\"\"         self.db = db         self.query = None         self.session = db.sf_session         self.rowcount = None         self.first_row = None         self.lastrowid = None  # not moved to driver because INSERT is implemented here         self.cursor = self.db.connection.cursor()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python monkeyptach database conenctiona nd results exmaples [SEP] def configure(logger=None):     \"\"\"Pass stump a logger to use. If no logger is supplied, a basic logger     of level INFO will print to stdout.      \"\"\"     global LOGGER     if logger is None:         LOGGER = logging.basicConfig(stream=sys.stdout, level=logging.INFO)     else:         LOGGER = logger", "target": 0, "target_options": ["no match", "match"]}
{"input": "python check whether a day is friday [SEP] def is_third_friday(day=None):     \"\"\" check if day is month's 3rd friday \"\"\"     day = day if day is not None else datetime.datetime.now()     defacto_friday = (day.weekday() == 4) or (         day.weekday() == 3 and day.hour() >= 17)     return defacto_friday and 14 < day.day < 22", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python check whether a day is friday [SEP] def datetime64_to_datetime(dt):     \"\"\" convert numpy's datetime64 to datetime \"\"\"     dt64 = np.datetime64(dt)     ts = (dt64 - np.datetime64('1970-01-01T00:00:00')) / np.timedelta64(1, 's')     return datetime.datetime.utcfromtimestamp(ts)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python check whether a day is friday [SEP] def isworkday(self, date):         \"\"\"         Check if a given date is a work date, ignoring holidays.          Args:             date (date, datetime or str): Date to be checked.          Returns:             bool: True if the date is a work date, False otherwise.         \"\"\"         date = parsefun(date)         return self.weekdaymap[date.weekday()].isworkday", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python check whether a day is friday [SEP] def printdict(adict):     \"\"\"printdict\"\"\"     dlist = list(adict.keys())     dlist.sort()     for i in range(0, len(dlist)):         print(dlist[i], adict[dlist[i]])", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to prase the response json [SEP] def response_to_json_dict(response, **kwargs):     \"\"\"     Standard place to convert responses to JSON.      :param response: requests response object     :param **kwargs: arguments accepted by json.loads      :returns: dict of JSON response     \"\"\"     if response.encoding is None:         response.encoding = 'utf-8'     return json.loads(response.text, **kwargs)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to prase the response json [SEP] def __contains__(self, key):         \"\"\"         Invoked when determining whether a specific key is in the dictionary         using `key in d`.          The key is looked up case-insensitively.         \"\"\"         k = self._real_key(key)         return k in self._data", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to prase the response json [SEP] def prt_js(js, sort_keys=True, indent=4):     \"\"\"Print Json in pretty format.     There's a standard module pprint, can pretty print python dict and list.     But it doesn't support sorted key. That why we need this func.      Usage::          >>> from weatherlab.lib.dataIO.js import prt_js         >>> prt_js({\"a\": 1, \"b\": 2})         {             \"a\": 1,             \"b\": 2         }      **中文文档**      以人类可读的方式打印可Json化的Python对象。     \"\"\"     print(js2str(js, sort_keys, indent))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to prase the response json [SEP] def round_to_x_digits(number, digits):     \"\"\"     Returns 'number' rounded to 'digits' digits.     \"\"\"     return round(number * math.pow(10, digits)) / math.pow(10, digits)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python cycle through elements in list [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python cycle through elements in list [SEP] def is_agent_listening(self, host, port):         \"\"\"         Check if the Instana Agent is listening on <host> and <port>.         \"\"\"         try:             rv = False             url = \"http://%s:%s/\" % (host, port)             response = self.client.get(url, timeout=0.8)              server_header = response.headers[\"Server\"]             if server_header == AGENT_HEADER:                 logger.debug(\"Host agent found on %s:%d\" % (host, port))                 rv = True             else:                 logger.debug(\"...something is listening on %s:%d but it's not the Instana Agent: %s\"                              % (host, port, server_header))         except (requests.ConnectTimeout, requests.ConnectionError):             logger.debug(\"No host agent listening on %s:%d\" % (host, port))             rv = False         finally:             return rv", "target": 0, "target_options": ["no match", "match"]}
{"input": "python cycle through elements in list [SEP] def flatten_list(x: List[Any]) -> List[Any]:     \"\"\"     Converts a list of lists into a flat list.          Args:         x: list of lists       Returns:         flat list              As per     http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python      \"\"\"  # noqa     return [item for sublist in x for item in sublist]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python cycle through elements in list [SEP] def data(fname):     \"\"\"Return the contents of a data file of ours.\"\"\"     data_file = open(data_filename(fname))     try:         return data_file.read()     finally:         data_file.close()", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to remove ! in a string python [SEP] def strip_codes(s: Any) -> str:     \"\"\" Strip all color codes from a string.         Returns empty string for \"falsey\" inputs.     \"\"\"     return codepat.sub('', str(s) if (s or (s == 0)) else '')", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to remove ! in a string python [SEP] def logger(message, level=10):     \"\"\"Handle logging.\"\"\"     logging.getLogger(__name__).log(level, str(message))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to remove ! in a string python [SEP] def strip_accents(text):     \"\"\"     Strip agents from a string.     \"\"\"      normalized_str = unicodedata.normalize('NFD', text)      return ''.join([         c for c in normalized_str if unicodedata.category(c) != 'Mn'])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to remove ! in a string python [SEP] def digit(m: Union[int, pd.Series], n: int) -> Union[int, pd.Series]:         \"\"\"Returns the nth digit of each number in m.\"\"\"         return (m // (10 ** n)) % 10", "target": 0, "target_options": ["no match", "match"]}
{"input": "python loop until and do nothing [SEP] def stop(self) -> None:         \"\"\"Stops the analysis as soon as possible.\"\"\"         if self._stop and not self._posted_kork:             self._stop()             self._stop = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python loop until and do nothing [SEP] def sing(a, b, c=False, name='yetone'):     \"\"\"sing a song     hehe      :param a: I'm a     :param b: I'm b     :param c: I'm c     :param name: I'm name     \"\"\"     print('test0.sing: <a: {}, b: {}, c: {}> by {}'.format(a, b, c, name))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python loop until and do nothing [SEP] def wait_until_exit(self):         \"\"\" Wait until thread exit              Used for testing purpose only         \"\"\"          if self._timeout is None:             raise Exception(\"Thread will never exit. Use stop or specify timeout when starting it!\")          self._thread.join()         self.stop()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python loop until and do nothing [SEP] def make_regex(separator):     \"\"\"Utility function to create regexp for matching escaped separators     in strings.      \"\"\"     return re.compile(r'(?:' + re.escape(separator) + r')?((?:[^' +                       re.escape(separator) + r'\\\\]|\\\\.)+)')", "target": 0, "target_options": ["no match", "match"]}
{"input": "python epub to text [SEP] def html_to_text(content):     \"\"\" Converts html content to plain text \"\"\"     text = None     h2t = html2text.HTML2Text()     h2t.ignore_links = False     text = h2t.handle(content)     return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python epub to text [SEP] def as_dictionary(self):         \"\"\"         Convert this object to a dictionary with formatting appropriate for a PIF.          :returns: Dictionary with the content of this object formatted for a PIF.         \"\"\"         return {to_camel_case(i): Serializable._convert_to_dictionary(self.__dict__[i])                 for i in self.__dict__ if self.__dict__[i] is not None}", "target": 0, "target_options": ["no match", "match"]}
{"input": "python epub to text [SEP] def is_published(self):         \"\"\"stub\"\"\"         if 'published' not in self.my_osid_object._my_map:             return False         return bool(self.my_osid_object._my_map['published'])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python epub to text [SEP] def dims_intersect(self):         \"\"\"Dimensions of the arrays in this list that are used in all arrays         \"\"\"         return set.intersection(*map(             set, (getattr(arr, 'dims_intersect', arr.dims) for arr in self)))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python scrape table from website multiple tables [SEP] def find_table_links(self):         \"\"\"         When given a url, this function will find all the available table names         for that EPA dataset.         \"\"\"         html = urlopen(self.model_url).read()         doc = lh.fromstring(html)         href_list = [area.attrib['href'] for area in doc.cssselect('map area')]         tables = self._inception_table_links(href_list)         return tables", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python scrape table from website multiple tables [SEP] def finish_plot():     \"\"\"Helper for plotting.\"\"\"     plt.legend()     plt.grid(color='0.7')     plt.xlabel('x')     plt.ylabel('y')     plt.show()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python scrape table from website multiple tables [SEP] def html(header_rows):     \"\"\"     Convert a list of tuples describing a table into a HTML string     \"\"\"     name = 'table%d' % next(tablecounter)     return HtmlTable([map(str, row) for row in header_rows], name).render()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python scrape table from website multiple tables [SEP] def calculate_bounding_box(data):     \"\"\"     Returns a 2 x m array indicating the min and max along each     dimension.     \"\"\"     mins = data.min(0)     maxes = data.max(0)     return mins, maxes", "target": 0, "target_options": ["no match", "match"]}
{"input": "calculating the accuracy of a variable inside for loops python [SEP] def token_accuracy(labels, outputs):   \"\"\"Compute tokenwise (elementwise) accuracy.    Args:     labels: ground-truth labels, shape=(batch, seq_length)     outputs: predicted tokens, shape=(batch, seq_length)   Returns:     Two ops, one for getting the current average accuracy and another for     updating the running average estimate.   \"\"\"   weights = tf.to_float(tf.not_equal(labels, 0))   return tf.metrics.accuracy(labels, outputs, weights=weights)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "calculating the accuracy of a variable inside for loops python [SEP] def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value", "target": 0, "target_options": ["no match", "match"]}
{"input": "calculating the accuracy of a variable inside for loops python [SEP] def local_accuracy(X_train, y_train, X_test, y_test, attr_test, model_generator, metric, trained_model):     \"\"\" The how well do the features plus a constant base rate sum up to the model output.     \"\"\"      X_train, X_test = to_array(X_train, X_test)      # how many features to mask     assert X_train.shape[1] == X_test.shape[1]      # keep nkeep top features and re-train the model for each test explanation     yp_test = trained_model.predict(X_test)      return metric(yp_test, strip_list(attr_test).sum(1))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "calculating the accuracy of a variable inside for loops python [SEP] def _one_exists(input_files):     \"\"\"     at least one file must exist for multiqc to run properly     \"\"\"     for f in input_files:         if os.path.exists(f):             return True     return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to tell if an int is base 2 [SEP] def _find_base_type(data_type):     \"\"\"Find the Nani's base type for a given data type.      This is useful when Nani's data types were subclassed and the original type     is required.     \"\"\"     bases = type(data_type).__mro__     for base in bases:         if base in _ALL:             return base      return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to tell if an int is base 2 [SEP] def _remove_invalid_char(s):     \"\"\"Remove invalid and dangerous characters from a string.\"\"\"      s = ''.join([i if ord(i) >= 32 and ord(i) < 127 else '' for i in s])     s = s.translate(dict.fromkeys(map(ord, \"_%~#\\\\{}\\\":\")))     return s", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to tell if an int is base 2 [SEP] def _is_bit(obj):     \"\"\"Determine if obj is a bit\"\"\"     # If there is a bit type this could be replaced by isinstance.     if isinstance(obj, tuple) and len(obj) == 2:         if isinstance(obj[0], Register) and isinstance(obj[1], int) and obj[1] < len(obj[0]):             return True     return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to tell if an int is base 2 [SEP] def classnameify(s):   \"\"\"   Makes a classname   \"\"\"   return ''.join(w if w in ACRONYMS else w.title() for w in s.split('_'))", "target": 0, "target_options": ["no match", "match"]}
{"input": "index f a list in python starts with 0 or 1 [SEP] def find_index(array, x):     \"\"\"     Locate the leftmost value exactly equal to x.      :type array: list     :param array: an iterable object that support inex      :param x: a comparable value      **中文文档**      返回第一个值等于x的元素的索引。     \"\"\"     i = bisect.bisect_left(array, x)     if i != len(array) and array[i] == x:         return i     raise ValueError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "index f a list in python starts with 0 or 1 [SEP] def unique(self, values):         \"\"\"Place each entry in a table, while asserting that each entry occurs once\"\"\"         _, count = self.count()         if not np.array_equiv(count, 1):             raise ValueError(\"Not every entry in the table is assigned a unique value\")         return self.sum(values)", "target": 0, "target_options": ["no match", "match"]}
{"input": "index f a list in python starts with 0 or 1 [SEP] def isin(value, values):     \"\"\" Check that value is in values \"\"\"     for i, v in enumerate(value):         if v not in np.array(values)[:, i]:             return False     return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "index f a list in python starts with 0 or 1 [SEP] def dot_product(self, other):         \"\"\" Return the dot product of the given vectors. \"\"\"         return self.x * other.x + self.y * other.y", "target": 0, "target_options": ["no match", "match"]}
{"input": "clear a variable in python [SEP] def apply_mana_drain(self):         \"\"\"Clear current mana values.\"\"\"         self.r = self.g = self.b = self.y = 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "clear a variable in python [SEP] def trimmed_split(s, seps=(\";\", \",\")):     \"\"\"Given a string s, split is by one of one of the seps.\"\"\"     for sep in seps:         if sep not in s:             continue         data = [item.strip() for item in s.strip().split(sep)]         return data     return [s]", "target": 0, "target_options": ["no match", "match"]}
{"input": "clear a variable in python [SEP] def forget_coords(self):         \"\"\"Forget all loaded coordinates.\"\"\"         self.w.ntotal.set_text('0')         self.coords_dict.clear()         self.redo()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "clear a variable in python [SEP] def classnameify(s):   \"\"\"   Makes a classname   \"\"\"   return ''.join(w if w in ACRONYMS else w.title() for w in s.split('_'))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python using a list as an iterator [SEP] def __iter__(self):     \"\"\"Return all elements from the list.\"\"\"     for index in range(0, self._size):       try:         yield self._list[(self._index + index) % self._size]       except IndexError:         pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python using a list as an iterator [SEP] def ziptake(items_list, indexes_list):     \"\"\"     SeeAlso:         vt.ziptake     \"\"\"     return [take(list_, index_list)             for list_, index_list in zip(items_list, indexes_list)]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python using a list as an iterator [SEP] def _generate_instances(self):         \"\"\"         ListNode item generator. Will be used internally by __iter__ and __getitem__          Yields:             ListNode items (instances)         \"\"\"         for node in self.node_stack:             yield node         while self._data:             yield self._make_instance(self._data.pop(0))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python using a list as an iterator [SEP] def one_over_x_like(x):     \"\"\"     returns -np.Inf if x<0, -np.log(x) otherwise.     \"\"\"     if np.any(x < 0):         return -np.Inf     else:         return -np.sum(np.log(x))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to pass a path to a file in python [SEP] def get_file_string(filepath):     \"\"\"Get string from file.\"\"\"     with open(os.path.abspath(filepath)) as f:         return f.read()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to pass a path to a file in python [SEP] def extent(self):          \"\"\"         return range of 2D data         \"\"\"          return [min(self.x), max(self.x), min(self.y), max(self.y)]", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to pass a path to a file in python [SEP] def read(*p):     \"\"\"Build a file path from paths and return the contents.\"\"\"     with open(os.path.join(*p), 'r') as fi:         return fi.read()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to pass a path to a file in python [SEP] def lint_file(in_file, out_file=None):     \"\"\"Helps remove extraneous whitespace from the lines of a file      :param file in_file: A readable file or file-like     :param file out_file: A writable file or file-like     \"\"\"     for line in in_file:         print(line.strip(), file=out_file)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python build tree by subelment [SEP] def WalkChildren(elem): \t\"\"\" \tWalk the XML tree of children below elem, returning each in order. \t\"\"\" \tfor child in elem.childNodes: \t\tyield child \t\tfor elem in WalkChildren(child): \t\t\tyield elem", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python build tree by subelment [SEP] def im2mat(I):     \"\"\"Converts and image to matrix (one pixel per line)\"\"\"     return I.reshape((I.shape[0] * I.shape[1], I.shape[2]))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python build tree by subelment [SEP] def parse_station_table(root):     \"\"\"Parse station list XML file.\"\"\"     stations = [parse_xml_station(elem) for elem in root.findall('station')]     return {st.id: st for st in stations}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python build tree by subelment [SEP] def _factln(num):     # type: (int) -> float     \"\"\"     Computes logfactorial regularly for tractable numbers, uses Ramanujans approximation otherwise.     \"\"\"      if num < 20:         log_factorial = log(factorial(num))     else:         log_factorial = num * log(num) - num + log(num * (1 + 4 * num * (             1 + 2 * num))) / 6.0 + log(pi) / 2      return log_factorial", "target": 0, "target_options": ["no match", "match"]}
{"input": "python 3 str to utf8 [SEP] def safe_unicode(string):     \"\"\"If Python 2, replace non-ascii characters and return encoded string.\"\"\"     if not PY3:         uni = string.replace(u'\\u2019', \"'\")         return uni.encode('utf-8')              return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python 3 str to utf8 [SEP] def skip_connection_distance(a, b):     \"\"\"The distance between two skip-connections.\"\"\"     if a[2] != b[2]:         return 1.0     len_a = abs(a[1] - a[0])     len_b = abs(b[1] - b[0])     return (abs(a[0] - b[0]) + abs(len_a - len_b)) / (max(a[0], b[0]) + max(len_a, len_b))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python 3 str to utf8 [SEP] def utf8(value):     \"\"\"Converts a string argument to a byte string.      If the argument is already a byte string or None, it is returned unchanged.     Otherwise it must be a unicode string and is encoded as utf8.     \"\"\"     if isinstance(value, _UTF8_TYPES):         return value     assert isinstance(value, unicode)     return value.encode(\"utf-8\")", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python 3 str to utf8 [SEP] def week_number(date):     \"\"\"     Return the Python week number of a date.     The django \\|date:\"W\" returns incompatible value     with the view implementation.     \"\"\"     week_number = date.strftime('%W')     if int(week_number) < 10:         week_number = week_number[-1]     return week_number", "target": 0, "target_options": ["no match", "match"]}
{"input": "python apply custom convolutional filters [SEP] def DynamicConvFilter(inputs, filters, out_channel,                       kernel_shape,                       stride=1,                       padding='SAME'):     \"\"\" see \"Dynamic Filter Networks\" (NIPS 2016)         by Bert De Brabandere*, Xu Jia*, Tinne Tuytelaars and Luc Van Gool      Remarks:         This is the convolution version of a dynamic filter.      Args:         inputs : unfiltered input [b, h, w, 1] only grayscale images.         filters : learned filters of [b, k, k, 1] (dynamically generated by the network).         out_channel (int): number of output channel.         kernel_shape: (h, w) tuple or a int.         stride: (h, w) tuple or a int.         padding (str): 'valid' or 'same'. Case insensitive.      Returns         tf.Tensor named ``output``.     \"\"\"      # tf.unstack only works with known batch_size :-(     batch_size, h, w, in_channel = inputs.get_shape().as_list()     stride = shape4d(stride)      inputs = tf.unstack(inputs)     filters = tf.reshape(filters, [batch_size] + shape2d(kernel_shape) + [in_channel, out_channel])     filters = tf.unstack(filters)      # this is ok as TF uses the cuda stream context     rsl = [tf.nn.conv2d(tf.reshape(d, [1, h, w, in_channel]),                         tf.reshape(k, [kernel_shape, kernel_shape, in_channel, out_channel]),                         stride, padding=\"SAME\") for d, k in zip(inputs, filters)]     rsl = tf.concat(rsl, axis=0, name='output')     return rsl", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python apply custom convolutional filters [SEP] def bitsToString(arr):   \"\"\"Returns a string representing a numpy array of 0's and 1's\"\"\"   s = array('c','.'*len(arr))   for i in xrange(len(arr)):     if arr[i] == 1:       s[i]='*'   return s", "target": 0, "target_options": ["no match", "match"]}
{"input": "python apply custom convolutional filters [SEP] def lowpass(data,filterSize=None):     \"\"\"     minimal complexity low-pass filtering.     Filter size is how \"wide\" the filter will be.     Sigma will be 1/10 of this filter width.     If filter size isn't given, it will be 1/10 of the data size.     \"\"\"     if filterSize is None:         filterSize=len(data)/10     kernel=kernel_gaussian(size=filterSize)     data=convolve(data,kernel) # do the convolution with padded edges     return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python apply custom convolutional filters [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to make consecutive numbers python [SEP] def _numbers_units(N):     \"\"\"     >>> _numbers_units(45)     '123456789012345678901234567890123456789012345'     \"\"\"     lst = range(1, N + 1)     return \"\".join(list(map(lambda i: str(i % 10), lst)))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to make consecutive numbers python [SEP] def isworkday(self, date):         \"\"\"         Check if a given date is a work date, ignoring holidays.          Args:             date (date, datetime or str): Date to be checked.          Returns:             bool: True if the date is a work date, False otherwise.         \"\"\"         date = parsefun(date)         return self.weekdaymap[date.weekday()].isworkday", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to make consecutive numbers python [SEP] def digit(m: Union[int, pd.Series], n: int) -> Union[int, pd.Series]:         \"\"\"Returns the nth digit of each number in m.\"\"\"         return (m // (10 ** n)) % 10", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to make consecutive numbers python [SEP] def to_dataframe(products):         \"\"\"Return the products from a query response as a Pandas DataFrame         with the values in their appropriate Python types.         \"\"\"         try:             import pandas as pd         except ImportError:             raise ImportError(\"to_dataframe requires the optional dependency Pandas.\")          return pd.DataFrame.from_dict(products, orient='index')", "target": 0, "target_options": ["no match", "match"]}
{"input": "python send method as a variable [SEP] def _apply_list(self, methods):     \"\"\"Return a single callable that applies a list of methods to a value.      If a method returns None, the last value is kept; if it returns     some other value, that replaces the last value.  Exceptions are     not caught.     \"\"\"     def call(value):       for method in methods:         newvalue = method(self, value)         if newvalue is not None:           value = newvalue       return value     return call", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python send method as a variable [SEP] def smooth_array(array, amount=1):     \"\"\"      Returns the nearest-neighbor (+/- amount) smoothed array.     This does not modify the array or slice off the funny end points.      \"\"\"     if amount==0: return array      # we have to store the old values in a temp array to keep the     # smoothing from affecting the smoothing     new_array = _n.array(array)      for n in range(len(array)):         new_array[n] = smooth(array, n, amount)      return new_array", "target": 0, "target_options": ["no match", "match"]}
{"input": "python send method as a variable [SEP] def executeMethod(self, methodName, args):     \"\"\"Executes a method named ``methodName`` with the specified arguments.      This method is called when the user executes a command as defined in     the node spec. It provides a perfectly reasonble implementation     of the command mechanism. As a sub-class developer you just need to     implement a method for each command in the node spec. Note that due to     the command mechanism only unnamed argument are supported.      :param methodName: (string) the name of the method that correspond to a            command in the spec.     :param args: (list) of arguments that will be passed to the method     \"\"\"     if not hasattr(self, methodName):       raise Exception('Missing command method: ' + methodName)      m = getattr(self, methodName)     if not hasattr(m, '__call__'):       raise Exception('Command: ' + methodName + ' must be callable')      return m(*args)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python send method as a variable [SEP] def none_of(value, *args):     \"\"\" None of the items in value should match \"\"\"      if len(args):         value = (value,) + args      return ExpectationNone(value)", "target": 0, "target_options": ["no match", "match"]}
{"input": "extract value from a list of tuples python [SEP] def compose_all(tups):   \"\"\"Compose all given tuples together.\"\"\"   from . import ast  # I weep for humanity   return functools.reduce(lambda x, y: x.compose(y), map(ast.make_tuple, tups), ast.make_tuple({}))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "extract value from a list of tuples python [SEP] def dictify(a_named_tuple):     \"\"\"Transform a named tuple into a dictionary\"\"\"     return dict((s, getattr(a_named_tuple, s)) for s in a_named_tuple._fields)", "target": 0, "target_options": ["no match", "match"]}
{"input": "extract value from a list of tuples python [SEP] def readTuple(self, line, n=3):         \"\"\" Reads a tuple of numbers. e.g. vertices, normals or teture coords.         \"\"\"         numbers = [num for num in line.split(' ') if num]         return [float(num) for num in numbers[1:n + 1]]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "extract value from a list of tuples python [SEP] def _import_string(names):     \"\"\"return a list of (name, asname) formatted as a string\"\"\"     _names = []     for name, asname in names:         if asname is not None:             _names.append(\"%s as %s\" % (name, asname))         else:             _names.append(name)     return \", \".join(_names)", "target": 0, "target_options": ["no match", "match"]}
{"input": "multiple returns function python print with spaces [SEP] def indented_show(text, howmany=1):         \"\"\"Print a formatted indented text.         \"\"\"         print(StrTemplate.pad_indent(text=text, howmany=howmany))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "multiple returns function python print with spaces [SEP] def _remove_dict_keys_with_value(dict_, val):   \"\"\"Removes `dict` keys which have have `self` as value.\"\"\"   return {k: v for k, v in dict_.items() if v is not val}", "target": 0, "target_options": ["no match", "match"]}
{"input": "multiple returns function python print with spaces [SEP] def print_with_header(header, message, color, indent=0):     \"\"\"     Use one of the functions below for printing, not this one.     \"\"\"     print()     padding = ' ' * indent     print(padding + color + BOLD + header + ENDC + color + message + ENDC)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "multiple returns function python print with spaces [SEP] def set(self, mutagen_file, value):         \"\"\"Assign the value for the field using this style.         \"\"\"         self.store(mutagen_file, self.serialize(value))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python creating an array of fixed size [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python creating an array of fixed size [SEP] def fit(self, X):         \"\"\" Apply KMeans Clustering               X: dataset with feature vectors         \"\"\"         self.centers_, self.labels_, self.sse_arr_, self.n_iter_ = \\               _kmeans(X, self.n_clusters, self.max_iter, self.n_trials, self.tol)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python creating an array of fixed size [SEP] def chunks(items, size):     \"\"\" Split list into chunks of the given size.     Original order is preserved.      Example:         > chunks([1,2,3,4,5,6,7,8], 3)         [[1, 2, 3], [4, 5, 6], [7, 8]]     \"\"\"     return [items[i:i+size] for i in range(0, len(items), size)]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python creating an array of fixed size [SEP] def str2int(string_with_int):     \"\"\" Collect digits from a string \"\"\"     return int(\"\".join([char for char in string_with_int if char in string.digits]) or 0)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python remove last 3 elements from list [SEP] def indicate_last(items):     \"\"\"     iterate through list and indicate which item is the last, intended to     assist tree displays of hierarchical content.      :return: yielding (<bool>, <item>) where bool is True only on last entry     :rtype: generator     \"\"\"     last_index = len(items) - 1     for (i, item) in enumerate(items):         yield (i == last_index, item)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python remove last 3 elements from list [SEP] def unpunctuate(s, *, char_blacklist=string.punctuation):     \"\"\" Remove punctuation from string s. \"\"\"     # remove punctuation     s = \"\".join(c for c in s if c not in char_blacklist)     # remove consecutive spaces     return \" \".join(filter(None, s.split(\" \")))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python remove last 3 elements from list [SEP] def get_last(self, table=None):         \"\"\"Just the last entry.\"\"\"         if table is None: table = self.main_table         query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table         return self.own_cursor.execute(query).fetchone()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python remove last 3 elements from list [SEP] def clean_strings(iterable):     \"\"\"     Take a list of strings and clear whitespace      on each one. If a value in the list is not a      string pass it through untouched.      Args:         iterable: mixed list      Returns:          mixed list     \"\"\"     retval = []     for val in iterable:         try:             retval.append(val.strip())         except(AttributeError):             retval.append(val)     return retval", "target": 0, "target_options": ["no match", "match"]}
{"input": "call python constructor from different file [SEP] def __init__(self, baken_file=None):         \"\"\"Initialise a new `Bakens` object.\"\"\"         super(Bakens, self).__init__()         if baken_file:             self.import_locations(baken_file)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "call python constructor from different file [SEP] def searchlast(self,n=10):         \"\"\"Return the last n results (or possibly less if not found). Note that the last results are not necessarily the best ones! Depending on the search type.\"\"\"                     solutions = deque([], n)         for solution in self:             solutions.append(solution)         return solutions", "target": 0, "target_options": ["no match", "match"]}
{"input": "call python constructor from different file [SEP] def __init__(self, args, loop):         \"\"\"Initialize a new instance of GlobalCommands.\"\"\"         self.args = args         self.loop = loop", "target": 1, "target_options": ["no_match", "match"]}
{"input": "call python constructor from different file [SEP] def insert(self, index, item):         \"\"\"Insert an item at the specified index.          Args:             index (int): Position to insert the item.             item: Item to be inserted.          Raises:             :exc:`~.exceptions.WrongListItemType`: If an item has a different                 type than the first item to be stored.          \"\"\"         if not self:             list.append(self, item)         elif item.__class__ == self[0].__class__:             list.insert(self, index, item)         else:             raise exceptions.WrongListItemType(item.__class__.__name__,                                                self[0].__class__.__name__)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python string split nonwhitespace [SEP] def strip_spaces(s):     \"\"\" Strip excess spaces from a string \"\"\"     return u\" \".join([c for c in s.split(u' ') if c])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python string split nonwhitespace [SEP] def get_case_insensitive_dict_key(d: Dict, k: str) -> Optional[str]:     \"\"\"     Within the dictionary ``d``, find a key that matches (in case-insensitive     fashion) the key ``k``, and return it (or ``None`` if there isn't one).     \"\"\"     for key in d.keys():         if k.lower() == key.lower():             return key     return None", "target": 0, "target_options": ["no match", "match"]}
{"input": "python string split nonwhitespace [SEP] def split_on(s, sep=\" \"):     \"\"\"Split s by sep, unless it's inside a quote.\"\"\"     pattern = '''((?:[^%s\"']|\"[^\"]*\"|'[^']*')+)''' % sep      return [_strip_speechmarks(t) for t in re.split(pattern, s)[1::2]]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python string split nonwhitespace [SEP] def prt_js(js, sort_keys=True, indent=4):     \"\"\"Print Json in pretty format.     There's a standard module pprint, can pretty print python dict and list.     But it doesn't support sorted key. That why we need this func.      Usage::          >>> from weatherlab.lib.dataIO.js import prt_js         >>> prt_js({\"a\": 1, \"b\": 2})         {             \"a\": 1,             \"b\": 2         }      **中文文档**      以人类可读的方式打印可Json化的Python对象。     \"\"\"     print(js2str(js, sort_keys, indent))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python file replace suffix [SEP] def add_suffix(fullname, suffix):     \"\"\" Add suffix to a full file name\"\"\"     name, ext = os.path.splitext(fullname)     return name + '_' + suffix + ext", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python file replace suffix [SEP] def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:     \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"     for line in file_like:         line = line.rstrip('\\r\\n')         if line:             yield line", "target": 0, "target_options": ["no match", "match"]}
{"input": "python file replace suffix [SEP] def add_suffix(filename, suffix):         \"\"\"         ADD suffix TO THE filename (NOT INCLUDING THE FILE EXTENSION)         \"\"\"         path = filename.split(\"/\")         parts = path[-1].split(\".\")         i = max(len(parts) - 2, 0)         parts[i] = parts[i] + suffix         path[-1] = \".\".join(parts)         return \"/\".join(path)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python file replace suffix [SEP] def list2dict(lst):     \"\"\"Takes a list of (key,value) pairs and turns it into a dict.\"\"\"      dic = {}     for k,v in lst: dic[k] = v     return dic", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to print a loop in one line in python [SEP] def main():     \"\"\"Ideally we shouldn't lose the first second of events\"\"\"     time.sleep(1)     with Input() as input_generator:         for e in input_generator:             print(repr(e))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to print a loop in one line in python [SEP] def html_to_text(content):     \"\"\" Converts html content to plain text \"\"\"     text = None     h2t = html2text.HTML2Text()     h2t.ignore_links = False     text = h2t.handle(content)     return text", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to print a loop in one line in python [SEP] def __call__(self, _):         \"\"\"Print the current iteration.\"\"\"         if self.iter % self.step == 0:             print(self.fmt.format(self.iter), **self.kwargs)          self.iter += 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to print a loop in one line in python [SEP] def Join(self):     \"\"\"Waits until all outstanding tasks are completed.\"\"\"      for _ in range(self.JOIN_TIMEOUT_DECISECONDS):       if self._queue.empty() and not self.busy_threads:         return       time.sleep(0.1)      raise ValueError(\"Timeout during Join() for threadpool %s.\" % self.name)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python load data into array [SEP] def convert_array(array):     \"\"\"     Converts an ARRAY string stored in the database back into a Numpy array.      Parameters     ----------     array: ARRAY         The array object to be converted back into a Numpy array.      Returns     -------     array             The converted Numpy array.      \"\"\"     out = io.BytesIO(array)     out.seek(0)     return np.load(out)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python load data into array [SEP] def get_list_index(lst, index_or_name):     \"\"\"     Return the index of an element in the list.      Args:         lst (list): The list.         index_or_name (int or str): The value of the reference element, or directly its numeric index.      Returns:         (int) The index of the element in the list.     \"\"\"     if isinstance(index_or_name, six.integer_types):         return index_or_name      return lst.index(index_or_name)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python load data into array [SEP] def C_dict2array(C):     \"\"\"Convert an OrderedDict containing C values to a 1D array.\"\"\"     return np.hstack([np.asarray(C[k]).ravel() for k in C_keys])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python load data into array [SEP] def tt_comp(self, sampled_topics):          \"\"\"         Compute term-topic matrix from sampled_topics.         \"\"\"          samples = sampled_topics.shape[0]         tt = np.zeros((self.V, self.K, samples))          for s in range(samples):                         tt[:, :, s] = \\                 samplers_lda.tt_comp(self.tokens, sampled_topics[s, :],                                      self.N, self.V, self.K, self.beta)          return tt", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to change negetive values to zero for a particular column in python [SEP] def clean_with_zeros(self,x):         \"\"\" set nan and inf rows from x to zero\"\"\"         x[~np.any(np.isnan(x) | np.isinf(x),axis=1)] = 0         return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to change negetive values to zero for a particular column in python [SEP] def plot_target(target, ax):     \"\"\"Ajoute la target au plot\"\"\"     ax.scatter(target[0], target[1], target[2], c=\"red\", s=80)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to change negetive values to zero for a particular column in python [SEP] def _replace_nan(a, val):     \"\"\"     replace nan in a by val, and returns the replaced array and the nan     position     \"\"\"     mask = isnull(a)     return where_method(val, mask, a), mask", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to change negetive values to zero for a particular column in python [SEP] def check_bucket_exists(self, bucket: str) -> bool:         \"\"\"         Checks if bucket with specified name exists.         :param bucket: the bucket to be checked.         :return: true if specified bucket exists.         \"\"\"         exists = True         try:             self.s3_client.head_bucket(Bucket=bucket)         except botocore.exceptions.ClientError as e:             # If a client error is thrown, then check that it was a 404 error.             # If it was a 404 error, then the bucket does not exist.             error_code = int(e.response['Error']['Code'])             if error_code == 404:                 exists = False         return exists", "target": 0, "target_options": ["no match", "match"]}
{"input": "bring out array from dictionary python [SEP] def C_dict2array(C):     \"\"\"Convert an OrderedDict containing C values to a 1D array.\"\"\"     return np.hstack([np.asarray(C[k]).ravel() for k in C_keys])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "bring out array from dictionary python [SEP] def post_sea_resource(url, body):     \"\"\"     Get the requested resource using the Seattle account     :returns: http response with content in json     \"\"\"     response = None     response = TrumbaSea_DAO().postURL(         url,         {\"Content-Type\": \"application/json\"},         body)     _log_json_resp(\"Seattle\", url, body, response)     return response", "target": 0, "target_options": ["no match", "match"]}
{"input": "bring out array from dictionary python [SEP] def convert_array(array):     \"\"\"     Converts an ARRAY string stored in the database back into a Numpy array.      Parameters     ----------     array: ARRAY         The array object to be converted back into a Numpy array.      Returns     -------     array             The converted Numpy array.      \"\"\"     out = io.BytesIO(array)     out.seek(0)     return np.load(out)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "bring out array from dictionary python [SEP] def Ry_matrix(theta):     \"\"\"Rotation matrix around the Y axis\"\"\"     return np.array([         [np.cos(theta), 0, np.sin(theta)],         [0, 1, 0],         [-np.sin(theta), 0, np.cos(theta)]     ])", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to make 2d arraylist python [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to make 2d arraylist python [SEP] def is_bool_matrix(l):     r\"\"\"Checks if l is a 2D numpy array of bools      \"\"\"     if isinstance(l, np.ndarray):         if l.ndim == 2 and (l.dtype == bool):             return True     return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to make 2d arraylist python [SEP] def torecarray(*args, **kwargs):     \"\"\"     Convenient shorthand for ``toarray(*args, **kwargs).view(np.recarray)``.      \"\"\"      import numpy as np     return toarray(*args, **kwargs).view(np.recarray)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to make 2d arraylist python [SEP] def join_cols(cols):     \"\"\"Join list of columns into a string for a SQL query\"\"\"     return \", \".join([i for i in cols]) if isinstance(cols, (list, tuple, set)) else cols", "target": 0, "target_options": ["no match", "match"]}
{"input": "turn pair of rows into one row python [SEP] def pivot(self):         \"\"\"         transposes rows and columns         \"\"\"         self.op_data = [list(i) for i in zip(*self.ip_data)]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "turn pair of rows into one row python [SEP] def generate_hash(filepath):     \"\"\"Public function that reads a local file and generates a SHA256 hash digest for it\"\"\"     fr = FileReader(filepath)     data = fr.read_bin()     return _calculate_sha256(data)", "target": 0, "target_options": ["no match", "match"]}
{"input": "turn pair of rows into one row python [SEP] def partition(list_, columns=2):     \"\"\"     Break a list into ``columns`` number of columns.     \"\"\"      iter_ = iter(list_)     columns = int(columns)     rows = []      while True:         row = []         for column_number in range(1, columns + 1):             try:                 value = six.next(iter_)             except StopIteration:                 pass             else:                 row.append(value)          if not row:             return rows         rows.append(row)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "turn pair of rows into one row python [SEP] def load_file(self, input_file):         \"\"\" Loads data array from file (result of this converter)          Tries to import, load and replace files' data.         It will overwirte previously added items with #add_file or #load_file.          :param input_file         :type str or unicode         \"\"\"         pyimg = imp.load_source('image2py_taf', input_file)         self.files = pyimg.data         self.set_template(templates.templateByName(pyimg.template))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to retreive json data from dynamic url using python [SEP] def get_jsonparsed_data(url):     \"\"\"Receive the content of ``url``, parse it as JSON and return the        object.     \"\"\"     response = urlopen(url)     data = response.read().decode('utf-8')     return json.loads(data)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to retreive json data from dynamic url using python [SEP] def _read_json_file(self, json_file):         \"\"\" Helper function to read JSON file as OrderedDict \"\"\"          self.log.debug(\"Reading '%s' JSON file...\" % json_file)          with open(json_file, 'r') as f:             return json.load(f, object_pairs_hook=OrderedDict)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to retreive json data from dynamic url using python [SEP] def load_data(url): \t\"\"\" \t\"\"\"  \t# http request \tr = requests.get(url)  \t# decode to json \tdata = r.json()  \treturn data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to retreive json data from dynamic url using python [SEP] def clean(s):   \"\"\"Removes trailing whitespace on each line.\"\"\"   lines = [l.rstrip() for l in s.split('\\n')]   return '\\n'.join(lines)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python remove punctuation and stop words from string [SEP] def unpunctuate(s, *, char_blacklist=string.punctuation):     \"\"\" Remove punctuation from string s. \"\"\"     # remove punctuation     s = \"\".join(c for c in s if c not in char_blacklist)     # remove consecutive spaces     return \" \".join(filter(None, s.split(\" \")))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python remove punctuation and stop words from string [SEP] def pp(i, base=1024):     \"\"\"     Pretty-print the integer `i` as a human-readable size representation.     \"\"\"     degree = 0     pattern = \"%4d     %s\"     while i > base:         pattern = \"%7.2f %s\"         i = i / float(base)         degree += 1     scales = ['B', 'KB', 'MB', 'GB', 'TB', 'EB']     return pattern % (i, scales[degree])", "target": 0, "target_options": ["no match", "match"]}
{"input": "python remove punctuation and stop words from string [SEP] def clean(self, text):         \"\"\"Remove all unwanted characters from text.\"\"\"         return ''.join([c for c in text if c in self.alphabet])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python remove punctuation and stop words from string [SEP] def dict_merge(set1, set2):     \"\"\"Joins two dictionaries.\"\"\"     return dict(list(set1.items()) + list(set2.items()))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python list to store your data [SEP] def sflow_sample_rate(self, **kwargs):         \"\"\"Auto Generated Code         \"\"\"         config = ET.Element(\"config\")         sflow = ET.SubElement(config, \"sflow\", xmlns=\"urn:brocade.com:mgmt:brocade-sflow\")         sample_rate = ET.SubElement(sflow, \"sample-rate\")         sample_rate.text = kwargs.pop('sample_rate')          callback = kwargs.pop('callback', self._callback)         return callback(config)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python list to store your data [SEP] def isstring(value):     \"\"\"Report whether the given value is a byte or unicode string.\"\"\"     classes = (str, bytes) if pyutils.PY3 else basestring  # noqa: F821     return isinstance(value, classes)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python list to store your data [SEP] def set_http_application_url_input_config_http_app_url_op_type(self, **kwargs):         \"\"\"Auto Generated Code         \"\"\"         config = ET.Element(\"config\")         set_http_application_url = ET.Element(\"set_http_application_url\")         config = set_http_application_url         input = ET.SubElement(set_http_application_url, \"input\")         config_http_app_url = ET.SubElement(input, \"config-http-app-url\")         op_type = ET.SubElement(config_http_app_url, \"op-type\")         op_type.text = kwargs.pop('op_type')          callback = kwargs.pop('callback', self._callback)         return callback(config)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python list to store your data [SEP] def dropna(self, subset=None):         \"\"\"Remove missing values according to Baloo's convention.          Parameters         ----------         subset : list of str, optional             Which columns to check for missing values in.          Returns         -------         DataFrame             DataFrame with no null values in columns.          \"\"\"         subset = check_and_obtain_subset_columns(subset, self)         not_nas = [v.notna() for v in self[subset]._iter()]         and_filter = reduce(lambda x, y: x & y, not_nas)          return self[and_filter]", "target": 0, "target_options": ["no match", "match"]}
{"input": "is 0 not an integer in python [SEP] def isInt(num):     \"\"\"Returns true if `num` is (sort of) an integer.     >>> isInt(3) == isInt(3.0) == 1     True     >>> isInt(3.2)     False     >>> import numpy     >>> isInt(numpy.array(1))     True     >>> isInt(numpy.array([1]))     False     \"\"\"     try:         len(num) # FIXME fails for Numeric but Numeric is obsolete     except:         try:             return (num - math.floor(num) == 0) == True         except: return False     else: return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "is 0 not an integer in python [SEP] def _sim_colour(r1, r2):     \"\"\"         calculate the sum of histogram intersection of colour     \"\"\"     return sum([min(a, b) for a, b in zip(r1[\"hist_c\"], r2[\"hist_c\"])])", "target": 0, "target_options": ["no match", "match"]}
{"input": "is 0 not an integer in python [SEP] def to_int(self):         \"\"\"Convert vector to an integer, if possible.          This is only useful for arrays filled with zero/one entries.         \"\"\"         num = self.to_uint()         if num and self._items[-1].unbox():             return num - (1 << self.size)         else:             return num", "target": 1, "target_options": ["no_match", "match"]}
{"input": "is 0 not an integer in python [SEP] def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:     \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"     for line in file_like:         line = line.rstrip('\\r\\n')         if line:             yield line", "target": 0, "target_options": ["no match", "match"]}
{"input": "change a list to an int in python [SEP] def str2int(num, radix=10, alphabet=BASE85):     \"\"\"helper function for quick base conversions from strings to integers\"\"\"     return NumConv(radix, alphabet).str2int(num)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "change a list to an int in python [SEP] def commajoin_as_strings(iterable):     \"\"\" Join the given iterable with ',' \"\"\"     return _(u',').join((six.text_type(i) for i in iterable))", "target": 0, "target_options": ["no match", "match"]}
{"input": "change a list to an int in python [SEP] def valuesToInts(values):     \"\"\"     Iterable of values to ints (nonvalid = None)     \"\"\"     res = []     append = res.append     for d in values:         if isinstance(d, int):             append(d)         else:             append(valToInt(d))     return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "change a list to an int in python [SEP] def stylize(text, styles, reset=True):     \"\"\"conveniently styles your text as and resets ANSI codes at its end.\"\"\"     terminator = attr(\"reset\") if reset else \"\"     return \"{}{}{}\".format(\"\".join(styles), text, terminator)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to change datetime to float in python [SEP] def date_to_number(self, date):         \"\"\"         Converts a date or datetime instance to a corresponding float value.         \"\"\"         if isinstance(date, datetime.datetime):             delta = date - self._null_date         elif isinstance(date, datetime.date):             delta = date - self._null_date.date()         else:             raise TypeError(date)         return delta.days + delta.seconds / (24.0 * 60 * 60)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to change datetime to float in python [SEP] def bitsToString(arr):   \"\"\"Returns a string representing a numpy array of 0's and 1's\"\"\"   s = array('c','.'*len(arr))   for i in xrange(len(arr)):     if arr[i] == 1:       s[i]='*'   return s", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to change datetime to float in python [SEP] def _dt_to_float_ordinal(dt):     \"\"\"     Convert :mod:`datetime` to the Gregorian date as UTC float days,     preserving hours, minutes, seconds and microseconds.  Return value     is a :func:`float`.     \"\"\"     if (isinstance(dt, (np.ndarray, Index, ABCSeries)                    ) and is_datetime64_ns_dtype(dt)):         base = dates.epoch2num(dt.asi8 / 1.0E9)     else:         base = dates.date2num(dt)     return base", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to change datetime to float in python [SEP] def list2string (inlist,delimit=' '):     \"\"\" Converts a 1D list to a single long string for file output, using the string.join function.  Usage:   list2string (inlist,delimit=' ') Returns: the string created from inlist \"\"\"     stringlist = [makestr(_) for _ in inlist]     return string.join(stringlist,delimit)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python3 switch window focus linux [SEP] def inFocus(self):         \"\"\"Set GUI on-top flag\"\"\"         previous_flags = self.window.flags()         self.window.setFlags(previous_flags |                              QtCore.Qt.WindowStaysOnTopHint)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python3 switch window focus linux [SEP] def realized_pnl(self):         \"\"\"         [float] 平仓盈亏         \"\"\"         return sum(position.realized_pnl for position in six.itervalues(self._positions))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python3 switch window focus linux [SEP] def SwitchToThisWindow(handle: int) -> None:     \"\"\"     SwitchToThisWindow from Win32.     handle: int, the handle of a native window.     \"\"\"     ctypes.windll.user32.SwitchToThisWindow(ctypes.c_void_p(handle), 1)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python3 switch window focus linux [SEP] def txt_line_iterator(path):   \"\"\"Iterate through lines of file.\"\"\"   with tf.gfile.Open(path) as f:     for line in f:       yield line.strip()", "target": 0, "target_options": ["no match", "match"]}
{"input": "return row python 2 dimensional list [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return row python 2 dimensional list [SEP] def list_move_to_front(l,value='other'):     \"\"\"if the value is in the list, move it to the front and return it.\"\"\"     l=list(l)     if value in l:         l.remove(value)         l.insert(0,value)     return l", "target": 0, "target_options": ["no match", "match"]}
{"input": "return row python 2 dimensional list [SEP] def to_list(self):         \"\"\"Convert this confusion matrix into a 2x2 plain list of values.\"\"\"         return [[int(self.table.cell_values[0][1]), int(self.table.cell_values[0][2])],                 [int(self.table.cell_values[1][1]), int(self.table.cell_values[1][2])]]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return row python 2 dimensional list [SEP] def __iter__(self):     \"\"\"Return all elements from the list.\"\"\"     for index in range(0, self._size):       try:         yield self._list[(self._index + index) % self._size]       except IndexError:         pass", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to extract html of a webpage [SEP] def html_to_text(content):     \"\"\" Converts html content to plain text \"\"\"     text = None     h2t = html2text.HTML2Text()     h2t.ignore_links = False     text = h2t.handle(content)     return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to extract html of a webpage [SEP] def drop_bad_characters(text):     \"\"\"Takes a text and drops all non-printable and non-ascii characters and     also any whitespace characters that aren't space.      :arg str text: the text to fix      :returns: text with all bad characters dropped      \"\"\"     # Strip all non-ascii and non-printable characters     text = ''.join([c for c in text if c in ALLOWED_CHARS])     return text", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to extract html of a webpage [SEP] def markdown_to_text(body):     \"\"\"Converts markdown to text.      Args:         body: markdown (or plaintext, or maybe HTML) input      Returns:         Plaintext with all tags and frills removed     \"\"\"     # Turn our input into HTML     md = markdown.markdown(body, extensions=[         'markdown.extensions.extra'     ])      # Safely parse HTML so that we don't have to parse it ourselves     soup = BeautifulSoup(md, 'html.parser')      # Return just the text of the parsed HTML     return soup.get_text()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to extract html of a webpage [SEP] def show_correlation_matrix(self, correlation_matrix):         \"\"\"Shows the given correlation matrix as image          :param correlation_matrix: Correlation matrix of features         \"\"\"         cr_plot.create_correlation_matrix_plot(             correlation_matrix, self.title, self.headers_to_test         )         pyplot.show()", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to make python run until someone types [SEP] def main(idle):     \"\"\"Any normal python logic which runs a loop. Can take arguments.\"\"\"     while True:          LOG.debug(\"Sleeping for {0} seconds.\".format(idle))         time.sleep(idle)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to make python run until someone types [SEP] def plot_curves_z(data, name, title=None):     \"\"\"Generates a simple plot of the quasiparticle weight decay curves given        data object with doping setup\"\"\"      plt.figure()     for zet, c in zip(data['zeta'], data['doping']):         plt.plot(data['u_int'], zet[:, 0], label='$n={}$'.format(str(c)))     if title != None:         plt.title(title)     label_saves(name+'.png')", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to make python run until someone types [SEP] def run(self, forever=True):         \"\"\"start the bot\"\"\"         loop = self.create_connection()         self.add_signal_handlers()         if forever:             loop.run_forever()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to make python run until someone types [SEP] def rand_elem(seq, n=None):     \"\"\"returns a random element from seq n times. If n is None, it continues indefinitly\"\"\"     return map(random.choice, repeat(seq, n) if n is not None else repeat(seq))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python string match ignor case [SEP] def ismatch(text, pattern):     \"\"\"Test whether text contains string or matches regex.\"\"\"      if hasattr(pattern, 'search'):         return pattern.search(text) is not None     else:         return pattern in text if Config.options.case_sensitive \\             else pattern.lower() in text.lower()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python string match ignor case [SEP] def csv_to_matrix(csv_file_path):     \"\"\"Load a CSV file into a Python matrix of strings.      Args:         csv_file_path: Full path to a valid CSV file (e.g. c:/ladybug/test.csv)     \"\"\"     mtx = []     with open(csv_file_path) as csv_data_file:         for row in csv_data_file:             mtx.append(row.split(','))     return mtx", "target": 0, "target_options": ["no match", "match"]}
{"input": "python string match ignor case [SEP] def find_whole_word(w):     \"\"\"     Scan through string looking for a location where this word produces a match,     and return a corresponding MatchObject instance.     Return None if no position in the string matches the pattern;     note that this is different from finding a zero-length match at some point in the string.     \"\"\"     return re.compile(r'\\b({0})\\b'.format(w), flags=re.IGNORECASE).search", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python string match ignor case [SEP] def QA_util_datetime_to_strdate(dt):     \"\"\"     :param dt:  pythone datetime.datetime     :return:  1999-02-01 string type     \"\"\"     strdate = \"%04d-%02d-%02d\" % (dt.year, dt.month, dt.day)     return strdate", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to split a string by colons python [SEP] def split(s):   \"\"\"Uses dynamic programming to infer the location of spaces in a string without spaces.\"\"\"   l = [_split(x) for x in _SPLIT_RE.split(s)]   return [item for sublist in l for item in sublist]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to split a string by colons python [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to split a string by colons python [SEP] def _split(string, splitters):     \"\"\"Splits a string into parts at multiple characters\"\"\"     part = ''     for character in string:         if character in splitters:             yield part             part = ''         else:             part += character     yield part", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to split a string by colons python [SEP] def is_label(self):         \"\"\"Return true if the colum is a dimension\"\"\"         from ambry.valuetype.core import ROLE         return self.role == ROLE.LABEL", "target": 0, "target_options": ["no match", "match"]}
{"input": "python extract date from timesdelta [SEP] def datetime64_to_datetime(dt):     \"\"\" convert numpy's datetime64 to datetime \"\"\"     dt64 = np.datetime64(dt)     ts = (dt64 - np.datetime64('1970-01-01T00:00:00')) / np.timedelta64(1, 's')     return datetime.datetime.utcfromtimestamp(ts)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python extract date from timesdelta [SEP] def should_skip_logging(func):     \"\"\"     Should we skip logging for this handler?      \"\"\"     disabled = strtobool(request.headers.get(\"x-request-nolog\", \"false\"))     return disabled or getattr(func, SKIP_LOGGING, False)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python extract date from timesdelta [SEP] def timestamp_from_dt(dt, epoch=datetime(1970, 1, 1)):     \"\"\"     Convert a datetime to a timestamp.     https://stackoverflow.com/a/8778548/141395     \"\"\"     delta = dt - epoch     # return delta.total_seconds()     return delta.seconds + delta.days * 86400", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python extract date from timesdelta [SEP] def getBitmap(self):         \"\"\" Captures screen area of this region, at least the part that is on the screen          Returns image as numpy array         \"\"\"         return PlatformManager.getBitmapFromRect(self.x, self.y, self.w, self.h)", "target": 0, "target_options": ["no match", "match"]}
{"input": "get specific index of a string python [SEP] def find_first_in_list(txt: str, str_list: [str]) -> int:  # type: ignore     \"\"\"     Returns the index of the earliest occurence of an item from a list in a string      Ex: find_first_in_list('foobar', ['bar', 'fin']) -> 3     \"\"\"     start = len(txt) + 1     for item in str_list:         if start > txt.find(item) > -1:             start = txt.find(item)     return start if len(txt) + 1 > start > -1 else -1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get specific index of a string python [SEP] def _css_select(soup, css_selector):         \"\"\" Returns the content of the element pointed by the CSS selector,         or an empty string if not found \"\"\"         selection = soup.select(css_selector)         if len(selection) > 0:             if hasattr(selection[0], 'text'):                 retour = selection[0].text.strip()             else:                 retour = \"\"         else:             retour = \"\"         return retour", "target": 0, "target_options": ["no match", "match"]}
{"input": "get specific index of a string python [SEP] def get_list_index(lst, index_or_name):     \"\"\"     Return the index of an element in the list.      Args:         lst (list): The list.         index_or_name (int or str): The value of the reference element, or directly its numeric index.      Returns:         (int) The index of the element in the list.     \"\"\"     if isinstance(index_or_name, six.integer_types):         return index_or_name      return lst.index(index_or_name)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get specific index of a string python [SEP] def getSystemVariable(self, remote, name):         \"\"\"Get single system variable from CCU / Homegear\"\"\"         if self._server is not None:             return self._server.getSystemVariable(remote, name)", "target": 0, "target_options": ["no match", "match"]}
{"input": "make 2d list in python from 1d [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "make 2d list in python from 1d [SEP] def rm_keys_from_dict(d, keys):     \"\"\"     Given a dictionary and a key list, remove any data in the dictionary with the given keys.      :param dict d: Metadata     :param list keys: Keys to be removed     :return dict d: Metadata     \"\"\"     # Loop for each key given     for key in keys:         # Is the key in the dictionary?         if key in d:             try:                 d.pop(key, None)             except KeyError:                 # Not concerned with an error. Keep going.                 pass     return d", "target": 0, "target_options": ["no match", "match"]}
{"input": "make 2d list in python from 1d [SEP] def pack_triples_numpy(triples):     \"\"\"Packs a list of triple indexes into a 2D numpy array.\"\"\"     if len(triples) == 0:         return np.array([], dtype=np.int64)     return np.stack(list(map(_transform_triple_numpy, triples)), axis=0)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "make 2d list in python from 1d [SEP] def extent(self):          \"\"\"         return range of 2D data         \"\"\"          return [min(self.x), max(self.x), min(self.y), max(self.y)]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to slice a dictionary [SEP] def chunks(data, size):     \"\"\"     Get chink for dict, copy as-is from https://stackoverflow.com/a/8290508/6753144     \"\"\"     it = iter(data)     for i in range(0, len(data), size):         yield {k: data[k] for k in islice(it, size)}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to slice a dictionary [SEP] def robust_int(v):     \"\"\"Parse an int robustly, ignoring commas and other cruft. \"\"\"      if isinstance(v, int):         return v      if isinstance(v, float):         return int(v)      v = str(v).replace(',', '')      if not v:         return None      return int(v)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to slice a dictionary [SEP] def dict_chunks(dictionary, chunk):     \"\"\"Return a list of dictionary with n-keys (chunk) per list.\"\"\"     return [{k: v for k, v in dictionary.items() if k in i} for i in chunks(list(dictionary.keys()), chunk)]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to slice a dictionary [SEP] def contains_empty(features):     \"\"\"Check features data are not empty      :param features: The features data to check.     :type features: list of numpy arrays.      :return: True if one of the array is empty, False else.      \"\"\"     if not features:         return True     for feature in features:         if feature.shape[0] == 0:             return True     return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "accessing only numeric values in a tuple python [SEP] def rgba_bytes_tuple(self, x):         \"\"\"Provides the color corresponding to value `x` in the         form of a tuple (R,G,B,A) with int values between 0 and 255.         \"\"\"         return tuple(int(u*255.9999) for u in self.rgba_floats_tuple(x))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "accessing only numeric values in a tuple python [SEP] def clean_with_zeros(self,x):         \"\"\" set nan and inf rows from x to zero\"\"\"         x[~np.any(np.isnan(x) | np.isinf(x),axis=1)] = 0         return x", "target": 0, "target_options": ["no match", "match"]}
{"input": "accessing only numeric values in a tuple python [SEP] def get_value_tuple(self):         \"\"\"         Returns a tuple of the color's values (in order). For example,         an LabColor object will return (lab_l, lab_a, lab_b), where each         member of the tuple is the float value for said variable.         \"\"\"         retval = tuple()         for val in self.VALUES:             retval += (getattr(self, val),)         return retval", "target": 1, "target_options": ["no_match", "match"]}
{"input": "accessing only numeric values in a tuple python [SEP] def _remove_duplicates(objects):     \"\"\"Removes duplicate objects.      http://www.peterbe.com/plog/uniqifiers-benchmark.     \"\"\"     seen, uniq = set(), []     for obj in objects:         obj_id = id(obj)         if obj_id in seen:             continue         seen.add(obj_id)         uniq.append(obj)     return uniq", "target": 0, "target_options": ["no match", "match"]}
{"input": "remove whitespace in a list in python [SEP] def _str_to_list(s):     \"\"\"Converts a comma separated string to a list\"\"\"     _list = s.split(\",\")     return list(map(lambda i: i.lstrip(), _list))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove whitespace in a list in python [SEP] def closest(xarr, val):     \"\"\" Return the index of the closest in xarr to value val \"\"\"     idx_closest = np.argmin(np.abs(np.array(xarr) - val))     return idx_closest", "target": 0, "target_options": ["no match", "match"]}
{"input": "remove whitespace in a list in python [SEP] def strip_spaces(value, sep=None, join=True):     \"\"\"Cleans trailing whitespaces and replaces also multiple whitespaces with a single space.\"\"\"     value = value.strip()     value = [v.strip() for v in value.split(sep)]     join_sep = sep or ' '     return join_sep.join(value) if join else value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove whitespace in a list in python [SEP] def _write_pidfile(pidfile):     \"\"\" Write file with current process ID.     \"\"\"     pid = str(os.getpid())     handle = open(pidfile, 'w')     try:         handle.write(\"%s\\n\" % pid)     finally:         handle.close()", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to pass values continuosly from python to html [SEP] def do_forceescape(value):     \"\"\"Enforce HTML escaping.  This will probably double escape variables.\"\"\"     if hasattr(value, '__html__'):         value = value.__html__()     return escape(text_type(value))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to pass values continuosly from python to html [SEP] def token_accuracy(labels, outputs):   \"\"\"Compute tokenwise (elementwise) accuracy.    Args:     labels: ground-truth labels, shape=(batch, seq_length)     outputs: predicted tokens, shape=(batch, seq_length)   Returns:     Two ops, one for getting the current average accuracy and another for     updating the running average estimate.   \"\"\"   weights = tf.to_float(tf.not_equal(labels, 0))   return tf.metrics.accuracy(labels, outputs, weights=weights)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to pass values continuosly from python to html [SEP] def example_view():     text = request.args.get('text', 'http://www.youtube.com/watch?v=nda_OSWeyn8')     html = request.args.get('html', \"\"\" <p>This is a test</p> <p>http://www.youtube.com/watch?v=nda_OSWeyn8</p> <p>This will get rendered as a link: http://www.youtube.com/watch?v=nda_OSWeyn8</p> <p>This will not be modified: <a href=\"http://www.google.com/\">http://www.youtube.com/watch?v=nda_OSWeyn8</a></p>     \"\"\")     return render_template('example.html', text=text, html=html)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to pass values continuosly from python to html [SEP] def executeMethod(self, methodName, args):     \"\"\"Executes a method named ``methodName`` with the specified arguments.      This method is called when the user executes a command as defined in     the node spec. It provides a perfectly reasonble implementation     of the command mechanism. As a sub-class developer you just need to     implement a method for each command in the node spec. Note that due to     the command mechanism only unnamed argument are supported.      :param methodName: (string) the name of the method that correspond to a            command in the spec.     :param args: (list) of arguments that will be passed to the method     \"\"\"     if not hasattr(self, methodName):       raise Exception('Missing command method: ' + methodName)      m = getattr(self, methodName)     if not hasattr(m, '__call__'):       raise Exception('Command: ' + methodName + ' must be callable')      return m(*args)", "target": 0, "target_options": ["no match", "match"]}
{"input": "date greater than current date python [SEP] def created_today(self):         \"\"\"Return True if created today.\"\"\"         if self.datetime.date() == datetime.today().date():             return True         return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "date greater than current date python [SEP] def add_bg(img, padding, color=COL_WHITE):     \"\"\"     Adds a padding to the given image as background of specified color      :param img: Input image.     :param padding: constant padding around the image.     :param color: background color that needs to filled for the newly padded region.     :return: New image with background.     \"\"\"     img = gray3(img)     h, w, d = img.shape     new_img = np.ones((h + 2*padding, w + 2*padding, d)) * color[:d]     new_img = new_img.astype(np.uint8)     set_img_box(new_img, (padding, padding, w, h), img)     return new_img", "target": 0, "target_options": ["no match", "match"]}
{"input": "date greater than current date python [SEP] def now_time(str=False):     \"\"\"Get the current time.\"\"\"     if str:         return datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")     return datetime.datetime.now()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "date greater than current date python [SEP] def url_to_image(url):     \"\"\"     Fetch an image from url and convert it into a Pillow Image object     \"\"\"     r = requests.get(url)     image = StringIO(r.content)     return image", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to access a 4d array [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to access a 4d array [SEP] def list_to_str(list, separator=','):     \"\"\"     >>> list = [0, 0, 7]     >>> list_to_str(list)     '0,0,7'     \"\"\"     list = [str(x) for x in list]     return separator.join(list)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to access a 4d array [SEP] def torecarray(*args, **kwargs):     \"\"\"     Convenient shorthand for ``toarray(*args, **kwargs).view(np.recarray)``.      \"\"\"      import numpy as np     return toarray(*args, **kwargs).view(np.recarray)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to access a 4d array [SEP] def to_list(self):         \"\"\"Convert this confusion matrix into a 2x2 plain list of values.\"\"\"         return [[int(self.table.cell_values[0][1]), int(self.table.cell_values[0][2])],                 [int(self.table.cell_values[1][1]), int(self.table.cell_values[1][2])]]", "target": 0, "target_options": ["no match", "match"]}
{"input": "put two lists together python as dictionary [SEP] def list2dict(lst):     \"\"\"Takes a list of (key,value) pairs and turns it into a dict.\"\"\"      dic = {}     for k,v in lst: dic[k] = v     return dic", "target": 1, "target_options": ["no_match", "match"]}
{"input": "put two lists together python as dictionary [SEP] def is_string(obj):     \"\"\"Is this a string.      :param object obj:     :rtype: bool     \"\"\"     if PYTHON3:         str_type = (bytes, str)     else:         str_type = (bytes, str, unicode)     return isinstance(obj, str_type)", "target": 0, "target_options": ["no match", "match"]}
{"input": "put two lists together python as dictionary [SEP] def list_of_lists_to_dict(l):     \"\"\" Convert list of key,value lists to dict      [['id', 1], ['id', 2], ['id', 3], ['foo': 4]]     {'id': [1, 2, 3], 'foo': [4]}     \"\"\"     d = {}     for key, val in l:         d.setdefault(key, []).append(val)     return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "put two lists together python as dictionary [SEP] def print_with_header(header, message, color, indent=0):     \"\"\"     Use one of the functions below for printing, not this one.     \"\"\"     print()     padding = ' ' * indent     print(padding + color + BOLD + header + ENDC + color + message + ENDC)", "target": 0, "target_options": ["no match", "match"]}
{"input": "count characters length python [SEP] def array_dim(arr):     \"\"\"Return the size of a multidimansional array.     \"\"\"     dim = []     while True:         try:             dim.append(len(arr))             arr = arr[0]         except TypeError:             return dim", "target": 1, "target_options": ["no_match", "match"]}
{"input": "count characters length python [SEP] def _transform_triple_numpy(x):     \"\"\"Transform triple index into a 1-D numpy array.\"\"\"     return np.array([x.head, x.relation, x.tail], dtype=np.int64)", "target": 0, "target_options": ["no match", "match"]}
{"input": "count characters length python [SEP] def __len__(self):         \"\"\" This will equal 124 for the V1 database. \"\"\"         length = 0         for typ, siz, _ in self.format:             length += siz         return length", "target": 1, "target_options": ["no_match", "match"]}
{"input": "count characters length python [SEP] def read_set_from_file(filename: str) -> Set[str]:     \"\"\"     Extract a de-duped collection (set) of text from a file.     Expected file format is one item per line.     \"\"\"     collection = set()     with open(filename, 'r') as file_:         for line in file_:             collection.add(line.rstrip())     return collection", "target": 0, "target_options": ["no match", "match"]}
{"input": "check if an element exist python [SEP] def elXpath(self, xpath, dom=None):         \"\"\"check if element is present by css\"\"\"         if dom is None:             dom = self.browser         return expect(dom.is_element_present_by_xpath, args=[xpath])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check if an element exist python [SEP] def load_b26_file(file_name):     \"\"\"     loads a .b26 file into a dictionary      Args:         file_name:      Returns: dictionary with keys instrument, scripts, probes      \"\"\"     # file_name = \"Z:\\Lab\\Cantilever\\Measurements\\\\tmp_\\\\a\"      assert os.path.exists(file_name)      with open(file_name, 'r') as infile:         data = yaml.safe_load(infile)     return data", "target": 0, "target_options": ["no match", "match"]}
{"input": "check if an element exist python [SEP] def is_present(self, selector):         \"\"\"Check if an element is present in the dom or not          This method won't check if the element is displayed or not         This method won't wait until the element is visible or present         This method won't raise any exception if the element is not present          Returns:             bool: True if the element is present; False otherwise         \"\"\"         self.debug_log(\"Is present (%s)\" % selector)          element = self.find(             selector,             raise_exception=False,             wait_until_present=False,             wait_until_visible=False         )         if element:             self.debug_log(\"is present: True\")             return True         else:             self.debug_log(\"is present: False\")             return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check if an element exist python [SEP] def str2int(num, radix=10, alphabet=BASE85):     \"\"\"helper function for quick base conversions from strings to integers\"\"\"     return NumConv(radix, alphabet).str2int(num)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python setter for tupple [SEP] def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python setter for tupple [SEP] def _tab(content):     \"\"\"     Helper funcation that converts text-based get response     to tab separated values for additional manipulation.     \"\"\"     response = _data_frame(content).to_csv(index=False,sep='\\t')     return response", "target": 0, "target_options": ["no match", "match"]}
{"input": "python setter for tupple [SEP] def get_value_tuple(self):         \"\"\"         Returns a tuple of the color's values (in order). For example,         an LabColor object will return (lab_l, lab_a, lab_b), where each         member of the tuple is the float value for said variable.         \"\"\"         retval = tuple()         for val in self.VALUES:             retval += (getattr(self, val),)         return retval", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python setter for tupple [SEP] def searchlast(self,n=10):         \"\"\"Return the last n results (or possibly less if not found). Note that the last results are not necessarily the best ones! Depending on the search type.\"\"\"                     solutions = deque([], n)         for solution in self:             solutions.append(solution)         return solutions", "target": 0, "target_options": ["no match", "match"]}
{"input": "sort uniq in python strings [SEP] def uniqued(iterable):     \"\"\"Return unique list of ``iterable`` items preserving order.      >>> uniqued('spameggs')     ['s', 'p', 'a', 'm', 'e', 'g']     \"\"\"     seen = set()     return [item for item in iterable if item not in seen and not seen.add(item)]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "sort uniq in python strings [SEP] def main(ctx, connection):     \"\"\"Command line interface for PyBEL.\"\"\"     ctx.obj = Manager(connection=connection)     ctx.obj.bind()", "target": 0, "target_options": ["no match", "match"]}
{"input": "sort uniq in python strings [SEP] def _uniquify(_list):     \"\"\"Remove duplicates in a list.\"\"\"     seen = set()     result = []     for x in _list:         if x not in seen:             result.append(x)             seen.add(x)     return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "sort uniq in python strings [SEP] def exit(exit_code=0):   r\"\"\"A function to support exiting from exit hooks.    Could also be used to exit from the calling scripts in a thread safe manner.   \"\"\"   core.processExitHooks()    if state.isExitHooked and not hasattr(sys, 'exitfunc'): # The function is called from the exit hook     sys.stderr.flush()     sys.stdout.flush()     os._exit(exit_code) #pylint: disable=W0212    sys.exit(exit_code)", "target": 0, "target_options": ["no match", "match"]}
{"input": "given a list, calculate the sum of its value recursively python [SEP] def calc_list_average(l):     \"\"\"     Calculates the average value of a list of numbers     Returns a float     \"\"\"     total = 0.0     for value in l:         total += value     return total / len(l)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "given a list, calculate the sum of its value recursively python [SEP] def write(file_name, data):     \"\"\"Encode and write a Hip file.\"\"\"     with open(file_name, 'w') as f:         f.write(encode(data))", "target": 0, "target_options": ["no match", "match"]}
{"input": "given a list, calculate the sum of its value recursively python [SEP] def cumsum(inlist):     \"\"\" Returns a list consisting of the cumulative sum of the items in the passed list.  Usage:   lcumsum(inlist) \"\"\"     newlist = copy.deepcopy(inlist)     for i in range(1, len(newlist)):         newlist[i] = newlist[i] + newlist[i - 1]     return newlist", "target": 1, "target_options": ["no_match", "match"]}
{"input": "given a list, calculate the sum of its value recursively python [SEP] def parent_directory(self):         \"\"\"Change working directory to parent directory\"\"\"         self.chdir(os.path.join(getcwd_or_home(), os.path.pardir))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python pil capture selected screen [SEP] def getBitmap(self):         \"\"\" Captures screen area of this region, at least the part that is on the screen          Returns image as numpy array         \"\"\"         return PlatformManager.getBitmapFromRect(self.x, self.y, self.w, self.h)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python pil capture selected screen [SEP] def try_cast_int(s):     \"\"\"(str) -> int     All the digits in a given string are concatenated and converted into a single number.     \"\"\"     try:         temp = re.findall('\\d', str(s))         temp = ''.join(temp)         return int(temp)     except:         return s", "target": 0, "target_options": ["no match", "match"]}
{"input": "python pil capture selected screen [SEP] def transform_coords(self, width, height): \t\t\"\"\"Return the current absolute (x, y) coordinates of \t\tthe tablet tool event, transformed to screen coordinates and \t\twhether they have changed in this event.  \t\tNote: \t\t\tOn some devices, returned value may be negative or larger than \t\t\tthe width of the device. See `Out-of-bounds motion events`_ \t\t\tfor more details. \t\tArgs: \t\t\twidth (int): The current output screen width. \t\t\theight (int): The current output screen height. \t\tReturns: \t\t\t((float, float), bool): The current absolute (x, y) coordinates \t\t\ttransformed to screen coordinates and whether they have changed. \t\t\"\"\"  \t\tx = self._libinput.libinput_event_tablet_tool_get_x_transformed( \t\t\tself._handle, width) \t\ty = self._libinput.libinput_event_tablet_tool_get_y_transformed( \t\t\tself._handle, height) \t\tx_changed = self._libinput.libinput_event_tablet_tool_x_has_changed( \t\t\tself._handle) \t\ty_changed = self._libinput.libinput_event_tablet_tool_y_has_changed( \t\t\tself._handle) \t\treturn (x, y), x_changed or y_changed", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python pil capture selected screen [SEP] def bytes_to_bits(bytes_):     \"\"\"Convert bytes to a list of bits     \"\"\"     res = []     for x in bytes_:         if not isinstance(x, int):             x = ord(x)         res += byte_to_bits(x)     return res", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to print list alphabetical python [SEP] def __repr__(self):         \"\"\"         Basic string representation of the order.         \"\"\"         list_repr = \"<MarketOrderList: \\n\"          for order_list in [olist.orders for olist in self._orders.values()]:             for order in order_list:                 list_repr += repr(order)          return list_repr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to print list alphabetical python [SEP] def dot_product(self, other):         \"\"\" Return the dot product of the given vectors. \"\"\"         return self.x * other.x + self.y * other.y", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to print list alphabetical python [SEP] def _tuple_repr(data):     \"\"\"Return a repr() for a list/tuple\"\"\"     if len(data) == 1:         return \"(%s,)\" % rpr(data[0])     else:         return \"(%s)\" % \", \".join([rpr(x) for x in data])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to print list alphabetical python [SEP] def __len__(self):         \"\"\" This will equal 124 for the V1 database. \"\"\"         length = 0         for typ, siz, _ in self.format:             length += siz         return length", "target": 0, "target_options": ["no match", "match"]}
{"input": "python open a file and append [SEP] def add_binary_file(self, filename, address=0, overwrite=False):         \"\"\"Open given binary file and add its contents. Set `overwrite` to         ``True`` to allow already added data to be overwritten.          \"\"\"          with open(filename, 'rb') as fin:             self.add_binary(fin.read(), address, overwrite)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python open a file and append [SEP] def needs_check(self):         \"\"\"         Check if enough time has elapsed to perform a check().          If this time has elapsed, a state change check through         has_state_changed() should be performed and eventually a sync().          :rtype: boolean         \"\"\"         if self.lastcheck is None:             return True         return time.time() - self.lastcheck >= self.ipchangedetection_sleep", "target": 0, "target_options": ["no match", "match"]}
{"input": "python open a file and append [SEP] def prepend_line(filepath, line):     \"\"\"Rewrite a file adding a line to its beginning.     \"\"\"     with open(filepath) as f:         lines = f.readlines()      lines.insert(0, line)      with open(filepath, 'w') as f:         f.writelines(lines)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python open a file and append [SEP] def __init__(self, db):         \"\"\"         Connect to the Salesforce API.         \"\"\"         self.db = db         self.query = None         self.session = db.sf_session         self.rowcount = None         self.first_row = None         self.lastrowid = None  # not moved to driver because INSERT is implemented here         self.cursor = self.db.connection.cursor()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python index of max in array [SEP] def MultiArgMax(x):   \"\"\"   Get tuple (actually a generator) of indices where the max value of   array x occurs. Requires that x have a max() method, as x.max()   (in the case of NumPy) is much faster than max(x).   For a simpler, faster argmax when there is only a single maximum entry,   or when knowing only the first index where the maximum occurs,   call argmax() on a NumPy array.    :param x: Any sequence that has a max() method.   :returns: Generator with the indices where the max value occurs.   \"\"\"   m = x.max()   return (i for i, v in enumerate(x) if v == m)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python index of max in array [SEP] def acc_hash(filepath: str, hasher):     \"\"\"Accumulate content of file at `filepath` in `hasher`.\"\"\"     with open(filepath, 'rb') as f:         while True:             chunk = f.read(_BUF_SIZE)             if not chunk:                 break             hasher.update(chunk)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python index of max in array [SEP] def closest(xarr, val):     \"\"\" Return the index of the closest in xarr to value val \"\"\"     idx_closest = np.argmin(np.abs(np.array(xarr) - val))     return idx_closest", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python index of max in array [SEP] def main(arguments=None):     \"\"\"Main command line entry point.\"\"\"      if not arguments:         arguments = sys.argv[1:]      wordlist, sowpods, by_length, start, end = argument_parser(arguments)     for word in wordlist:         pretty_print(             word,             anagrams_in_word(word, sowpods, start, end),             by_length,         )", "target": 0, "target_options": ["no match", "match"]}
{"input": "first item in a tuple python [SEP] def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "first item in a tuple python [SEP] def add_bg(img, padding, color=COL_WHITE):     \"\"\"     Adds a padding to the given image as background of specified color      :param img: Input image.     :param padding: constant padding around the image.     :param color: background color that needs to filled for the newly padded region.     :return: New image with background.     \"\"\"     img = gray3(img)     h, w, d = img.shape     new_img = np.ones((h + 2*padding, w + 2*padding, d)) * color[:d]     new_img = new_img.astype(np.uint8)     set_img_box(new_img, (padding, padding, w, h), img)     return new_img", "target": 0, "target_options": ["no match", "match"]}
{"input": "first item in a tuple python [SEP] def compose_all(tups):   \"\"\"Compose all given tuples together.\"\"\"   from . import ast  # I weep for humanity   return functools.reduce(lambda x, y: x.compose(y), map(ast.make_tuple, tups), ast.make_tuple({}))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "first item in a tuple python [SEP] def gray2bgr(img):     \"\"\"Convert a grayscale image to BGR image.      Args:         img (ndarray or str): The input image.      Returns:         ndarray: The converted BGR image.     \"\"\"     img = img[..., None] if img.ndim == 2 else img     out_img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)     return out_img", "target": 0, "target_options": ["no match", "match"]}
{"input": "python multiprocessing logger pass in by function [SEP] def debug(self, text): \t\t\"\"\" Ajout d'un message de log de type DEBUG \"\"\" \t\tself.logger.debug(\"{}{}\".format(self.message_prefix, text))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python multiprocessing logger pass in by function [SEP] def callprint(self, cmd, shell=None, lock_file=None, nofail=False, container=None):         \"\"\"         Prints the command, and then executes it, then prints the memory use and         return code of the command.          Uses python's subprocess.Popen() to execute the given command. The shell argument is simply         passed along to Popen(). You should use shell=False (default) where possible, because this enables memory         profiling. You should use shell=True if you require shell functions like redirects (>) or stars (*), but this         will prevent the script from monitoring memory use. The pipes (|) will be used to split the command into         subprocesses run within python, so the memory profiling is possible.          cmd can also be a series (a dict object) of multiple commands, which will be run in succession.          :param str | Iterable[str] cmd: Bash command(s) to be run.         :param str lock_file: a lock file name         :param bool nofail: Should the pipeline bail on a nonzero return from a process? Default: False             Nofail can be used to implement non-essential parts of the pipeline; if these processes fail,             they will not cause the pipeline to bail out.         :param bool shell: if the command should be run it its own shell, default: None (will try             to determine based on the command)         :param container: Named Docker container in which to execute.         :param container: str         \"\"\"         # The Popen shell argument works like this:         # if shell=False, then we format the command (with split()) to be a list of command and its arguments.         # Split the command to use shell=False;         # leave it together to use shell=True;          def get_mem_child_sum(proc):             try:                 # get children processes                 children = proc.children(recursive=True)                 # get RSS memory of each child proc and sum all                 mem_sum = sum([x.memory_info().rss for x in children])                 # return in gigs                 return mem_sum/1e9             except (psutil.NoSuchProcess, psutil.ZombieProcess) as e:                 print(e)                 print(\"Warning: couldn't add memory use for process: {}\".format(proc.pid))                 return 0           def display_memory(memval):             return None if memval < 0 else \"{}GB\".format(round(memval, 3))          def make_dict(command):             a, s = (command, True) if check_shell(command, shell) else (shlex.split(command), False)             return dict(args=a, stdout=subprocess.PIPE, shell=s)          if container:             cmd = \"docker exec \" + container + \" \" + cmd          param_list = [make_dict(c) for c in split_by_pipes(cmd)] \\             if check_shell_pipes(cmd) else [dict(args=cmd, stdout=None, shell=True)]          proc_name = get_proc_name(cmd)          # stop_times = []         processes = []         running_processes = []         start_time = time.time()         for i in range(len(param_list)):             running_processes.append(i)             if i == 0:                 processes.append(psutil.Popen(preexec_fn=os.setpgrp, **param_list[i]))             else:                 param_list[i][\"stdin\"] = processes[i - 1].stdout                 processes.append(psutil.Popen(preexec_fn=os.setpgrp, **param_list[i]))              self.procs[processes[-1].pid] = {                 \"proc_name\": proc_name,                 \"subproc_name\" : get_proc_name(param_list[i][\"args\"]),                 \"start_time\": start_time,                 \"container\": container,                 \"p\": processes[-1]             }          self._report_command(cmd, [x.pid for x in processes])             # Capture the subprocess output in <pre> tags to make it format nicely             # if the markdown log file is displayed as HTML.         print(\"<pre>\")          local_maxmems = [-1] * len(running_processes)         returncodes = [None] * len(running_processes)          if not self.wait:             print(\"</pre>\")             ids = [x.pid for x in processes]             print (\"Not waiting for subprocess(es): \" + str(ids))             return [0, -1]          def proc_wrapup(i):             \"\"\"             :param i: internal ID number of the subprocess             \"\"\"             returncode = processes[i].returncode             current_pid = processes[i].pid              info = \"Process {pid} returned {ret}; memory: {mem}. \".format(                 pid=current_pid,                  ret=processes[i].returncode,                 mem=display_memory(local_maxmems[i]))                          # report process profile             self._report_profile(self.procs[current_pid][\"proc_name\"], lock_file, time.time() - self.procs[current_pid][\"start_time\"], local_maxmems[i])              # Remove this as a running subprocess             del self.procs[current_pid]             running_processes.remove(i)              returncodes[i] = returncode             return info           sleeptime = .0001         info = \"\"         while running_processes:             for i in running_processes:                 local_maxmems[i] = max(local_maxmems[i], (get_mem_child_sum(processes[i])))                 self.peak_memory = max(self.peak_memory, local_maxmems[i])                 if not self._attend_process(processes[i], sleeptime):                     info += proc_wrapup(i)              # the sleeptime is extremely short at the beginning and gets longer exponentially              # (+ constant to prevent copious checks at the very beginning)             # = more precise mem tracing for short processes             sleeptime = min((sleeptime + 0.25) * 3 , 60/len(processes))          # All jobs are done, print a final closing and job info         stop_time = time.time()         info += \" Elapsed: \" + str(datetime.timedelta(seconds=self.time_elapsed(start_time))) + \".\"         info += \" Peak memory: {pipe}.\".format(pipe=display_memory(self.peak_memory))          print(\"</pre>\")         print(info)          for rc in returncodes:             if rc != 0:                 msg = \"Subprocess returned nonzero result. Check above output for details\"                 self._triage_error(SubprocessError(msg), nofail)            return [returncodes, local_maxmems]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python multiprocessing logger pass in by function [SEP] def log(self, level, msg=None, *args, **kwargs):         \"\"\"Writes log out at any arbitray level.\"\"\"          return self._log(level, msg, args, kwargs)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python multiprocessing logger pass in by function [SEP] def argument_search(self):         \"\"\"             Uses the command line arguments to fill the search function and call it.         \"\"\"         arguments, _ = self.argparser.parse_known_args()         return self.search(**vars(arguments))", "target": 0, "target_options": ["no match", "match"]}
{"input": "email function discord api python [SEP] def create_message(self, channel_id, text):         \"\"\"         Sends a message to a Discord channel or user via REST API          Args:             channel_id (string): ID of destingation Discord channel             text (string): Content of message         \"\"\"          baseurl = self.rest_baseurl + \\             '/channels/{}/messages'.format(channel_id)         requests.post(baseurl,                       headers=self.headers,                       data=json.dumps({'content': text}))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "email function discord api python [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 0, "target_options": ["no match", "match"]}
{"input": "email function discord api python [SEP] def cmd(send, msg, args):     \"\"\"'Inspects a bot attribute.      Syntax: {command} <attr>      \"\"\"     if not hasattr(args['handler'], msg):         send(\"That attribute was not found in the handler.\")         return     send(str(getattr(args['handler'], msg)))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "email function discord api python [SEP] def get_magnitude_squared(self):         \"\"\"Returns the square of the magnitude of this vector.\"\"\"         return self.x*self.x + self.y*self.y", "target": 0, "target_options": ["no match", "match"]}
{"input": "python 3 iterate sort dictionary [SEP] def _dict_values_sorted_by_key(dictionary):     # This should be a yield from instead.     \"\"\"Internal helper to return the values of a dictionary, sorted by key.     \"\"\"     for _, value in sorted(dictionary.iteritems(), key=operator.itemgetter(0)):         yield value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python 3 iterate sort dictionary [SEP] def shutdown(self):         \"\"\"         Shutdown the cluster.         \"\"\"         self.stop = True         if self.stats:             self.stats.shutDownStats()         self.join()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python 3 iterate sort dictionary [SEP] def csort(objs, key):     \"\"\"Order-preserving sorting function.\"\"\"     idxs = dict((obj, i) for (i, obj) in enumerate(objs))     return sorted(objs, key=lambda obj: (key(obj), idxs[obj]))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python 3 iterate sort dictionary [SEP] def shutdown(self):         \"\"\"close socket, immediately.\"\"\"         if self.sock:             self.sock.close()             self.sock = None             self.connected = False", "target": 0, "target_options": ["no match", "match"]}
{"input": "python string in not in string [SEP] def __contains__(self, char):  # noqa: D105         \"\"\"Implement the `in` keyword, searches the sequence.         \"\"\"         return len(char) <= len(self) and char in str(self.seq) * 2", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python string in not in string [SEP] def realized_pnl(self):         \"\"\"         [float] 平仓盈亏         \"\"\"         return sum(position.realized_pnl for position in six.itervalues(self._positions))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python string in not in string [SEP] def notin(arg, values):     \"\"\"     Like isin, but checks whether this expression's value(s) are not     contained in the passed values. See isin docs for full usage.     \"\"\"     op = ops.NotContains(arg, values)     return op.to_expr()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python string in not in string [SEP] def replace_all(filepath, searchExp, replaceExp):     \"\"\"     Replace all the ocurrences (in a file) of a string with another value.     \"\"\"     for line in fileinput.input(filepath, inplace=1):         if searchExp in line:             line = line.replace(searchExp, replaceExp)         sys.stdout.write(line)", "target": 0, "target_options": ["no match", "match"]}
{"input": "rounding a float to 2 decimal places in python [SEP] def intround(value):     \"\"\"Given a float returns a rounded int. Should give the same result on     both Py2/3     \"\"\"      return int(decimal.Decimal.from_float(         value).to_integral_value(decimal.ROUND_HALF_EVEN))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "rounding a float to 2 decimal places in python [SEP] def clean(self, text):         \"\"\"Remove all unwanted characters from text.\"\"\"         return ''.join([c for c in text if c in self.alphabet])", "target": 0, "target_options": ["no match", "match"]}
{"input": "rounding a float to 2 decimal places in python [SEP] def py3round(number):     \"\"\"Unified rounding in all python versions.\"\"\"     if abs(round(number) - number) == 0.5:         return int(2.0 * round(number / 2.0))      return int(round(number))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "rounding a float to 2 decimal places in python [SEP] def replace(s, replace):     \"\"\"Replace multiple values in a string\"\"\"     for r in replace:         s = s.replace(*r)     return s", "target": 0, "target_options": ["no match", "match"]}
{"input": "removing just one comma from a string in python [SEP] def _str_to_list(s):     \"\"\"Converts a comma separated string to a list\"\"\"     _list = s.split(\",\")     return list(map(lambda i: i.lstrip(), _list))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "removing just one comma from a string in python [SEP] def title(msg):     \"\"\"Sets the title of the console window.\"\"\"     if sys.platform.startswith(\"win\"):         ctypes.windll.kernel32.SetConsoleTitleW(tounicode(msg))", "target": 0, "target_options": ["no match", "match"]}
{"input": "removing just one comma from a string in python [SEP] def strip_spaces(s):     \"\"\" Strip excess spaces from a string \"\"\"     return u\" \".join([c for c in s.split(u' ') if c])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "removing just one comma from a string in python [SEP] def norm_vec(vector):     \"\"\"Normalize the length of a vector to one\"\"\"     assert len(vector) == 3     v = np.array(vector)     return v/np.sqrt(np.sum(v**2))", "target": 0, "target_options": ["no match", "match"]}
{"input": "what command stops a python program [SEP] def timeout_thread_handler(timeout, stop_event):     \"\"\"A background thread to kill the process if it takes too long.      Args:         timeout (float): The number of seconds to wait before killing             the process.         stop_event (Event): An optional event to cleanly stop the background             thread if required during testing.     \"\"\"      stop_happened = stop_event.wait(timeout)     if stop_happened is False:         print(\"Killing program due to %f second timeout\" % timeout)      os._exit(2)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "what command stops a python program [SEP] async def load_unicode(reader):     \"\"\"     Loads UTF8 string     :param reader:     :return:     \"\"\"     ivalue = await load_uvarint(reader)     fvalue = bytearray(ivalue)     await reader.areadinto(fvalue)     return str(fvalue, 'utf8')", "target": 0, "target_options": ["no match", "match"]}
{"input": "what command stops a python program [SEP] def stop_process(self):         \"\"\"         Stops the child process.         \"\"\"         self._process.terminate()         if not self._process.waitForFinished(100):             self._process.kill()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "what command stops a python program [SEP] def _is_bit(obj):     \"\"\"Determine if obj is a bit\"\"\"     # If there is a bit type this could be replaced by isinstance.     if isinstance(obj, tuple) and len(obj) == 2:         if isinstance(obj[0], Register) and isinstance(obj[1], int) and obj[1] < len(obj[0]):             return True     return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "multiplying two array element wise python [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "multiplying two array element wise python [SEP] def torecarray(*args, **kwargs):     \"\"\"     Convenient shorthand for ``toarray(*args, **kwargs).view(np.recarray)``.      \"\"\"      import numpy as np     return toarray(*args, **kwargs).view(np.recarray)", "target": 0, "target_options": ["no match", "match"]}
{"input": "multiplying two array element wise python [SEP] def Unpack(a, num, axis):     \"\"\"     Unpack op.     \"\"\"     return tuple(np.squeeze(b, axis=axis) for b in np.split(a, num, axis=axis))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "multiplying two array element wise python [SEP] def write(file_name, data):     \"\"\"Encode and write a Hip file.\"\"\"     with open(file_name, 'w') as f:         f.write(encode(data))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to use a vector loop in python [SEP] def apply(f, obj, *args, **kwargs):     \"\"\"Apply a function in parallel to each element of the input\"\"\"     return vectorize(f)(obj, *args, **kwargs)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to use a vector loop in python [SEP] def Tmatrix(X):     \"\"\"     gets the orientation matrix (T) from data in X     \"\"\"     T = [[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]]     for row in X:         for k in range(3):             for l in range(3):                 T[k][l] += row[k] * row[l]     return T", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to use a vector loop in python [SEP] def norm_vec(vector):     \"\"\"Normalize the length of a vector to one\"\"\"     assert len(vector) == 3     v = np.array(vector)     return v/np.sqrt(np.sum(v**2))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to use a vector loop in python [SEP] def _str_to_list(s):     \"\"\"Converts a comma separated string to a list\"\"\"     _list = s.split(\",\")     return list(map(lambda i: i.lstrip(), _list))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python3 print seconds from deltatime [SEP] def datetime_to_ms(dt):     \"\"\"     Converts a datetime to a millisecond accuracy timestamp     \"\"\"     seconds = calendar.timegm(dt.utctimetuple())     return seconds * 1000 + int(dt.microsecond / 1000)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python3 print seconds from deltatime [SEP] def SaveDataToFD(self, raw_data, fd):     \"\"\"Merge the raw data with the config file and store it.\"\"\"     for key, value in iteritems(raw_data):       # TODO(hanuszczak): Incorrect type specification for `set`.       # pytype: disable=wrong-arg-types       self.set(\"\", key, value=value)       # pytype: enable=wrong-arg-types      self.write(fd)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python3 print seconds from deltatime [SEP] def total_seconds(td):     \"\"\"For those with older versions of Python, a pure-Python     implementation of Python 2.7's :meth:`~datetime.timedelta.total_seconds`.      Args:         td (datetime.timedelta): The timedelta to convert to seconds.     Returns:         float: total number of seconds      >>> td = timedelta(days=4, seconds=33)     >>> total_seconds(td)     345633.0     \"\"\"     a_milli = 1000000.0     td_ds = td.seconds + (td.days * 86400)  # 24 * 60 * 60     td_micro = td.microseconds + (td_ds * a_milli)     return td_micro / a_milli", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python3 print seconds from deltatime [SEP] def insert_slash(string, every=2):     \"\"\"insert_slash insert / every 2 char\"\"\"     return os.path.join(string[i:i+every] for i in xrange(0, len(string), every))", "target": 0, "target_options": ["no match", "match"]}
{"input": "simple program in adaline to identify healthy or not in python [SEP] def is_alive(self):         \"\"\"         Will test whether the ACS service is up and alive.         \"\"\"         response = self.get_monitoring_heartbeat()         if response.status_code == 200 and response.content == 'alive':             return True          return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "simple program in adaline to identify healthy or not in python [SEP] def DynamicConvFilter(inputs, filters, out_channel,                       kernel_shape,                       stride=1,                       padding='SAME'):     \"\"\" see \"Dynamic Filter Networks\" (NIPS 2016)         by Bert De Brabandere*, Xu Jia*, Tinne Tuytelaars and Luc Van Gool      Remarks:         This is the convolution version of a dynamic filter.      Args:         inputs : unfiltered input [b, h, w, 1] only grayscale images.         filters : learned filters of [b, k, k, 1] (dynamically generated by the network).         out_channel (int): number of output channel.         kernel_shape: (h, w) tuple or a int.         stride: (h, w) tuple or a int.         padding (str): 'valid' or 'same'. Case insensitive.      Returns         tf.Tensor named ``output``.     \"\"\"      # tf.unstack only works with known batch_size :-(     batch_size, h, w, in_channel = inputs.get_shape().as_list()     stride = shape4d(stride)      inputs = tf.unstack(inputs)     filters = tf.reshape(filters, [batch_size] + shape2d(kernel_shape) + [in_channel, out_channel])     filters = tf.unstack(filters)      # this is ok as TF uses the cuda stream context     rsl = [tf.nn.conv2d(tf.reshape(d, [1, h, w, in_channel]),                         tf.reshape(k, [kernel_shape, kernel_shape, in_channel, out_channel]),                         stride, padding=\"SAME\") for d, k in zip(inputs, filters)]     rsl = tf.concat(rsl, axis=0, name='output')     return rsl", "target": 0, "target_options": ["no match", "match"]}
{"input": "simple program in adaline to identify healthy or not in python [SEP] def is_agent_listening(self, host, port):         \"\"\"         Check if the Instana Agent is listening on <host> and <port>.         \"\"\"         try:             rv = False             url = \"http://%s:%s/\" % (host, port)             response = self.client.get(url, timeout=0.8)              server_header = response.headers[\"Server\"]             if server_header == AGENT_HEADER:                 logger.debug(\"Host agent found on %s:%d\" % (host, port))                 rv = True             else:                 logger.debug(\"...something is listening on %s:%d but it's not the Instana Agent: %s\"                              % (host, port, server_header))         except (requests.ConnectTimeout, requests.ConnectionError):             logger.debug(\"No host agent listening on %s:%d\" % (host, port))             rv = False         finally:             return rv", "target": 1, "target_options": ["no_match", "match"]}
{"input": "simple program in adaline to identify healthy or not in python [SEP] def unicode_is_ascii(u_string):     \"\"\"Determine if unicode string only contains ASCII characters.      :param str u_string: unicode string to check. Must be unicode         and not Python 2 `str`.     :rtype: bool     \"\"\"     assert isinstance(u_string, str)     try:         u_string.encode('ascii')         return True     except UnicodeEncodeError:         return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "plot points in image python matlibplot [SEP] def draw_image(self, ax, image):         \"\"\"Process a matplotlib image object and call renderer.draw_image\"\"\"         self.renderer.draw_image(imdata=utils.image_to_base64(image),                                  extent=image.get_extent(),                                  coordinates=\"data\",                                  style={\"alpha\": image.get_alpha(),                                         \"zorder\": image.get_zorder()},                                  mplobj=image)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "plot points in image python matlibplot [SEP] def read_string(buff, byteorder='big'):     \"\"\"Read a string from a file-like object.\"\"\"     length = read_numeric(USHORT, buff, byteorder)     return buff.read(length).decode('utf-8')", "target": 0, "target_options": ["no match", "match"]}
{"input": "plot points in image python matlibplot [SEP] def imshow(self, canvas, X, extent=None, label=None, vmin=None, vmax=None, **kwargs):         \"\"\"         Show the image stored in X on the canvas.                  The origin of the image show is (0,0), such that X[0,0] gets plotted at [0,0] of the image!                  the kwargs are plotting library specific kwargs!         \"\"\"         raise NotImplementedError(\"Implement all plot functions in AbstractPlottingLibrary in order to use your own plotting library\")", "target": 1, "target_options": ["no_match", "match"]}
{"input": "plot points in image python matlibplot [SEP] def load_data(filename):     \"\"\"     :rtype : numpy matrix     \"\"\"     data = pandas.read_csv(filename, header=None, delimiter='\\t', skiprows=9)     return data.as_matrix()", "target": 0, "target_options": ["no match", "match"]}
{"input": "writing an xml in python [SEP] def etree_write(tree, stream):     \"\"\"     Write XML ElementTree 'root' content into 'stream'.      :param tree: XML ElementTree object     :param stream: File or file-like object can write to     \"\"\"     try:         tree.write(stream, encoding=\"utf-8\", xml_declaration=True)     except TypeError:         tree.write(stream, encoding=\"unicode\", xml_declaration=True)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "writing an xml in python [SEP] def quaternion_to_rotation_matrix(quaternion):     \"\"\"Compute the rotation matrix representated by the quaternion\"\"\"     c, x, y, z = quaternion     return np.array([         [c*c + x*x - y*y - z*z, 2*x*y - 2*c*z,         2*x*z + 2*c*y        ],         [2*x*y + 2*c*z,         c*c - x*x + y*y - z*z, 2*y*z - 2*c*x        ],         [2*x*z - 2*c*y,         2*y*z + 2*c*x,         c*c - x*x - y*y + z*z]     ], float)", "target": 0, "target_options": ["no match", "match"]}
{"input": "writing an xml in python [SEP] def write(self, writer):         \"\"\"         Writes an XML representation of this node (including descendants) to the specified file-like object.          :param writer: An :class:`XmlWriter` instance to write this node to         \"\"\"         multiline = bool(self._children)         newline_start = multiline and not bool(self.data)         writer.start(self.tagname, self.attrs, newline=newline_start)         if self.data:             writer.data(self.data, newline=bool(self._children))         for c in self._children:             c.write(writer)         writer.end(self.tagname, indent=multiline)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "writing an xml in python [SEP] def isin(elems, line):     \"\"\"Check if an element from a list is in a string.      :type elems: list     :type line: str      \"\"\"     found = False     for e in elems:         if e in line.lower():             found = True             break     return found", "target": 0, "target_options": ["no match", "match"]}
{"input": "python input function two integers [SEP] def minus(*args):     \"\"\"Also, converts either to ints or to floats.\"\"\"     if len(args) == 1:         return -to_numeric(args[0])     return to_numeric(args[0]) - to_numeric(args[1])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python input function two integers [SEP] def color_text_boxes(ax, labels, colors, color_arrow=True):     \"\"\"Color text boxes.      Instead of this function, one can pass annotate_kwargs and plot_kwargs to     plot_line_ids function.     \"\"\"     assert len(labels) == len(colors), \\         \"Equal no. of colors and lables must be given\"     boxes = ax.findobj(mpl.text.Annotation)     box_labels = lineid_plot.unique_labels(labels)     for box in boxes:         l = box.get_label()         try:             loc = box_labels.index(l)         except ValueError:             continue  # No changes for this box         box.set_color(colors[loc])         if color_arrow:             box.arrow_patch.set_color(colors[loc])      ax.figure.canvas.draw()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python input function two integers [SEP] def divide(x: LispNumber, y: LispNumber) -> LispNumber:     \"\"\"Division reducer. If both arguments are integers, return a Fraction.     Otherwise, return the true division of x and y.\"\"\"     if isinstance(x, int) and isinstance(y, int):         return Fraction(x, y)     return x / y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python input function two integers [SEP] def fit(self, X):         \"\"\" Apply KMeans Clustering               X: dataset with feature vectors         \"\"\"         self.centers_, self.labels_, self.sse_arr_, self.n_iter_ = \\               _kmeans(X, self.n_clusters, self.max_iter, self.n_trials, self.tol)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to add dollar signs to in python [SEP] def format_screen(strng):     \"\"\"Format a string for screen printing.      This removes some latex-type format codes.\"\"\"     # Paragraph continue     par_re = re.compile(r'\\\\$',re.MULTILINE)     strng = par_re.sub('',strng)     return strng", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to add dollar signs to in python [SEP] def check_auth(email, password):     \"\"\"Check if a username/password combination is valid.     \"\"\"     try:         user = User.get(User.email == email)     except User.DoesNotExist:         return False     return password == user.password", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to add dollar signs to in python [SEP] def format_float(value): # not used     \"\"\"Modified form of the 'g' format specifier.     \"\"\"     string = \"{:g}\".format(value).replace(\"e+\", \"e\")     string = re.sub(\"e(-?)0*(\\d+)\", r\"e\\1\\2\", string)     return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to add dollar signs to in python [SEP] def dot1x_enable(self, **kwargs):         \"\"\"Auto Generated Code         \"\"\"         config = ET.Element(\"config\")         dot1x = ET.SubElement(config, \"dot1x\", xmlns=\"urn:brocade.com:mgmt:brocade-dot1x\")         enable = ET.SubElement(dot1x, \"enable\")          callback = kwargs.pop('callback', self._callback)         return callback(config)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python pass numpy array to method [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python pass numpy array to method [SEP] def __init__(self, pidfile, daemonize=True, root=False, root_chk_argv=True, stdin=\"/dev/null\", stdout=\"/dev/null\", stderr=\"/dev/null\"): \t\t\"\"\" \t\tMake our daemon instance. \t\tpidfile: the file we're going to store the process id in. ex: /tmp/matt-daemon.pid \t\troot:    does this script require root? True if it does, False if it doesn't. Will be enforced. \t\troot_chk_argv:  does the script require '--requires-root' in sys.argv to run as root? (usage is good) \t\tstdin:   where the script gets stdin from. \"/dev/null\", \"/dev/stdin\", etc. \t\tstdout:  where the script writes stdout. \"/dev/null\", \"/dev/stdout\", etc. \t\tstderr:  where the script writes stderr. \"/dev/null\", \"/dev/stderr\", etc. \t\t\"\"\" \t\t# Enforce root usage or non-usage. \t\tRootCheck.check(root, check_argv=root_chk_argv) \t\tself.pidfile = pidfile \t\tself.should_daemonize = daemonize \t\tself.stdin = stdin \t\tself.stdout = stdout \t\tself.stderr = stderr", "target": 0, "target_options": ["no match", "match"]}
{"input": "python pass numpy array to method [SEP] def _to_array(value):     \"\"\"As a convenience, turn Python lists and tuples into NumPy arrays.\"\"\"     if isinstance(value, (tuple, list)):         return array(value)     elif isinstance(value, (float, int)):         return np.float64(value)     else:         return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python pass numpy array to method [SEP] def draw(self):         \"\"\"Draw the shape in the current OpenGL context.          \"\"\"         if self.enabled:             self._vertex_list.colors = self._gl_colors             self._vertex_list.vertices = self._gl_vertices             self._vertex_list.draw(pyglet.gl.GL_TRIANGLES)", "target": 0, "target_options": ["no match", "match"]}
{"input": "remove key value from pythondictinary [SEP] def _remove_dict_keys_with_value(dict_, val):   \"\"\"Removes `dict` keys which have have `self` as value.\"\"\"   return {k: v for k, v in dict_.items() if v is not val}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove key value from pythondictinary [SEP] def read_stdin():     \"\"\" Read text from stdin, and print a helpful message for ttys. \"\"\"     if sys.stdin.isatty() and sys.stdout.isatty():         print('\\nReading from stdin until end of file (Ctrl + D)...')      return sys.stdin.read()", "target": 0, "target_options": ["no match", "match"]}
{"input": "remove key value from pythondictinary [SEP] def _prune(self):         \"\"\"Primitive way to keep dict in sync with RB.\"\"\"         delkeys = [k for k in self.keys() if k not in self.__ringbuffer]         for k in delkeys:  # necessary because dict is changed during iterations             super(KRingbuffer,self).__delitem__(k)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove key value from pythondictinary [SEP] def clean(self, text):         \"\"\"Remove all unwanted characters from text.\"\"\"         return ''.join([c for c in text if c in self.alphabet])", "target": 0, "target_options": ["no match", "match"]}
{"input": "python autoconvert to boolean [SEP] def strToBool(val):     \"\"\"     Helper function to turn a string representation of \"true\" into     boolean True.     \"\"\"     if isinstance(val, str):         val = val.lower()      return val in ['true', 'on', 'yes', True]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python autoconvert to boolean [SEP] def isin(elems, line):     \"\"\"Check if an element from a list is in a string.      :type elems: list     :type line: str      \"\"\"     found = False     for e in elems:         if e in line.lower():             found = True             break     return found", "target": 0, "target_options": ["no match", "match"]}
{"input": "python autoconvert to boolean [SEP] def _check_and_convert_bools(self):         \"\"\"Replace boolean variables by the characters 'F'/'T'         \"\"\"         replacements = {             True: 'T',             False: 'F',         }          for key in self.bools:             if isinstance(self[key], bool):                 self[key] = replacements[self[key]]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python autoconvert to boolean [SEP] def get(self):         \"\"\"         \"\"\"          if self.saved_list is None and self.null is False:             self.saved_list = []          return self.saved_list", "target": 0, "target_options": ["no match", "match"]}
{"input": "python get the value in the list starting with the str [SEP] def get_list_index(lst, index_or_name):     \"\"\"     Return the index of an element in the list.      Args:         lst (list): The list.         index_or_name (int or str): The value of the reference element, or directly its numeric index.      Returns:         (int) The index of the element in the list.     \"\"\"     if isinstance(index_or_name, six.integer_types):         return index_or_name      return lst.index(index_or_name)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python get the value in the list starting with the str [SEP] def _find_base_type(data_type):     \"\"\"Find the Nani's base type for a given data type.      This is useful when Nani's data types were subclassed and the original type     is required.     \"\"\"     bases = type(data_type).__mro__     for base in bases:         if base in _ALL:             return base      return None", "target": 0, "target_options": ["no match", "match"]}
{"input": "python get the value in the list starting with the str [SEP] def get_substring_idxs(substr, string):     \"\"\"     Return a list of indexes of substr. If substr not found, list is     empty.      Arguments:         substr (str): Substring to match.         string (str): String to match in.      Returns:         list of int: Start indices of substr.     \"\"\"     return [match.start() for match in re.finditer(substr, string)]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python get the value in the list starting with the str [SEP] def _quit(self, *args):         \"\"\" quit crash \"\"\"         self.logger.warn('Bye!')         sys.exit(self.exit())", "target": 0, "target_options": ["no match", "match"]}
{"input": "create a square wave python [SEP] def sine_wave(frequency):   \"\"\"Emit a sine wave at the given frequency.\"\"\"   xs = tf.reshape(tf.range(_samples(), dtype=tf.float32), [1, _samples(), 1])   ts = xs / FLAGS.sample_rate   return tf.sin(2 * math.pi * frequency * ts)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "create a square wave python [SEP] def html_to_text(content):     \"\"\" Converts html content to plain text \"\"\"     text = None     h2t = html2text.HTML2Text()     h2t.ignore_links = False     text = h2t.handle(content)     return text", "target": 0, "target_options": ["no match", "match"]}
{"input": "create a square wave python [SEP] def constant(times: np.ndarray, amp: complex) -> np.ndarray:     \"\"\"Continuous constant pulse.      Args:         times: Times to output pulse for.         amp: Complex pulse amplitude.     \"\"\"     return np.full(len(times), amp, dtype=np.complex_)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "create a square wave python [SEP] def recarray(self):         \"\"\"Returns data as :class:`numpy.recarray`.\"\"\"         return numpy.rec.fromrecords(self.records, names=self.names)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python script to run against a list of servers [SEP] def _connect(self, servers):         \"\"\" connect to the given server, e.g.: \\\\connect localhost:4200 \"\"\"         self._do_connect(servers.split(' '))         self._verify_connection(verbose=True)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python script to run against a list of servers [SEP] def to_capitalized_camel_case(snake_case_string):     \"\"\"     Convert a string from snake case to camel case with the first letter capitalized. For example, \"some_var\"     would become \"SomeVar\".      :param snake_case_string: Snake-cased string to convert to camel case.     :returns: Camel-cased version of snake_case_string.     \"\"\"     parts = snake_case_string.split('_')     return ''.join([i.title() for i in parts])", "target": 0, "target_options": ["no match", "match"]}
{"input": "python script to run against a list of servers [SEP] def is_http_running_on(port):   \"\"\" Check if an http server runs on a given port.    Args:     The port to check.   Returns:     True if it is used by an http server. False otherwise.   \"\"\"   try:     conn = httplib.HTTPConnection('127.0.0.1:' + str(port))     conn.connect()     conn.close()     return True   except Exception:     return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python script to run against a list of servers [SEP] def insert_slash(string, every=2):     \"\"\"insert_slash insert / every 2 char\"\"\"     return os.path.join(string[i:i+every] for i in xrange(0, len(string), every))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python 3 check obj is num [SEP] def is_integer(obj):     \"\"\"Is this an integer.      :param object obj:     :return:     \"\"\"     if PYTHON3:         return isinstance(obj, int)     return isinstance(obj, (int, long))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python 3 check obj is num [SEP] def imshow(self, canvas, X, extent=None, label=None, vmin=None, vmax=None, **kwargs):         \"\"\"         Show the image stored in X on the canvas.                  The origin of the image show is (0,0), such that X[0,0] gets plotted at [0,0] of the image!                  the kwargs are plotting library specific kwargs!         \"\"\"         raise NotImplementedError(\"Implement all plot functions in AbstractPlottingLibrary in order to use your own plotting library\")", "target": 0, "target_options": ["no match", "match"]}
{"input": "python 3 check obj is num [SEP] def _is_bit(obj):     \"\"\"Determine if obj is a bit\"\"\"     # If there is a bit type this could be replaced by isinstance.     if isinstance(obj, tuple) and len(obj) == 2:         if isinstance(obj[0], Register) and isinstance(obj[1], int) and obj[1] < len(obj[0]):             return True     return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python 3 check obj is num [SEP] def intround(value):     \"\"\"Given a float returns a rounded int. Should give the same result on     both Py2/3     \"\"\"      return int(decimal.Decimal.from_float(         value).to_integral_value(decimal.ROUND_HALF_EVEN))", "target": 0, "target_options": ["no match", "match"]}
{"input": "removing an element from a dictionary python [SEP] def _remove_dict_keys_with_value(dict_, val):   \"\"\"Removes `dict` keys which have have `self` as value.\"\"\"   return {k: v for k, v in dict_.items() if v is not val}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "removing an element from a dictionary python [SEP] def _generate_instances(self):         \"\"\"         ListNode item generator. Will be used internally by __iter__ and __getitem__          Yields:             ListNode items (instances)         \"\"\"         for node in self.node_stack:             yield node         while self._data:             yield self._make_instance(self._data.pop(0))", "target": 0, "target_options": ["no match", "match"]}
{"input": "removing an element from a dictionary python [SEP] def pop (self, key):         \"\"\"Remove key from dict and return value.\"\"\"         if key in self._keys:             self._keys.remove(key)         super(ListDict, self).pop(key)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "removing an element from a dictionary python [SEP] def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value", "target": 0, "target_options": ["no match", "match"]}
{"input": "python 3 overriding print [SEP] def pstd(self, *args, **kwargs):         \"\"\" Console to STDOUT \"\"\"         kwargs['file'] = self.out         self.print(*args, **kwargs)         sys.stdout.flush()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python 3 overriding print [SEP] def timeout_thread_handler(timeout, stop_event):     \"\"\"A background thread to kill the process if it takes too long.      Args:         timeout (float): The number of seconds to wait before killing             the process.         stop_event (Event): An optional event to cleanly stop the background             thread if required during testing.     \"\"\"      stop_happened = stop_event.wait(timeout)     if stop_happened is False:         print(\"Killing program due to %f second timeout\" % timeout)      os._exit(2)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python 3 overriding print [SEP] def flushed_print(*args, **kwargs):     \"\"\"     Use to replace print(*args, flush=True) that doesn't exist for python<3.3     \"\"\"     print(*args, **kwargs)     file = kwargs.get('file', sys.stdout)     file.flush() if file is not None else sys.stdout.flush()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python 3 overriding print [SEP] def html(header_rows):     \"\"\"     Convert a list of tuples describing a table into a HTML string     \"\"\"     name = 'table%d' % next(tablecounter)     return HtmlTable([map(str, row) for row in header_rows], name).render()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python pretty print to a variable [SEP] def py(self, output):         \"\"\"Output data as a nicely-formatted python data structure\"\"\"         import pprint         pprint.pprint(output, stream=self.outfile)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python pretty print to a variable [SEP] def boolean(value):     \"\"\"     Configuration-friendly boolean type converter.      Supports both boolean-valued and string-valued inputs (e.g. from env vars).      \"\"\"     if isinstance(value, bool):         return value      if value == \"\":         return False      return strtobool(value)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python pretty print to a variable [SEP] def ss(*args, **kwargs):     \"\"\"     exactly like s, but doesn't return variable names or file positions (useful for logging)      since -- 10-15-2015     return -- str     \"\"\"     if not args:         raise ValueError(\"you didn't pass any arguments to print out\")      with Reflect.context(args, **kwargs) as r:         instance = V_CLASS(r, stream, **kwargs)         return instance.value().strip()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python pretty print to a variable [SEP] def S(self):         \"\"\":obj:`numpy.ndarray` : The 3x3 scaling matrix for this projection         \"\"\"         S = np.array([[self._plane_width / self._vol_width, 0, 0],                       [0, self._plane_height / self._vol_height, 0],                       [0, 0, self._depth_scale / self._vol_depth]])         return S", "target": 0, "target_options": ["no match", "match"]}
{"input": "python remove redundant elements of list [SEP] def dedup_list(l):     \"\"\"Given a list (l) will removing duplicates from the list,        preserving the original order of the list. Assumes that        the list entrie are hashable.\"\"\"     dedup = set()     return [ x for x in l if not (x in dedup or dedup.add(x))]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python remove redundant elements of list [SEP] def get_matrix(self):         \"\"\"  Use numpy to create a real matrix object from the data          :return: the matrix representation of the fvm         \"\"\"         return np.array([ self.get_row_list(i) for i in range(self.row_count()) ])", "target": 0, "target_options": ["no match", "match"]}
{"input": "python remove redundant elements of list [SEP] def unique(list):     \"\"\" Returns a copy of the list without duplicates.     \"\"\"     unique = []; [unique.append(x) for x in list if x not in unique]     return unique", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python remove redundant elements of list [SEP] def is_executable(path):   \"\"\"Returns whether a path names an existing executable file.\"\"\"   return os.path.isfile(path) and os.access(path, os.X_OK)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python only unique elements in list [SEP] def unique(list):     \"\"\" Returns a copy of the list without duplicates.     \"\"\"     unique = []; [unique.append(x) for x in list if x not in unique]     return unique", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python only unique elements in list [SEP] def convert_html_subscripts_to_latex(text):     \"\"\"Convert some HTML tags to latex equivalents.\"\"\"     text = re.sub(\"<sub>(.*?)</sub>\", r\"$_{\\1}$\", text)     text = re.sub(\"<sup>(.*?)</sup>\", r\"$^{\\1}$\", text)     return text", "target": 0, "target_options": ["no match", "match"]}
{"input": "python only unique elements in list [SEP] def remove_duplicates(lst):     \"\"\"     Emulate what a Python ``set()`` does, but keeping the element's order.     \"\"\"     dset = set()     return [l for l in lst if l not in dset and not dset.add(l)]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python only unique elements in list [SEP] def get_inputs_from_cm(index, cm):     \"\"\"Return indices of inputs to the node with the given index.\"\"\"     return tuple(i for i in range(cm.shape[0]) if cm[i][index])", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to animate a rotating line in python [SEP] def _rotate(n, x, y, rx, ry):     \"\"\"Rotate and flip a quadrant appropriately      Based on the implementation here:         https://en.wikipedia.org/w/index.php?title=Hilbert_curve&oldid=797332503      \"\"\"     if ry == 0:         if rx == 1:             x = n - 1 - x             y = n - 1 - y         return y, x     return x, y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to animate a rotating line in python [SEP] def get_input(input_func, input_str):     \"\"\"     Get input from the user given an input function and an input string     \"\"\"     val = input_func(\"Please enter your {0}: \".format(input_str))     while not val or not len(val.strip()):         val = input_func(\"You didn't enter a valid {0}, please try again: \".format(input_str))     return val", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to animate a rotating line in python [SEP] def rotate_left(self, seconds=None):         \"\"\"Rotate robot left.\"\"\"         self._move(speed=0, steering=STEER_MAX, seconds=seconds)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to animate a rotating line in python [SEP] def hex2dec(s):     \"\"\"     hex2dec     十六进制 to 十进制     :param s:     :return:     \"\"\"     if not isinstance(s, str):         s = str(s)     return int(s.upper(), 16)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python reading dict of a dict of a dict [SEP] def from_dict(cls, d):         \"\"\"         Makes XcFunc obey the general json interface used in pymatgen for easier serialization.         \"\"\"         return cls(xc=d.get(\"xc\"), x=d.get(\"x\"), c=d.get(\"c\"))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python reading dict of a dict of a dict [SEP] def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:     \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"     for line in file_like:         line = line.rstrip('\\r\\n')         if line:             yield line", "target": 0, "target_options": ["no match", "match"]}
{"input": "python reading dict of a dict of a dict [SEP] def unicode_dict(_dict):     \"\"\"     Make sure keys and values of dict is unicode.     \"\"\"     r = {}     for k, v in iteritems(_dict):         r[unicode_obj(k)] = unicode_obj(v)     return r", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python reading dict of a dict of a dict [SEP] def created_today(self):         \"\"\"Return True if created today.\"\"\"         if self.datetime.date() == datetime.today().date():             return True         return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "deleting all values from a dictionary in python [SEP] def normalize_dictionary(data_dict):     \"\"\"     Converts all the keys in \"data_dict\" to strings. The keys must be     convertible using str().     \"\"\"     for key, value in data_dict.items():         if not isinstance(key, str):             del data_dict[key]             data_dict[str(key)] = value     return data_dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "deleting all values from a dictionary in python [SEP] def __init__(self, baken_file=None):         \"\"\"Initialise a new `Bakens` object.\"\"\"         super(Bakens, self).__init__()         if baken_file:             self.import_locations(baken_file)", "target": 0, "target_options": ["no match", "match"]}
{"input": "deleting all values from a dictionary in python [SEP] def rm_keys_from_dict(d, keys):     \"\"\"     Given a dictionary and a key list, remove any data in the dictionary with the given keys.      :param dict d: Metadata     :param list keys: Keys to be removed     :return dict d: Metadata     \"\"\"     # Loop for each key given     for key in keys:         # Is the key in the dictionary?         if key in d:             try:                 d.pop(key, None)             except KeyError:                 # Not concerned with an error. Keep going.                 pass     return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "deleting all values from a dictionary in python [SEP] def finish_plot():     \"\"\"Helper for plotting.\"\"\"     plt.legend()     plt.grid(color='0.7')     plt.xlabel('x')     plt.ylabel('y')     plt.show()", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to check a string is decimal in python 2 [SEP] def is_dec(ip):     \"\"\"Return true if the IP address is in decimal notation.\"\"\"     try:         dec = int(str(ip))     except ValueError:         return False     if dec > 4294967295 or dec < 0:         return False     return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to check a string is decimal in python 2 [SEP] def firmware_download_input_rbridge_id(self, **kwargs):         \"\"\"Auto Generated Code         \"\"\"         config = ET.Element(\"config\")         firmware_download = ET.Element(\"firmware_download\")         config = firmware_download         input = ET.SubElement(firmware_download, \"input\")         rbridge_id = ET.SubElement(input, \"rbridge-id\")         rbridge_id.text = kwargs.pop('rbridge_id')          callback = kwargs.pop('callback', self._callback)         return callback(config)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to check a string is decimal in python 2 [SEP] def _isint(string):     \"\"\"     >>> _isint(\"123\")     True     >>> _isint(\"123.45\")     False     \"\"\"     return type(string) is int or \\            (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\            _isconvertible(int, string)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to check a string is decimal in python 2 [SEP] def executeMethod(self, methodName, args):     \"\"\"Executes a method named ``methodName`` with the specified arguments.      This method is called when the user executes a command as defined in     the node spec. It provides a perfectly reasonble implementation     of the command mechanism. As a sub-class developer you just need to     implement a method for each command in the node spec. Note that due to     the command mechanism only unnamed argument are supported.      :param methodName: (string) the name of the method that correspond to a            command in the spec.     :param args: (list) of arguments that will be passed to the method     \"\"\"     if not hasattr(self, methodName):       raise Exception('Missing command method: ' + methodName)      m = getattr(self, methodName)     if not hasattr(m, '__call__'):       raise Exception('Command: ' + methodName + ' must be callable')      return m(*args)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python, how to put a variable in a string [SEP] def __str__(self):         \"\"\"Returns full address string.\"\"\"         return \"{}\\n{}, {} {}\".format(self.street, self.city, self.state, self.postal_code)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python, how to put a variable in a string [SEP] def etree_write(tree, stream):     \"\"\"     Write XML ElementTree 'root' content into 'stream'.      :param tree: XML ElementTree object     :param stream: File or file-like object can write to     \"\"\"     try:         tree.write(stream, encoding=\"utf-8\", xml_declaration=True)     except TypeError:         tree.write(stream, encoding=\"unicode\", xml_declaration=True)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python, how to put a variable in a string [SEP] def full_name(self):         \"\"\"         You can get full name of user.          :return: str         \"\"\"         full_name = self.first_name         if self.last_name:             full_name += ' ' + self.last_name         return full_name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python, how to put a variable in a string [SEP] def close(self):         \"\"\"Close the connection.\"\"\"         if self.sock:             self.sock.close()         self.sock = 0         self.eof = 1", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to pull 4 keys from a dictionary [SEP] def key_of(d):     \"\"\"     Returns the key of a single element dict.     \"\"\"     if len(d) > 1 and not type(d) == dict():         raise ValueError('key_of(d) may only except single element dict')     else:         return keys_of(d)[0]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to pull 4 keys from a dictionary [SEP] def is_present(self, selector):         \"\"\"Check if an element is present in the dom or not          This method won't check if the element is displayed or not         This method won't wait until the element is visible or present         This method won't raise any exception if the element is not present          Returns:             bool: True if the element is present; False otherwise         \"\"\"         self.debug_log(\"Is present (%s)\" % selector)          element = self.find(             selector,             raise_exception=False,             wait_until_present=False,             wait_until_visible=False         )         if element:             self.debug_log(\"is present: True\")             return True         else:             self.debug_log(\"is present: False\")             return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to pull 4 keys from a dictionary [SEP] def get_single_item(d):     \"\"\"Get an item from a dict which contains just one item.\"\"\"     assert len(d) == 1, 'Single-item dict must have just one item, not %d.' % len(d)     return next(six.iteritems(d))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to pull 4 keys from a dictionary [SEP] def server(port):     \"\"\"Start the Django dev server.\"\"\"     args = ['python', 'manage.py', 'runserver']     if port:         args.append(port)     run.main(args)", "target": 0, "target_options": ["no match", "match"]}
{"input": "strip second word python [SEP] def lowstrip(term):     \"\"\"Convert to lowercase and strip spaces\"\"\"     term = re.sub('\\s+', ' ', term)     term = term.lower()     return term", "target": 1, "target_options": ["no_match", "match"]}
{"input": "strip second word python [SEP] def acc_hash(filepath: str, hasher):     \"\"\"Accumulate content of file at `filepath` in `hasher`.\"\"\"     with open(filepath, 'rb') as f:         while True:             chunk = f.read(_BUF_SIZE)             if not chunk:                 break             hasher.update(chunk)", "target": 0, "target_options": ["no match", "match"]}
{"input": "strip second word python [SEP] def format_single_space_only(text):     \"\"\"Revise consecutive empty space to single space.      Example::          \" I   feel    so  GOOD!\" => \"This is so GOOD!\"      **中文文档**      确保文本中不会出现多余连续1次的空格。     \"\"\"     return \" \".join([word for word in text.strip().split(\" \") if len(word) >= 1])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "strip second word python [SEP] def walk_tree(root):     \"\"\"Pre-order depth-first\"\"\"     yield root      for child in root.children:         for el in walk_tree(child):             yield el", "target": 0, "target_options": ["no match", "match"]}
{"input": "python open a web page and save all text [SEP] def wget(url):     \"\"\"     Download the page into a string     \"\"\"     import urllib.parse     request = urllib.request.urlopen(url)     filestring = request.read()     return filestring", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python open a web page and save all text [SEP] def is_number(obj):     \"\"\"     Helper function to determine numbers     across Python 2.x and 3.x     \"\"\"     try:         from numbers import Number     except ImportError:         from operator import isNumberType         return isNumberType(obj)     else:         return isinstance(obj, Number)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python open a web page and save all text [SEP] def Output(self):     \"\"\"Output all sections of the page.\"\"\"     self.Open()     self.Header()     self.Body()     self.Footer()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python open a web page and save all text [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 0, "target_options": ["no match", "match"]}
{"input": "extracting time from datetime object python [SEP] def timestamp_to_datetime(timestamp):     \"\"\"Convert an ARF timestamp to a datetime.datetime object (naive local time)\"\"\"     from datetime import datetime, timedelta     obj = datetime.fromtimestamp(timestamp[0])     return obj + timedelta(microseconds=int(timestamp[1]))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "extracting time from datetime object python [SEP] def _factln(num):     # type: (int) -> float     \"\"\"     Computes logfactorial regularly for tractable numbers, uses Ramanujans approximation otherwise.     \"\"\"      if num < 20:         log_factorial = log(factorial(num))     else:         log_factorial = num * log(num) - num + log(num * (1 + 4 * num * (             1 + 2 * num))) / 6.0 + log(pi) / 2      return log_factorial", "target": 0, "target_options": ["no match", "match"]}
{"input": "extracting time from datetime object python [SEP] def unmarshal(self, v):         \"\"\"         Convert a date in \"2012-12-13\" format to a :class:`datetime.date` object.         \"\"\"         if not isinstance(v, date):             # 2012-12-13             v = datetime.strptime(v, \"%Y-%m-%d\").date()         return v", "target": 1, "target_options": ["no_match", "match"]}
{"input": "extracting time from datetime object python [SEP] def csvpretty(csvfile: csvfile=sys.stdin):     \"\"\" Pretty print a CSV file. \"\"\"     shellish.tabulate(csv.reader(csvfile))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python directory tree print [SEP] def print_tree(self, indent=2):         \"\"\" print_tree: prints out structure of tree             Args: indent (int): What level of indentation at which to start printing             Returns: None         \"\"\"         config.LOGGER.info(\"{indent}{data}\".format(indent=\"   \" * indent, data=str(self)))         for child in self.children:             child.print_tree(indent + 1)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python directory tree print [SEP] def file_read(filename):     \"\"\"Read a file and close it.  Returns the file source.\"\"\"     fobj = open(filename,'r');     source = fobj.read();     fobj.close()     return source", "target": 0, "target_options": ["no match", "match"]}
{"input": "python directory tree print [SEP] def print_item_with_children(ac, classes, level):     \"\"\" Print the given item and all children items \"\"\"     print_row(ac.id, ac.name, f\"{ac.allocation:,.2f}\", level)     print_children_recursively(classes, ac, level + 1)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python directory tree print [SEP] def _is_bit(obj):     \"\"\"Determine if obj is a bit\"\"\"     # If there is a bit type this could be replaced by isinstance.     if isinstance(obj, tuple) and len(obj) == 2:         if isinstance(obj[0], Register) and isinstance(obj[1], int) and obj[1] < len(obj[0]):             return True     return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "read variable in different file python [SEP] def file_read(filename):     \"\"\"Read a file and close it.  Returns the file source.\"\"\"     fobj = open(filename,'r');     source = fobj.read();     fobj.close()     return source", "target": 1, "target_options": ["no_match", "match"]}
{"input": "read variable in different file python [SEP] def isAlphanum(c):     \"\"\"return true if the character is a letter, digit, underscore,            dollar sign, or non-ASCII character.     \"\"\"     return ((c >= 'a' and c <= 'z') or (c >= '0' and c <= '9') or             (c >= 'A' and c <= 'Z') or c == '_' or c == '$' or c == '\\\\' or (c is not None and ord(c) > 126));", "target": 0, "target_options": ["no match", "match"]}
{"input": "read variable in different file python [SEP] def Load(file):     \"\"\" Loads a model from specified file \"\"\"     with open(file, 'rb') as file:         model = dill.load(file)         return model", "target": 1, "target_options": ["no_match", "match"]}
{"input": "read variable in different file python [SEP] def isin(elems, line):     \"\"\"Check if an element from a list is in a string.      :type elems: list     :type line: str      \"\"\"     found = False     for e in elems:         if e in line.lower():             found = True             break     return found", "target": 0, "target_options": ["no match", "match"]}
{"input": "print to create a range in python [SEP] def frange(start, stop, step, precision):     \"\"\"A generator that will generate a range of floats.\"\"\"     value = start     while round(value, precision) < stop:         yield round(value, precision)         value += step", "target": 1, "target_options": ["no_match", "match"]}
{"input": "print to create a range in python [SEP] def get_subdirs(parent_path):   \"\"\"Return a list of (name, path) tuples of direct subdirectories of      parent_path, where each tuple corresponds to one subdirectory. Files     in the parent_path are excluded from the output.     \"\"\"   entries = os.listdir(parent_path)   subdirs = [(entry, os.path.join(parent_path, entry))              for entry in entries              if os.path.isdir(entry)]   return subdirs", "target": 0, "target_options": ["no match", "match"]}
{"input": "print to create a range in python [SEP] def extent(self):          \"\"\"         return range of 2D data         \"\"\"          return [min(self.x), max(self.x), min(self.y), max(self.y)]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "print to create a range in python [SEP] def find_first_in_list(txt: str, str_list: [str]) -> int:  # type: ignore     \"\"\"     Returns the index of the earliest occurence of an item from a list in a string      Ex: find_first_in_list('foobar', ['bar', 'fin']) -> 3     \"\"\"     start = len(txt) + 1     for item in str_list:         if start > txt.find(item) > -1:             start = txt.find(item)     return start if len(txt) + 1 > start > -1 else -1", "target": 0, "target_options": ["no match", "match"]}
{"input": "output dispaly python shell [SEP] def out(self, output, newline=True):         \"\"\"Outputs a string to the console (stdout).\"\"\"         click.echo(output, nl=newline)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "output dispaly python shell [SEP] def getbyteslice(self, start, end):         \"\"\"Direct access to byte data.\"\"\"         c = self._rawarray[start:end]         return c", "target": 0, "target_options": ["no match", "match"]}
{"input": "output dispaly python shell [SEP] def call_out(command):   \"\"\"   Run the given command (with shell=False) and return a tuple of   (int returncode, str output). Strip the output of enclosing whitespace.   \"\"\"   # start external command process   p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)    # get outputs   out, _ = p.communicate()    return p.returncode, out.strip()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "output dispaly python shell [SEP] def random_id(length):     \"\"\"Generates a random ID of given length\"\"\"      def char():         \"\"\"Generate single random char\"\"\"          return random.choice(string.ascii_letters + string.digits)      return \"\".join(char() for _ in range(length))", "target": 0, "target_options": ["no match", "match"]}
{"input": "string saprete to letter python [SEP] def format_name(text):     \"\"\"Format a comic name.\"\"\"     name = unescape(text)     name = asciify(name.replace(u'&', u'And').replace(u'@', u'At'))     name = capfirst(name)     return name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "string saprete to letter python [SEP] def column(self, i):          \"\"\"from right\"\"\"         return ''.join([str(digitat2(r,i)) for r in self])", "target": 0, "target_options": ["no match", "match"]}
{"input": "string saprete to letter python [SEP] def normalize(pw):     \"\"\" Lower case, and change the symbols to closest characters\"\"\"     pw_lower = pw.lower()     return ''.join(helper.L33T.get(c, c) for c in pw_lower)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "string saprete to letter python [SEP] def sing(a, b, c=False, name='yetone'):     \"\"\"sing a song     hehe      :param a: I'm a     :param b: I'm b     :param c: I'm c     :param name: I'm name     \"\"\"     print('test0.sing: <a: {}, b: {}, c: {}> by {}'.format(a, b, c, name))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to access element of matrix python [SEP] def lengths( self ):         \"\"\"         The cell lengths.          Args:             None          Returns:             (np.array(a,b,c)): The cell lengths.         \"\"\"         return( np.array( [ math.sqrt( sum( row**2 ) ) for row in self.matrix ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to access element of matrix python [SEP] def __str__(self): \t\t\"\"\" Convert to string  \t\t:return: str \t\t\"\"\" \t\taddress = [\"{:02x}\".format(int(x)) for x in self.__address] \t\treturn ':'.join(address)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to access element of matrix python [SEP] def to_list(self):         \"\"\"Convert this confusion matrix into a 2x2 plain list of values.\"\"\"         return [[int(self.table.cell_values[0][1]), int(self.table.cell_values[0][2])],                 [int(self.table.cell_values[1][1]), int(self.table.cell_values[1][2])]]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to access element of matrix python [SEP] def stringify_dict_contents(dct):     \"\"\"Turn dict keys and values into native strings.\"\"\"     return {         str_if_nested_or_str(k): str_if_nested_or_str(v)         for k, v in dct.items()     }", "target": 0, "target_options": ["no match", "match"]}
{"input": "python replace a list in matrix with another list [SEP] def Tmatrix(X):     \"\"\"     gets the orientation matrix (T) from data in X     \"\"\"     T = [[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]]     for row in X:         for k in range(3):             for l in range(3):                 T[k][l] += row[k] * row[l]     return T", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python replace a list in matrix with another list [SEP] def readTuple(self, line, n=3):         \"\"\" Reads a tuple of numbers. e.g. vertices, normals or teture coords.         \"\"\"         numbers = [num for num in line.split(' ') if num]         return [float(num) for num in numbers[1:n + 1]]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python replace a list in matrix with another list [SEP] def transform(foci, mat):     \"\"\" Convert coordinates from one space to another using provided     transformation matrix. \"\"\"     t = linalg.pinv(mat)     foci = np.hstack((foci, np.ones((foci.shape[0], 1))))     return np.dot(foci, t)[:, 0:3]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python replace a list in matrix with another list [SEP] def _uniquify(_list):     \"\"\"Remove duplicates in a list.\"\"\"     seen = set()     result = []     for x in _list:         if x not in seen:             result.append(x)             seen.add(x)     return result", "target": 0, "target_options": ["no match", "match"]}
{"input": "python numpy array how to add values [SEP] def append(self, value):         \"\"\"         \"\"\"         if isinstance(value, nparray.ndarray):             value = value.to_array()          new_value = np.append(self.get_value(), value)         self.set_value(new_value)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python numpy array how to add values [SEP] def local_accuracy(X_train, y_train, X_test, y_test, attr_test, model_generator, metric, trained_model):     \"\"\" The how well do the features plus a constant base rate sum up to the model output.     \"\"\"      X_train, X_test = to_array(X_train, X_test)      # how many features to mask     assert X_train.shape[1] == X_test.shape[1]      # keep nkeep top features and re-train the model for each test explanation     yp_test = trained_model.predict(X_test)      return metric(yp_test, strip_list(attr_test).sum(1))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python numpy array how to add values [SEP] def add(self, x, axis):         \"\"\"Function to add 3D View with vector or 2D array (type = numpy.ndarray or 2D Field or 2D View) or 2D View with vector (type = numpy.ndarray)         :param x: array(1D, 2D) or field (2D) or View(2D)         :param axis: specifies axis, eg. axis = (1,2) plane lies in yz-plane, axis=0 vector along x axis         :return: dict with result of operation (same form as view.d)         \"\"\"         return self.__array_op(operator.add, x, axis)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python numpy array how to add values [SEP] def normalize(data):     \"\"\"     Function to normalize data to have mean 0 and unity standard deviation     (also called z-transform)               Parameters     ----------     data : numpy.ndarray               Returns     -------     numpy.ndarray         z-transform of input array          \"\"\"     data = data.astype(float)     data -= data.mean()          return data / data.std()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python read tuples from file [SEP] def readTuple(self, line, n=3):         \"\"\" Reads a tuple of numbers. e.g. vertices, normals or teture coords.         \"\"\"         numbers = [num for num in line.split(' ') if num]         return [float(num) for num in numbers[1:n + 1]]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python read tuples from file [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python read tuples from file [SEP] def _parse_tuple_string(argument):         \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"         if isinstance(argument, str):             return tuple(int(p.strip()) for p in argument.split(','))         return argument", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python read tuples from file [SEP] def extend(a: dict, b: dict) -> dict:     \"\"\"Merge two dicts and return a new dict. Much like subclassing works.\"\"\"     res = a.copy()     res.update(b)     return res", "target": 0, "target_options": ["no match", "match"]}
{"input": "pythone current process memory usage [SEP] def get_memory_usage():     \"\"\"Gets RAM memory usage      :return: MB of memory used by this process     \"\"\"     process = psutil.Process(os.getpid())     mem = process.memory_info().rss     return mem / (1024 * 1024)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "pythone current process memory usage [SEP] def format_single_space_only(text):     \"\"\"Revise consecutive empty space to single space.      Example::          \" I   feel    so  GOOD!\" => \"This is so GOOD!\"      **中文文档**      确保文本中不会出现多余连续1次的空格。     \"\"\"     return \" \".join([word for word in text.strip().split(\" \") if len(word) >= 1])", "target": 0, "target_options": ["no match", "match"]}
{"input": "pythone current process memory usage [SEP] def machine_info():     \"\"\"Retrieve core and memory information for the current machine.     \"\"\"     import psutil     BYTES_IN_GIG = 1073741824.0     free_bytes = psutil.virtual_memory().total     return [{\"memory\": float(\"%.1f\" % (free_bytes / BYTES_IN_GIG)), \"cores\": multiprocessing.cpu_count(),              \"name\": socket.gethostname()}]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "pythone current process memory usage [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 0, "target_options": ["no match", "match"]}
{"input": "list choronical order python [SEP] def toposort_flatten(data, sort=True):     \"\"\"Returns a single list of dependencies. For any set returned by toposort(), those items are sorted and appended to the result (just to make the results deterministic).\"\"\"      result = []     for d in toposort(data):         try:             result.extend((sorted if sort else list)(d))         except TypeError as e:             result.extend(list(d))     return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "list choronical order python [SEP] def normalize(data):     \"\"\"     Function to normalize data to have mean 0 and unity standard deviation     (also called z-transform)               Parameters     ----------     data : numpy.ndarray               Returns     -------     numpy.ndarray         z-transform of input array          \"\"\"     data = data.astype(float)     data -= data.mean()          return data / data.std()", "target": 0, "target_options": ["no match", "match"]}
{"input": "list choronical order python [SEP] def csort(objs, key):     \"\"\"Order-preserving sorting function.\"\"\"     idxs = dict((obj, i) for (i, obj) in enumerate(objs))     return sorted(objs, key=lambda obj: (key(obj), idxs[obj]))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "list choronical order python [SEP] def shape(self):         \"\"\"Compute the shape of the dataset as (rows, cols).\"\"\"         if not self.data:             return (0, 0)         return (len(self.data), len(self.dimensions))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python get last n rows from list [SEP] def tail(self, n=10):         \"\"\"         Get an SArray that contains the last n elements in the SArray.          Parameters         ----------         n : int             The number of elements to fetch          Returns         -------         out : SArray             A new SArray which contains the last n rows of the current SArray.         \"\"\"         with cython_context():             return SArray(_proxy=self.__proxy__.tail(n))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python get last n rows from list [SEP] def get_memory_usage():     \"\"\"Gets RAM memory usage      :return: MB of memory used by this process     \"\"\"     process = psutil.Process(os.getpid())     mem = process.memory_info().rss     return mem / (1024 * 1024)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python get last n rows from list [SEP] def searchlast(self,n=10):         \"\"\"Return the last n results (or possibly less if not found). Note that the last results are not necessarily the best ones! Depending on the search type.\"\"\"                     solutions = deque([], n)         for solution in self:             solutions.append(solution)         return solutions", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python get last n rows from list [SEP] def is_break_tag(self, el):         \"\"\"Check if tag is an element we should break on.\"\"\"          name = el.name         return name in self.break_tags or name in self.user_break_tags", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to index a matrix python [SEP] def get_inputs_from_cm(index, cm):     \"\"\"Return indices of inputs to the node with the given index.\"\"\"     return tuple(i for i in range(cm.shape[0]) if cm[i][index])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to index a matrix python [SEP] def _isint(string):     \"\"\"     >>> _isint(\"123\")     True     >>> _isint(\"123.45\")     False     \"\"\"     return type(string) is int or \\            (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\            _isconvertible(int, string)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to index a matrix python [SEP] def _transform_triple_numpy(x):     \"\"\"Transform triple index into a 1-D numpy array.\"\"\"     return np.array([x.head, x.relation, x.tail], dtype=np.int64)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to index a matrix python [SEP] def inFocus(self):         \"\"\"Set GUI on-top flag\"\"\"         previous_flags = self.window.flags()         self.window.setFlags(previous_flags |                              QtCore.Qt.WindowStaysOnTopHint)", "target": 0, "target_options": ["no match", "match"]}
{"input": "pass list to argparse python [SEP] def parse_command_args():     \"\"\"Command line parser.\"\"\"     parser = argparse.ArgumentParser(description='Register PB devices.')     parser.add_argument('num_pb', type=int,                         help='Number of PBs devices to register.')     return parser.parse_args()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "pass list to argparse python [SEP] def flushed_print(*args, **kwargs):     \"\"\"     Use to replace print(*args, flush=True) that doesn't exist for python<3.3     \"\"\"     print(*args, **kwargs)     file = kwargs.get('file', sys.stdout)     file.flush() if file is not None else sys.stdout.flush()", "target": 0, "target_options": ["no match", "match"]}
{"input": "pass list to argparse python [SEP] def add_to_parser(self, parser):         \"\"\"         Adds the argument to an argparse.ArgumentParser instance          @param parser An argparse.ArgumentParser instance         \"\"\"         kwargs = self._get_kwargs()         args = self._get_args()         parser.add_argument(*args, **kwargs)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "pass list to argparse python [SEP] def list2dict(lst):     \"\"\"Takes a list of (key,value) pairs and turns it into a dict.\"\"\"      dic = {}     for k,v in lst: dic[k] = v     return dic", "target": 0, "target_options": ["no match", "match"]}
{"input": "python conver nan to none [SEP] def clean_with_zeros(self,x):         \"\"\" set nan and inf rows from x to zero\"\"\"         x[~np.any(np.isnan(x) | np.isinf(x),axis=1)] = 0         return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python conver nan to none [SEP] def plot_curves_z(data, name, title=None):     \"\"\"Generates a simple plot of the quasiparticle weight decay curves given        data object with doping setup\"\"\"      plt.figure()     for zet, c in zip(data['zeta'], data['doping']):         plt.plot(data['u_int'], zet[:, 0], label='$n={}$'.format(str(c)))     if title != None:         plt.title(title)     label_saves(name+'.png')", "target": 0, "target_options": ["no match", "match"]}
{"input": "python conver nan to none [SEP] def clean_dataframe(df):     \"\"\"Fill NaNs with the previous value, the next value or if all are NaN then 1.0\"\"\"     df = df.fillna(method='ffill')     df = df.fillna(0.0)     return df", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python conver nan to none [SEP] def compose_all(tups):   \"\"\"Compose all given tuples together.\"\"\"   from . import ast  # I weep for humanity   return functools.reduce(lambda x, y: x.compose(y), map(ast.make_tuple, tups), ast.make_tuple({}))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python add object to dict repeatly [SEP] def as_dictionary(self):         \"\"\"         Convert this object to a dictionary with formatting appropriate for a PIF.          :returns: Dictionary with the content of this object formatted for a PIF.         \"\"\"         return {to_camel_case(i): Serializable._convert_to_dictionary(self.__dict__[i])                 for i in self.__dict__ if self.__dict__[i] is not None}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python add object to dict repeatly [SEP] def flatten_list(x: List[Any]) -> List[Any]:     \"\"\"     Converts a list of lists into a flat list.          Args:         x: list of lists       Returns:         flat list              As per     http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python      \"\"\"  # noqa     return [item for sublist in x for item in sublist]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python add object to dict repeatly [SEP] def _zeep_to_dict(cls, obj):         \"\"\"Convert a zeep object to a dictionary.\"\"\"         res = serialize_object(obj)         res = cls._get_non_empty_dict(res)         return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python add object to dict repeatly [SEP] def get_pants_configdir():   \"\"\"Return the pants global config directory.\"\"\"   # Follow the unix XDB base spec: http://standards.freedesktop.org/basedir-spec/latest/index.html.   config_home = os.environ.get('XDG_CONFIG_HOME')   if not config_home:     config_home = '~/.config'   return os.path.expanduser(os.path.join(config_home, 'pants'))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to make matrix in python numpy [SEP] def get_matrix(self):         \"\"\"  Use numpy to create a real matrix object from the data          :return: the matrix representation of the fvm         \"\"\"         return np.array([ self.get_row_list(i) for i in range(self.row_count()) ])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to make matrix in python numpy [SEP] def remove_duplicates(lst):     \"\"\"     Emulate what a Python ``set()`` does, but keeping the element's order.     \"\"\"     dset = set()     return [l for l in lst if l not in dset and not dset.add(l)]", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to make matrix in python numpy [SEP] def length(self):         \"\"\"Array of vector lengths\"\"\"         return np.sqrt(np.sum(self**2, axis=1)).view(np.ndarray)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to make matrix in python numpy [SEP] def apply_mana_drain(self):         \"\"\"Clear current mana values.\"\"\"         self.r = self.g = self.b = self.y = 0", "target": 0, "target_options": ["no match", "match"]}
{"input": "one hot encoder binning python [SEP] def hex_escape(bin_str):   \"\"\"   Hex encode a binary string   \"\"\"   printable = string.ascii_letters + string.digits + string.punctuation + ' '   return ''.join(ch if ch in printable else r'0x{0:02x}'.format(ord(ch)) for ch in bin_str)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "one hot encoder binning python [SEP] def main(ctx, connection):     \"\"\"Command line interface for PyBEL.\"\"\"     ctx.obj = Manager(connection=connection)     ctx.obj.bind()", "target": 0, "target_options": ["no match", "match"]}
{"input": "one hot encoder binning python [SEP] def feature_encoders(self, data_dir):     \"\"\"Return a dict for encoding and decoding inference input/output.      Args:       data_dir: data directory      Returns:       A dict of <feature name, TextEncoder>.      \"\"\"     encoders = (super(BabiQa, self).feature_encoders(data_dir))     label_encoder = self.get_labels_encoder(data_dir)     encoders[\"targets\"] = label_encoder  # bAbi as a classification task     return encoders", "target": 1, "target_options": ["no_match", "match"]}
{"input": "one hot encoder binning python [SEP] def clean_with_zeros(self,x):         \"\"\" set nan and inf rows from x to zero\"\"\"         x[~np.any(np.isnan(x) | np.isinf(x),axis=1)] = 0         return x", "target": 0, "target_options": ["no match", "match"]}
{"input": "time to timedelta python [SEP] def run_time() -> timedelta:     \"\"\"      :return:     \"\"\"      delta = start_time if start_time else datetime.utcnow()     return datetime.utcnow() - delta", "target": 1, "target_options": ["no_match", "match"]}
{"input": "time to timedelta python [SEP] def txt_line_iterator(path):   \"\"\"Iterate through lines of file.\"\"\"   with tf.gfile.Open(path) as f:     for line in f:       yield line.strip()", "target": 0, "target_options": ["no match", "match"]}
{"input": "time to timedelta python [SEP] def elapsed_time_from(start_time):     \"\"\"calculate time delta from latched time and current time\"\"\"     time_then = make_time(start_time)     time_now = datetime.utcnow().replace(microsecond=0)     if time_then is None:         return     delta_t = time_now - time_then     return delta_t", "target": 1, "target_options": ["no_match", "match"]}
{"input": "time to timedelta python [SEP] def intround(value):     \"\"\"Given a float returns a rounded int. Should give the same result on     both Py2/3     \"\"\"      return int(decimal.Decimal.from_float(         value).to_integral_value(decimal.ROUND_HALF_EVEN))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python communicate str bytes [SEP] def bytes_to_str(s, encoding='utf-8'):     \"\"\"Returns a str if a bytes object is given.\"\"\"     if six.PY3 and isinstance(s, bytes):         return s.decode(encoding)     return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python communicate str bytes [SEP] def get_randomized_guid_sample(self, item_count):         \"\"\" Fetch a subset of randomzied GUIDs from the whitelist \"\"\"         dataset = self.get_whitelist()         random.shuffle(dataset)         return dataset[:item_count]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python communicate str bytes [SEP] def to_bytes(s, encoding=\"utf-8\"):     \"\"\"Convert a string to bytes.\"\"\"     if isinstance(s, six.binary_type):         return s     if six.PY3:         return bytes(s, encoding)     return s.encode(encoding)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python communicate str bytes [SEP] def index(self, item):         \"\"\" Not recommended for use on large lists due to time             complexity, but it works              -> #int list index of @item         \"\"\"         for i, x in enumerate(self.iter()):             if x == item:                 return i         return None", "target": 0, "target_options": ["no match", "match"]}
{"input": "print matrix object python [SEP] def _get_pretty_string(obj):     \"\"\"Return a prettier version of obj      Parameters     ----------     obj : object         Object to pretty print      Returns     -------     s : str         Pretty print object repr     \"\"\"     sio = StringIO()     pprint.pprint(obj, stream=sio)     return sio.getvalue()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "print matrix object python [SEP] def _parse_tuple_string(argument):         \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"         if isinstance(argument, str):             return tuple(int(p.strip()) for p in argument.split(','))         return argument", "target": 0, "target_options": ["no match", "match"]}
{"input": "print matrix object python [SEP] def get_object_info(self):         \"\"\"         Returns object info in following form <module.class object at address>         \"\"\"         objectinfo = str(self.__class__).replace(\">\", \"\")         objectinfo = objectinfo.replace(\"class \", \"\")         objectinfo = objectinfo.replace(\"'\", \"\")         objectinfo += \" object at 0x%x>\" % id(self)         return objectinfo", "target": 1, "target_options": ["no_match", "match"]}
{"input": "print matrix object python [SEP] def strToBool(val):     \"\"\"     Helper function to turn a string representation of \"true\" into     boolean True.     \"\"\"     if isinstance(val, str):         val = val.lower()      return val in ['true', 'on', 'yes', True]", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to remove duplicates from a text file python [SEP] def remove_dups(seq):     \"\"\"remove duplicates from a sequence, preserving order\"\"\"     seen = set()     seen_add = seen.add     return [x for x in seq if not (x in seen or seen_add(x))]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to remove duplicates from a text file python [SEP] def get_object_info(self):         \"\"\"         Returns object info in following form <module.class object at address>         \"\"\"         objectinfo = str(self.__class__).replace(\">\", \"\")         objectinfo = objectinfo.replace(\"class \", \"\")         objectinfo = objectinfo.replace(\"'\", \"\")         objectinfo += \" object at 0x%x>\" % id(self)         return objectinfo", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to remove duplicates from a text file python [SEP] def read_set_from_file(filename: str) -> Set[str]:     \"\"\"     Extract a de-duped collection (set) of text from a file.     Expected file format is one item per line.     \"\"\"     collection = set()     with open(filename, 'r') as file_:         for line in file_:             collection.add(line.rstrip())     return collection", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to remove duplicates from a text file python [SEP] def sflow_sample_rate(self, **kwargs):         \"\"\"Auto Generated Code         \"\"\"         config = ET.Element(\"config\")         sflow = ET.SubElement(config, \"sflow\", xmlns=\"urn:brocade.com:mgmt:brocade-sflow\")         sample_rate = ET.SubElement(sflow, \"sample-rate\")         sample_rate.text = kwargs.pop('sample_rate')          callback = kwargs.pop('callback', self._callback)         return callback(config)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python elasticsearch query dynamic condition [SEP] def search_on(self, *fields, **query):         \"\"\"         Search for query on given fields.          Query modifier can be one of these:             * exact             * contains             * startswith             * endswith             * range             * lte             * gte          Args:             \\*fields (str): Field list to be searched on             \\*\\*query:  Search query. While it's implemented as \\*\\*kwargs              we only support one (first) keyword argument.          Returns:             Self. Queryset object.          Examples:             >>> Person.objects.search_on('name', 'surname', contains='john')             >>> Person.objects.search_on('name', 'surname', startswith='jo')         \"\"\"         search_type = list(query.keys())[0]         parsed_query = self._parse_query_modifier(search_type, query[search_type], False)         self.add_query([(\"OR_QRY\", dict([(f, parsed_query) for f in fields]), True)])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python elasticsearch query dynamic condition [SEP] def add_suffix(filename, suffix):         \"\"\"         ADD suffix TO THE filename (NOT INCLUDING THE FILE EXTENSION)         \"\"\"         path = filename.split(\"/\")         parts = path[-1].split(\".\")         i = max(len(parts) - 2, 0)         parts[i] = parts[i] + suffix         path[-1] = \".\".join(parts)         return \"/\".join(path)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python elasticsearch query dynamic condition [SEP] def _term(self, term):         \"\"\"Add a term to the query.          Arguments:             term (str): The term to add.          Returns:             SearchHelper: Self         \"\"\"         # All terms must be strings for Elasticsearch         term = str(term)         if term:             self.__query[\"q\"] += term         return self", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python elasticsearch query dynamic condition [SEP] def _isint(string):     \"\"\"     >>> _isint(\"123\")     True     >>> _isint(\"123.45\")     False     \"\"\"     return type(string) is int or \\            (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\            _isconvertible(int, string)", "target": 0, "target_options": ["no match", "match"]}
{"input": "create document term matrix in python with tdidfvectorizer todense [SEP] def tt_comp(self, sampled_topics):          \"\"\"         Compute term-topic matrix from sampled_topics.         \"\"\"          samples = sampled_topics.shape[0]         tt = np.zeros((self.V, self.K, samples))          for s in range(samples):                         tt[:, :, s] = \\                 samplers_lda.tt_comp(self.tokens, sampled_topics[s, :],                                      self.N, self.V, self.K, self.beta)          return tt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "create document term matrix in python with tdidfvectorizer todense [SEP] def _connect(self, servers):         \"\"\" connect to the given server, e.g.: \\\\connect localhost:4200 \"\"\"         self._do_connect(servers.split(' '))         self._verify_connection(verbose=True)", "target": 0, "target_options": ["no match", "match"]}
{"input": "create document term matrix in python with tdidfvectorizer todense [SEP] def dt_comp(self, sampled_topics):          \"\"\"         Compute document-topic matrix from sampled_topics.         \"\"\"          samples = sampled_topics.shape[0]         dt = np.zeros((self.D, self.K, samples))          for s in range(samples):                             dt[:, :, s] = \\                     samplers_lda.dt_comp(self.docid, sampled_topics[s, :],                                          self.N, self.K, self.D, self.alpha)          return dt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "create document term matrix in python with tdidfvectorizer todense [SEP] def safe_int_conv(number):     \"\"\"Safely convert a single number to integer.\"\"\"     try:         return int(np.array(number).astype(int, casting='safe'))     except TypeError:         raise ValueError('cannot safely convert {} to integer'.format(number))", "target": 0, "target_options": ["no match", "match"]}
{"input": "matiain a logger across python files [SEP] def register_logging_factories(loader):     \"\"\"     Registers default factories for logging standard package.      :param loader: Loader where you want register default logging factories     \"\"\"     loader.register_factory(logging.Logger, LoggerFactory)     loader.register_factory(logging.Handler, LoggingHandlerFactory)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "matiain a logger across python files [SEP] def _str_to_list(s):     \"\"\"Converts a comma separated string to a list\"\"\"     _list = s.split(\",\")     return list(map(lambda i: i.lstrip(), _list))", "target": 0, "target_options": ["no match", "match"]}
{"input": "matiain a logger across python files [SEP] def configure(logger=None):     \"\"\"Pass stump a logger to use. If no logger is supplied, a basic logger     of level INFO will print to stdout.      \"\"\"     global LOGGER     if logger is None:         LOGGER = logging.basicConfig(stream=sys.stdout, level=logging.INFO)     else:         LOGGER = logger", "target": 1, "target_options": ["no_match", "match"]}
{"input": "matiain a logger across python files [SEP] def remove_dups(seq):     \"\"\"remove duplicates from a sequence, preserving order\"\"\"     seen = set()     seen_add = seen.add     return [x for x in seq if not (x in seen or seen_add(x))]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python 'str' object has no attribute 'length' [SEP] def short_repr(obj, max_len=40):   \"\"\"Returns a short, term-friendly string representation of the object.    Args:     obj: An object for which to return a string representation.     max_len: Maximum length of the returned string. Longer reprs will be turned         into a brief descriptive string giving the type and length of obj.   \"\"\"   obj_repr = repr(obj)   if len(obj_repr) <= max_len:     return obj_repr   return '<{} of length {}>'.format(type(obj).__name__, len(obj_repr))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python 'str' object has no attribute 'length' [SEP] def get_text_or_url(args):     \"\"\"Determine if we need text or url output\"\"\"     redirect_mode = args.bang or args.search or args.lucky     if redirect_mode or args.url:         return 'url'     else:         return 'text'", "target": 0, "target_options": ["no match", "match"]}
{"input": "python 'str' object has no attribute 'length' [SEP] def set_name(self, name):         \"\"\"Set the module name to a 6 byte string          If the string is too short it is appended with space characters.         \"\"\"          if len(name) > 6:             raise ArgumentError(\"Name must be at most 6 characters long\", name=name)          if len(name) < 6:             name += ' '*(6 - len(name))          self.name = name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python 'str' object has no attribute 'length' [SEP] def valid_substitution(strlen, index):     \"\"\"     skip performing substitutions that are outside the bounds of the string     \"\"\"     values = index[0]     return all([strlen > i for i in values])", "target": 0, "target_options": ["no match", "match"]}
{"input": "supervisor python execute shell [SEP] def _handle_shell(self,cfg_file,*args,**options):         \"\"\"Command 'supervisord shell' runs the interactive command shell.\"\"\"         args = (\"--interactive\",) + args         return supervisorctl.main((\"-c\",cfg_file) + args)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "supervisor python execute shell [SEP] def configure(logger=None):     \"\"\"Pass stump a logger to use. If no logger is supplied, a basic logger     of level INFO will print to stdout.      \"\"\"     global LOGGER     if logger is None:         LOGGER = logging.basicConfig(stream=sys.stdout, level=logging.INFO)     else:         LOGGER = logger", "target": 0, "target_options": ["no match", "match"]}
{"input": "supervisor python execute shell [SEP] def callprint(self, cmd, shell=None, lock_file=None, nofail=False, container=None):         \"\"\"         Prints the command, and then executes it, then prints the memory use and         return code of the command.          Uses python's subprocess.Popen() to execute the given command. The shell argument is simply         passed along to Popen(). You should use shell=False (default) where possible, because this enables memory         profiling. You should use shell=True if you require shell functions like redirects (>) or stars (*), but this         will prevent the script from monitoring memory use. The pipes (|) will be used to split the command into         subprocesses run within python, so the memory profiling is possible.          cmd can also be a series (a dict object) of multiple commands, which will be run in succession.          :param str | Iterable[str] cmd: Bash command(s) to be run.         :param str lock_file: a lock file name         :param bool nofail: Should the pipeline bail on a nonzero return from a process? Default: False             Nofail can be used to implement non-essential parts of the pipeline; if these processes fail,             they will not cause the pipeline to bail out.         :param bool shell: if the command should be run it its own shell, default: None (will try             to determine based on the command)         :param container: Named Docker container in which to execute.         :param container: str         \"\"\"         # The Popen shell argument works like this:         # if shell=False, then we format the command (with split()) to be a list of command and its arguments.         # Split the command to use shell=False;         # leave it together to use shell=True;          def get_mem_child_sum(proc):             try:                 # get children processes                 children = proc.children(recursive=True)                 # get RSS memory of each child proc and sum all                 mem_sum = sum([x.memory_info().rss for x in children])                 # return in gigs                 return mem_sum/1e9             except (psutil.NoSuchProcess, psutil.ZombieProcess) as e:                 print(e)                 print(\"Warning: couldn't add memory use for process: {}\".format(proc.pid))                 return 0           def display_memory(memval):             return None if memval < 0 else \"{}GB\".format(round(memval, 3))          def make_dict(command):             a, s = (command, True) if check_shell(command, shell) else (shlex.split(command), False)             return dict(args=a, stdout=subprocess.PIPE, shell=s)          if container:             cmd = \"docker exec \" + container + \" \" + cmd          param_list = [make_dict(c) for c in split_by_pipes(cmd)] \\             if check_shell_pipes(cmd) else [dict(args=cmd, stdout=None, shell=True)]          proc_name = get_proc_name(cmd)          # stop_times = []         processes = []         running_processes = []         start_time = time.time()         for i in range(len(param_list)):             running_processes.append(i)             if i == 0:                 processes.append(psutil.Popen(preexec_fn=os.setpgrp, **param_list[i]))             else:                 param_list[i][\"stdin\"] = processes[i - 1].stdout                 processes.append(psutil.Popen(preexec_fn=os.setpgrp, **param_list[i]))              self.procs[processes[-1].pid] = {                 \"proc_name\": proc_name,                 \"subproc_name\" : get_proc_name(param_list[i][\"args\"]),                 \"start_time\": start_time,                 \"container\": container,                 \"p\": processes[-1]             }          self._report_command(cmd, [x.pid for x in processes])             # Capture the subprocess output in <pre> tags to make it format nicely             # if the markdown log file is displayed as HTML.         print(\"<pre>\")          local_maxmems = [-1] * len(running_processes)         returncodes = [None] * len(running_processes)          if not self.wait:             print(\"</pre>\")             ids = [x.pid for x in processes]             print (\"Not waiting for subprocess(es): \" + str(ids))             return [0, -1]          def proc_wrapup(i):             \"\"\"             :param i: internal ID number of the subprocess             \"\"\"             returncode = processes[i].returncode             current_pid = processes[i].pid              info = \"Process {pid} returned {ret}; memory: {mem}. \".format(                 pid=current_pid,                  ret=processes[i].returncode,                 mem=display_memory(local_maxmems[i]))                          # report process profile             self._report_profile(self.procs[current_pid][\"proc_name\"], lock_file, time.time() - self.procs[current_pid][\"start_time\"], local_maxmems[i])              # Remove this as a running subprocess             del self.procs[current_pid]             running_processes.remove(i)              returncodes[i] = returncode             return info           sleeptime = .0001         info = \"\"         while running_processes:             for i in running_processes:                 local_maxmems[i] = max(local_maxmems[i], (get_mem_child_sum(processes[i])))                 self.peak_memory = max(self.peak_memory, local_maxmems[i])                 if not self._attend_process(processes[i], sleeptime):                     info += proc_wrapup(i)              # the sleeptime is extremely short at the beginning and gets longer exponentially              # (+ constant to prevent copious checks at the very beginning)             # = more precise mem tracing for short processes             sleeptime = min((sleeptime + 0.25) * 3 , 60/len(processes))          # All jobs are done, print a final closing and job info         stop_time = time.time()         info += \" Elapsed: \" + str(datetime.timedelta(seconds=self.time_elapsed(start_time))) + \".\"         info += \" Peak memory: {pipe}.\".format(pipe=display_memory(self.peak_memory))          print(\"</pre>\")         print(info)          for rc in returncodes:             if rc != 0:                 msg = \"Subprocess returned nonzero result. Check above output for details\"                 self._triage_error(SubprocessError(msg), nofail)            return [returncodes, local_maxmems]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "supervisor python execute shell [SEP] def unique(list):     \"\"\" Returns a copy of the list without duplicates.     \"\"\"     unique = []; [unique.append(x) for x in list if x not in unique]     return unique", "target": 0, "target_options": ["no match", "match"]}
{"input": "python string replace dash [SEP] def slugify(value):     \"\"\"Simple Slugify.\"\"\"     s1 = first_cap_re.sub(r'\\1_\\2', value)     s2 = all_cap_re.sub(r'\\1_\\2', s1)     return s2.lower().replace(' _', '_').replace(' ', '_')", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python string replace dash [SEP] def _gauss(mean: int, sigma: int) -> int:         \"\"\"         Creates a variation from a base value          Args:             mean: base value             sigma: gaussian sigma          Returns: random value          \"\"\"         return int(random.gauss(mean, sigma))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python string replace dash [SEP] def slugify(s):     \"\"\"     Converts the given string to a URL slug.     \"\"\"     s = strip_accents(s.replace(\"'\", '').lower())     return re.sub('[^a-z0-9]+', ' ', s).strip().replace(' ', '-')", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python string replace dash [SEP] def rvalues(self):         \"\"\"          in reversed order         \"\"\"         tmp = self         while tmp is not None:             yield tmp.data             tmp = tmp.prev", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to check postion of python program after break [SEP] def stop(self) -> None:         \"\"\"Stops the analysis as soon as possible.\"\"\"         if self._stop and not self._posted_kork:             self._stop()             self._stop = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to check postion of python program after break [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to check postion of python program after break [SEP] def timeout_thread_handler(timeout, stop_event):     \"\"\"A background thread to kill the process if it takes too long.      Args:         timeout (float): The number of seconds to wait before killing             the process.         stop_event (Event): An optional event to cleanly stop the background             thread if required during testing.     \"\"\"      stop_happened = stop_event.wait(timeout)     if stop_happened is False:         print(\"Killing program due to %f second timeout\" % timeout)      os._exit(2)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to check postion of python program after break [SEP] def set_empty_text(self):         \"\"\"Display the empty text         \"\"\"         self.buffer.insert_with_tags_by_name(             self.buffer.get_start_iter(),             self.empty_text, 'empty-text')", "target": 0, "target_options": ["no match", "match"]}
{"input": "string format for decimal places python [SEP] def format_float(value): # not used     \"\"\"Modified form of the 'g' format specifier.     \"\"\"     string = \"{:g}\".format(value).replace(\"e+\", \"e\")     string = re.sub(\"e(-?)0*(\\d+)\", r\"e\\1\\2\", string)     return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "string format for decimal places python [SEP] def _handle_shell(self,cfg_file,*args,**options):         \"\"\"Command 'supervisord shell' runs the interactive command shell.\"\"\"         args = (\"--interactive\",) + args         return supervisorctl.main((\"-c\",cfg_file) + args)", "target": 0, "target_options": ["no match", "match"]}
{"input": "string format for decimal places python [SEP] def _saferound(value, decimal_places):     \"\"\"     Rounds a float value off to the desired precision     \"\"\"     try:         f = float(value)     except ValueError:         return ''     format = '%%.%df' % decimal_places     return format % f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "string format for decimal places python [SEP] def cleanLines(source, lineSep=os.linesep):     \"\"\"     :param source: some iterable source (list, file, etc)     :param lineSep: string of separators (chars) that must be removed     :return: list of non empty lines with removed separators     \"\"\"     stripped = (line.strip(lineSep) for line in source)     return (line for line in stripped if len(line) != 0)", "target": 0, "target_options": ["no match", "match"]}
{"input": "print python in one line [SEP] def out(self, output, newline=True):         \"\"\"Outputs a string to the console (stdout).\"\"\"         click.echo(output, nl=newline)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "print python in one line [SEP] def is_dec(ip):     \"\"\"Return true if the IP address is in decimal notation.\"\"\"     try:         dec = int(str(ip))     except ValueError:         return False     if dec > 4294967295 or dec < 0:         return False     return True", "target": 0, "target_options": ["no match", "match"]}
{"input": "print python in one line [SEP] def _display(self, layout):         \"\"\"launch layouts display\"\"\"         print(file=self.out)         TextWriter().format(layout, self.out)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "print python in one line [SEP] def _format_bf(bf, precision=3, trim='0'):     \"\"\"Format BF10 to floating point or scientific notation.     \"\"\"     if bf >= 1e4 or bf <= 1e-4:         out = np.format_float_scientific(bf, precision=precision, trim=trim)     else:         out = np.format_float_positional(bf, precision=precision, trim=trim)     return out", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to duplicate object in a list in python [SEP] def remove_duplicates(lst):     \"\"\"     Emulate what a Python ``set()`` does, but keeping the element's order.     \"\"\"     dset = set()     return [l for l in lst if l not in dset and not dset.add(l)]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to duplicate object in a list in python [SEP] def csvpretty(csvfile: csvfile=sys.stdin):     \"\"\" Pretty print a CSV file. \"\"\"     shellish.tabulate(csv.reader(csvfile))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to duplicate object in a list in python [SEP] def unique(list):     \"\"\" Returns a copy of the list without duplicates.     \"\"\"     unique = []; [unique.append(x) for x in list if x not in unique]     return unique", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to duplicate object in a list in python [SEP] def csort(objs, key):     \"\"\"Order-preserving sorting function.\"\"\"     idxs = dict((obj, i) for (i, obj) in enumerate(objs))     return sorted(objs, key=lambda obj: (key(obj), idxs[obj]))", "target": 0, "target_options": ["no match", "match"]}
{"input": "extract year from column python [SEP] def format(x, format):     \"\"\"Uses http://www.cplusplus.com/reference/string/to_string/ for formatting\"\"\"     # don't change the dtype, otherwise for each block the dtype may be different (string length)     sl = vaex.strings.format(x, format)     return column.ColumnStringArrow(sl.bytes, sl.indices, sl.length, sl.offset, string_sequence=sl)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "extract year from column python [SEP] def rm_keys_from_dict(d, keys):     \"\"\"     Given a dictionary and a key list, remove any data in the dictionary with the given keys.      :param dict d: Metadata     :param list keys: Keys to be removed     :return dict d: Metadata     \"\"\"     # Loop for each key given     for key in keys:         # Is the key in the dictionary?         if key in d:             try:                 d.pop(key, None)             except KeyError:                 # Not concerned with an error. Keep going.                 pass     return d", "target": 0, "target_options": ["no match", "match"]}
{"input": "extract year from column python [SEP] def _tab(content):     \"\"\"     Helper funcation that converts text-based get response     to tab separated values for additional manipulation.     \"\"\"     response = _data_frame(content).to_csv(index=False,sep='\\t')     return response", "target": 1, "target_options": ["no_match", "match"]}
{"input": "extract year from column python [SEP] def notin(arg, values):     \"\"\"     Like isin, but checks whether this expression's value(s) are not     contained in the passed values. See isin docs for full usage.     \"\"\"     op = ops.NotContains(arg, values)     return op.to_expr()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python check a string is decimal [SEP] def hex2dec(s):     \"\"\"     hex2dec     十六进制 to 十进制     :param s:     :return:     \"\"\"     if not isinstance(s, str):         s = str(s)     return int(s.upper(), 16)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python check a string is decimal [SEP] def Tmatrix(X):     \"\"\"     gets the orientation matrix (T) from data in X     \"\"\"     T = [[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]]     for row in X:         for k in range(3):             for l in range(3):                 T[k][l] += row[k] * row[l]     return T", "target": 0, "target_options": ["no match", "match"]}
{"input": "python check a string is decimal [SEP] def is_dec(ip):     \"\"\"Return true if the IP address is in decimal notation.\"\"\"     try:         dec = int(str(ip))     except ValueError:         return False     if dec > 4294967295 or dec < 0:         return False     return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python check a string is decimal [SEP] def dot_product(self, other):         \"\"\" Return the dot product of the given vectors. \"\"\"         return self.x * other.x + self.y * other.y", "target": 0, "target_options": ["no match", "match"]}
{"input": "individual array into one array python\\ [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "individual array into one array python\\ [SEP] def intToBin(i):     \"\"\" Integer to two bytes \"\"\"     # divide in two parts (bytes)     i1 = i % 256     i2 = int(i / 256)     # make string (little endian)     return i.to_bytes(2, byteorder='little')", "target": 0, "target_options": ["no match", "match"]}
{"input": "individual array into one array python\\ [SEP] def pack_triples_numpy(triples):     \"\"\"Packs a list of triple indexes into a 2D numpy array.\"\"\"     if len(triples) == 0:         return np.array([], dtype=np.int64)     return np.stack(list(map(_transform_triple_numpy, triples)), axis=0)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "individual array into one array python\\ [SEP] def obj_in_list_always(target_list, obj):     \"\"\"     >>> l = [1,1,1]     >>> obj_in_list_always(l, 1)     True     >>> l.append(2)     >>> obj_in_list_always(l, 1)     False     \"\"\"     for item in set(target_list):         if item is not obj:             return False     return True", "target": 0, "target_options": ["no match", "match"]}
{"input": "python3 flask response modify header [SEP] def set_header(self, name, value):         \"\"\" Create a new response header, replacing any previously defined             headers with the same name. \"\"\"         self._headers[_hkey(name)] = [_hval(value)]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python3 flask response modify header [SEP] def _to_array(value):     \"\"\"As a convenience, turn Python lists and tuples into NumPy arrays.\"\"\"     if isinstance(value, (tuple, list)):         return array(value)     elif isinstance(value, (float, int)):         return np.float64(value)     else:         return value", "target": 0, "target_options": ["no match", "match"]}
{"input": "python3 flask response modify header [SEP] def get_wsgi_headers(self, environ):         \"\"\"This is automatically called right before the response is started         and returns headers modified for the given environment.  It returns a         copy of the headers from the response with some modifications applied         if necessary.          For example the location header (if present) is joined with the root         URL of the environment.  Also the content length is automatically set         to zero here for certain status codes.          .. versionchanged:: 0.6            Previously that function was called `fix_headers` and modified            the response object in place.  Also since 0.6, IRIs in location            and content-location headers are handled properly.             Also starting with 0.6, Werkzeug will attempt to set the content            length if it is able to figure it out on its own.  This is the            case if all the strings in the response iterable are already            encoded and the iterable is buffered.          :param environ: the WSGI environment of the request.         :return: returns a new :class:`~werkzeug.datastructures.Headers`                  object.         \"\"\"         headers = Headers(self.headers)         location = None         content_location = None         content_length = None         status = self.status_code          # iterate over the headers to find all values in one go.  Because         # get_wsgi_headers is used each response that gives us a tiny         # speedup.         for key, value in headers:             ikey = key.lower()             if ikey == u'location':                 location = value             elif ikey == u'content-location':                 content_location = value             elif ikey == u'content-length':                 content_length = value          # make sure the location header is an absolute URL         if location is not None:             old_location = location             if isinstance(location, text_type):                 # Safe conversion is necessary here as we might redirect                 # to a broken URI scheme (for instance itms-services).                 location = iri_to_uri(location, safe_conversion=True)              if self.autocorrect_location_header:                 current_url = get_current_url(environ, root_only=True)                 if isinstance(current_url, text_type):                     current_url = iri_to_uri(current_url)                 location = url_join(current_url, location)             if location != old_location:                 headers['Location'] = location          # make sure the content location is a URL         if content_location is not None and \\            isinstance(content_location, text_type):             headers['Content-Location'] = iri_to_uri(content_location)          # remove entity headers and set content length to zero if needed.         # Also update content_length accordingly so that the automatic         # content length detection does not trigger in the following         # code.         if 100 <= status < 200 or status == 204:             headers['Content-Length'] = content_length = u'0'         elif status == 304:             remove_entity_headers(headers)          # if we can determine the content length automatically, we         # should try to do that.  But only if this does not involve         # flattening the iterator or encoding of unicode strings in         # the response.  We however should not do that if we have a 304         # response.         if self.automatically_set_content_length and \\            self.is_sequence and content_length is None and status != 304:             try:                 content_length = sum(len(to_bytes(x, 'ascii'))                                      for x in self.response)             except UnicodeError:                 # aha, something non-bytestringy in there, too bad, we                 # can't safely figure out the length of the response.                 pass             else:                 headers['Content-Length'] = str(content_length)          return headers", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python3 flask response modify header [SEP] def abspath(*path):     \"\"\"A method to determine absolute path for a given relative path to the     directory where this setup.py script is located\"\"\"     setup_dir = os.path.dirname(os.path.abspath(__file__))     return os.path.join(setup_dir, *path)", "target": 0, "target_options": ["no match", "match"]}
{"input": "display result without matrix wrapper python [SEP] def print_matrix(X, decimals=1):     \"\"\"Pretty printing for numpy matrix X\"\"\"     for row in np.round(X, decimals=decimals):         print(row)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "display result without matrix wrapper python [SEP] def plot_target(target, ax):     \"\"\"Ajoute la target au plot\"\"\"     ax.scatter(target[0], target[1], target[2], c=\"red\", s=80)", "target": 0, "target_options": ["no match", "match"]}
{"input": "display result without matrix wrapper python [SEP] def size(self):         \"\"\"Total number of grid points.\"\"\"         # Since np.prod(()) == 1.0 we need to handle that by ourselves         return (0 if self.shape == () else                 int(np.prod(self.shape, dtype='int64')))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "display result without matrix wrapper python [SEP] def replaceNewlines(string, newlineChar): \t\"\"\"There's probably a way to do this with string functions but I was lazy. \t\tReplace all instances of \\r or \\n in a string with something else.\"\"\" \tif newlineChar in string: \t\tsegments = string.split(newlineChar) \t\tstring = \"\" \t\tfor segment in segments: \t\t\tstring += segment \treturn string", "target": 0, "target_options": ["no match", "match"]}
{"input": "python counts the number of words in a string [SEP] def onscreen_len(s):     \"\"\"     Calculate the length of a unicode string on screen,     accounting for double-width characters      \"\"\"      if sys.version_info < (3, 0) and isinstance(s, str):         return len(s)      length = 0     for ch in s:         length += 2 if unicodedata.east_asian_width(ch) == 'W' else 1      return length", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python counts the number of words in a string [SEP] def html(header_rows):     \"\"\"     Convert a list of tuples describing a table into a HTML string     \"\"\"     name = 'table%d' % next(tablecounter)     return HtmlTable([map(str, row) for row in header_rows], name).render()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python counts the number of words in a string [SEP] def display_len(text):     \"\"\"     Get the display length of a string. This can differ from the character     length if the string contains wide characters.     \"\"\"     text = unicodedata.normalize('NFD', text)     return sum(char_width(char) for char in text)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python counts the number of words in a string [SEP] def is_all_field_none(self):         \"\"\"         :rtype: bool         \"\"\"          if self._type_ is not None:             return False          if self._value is not None:             return False          if self._name is not None:             return False          return True", "target": 0, "target_options": ["no match", "match"]}
{"input": "python user defined function email with attachments [SEP] def create_message(username, message):     \"\"\" Creates a standard message from a given user with the message          Replaces newline with html break \"\"\"     message = message.replace('\\n', '<br/>')     return '{{\"service\":1, \"data\":{{\"message\":\"{mes}\", \"username\":\"{user}\"}} }}'.format(mes=message, user=username)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python user defined function email with attachments [SEP] def str2int(num, radix=10, alphabet=BASE85):     \"\"\"helper function for quick base conversions from strings to integers\"\"\"     return NumConv(radix, alphabet).str2int(num)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python user defined function email with attachments [SEP] def send_test_message(messenger_id, to=None):     \"\"\"Sends a test message using the given messenger.      :param str|unicode messenger_id: Messenger alias.     :param str|unicode to: Recipient address (if applicable).      \"\"\"     messenger_obj = get_registered_messenger_object(messenger_id)     return messenger_obj.send_test_message(to=to, text='Test message from sitemessages.')", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python user defined function email with attachments [SEP] def is_executable(path):   \"\"\"Returns whether a path names an existing executable file.\"\"\"   return os.path.isfile(path) and os.access(path, os.X_OK)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to read file from sharepoint using python [SEP] def get_file_string(filepath):     \"\"\"Get string from file.\"\"\"     with open(os.path.abspath(filepath)) as f:         return f.read()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to read file from sharepoint using python [SEP] def abspath(*path):     \"\"\"A method to determine absolute path for a given relative path to the     directory where this setup.py script is located\"\"\"     setup_dir = os.path.dirname(os.path.abspath(__file__))     return os.path.join(setup_dir, *path)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to read file from sharepoint using python [SEP] def str_from_file(path):     \"\"\"     Return file contents as string.      \"\"\"     with open(path) as f:         s = f.read().strip()     return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to read file from sharepoint using python [SEP] def Load(file):     \"\"\" Loads a model from specified file \"\"\"     with open(file, 'rb') as file:         model = dill.load(file)         return model", "target": 0, "target_options": ["no match", "match"]}
{"input": "store dir subdir to list of folder name python [SEP] def get_files(dir_name):     \"\"\"Simple directory walker\"\"\"     return [(os.path.join('.', d), [os.path.join(d, f) for f in files]) for d, _, files in os.walk(dir_name)]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "store dir subdir to list of folder name python [SEP] def local_accuracy(X_train, y_train, X_test, y_test, attr_test, model_generator, metric, trained_model):     \"\"\" The how well do the features plus a constant base rate sum up to the model output.     \"\"\"      X_train, X_test = to_array(X_train, X_test)      # how many features to mask     assert X_train.shape[1] == X_test.shape[1]      # keep nkeep top features and re-train the model for each test explanation     yp_test = trained_model.predict(X_test)      return metric(yp_test, strip_list(attr_test).sum(1))", "target": 0, "target_options": ["no match", "match"]}
{"input": "store dir subdir to list of folder name python [SEP] def get_subdirs(parent_path):   \"\"\"Return a list of (name, path) tuples of direct subdirectories of      parent_path, where each tuple corresponds to one subdirectory. Files     in the parent_path are excluded from the output.     \"\"\"   entries = os.listdir(parent_path)   subdirs = [(entry, os.path.join(parent_path, entry))              for entry in entries              if os.path.isdir(entry)]   return subdirs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "store dir subdir to list of folder name python [SEP] def read(*p):     \"\"\"Build a file path from paths and return the contents.\"\"\"     with open(os.path.join(*p), 'r') as fi:         return fi.read()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python flask receive a image opencv [SEP] def url_to_image(url, flag=cv2.IMREAD_COLOR):     \"\"\" download the image, convert it to a NumPy array, and then read     it into OpenCV format \"\"\"     resp = urlopen(url)     image = np.asarray(bytearray(resp.read()), dtype=\"uint8\")     image = cv2.imdecode(image, flag)     return image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python flask receive a image opencv [SEP] def is_square_matrix(mat):     \"\"\"Test if an array is a square matrix.\"\"\"     mat = np.array(mat)     if mat.ndim != 2:         return False     shape = mat.shape     return shape[0] == shape[1]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python flask receive a image opencv [SEP] def screen_cv2(self):         \"\"\"cv2 Image of current window screen\"\"\"         pil_image = self.screen.convert('RGB')         cv2_image = np.array(pil_image)         pil_image.close()         # Convert RGB to BGR          cv2_image = cv2_image[:, :, ::-1]         return cv2_image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python flask receive a image opencv [SEP] def callprint(self, cmd, shell=None, lock_file=None, nofail=False, container=None):         \"\"\"         Prints the command, and then executes it, then prints the memory use and         return code of the command.          Uses python's subprocess.Popen() to execute the given command. The shell argument is simply         passed along to Popen(). You should use shell=False (default) where possible, because this enables memory         profiling. You should use shell=True if you require shell functions like redirects (>) or stars (*), but this         will prevent the script from monitoring memory use. The pipes (|) will be used to split the command into         subprocesses run within python, so the memory profiling is possible.          cmd can also be a series (a dict object) of multiple commands, which will be run in succession.          :param str | Iterable[str] cmd: Bash command(s) to be run.         :param str lock_file: a lock file name         :param bool nofail: Should the pipeline bail on a nonzero return from a process? Default: False             Nofail can be used to implement non-essential parts of the pipeline; if these processes fail,             they will not cause the pipeline to bail out.         :param bool shell: if the command should be run it its own shell, default: None (will try             to determine based on the command)         :param container: Named Docker container in which to execute.         :param container: str         \"\"\"         # The Popen shell argument works like this:         # if shell=False, then we format the command (with split()) to be a list of command and its arguments.         # Split the command to use shell=False;         # leave it together to use shell=True;          def get_mem_child_sum(proc):             try:                 # get children processes                 children = proc.children(recursive=True)                 # get RSS memory of each child proc and sum all                 mem_sum = sum([x.memory_info().rss for x in children])                 # return in gigs                 return mem_sum/1e9             except (psutil.NoSuchProcess, psutil.ZombieProcess) as e:                 print(e)                 print(\"Warning: couldn't add memory use for process: {}\".format(proc.pid))                 return 0           def display_memory(memval):             return None if memval < 0 else \"{}GB\".format(round(memval, 3))          def make_dict(command):             a, s = (command, True) if check_shell(command, shell) else (shlex.split(command), False)             return dict(args=a, stdout=subprocess.PIPE, shell=s)          if container:             cmd = \"docker exec \" + container + \" \" + cmd          param_list = [make_dict(c) for c in split_by_pipes(cmd)] \\             if check_shell_pipes(cmd) else [dict(args=cmd, stdout=None, shell=True)]          proc_name = get_proc_name(cmd)          # stop_times = []         processes = []         running_processes = []         start_time = time.time()         for i in range(len(param_list)):             running_processes.append(i)             if i == 0:                 processes.append(psutil.Popen(preexec_fn=os.setpgrp, **param_list[i]))             else:                 param_list[i][\"stdin\"] = processes[i - 1].stdout                 processes.append(psutil.Popen(preexec_fn=os.setpgrp, **param_list[i]))              self.procs[processes[-1].pid] = {                 \"proc_name\": proc_name,                 \"subproc_name\" : get_proc_name(param_list[i][\"args\"]),                 \"start_time\": start_time,                 \"container\": container,                 \"p\": processes[-1]             }          self._report_command(cmd, [x.pid for x in processes])             # Capture the subprocess output in <pre> tags to make it format nicely             # if the markdown log file is displayed as HTML.         print(\"<pre>\")          local_maxmems = [-1] * len(running_processes)         returncodes = [None] * len(running_processes)          if not self.wait:             print(\"</pre>\")             ids = [x.pid for x in processes]             print (\"Not waiting for subprocess(es): \" + str(ids))             return [0, -1]          def proc_wrapup(i):             \"\"\"             :param i: internal ID number of the subprocess             \"\"\"             returncode = processes[i].returncode             current_pid = processes[i].pid              info = \"Process {pid} returned {ret}; memory: {mem}. \".format(                 pid=current_pid,                  ret=processes[i].returncode,                 mem=display_memory(local_maxmems[i]))                          # report process profile             self._report_profile(self.procs[current_pid][\"proc_name\"], lock_file, time.time() - self.procs[current_pid][\"start_time\"], local_maxmems[i])              # Remove this as a running subprocess             del self.procs[current_pid]             running_processes.remove(i)              returncodes[i] = returncode             return info           sleeptime = .0001         info = \"\"         while running_processes:             for i in running_processes:                 local_maxmems[i] = max(local_maxmems[i], (get_mem_child_sum(processes[i])))                 self.peak_memory = max(self.peak_memory, local_maxmems[i])                 if not self._attend_process(processes[i], sleeptime):                     info += proc_wrapup(i)              # the sleeptime is extremely short at the beginning and gets longer exponentially              # (+ constant to prevent copious checks at the very beginning)             # = more precise mem tracing for short processes             sleeptime = min((sleeptime + 0.25) * 3 , 60/len(processes))          # All jobs are done, print a final closing and job info         stop_time = time.time()         info += \" Elapsed: \" + str(datetime.timedelta(seconds=self.time_elapsed(start_time))) + \".\"         info += \" Peak memory: {pipe}.\".format(pipe=display_memory(self.peak_memory))          print(\"</pre>\")         print(info)          for rc in returncodes:             if rc != 0:                 msg = \"Subprocess returned nonzero result. Check above output for details\"                 self._triage_error(SubprocessError(msg), nofail)            return [returncodes, local_maxmems]", "target": 0, "target_options": ["no match", "match"]}
{"input": "file as stdin python [SEP] def read_stdin():     \"\"\" Read text from stdin, and print a helpful message for ttys. \"\"\"     if sys.stdin.isatty() and sys.stdout.isatty():         print('\\nReading from stdin until end of file (Ctrl + D)...')      return sys.stdin.read()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "file as stdin python [SEP] def data_format_value(self):         \"\"\"         :return: The data type of the data component as integer value.         \"\"\"         try:             if self._part:                 value = self._part.data_format             else:                 value = self._buffer.pixel_format         except InvalidParameterException:             value = self._node_map.PixelFormat.value         return value", "target": 0, "target_options": ["no match", "match"]}
{"input": "file as stdin python [SEP] def standard_input():     \"\"\"Generator that yields lines from standard input.\"\"\"     with click.get_text_stream(\"stdin\") as stdin:         while stdin.readable():             line = stdin.readline()             if line:                 yield line.strip().encode(\"utf-8\")", "target": 1, "target_options": ["no_match", "match"]}
{"input": "file as stdin python [SEP] def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:     \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"     for line in file_like:         line = line.rstrip('\\r\\n')         if line:             yield line", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to return several values without using tuple in python [SEP] def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to return several values without using tuple in python [SEP] def get_wsgi_headers(self, environ):         \"\"\"This is automatically called right before the response is started         and returns headers modified for the given environment.  It returns a         copy of the headers from the response with some modifications applied         if necessary.          For example the location header (if present) is joined with the root         URL of the environment.  Also the content length is automatically set         to zero here for certain status codes.          .. versionchanged:: 0.6            Previously that function was called `fix_headers` and modified            the response object in place.  Also since 0.6, IRIs in location            and content-location headers are handled properly.             Also starting with 0.6, Werkzeug will attempt to set the content            length if it is able to figure it out on its own.  This is the            case if all the strings in the response iterable are already            encoded and the iterable is buffered.          :param environ: the WSGI environment of the request.         :return: returns a new :class:`~werkzeug.datastructures.Headers`                  object.         \"\"\"         headers = Headers(self.headers)         location = None         content_location = None         content_length = None         status = self.status_code          # iterate over the headers to find all values in one go.  Because         # get_wsgi_headers is used each response that gives us a tiny         # speedup.         for key, value in headers:             ikey = key.lower()             if ikey == u'location':                 location = value             elif ikey == u'content-location':                 content_location = value             elif ikey == u'content-length':                 content_length = value          # make sure the location header is an absolute URL         if location is not None:             old_location = location             if isinstance(location, text_type):                 # Safe conversion is necessary here as we might redirect                 # to a broken URI scheme (for instance itms-services).                 location = iri_to_uri(location, safe_conversion=True)              if self.autocorrect_location_header:                 current_url = get_current_url(environ, root_only=True)                 if isinstance(current_url, text_type):                     current_url = iri_to_uri(current_url)                 location = url_join(current_url, location)             if location != old_location:                 headers['Location'] = location          # make sure the content location is a URL         if content_location is not None and \\            isinstance(content_location, text_type):             headers['Content-Location'] = iri_to_uri(content_location)          # remove entity headers and set content length to zero if needed.         # Also update content_length accordingly so that the automatic         # content length detection does not trigger in the following         # code.         if 100 <= status < 200 or status == 204:             headers['Content-Length'] = content_length = u'0'         elif status == 304:             remove_entity_headers(headers)          # if we can determine the content length automatically, we         # should try to do that.  But only if this does not involve         # flattening the iterator or encoding of unicode strings in         # the response.  We however should not do that if we have a 304         # response.         if self.automatically_set_content_length and \\            self.is_sequence and content_length is None and status != 304:             try:                 content_length = sum(len(to_bytes(x, 'ascii'))                                      for x in self.response)             except UnicodeError:                 # aha, something non-bytestringy in there, too bad, we                 # can't safely figure out the length of the response.                 pass             else:                 headers['Content-Length'] = str(content_length)          return headers", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to return several values without using tuple in python [SEP] def get_value_tuple(self):         \"\"\"         Returns a tuple of the color's values (in order). For example,         an LabColor object will return (lab_l, lab_a, lab_b), where each         member of the tuple is the float value for said variable.         \"\"\"         retval = tuple()         for val in self.VALUES:             retval += (getattr(self, val),)         return retval", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to return several values without using tuple in python [SEP] def _escape(self, s):         \"\"\"Escape bad characters for regular expressions.          Similar to `re.escape` but allows '%' to pass through.          \"\"\"         for ch, r_ch in self.ESCAPE_SETS:             s = s.replace(ch, r_ch)         return s", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to plot linear graph in python [SEP] def guinierplot(*args, **kwargs):     \"\"\"Make a Guinier plot. This is simply a wrapper around plotsascurve().\"\"\"     ret=plotsascurve(*args, **kwargs)     plt.xscale('power',exponent=2)     plt.yscale('log')     return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to plot linear graph in python [SEP] def _remove_invalid_char(s):     \"\"\"Remove invalid and dangerous characters from a string.\"\"\"      s = ''.join([i if ord(i) >= 32 and ord(i) < 127 else '' for i in s])     s = s.translate(dict.fromkeys(map(ord, \"_%~#\\\\{}\\\":\")))     return s", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to plot linear graph in python [SEP] def plot_curves_z(data, name, title=None):     \"\"\"Generates a simple plot of the quasiparticle weight decay curves given        data object with doping setup\"\"\"      plt.figure()     for zet, c in zip(data['zeta'], data['doping']):         plt.plot(data['u_int'], zet[:, 0], label='$n={}$'.format(str(c)))     if title != None:         plt.title(title)     label_saves(name+'.png')", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to plot linear graph in python [SEP] def apply(f, obj, *args, **kwargs):     \"\"\"Apply a function in parallel to each element of the input\"\"\"     return vectorize(f)(obj, *args, **kwargs)", "target": 0, "target_options": ["no match", "match"]}
{"input": "replace list element in python [SEP] def myreplace(astr, thefind, thereplace):     \"\"\"in string astr replace all occurences of thefind with thereplace\"\"\"     alist = astr.split(thefind)     new_s = alist.split(thereplace)     return new_s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "replace list element in python [SEP] def write(self, data):         \"\"\"         Write the given data to the file.         \"\"\"                  # Do the write         self.backingStream.write(data)                  for listener in self.writeListeners:             # Send out notifications             listener(len(data))", "target": 0, "target_options": ["no match", "match"]}
{"input": "replace list element in python [SEP] def replace(s, replace):     \"\"\"Replace multiple values in a string\"\"\"     for r in replace:         s = s.replace(*r)     return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "replace list element in python [SEP] def unique(list):     \"\"\" Returns a copy of the list without duplicates.     \"\"\"     unique = []; [unique.append(x) for x in list if x not in unique]     return unique", "target": 0, "target_options": ["no match", "match"]}
{"input": "python file directory self defining [SEP] def parent_directory(self):         \"\"\"Change working directory to parent directory\"\"\"         self.chdir(os.path.join(getcwd_or_home(), os.path.pardir))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python file directory self defining [SEP] def i2b(self, pkt, x):         \"\"\"Convert internal value to internal value\"\"\"         if type(x) is str:           x = bytes([ ord(i) for i in x ])         return x", "target": 0, "target_options": ["no match", "match"]}
{"input": "python file directory self defining [SEP] def go_to_parent_directory(self):         \"\"\"Go to parent directory\"\"\"         self.chdir(osp.abspath(osp.join(getcwd_or_home(), os.pardir)))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python file directory self defining [SEP] def rotate_2D(angle):     \"\"\"     Returns a 2x2 transformation matrix to rotate     by an angle in two dimensions     \"\"\"     return N.array([[N.cos(angle),-N.sin(angle)],                     [N.sin(angle),N.cos(angle)]])", "target": 0, "target_options": ["no match", "match"]}
{"input": "python print a character by ascii code [SEP] def _escape_char(c, escape_char=ESCAPE_CHAR):     \"\"\"Escape a single character\"\"\"     buf = []     for byte in c.encode('utf8'):         buf.append(escape_char)         buf.append('%X' % _ord(byte))     return ''.join(buf)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python print a character by ascii code [SEP] def datetime64_to_datetime(dt):     \"\"\" convert numpy's datetime64 to datetime \"\"\"     dt64 = np.datetime64(dt)     ts = (dt64 - np.datetime64('1970-01-01T00:00:00')) / np.timedelta64(1, 's')     return datetime.datetime.utcfromtimestamp(ts)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python print a character by ascii code [SEP] def unicode_is_ascii(u_string):     \"\"\"Determine if unicode string only contains ASCII characters.      :param str u_string: unicode string to check. Must be unicode         and not Python 2 `str`.     :rtype: bool     \"\"\"     assert isinstance(u_string, str)     try:         u_string.encode('ascii')         return True     except UnicodeEncodeError:         return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python print a character by ascii code [SEP] def chmod_add_excute(filename):         \"\"\"         Adds execute permission to file.         :param filename:         :return:         \"\"\"         st = os.stat(filename)         os.chmod(filename, st.st_mode | stat.S_IEXEC)", "target": 0, "target_options": ["no match", "match"]}
{"input": "show xml in text widget python [SEP] def text(self):         \"\"\"         Return the String assosicated with the current text         \"\"\"         if self.m_name == -1 or self.m_event != TEXT:             return ''          return self.sb[self.m_name]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "show xml in text widget python [SEP] def __init__(self, pidfile, daemonize=True, root=False, root_chk_argv=True, stdin=\"/dev/null\", stdout=\"/dev/null\", stderr=\"/dev/null\"): \t\t\"\"\" \t\tMake our daemon instance. \t\tpidfile: the file we're going to store the process id in. ex: /tmp/matt-daemon.pid \t\troot:    does this script require root? True if it does, False if it doesn't. Will be enforced. \t\troot_chk_argv:  does the script require '--requires-root' in sys.argv to run as root? (usage is good) \t\tstdin:   where the script gets stdin from. \"/dev/null\", \"/dev/stdin\", etc. \t\tstdout:  where the script writes stdout. \"/dev/null\", \"/dev/stdout\", etc. \t\tstderr:  where the script writes stderr. \"/dev/null\", \"/dev/stderr\", etc. \t\t\"\"\" \t\t# Enforce root usage or non-usage. \t\tRootCheck.check(root, check_argv=root_chk_argv) \t\tself.pidfile = pidfile \t\tself.should_daemonize = daemonize \t\tself.stdin = stdin \t\tself.stdout = stdout \t\tself.stderr = stderr", "target": 0, "target_options": ["no match", "match"]}
{"input": "show xml in text widget python [SEP] def to_text(self):         \"\"\"Render a Text MessageElement as plain text          :returns: Text representation of the Text MessageElement.         :rtype: str         \"\"\"         if self.text is None:             return         else:             text = ''             for t in self.text:                 text += t.to_text() + ' '             return ' '.join(text.split())", "target": 1, "target_options": ["no_match", "match"]}
{"input": "show xml in text widget python [SEP] def Tmatrix(X):     \"\"\"     gets the orientation matrix (T) from data in X     \"\"\"     T = [[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]]     for row in X:         for k in range(3):             for l in range(3):                 T[k][l] += row[k] * row[l]     return T", "target": 0, "target_options": ["no match", "match"]}
{"input": "python test if value is number [SEP] def get_number(s, cast=int):     \"\"\"     Try to get a number out of a string, and cast it.     \"\"\"     import string     d = \"\".join(x for x in str(s) if x in string.digits)     return cast(d)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python test if value is number [SEP] def write_tsv_line_from_list(linelist, outfp):     \"\"\"Utility method to convert list to tsv line with carriage return\"\"\"     line = '\\t'.join(linelist)     outfp.write(line)     outfp.write('\\n')", "target": 0, "target_options": ["no match", "match"]}
{"input": "python test if value is number [SEP] def _isint(string):     \"\"\"     >>> _isint(\"123\")     True     >>> _isint(\"123.45\")     False     \"\"\"     return type(string) is int or \\            (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\            _isconvertible(int, string)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python test if value is number [SEP] def myreplace(astr, thefind, thereplace):     \"\"\"in string astr replace all occurences of thefind with thereplace\"\"\"     alist = astr.split(thefind)     new_s = alist.split(thereplace)     return new_s", "target": 0, "target_options": ["no match", "match"]}
{"input": "python server disconnect socket [SEP] def shutdown(self):         \"\"\"close socket, immediately.\"\"\"         if self.sock:             self.sock.close()             self.sock = None             self.connected = False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python server disconnect socket [SEP] def to_int(self):         \"\"\"Convert vector to an integer, if possible.          This is only useful for arrays filled with zero/one entries.         \"\"\"         num = self.to_uint()         if num and self._items[-1].unbox():             return num - (1 << self.size)         else:             return num", "target": 0, "target_options": ["no match", "match"]}
{"input": "python server disconnect socket [SEP] async def disconnect(self):         \"\"\" Disconnect from target. \"\"\"         if not self.connected:             return          self.writer.close()         self.reader = None         self.writer = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python server disconnect socket [SEP] def split_strings_in_list_retain_spaces(orig_list):     \"\"\"     Function to split every line in a list, and retain spaces for a rejoin     :param orig_list: Original list     :return:         A List with split lines      \"\"\"     temp_list = list()     for line in orig_list:         line_split = __re.split(r'(\\s+)', line)         temp_list.append(line_split)      return temp_list", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to save print to txt file python [SEP] def _display(self, layout):         \"\"\"launch layouts display\"\"\"         print(file=self.out)         TextWriter().format(layout, self.out)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to save print to txt file python [SEP] def transcript_sort_key(transcript):     \"\"\"     Key function used to sort transcripts. Taking the negative of     protein sequence length and nucleotide sequence length so that     the transcripts with longest sequences come first in the list. This couldn't     be accomplished with `reverse=True` since we're also sorting by     transcript name (which places TP53-001 before TP53-002).     \"\"\"     return (         -len(transcript.protein_sequence),         -len(transcript.sequence),         transcript.name     )", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to save print to txt file python [SEP] def wr_txt(self, fout_txt=\"gos_depth01.txt\", title=None):         \"\"\"write text table of depth-01 GO terms and their letter representation.\"\"\"         with open(fout_txt, 'w') as prt:             self.prt_header(prt, title)             data_nts = self.prt_txt(prt)             sys.stdout.write(\"  {N:>5} items WROTE: {TXT}\\n\".format(                 N=len(data_nts), TXT=fout_txt))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to save print to txt file python [SEP] def executeMethod(self, methodName, args):     \"\"\"Executes a method named ``methodName`` with the specified arguments.      This method is called when the user executes a command as defined in     the node spec. It provides a perfectly reasonble implementation     of the command mechanism. As a sub-class developer you just need to     implement a method for each command in the node spec. Note that due to     the command mechanism only unnamed argument are supported.      :param methodName: (string) the name of the method that correspond to a            command in the spec.     :param args: (list) of arguments that will be passed to the method     \"\"\"     if not hasattr(self, methodName):       raise Exception('Missing command method: ' + methodName)      m = getattr(self, methodName)     if not hasattr(m, '__call__'):       raise Exception('Command: ' + methodName + ' must be callable')      return m(*args)", "target": 0, "target_options": ["no match", "match"]}
{"input": "encody python to string [SEP] def string_repr(s):     \"\"\"Return a string as hex dump.\"\"\"     if compat.is_bytes(s):         res = \"{!r}: \".format(s)         for b in s:             if type(b) is str:  # Py2                 b = ord(b)             res += \"%02x \" % b         return res     return \"{}\".format(s)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "encody python to string [SEP] def set_empty_text(self):         \"\"\"Display the empty text         \"\"\"         self.buffer.insert_with_tags_by_name(             self.buffer.get_start_iter(),             self.empty_text, 'empty-text')", "target": 0, "target_options": ["no match", "match"]}
{"input": "encody python to string [SEP] def to_unicode_repr( _letter ):     \"\"\" helpful in situations where browser/app may recognize Unicode encoding         in the \\u0b8e type syntax but not actual unicode glyph/code-point\"\"\"     # Python 2-3 compatible     return u\"u'\"+ u\"\".join( [ u\"\\\\u%04x\"%ord(l) for l in _letter ] ) + u\"'\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "encody python to string [SEP] def format_float(value): # not used     \"\"\"Modified form of the 'g' format specifier.     \"\"\"     string = \"{:g}\".format(value).replace(\"e+\", \"e\")     string = re.sub(\"e(-?)0*(\\d+)\", r\"e\\1\\2\", string)     return string", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to draw a rectangle ina plane opengl python [SEP] def draw(self):         \"\"\"Draw the shape in the current OpenGL context.          \"\"\"         if self.enabled:             self._vertex_list.colors = self._gl_colors             self._vertex_list.vertices = self._gl_vertices             self._vertex_list.draw(pyglet.gl.GL_TRIANGLES)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to draw a rectangle ina plane opengl python [SEP] def clean_text(text):     \"\"\"Clean text before parsing.\"\"\"     # Replace a few nasty unicode characters with their ASCII equivalent     maps = {u'×': u'x', u'–': u'-', u'−': '-'}     for element in maps:         text = text.replace(element, maps[element])      # Replace genitives     text = re.sub(r'(?<=\\w)\\'s\\b|(?<=\\w)s\\'(?!\\w)', '  ', text)      logging.debug(u'Clean text: \"%s\"', text)      return text", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to draw a rectangle ina plane opengl python [SEP] def draw(self, mode=\"triangles\"):         \"\"\" Draw collection \"\"\"          gl.glDepthMask(0)         Collection.draw(self, mode)         gl.glDepthMask(1)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to draw a rectangle ina plane opengl python [SEP] def __str__(self):         \"\"\"Return a string representation of the RedditContentObject.\"\"\"         retval = self.__unicode__()         if not six.PY3:             retval = retval.encode('utf-8')         return retval", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to write only unique to python [SEP] def _remove_duplicates(objects):     \"\"\"Removes duplicate objects.      http://www.peterbe.com/plog/uniqifiers-benchmark.     \"\"\"     seen, uniq = set(), []     for obj in objects:         obj_id = id(obj)         if obj_id in seen:             continue         seen.add(obj_id)         uniq.append(obj)     return uniq", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to write only unique to python [SEP] def recarray(self):         \"\"\"Returns data as :class:`numpy.recarray`.\"\"\"         return numpy.rec.fromrecords(self.records, names=self.names)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to write only unique to python [SEP] def unduplicate_field_names(field_names):     \"\"\"Append a number to duplicate field names to make them unique. \"\"\"     res = []     for k in field_names:         if k in res:             i = 1             while k + '_' + str(i) in res:                 i += 1             k += '_' + str(i)         res.append(k)     return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to write only unique to python [SEP] def __contains__(self, key):         \"\"\" Tests if a key is contained in the store.              May test againsts self.defaults              :param str value: Value         \"\"\"         if self._haveKey(key) or key in self.defaults:             return True         else:             return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "python print elements of list in string format [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python print elements of list in string format [SEP] def make_regex(separator):     \"\"\"Utility function to create regexp for matching escaped separators     in strings.      \"\"\"     return re.compile(r'(?:' + re.escape(separator) + r')?((?:[^' +                       re.escape(separator) + r'\\\\]|\\\\.)+)')", "target": 0, "target_options": ["no match", "match"]}
{"input": "python print elements of list in string format [SEP] def _str_to_list(s):     \"\"\"Converts a comma separated string to a list\"\"\"     _list = s.split(\",\")     return list(map(lambda i: i.lstrip(), _list))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python print elements of list in string format [SEP] def notify(self, msgtype, method, params):         \"\"\"Handle an incoming notify request.\"\"\"         self.dispatch.call(method, params)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to make yaml [SEP] def print_yaml(o):     \"\"\"Pretty print an object as YAML.\"\"\"     print(yaml.dump(o, default_flow_style=False, indent=4, encoding='utf-8'))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to make yaml [SEP] def format_float(value): # not used     \"\"\"Modified form of the 'g' format specifier.     \"\"\"     string = \"{:g}\".format(value).replace(\"e+\", \"e\")     string = re.sub(\"e(-?)0*(\\d+)\", r\"e\\1\\2\", string)     return string", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to make yaml [SEP] def yaml_to_param(obj, name): \t\"\"\" \tReturn the top-level element of a document sub-tree containing the \tYAML serialization of a Python object. \t\"\"\" \treturn from_pyvalue(u\"yaml:%s\" % name, unicode(yaml.dump(obj)))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to make yaml [SEP] def normalize_value(text):     \"\"\"     This removes newlines and multiple spaces from a string.     \"\"\"     result = text.replace('\\n', ' ')     result = re.subn('[ ]{2,}', ' ', result)[0]     return result", "target": 0, "target_options": ["no match", "match"]}
{"input": "linux python lock file [SEP] def __enter__(self):         \"\"\"Acquire a lock on the output file, prevents collisions between multiple runs.\"\"\"         self.fd = open(self.filename, 'a')         fcntl.lockf(self.fd, fcntl.LOCK_EX)         return self.fd", "target": 1, "target_options": ["no_match", "match"]}
{"input": "linux python lock file [SEP] def iget_list_column_slice(list_, start=None, stop=None, stride=None):     \"\"\" iterator version of get_list_column \"\"\"     if isinstance(start, slice):         slice_ = start     else:         slice_ = slice(start, stop, stride)     return (row[slice_] for row in list_)", "target": 0, "target_options": ["no match", "match"]}
{"input": "linux python lock file [SEP] def acquire_nix(lock_file):  # pragma: no cover     \"\"\"Acquire a lock file on linux or osx.\"\"\"     fd = os.open(lock_file, OPEN_MODE)      try:         fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)     except (IOError, OSError):         os.close(fd)     else:         return fd", "target": 1, "target_options": ["no_match", "match"]}
{"input": "linux python lock file [SEP] def unique(list):     \"\"\" Returns a copy of the list without duplicates.     \"\"\"     unique = []; [unique.append(x) for x in list if x not in unique]     return unique", "target": 0, "target_options": ["no match", "match"]}
{"input": "python visualizing line by line [SEP] def csvpretty(csvfile: csvfile=sys.stdin):     \"\"\" Pretty print a CSV file. \"\"\"     shellish.tabulate(csv.reader(csvfile))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python visualizing line by line [SEP] def C_dict2array(C):     \"\"\"Convert an OrderedDict containing C values to a 1D array.\"\"\"     return np.hstack([np.asarray(C[k]).ravel() for k in C_keys])", "target": 0, "target_options": ["no match", "match"]}
{"input": "python visualizing line by line [SEP] def reduce_multiline(string):     \"\"\"     reduces a multiline string to a single line of text.       args:         string: the text to reduce     \"\"\"     string = str(string)     return \" \".join([item.strip()                      for item in string.split(\"\\n\")                      if item.strip()])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python visualizing line by line [SEP] def abspath(*path):     \"\"\"A method to determine absolute path for a given relative path to the     directory where this setup.py script is located\"\"\"     setup_dir = os.path.dirname(os.path.abspath(__file__))     return os.path.join(setup_dir, *path)", "target": 0, "target_options": ["no match", "match"]}
{"input": "finding the median of an arrray in python [SEP] def fast_median(a):     \"\"\"Fast median operation for masked array using 50th-percentile     \"\"\"     a = checkma(a)     #return scoreatpercentile(a.compressed(), 50)     if a.count() > 0:         out = np.percentile(a.compressed(), 50)     else:         out = np.ma.masked     return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "finding the median of an arrray in python [SEP] def connected_socket(address, timeout=3):     \"\"\" yields a connected socket \"\"\"     sock = socket.create_connection(address, timeout)     yield sock     sock.close()", "target": 0, "target_options": ["no match", "match"]}
{"input": "finding the median of an arrray in python [SEP] def findMax(arr):     \"\"\"     in comparison to argrelmax() more simple and  reliable peak finder     \"\"\"     out = np.zeros(shape=arr.shape, dtype=bool)     _calcMax(arr, out)     return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "finding the median of an arrray in python [SEP] def load_files(files):     \"\"\"Load and execute a python file.\"\"\"      for py_file in files:         LOG.debug(\"exec %s\", py_file)         execfile(py_file, globals(), locals())", "target": 0, "target_options": ["no match", "match"]}
{"input": "concatenate list items into string python [SEP] def list2string (inlist,delimit=' '):     \"\"\" Converts a 1D list to a single long string for file output, using the string.join function.  Usage:   list2string (inlist,delimit=' ') Returns: the string created from inlist \"\"\"     stringlist = [makestr(_) for _ in inlist]     return string.join(stringlist,delimit)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "concatenate list items into string python [SEP] def nameTuple(s: Influence) -> Tuple[str, str]:     \"\"\" Returns a 2-tuple consisting of the top groundings of the subj and obj     of an Influence statement. \"\"\"     return top_grounding(s.subj), top_grounding(s.obj)", "target": 0, "target_options": ["no match", "match"]}
{"input": "concatenate list items into string python [SEP] def commajoin_as_strings(iterable):     \"\"\" Join the given iterable with ',' \"\"\"     return _(u',').join((six.text_type(i) for i in iterable))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "concatenate list items into string python [SEP] def split(s):   \"\"\"Uses dynamic programming to infer the location of spaces in a string without spaces.\"\"\"   l = [_split(x) for x in _SPLIT_RE.split(s)]   return [item for sublist in l for item in sublist]", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to make a list of lists in python [SEP] def flatten_list(x: List[Any]) -> List[Any]:     \"\"\"     Converts a list of lists into a flat list.          Args:         x: list of lists       Returns:         flat list              As per     http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python      \"\"\"  # noqa     return [item for sublist in x for item in sublist]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to make a list of lists in python [SEP] def Counter64(a, b, delta):     \"\"\"64bit counter aggregator with wrapping     \"\"\"     if b < a:         c = 18446744073709551615 - a         return (c + b) / float(delta)      return (b - a) / float(delta)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to make a list of lists in python [SEP] def serialize(self, value, **kwargs):         \"\"\"Serialize every item of the list.\"\"\"         return [self.item_type.serialize(val, **kwargs) for val in value]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to make a list of lists in python [SEP] def is_published(self):         \"\"\"stub\"\"\"         if 'published' not in self.my_osid_object._my_map:             return False         return bool(self.my_osid_object._my_map['published'])", "target": 0, "target_options": ["no match", "match"]}
{"input": "python3 binary integer to bytes [SEP] def intToBin(i):     \"\"\" Integer to two bytes \"\"\"     # divide in two parts (bytes)     i1 = i % 256     i2 = int(i / 256)     # make string (little endian)     return i.to_bytes(2, byteorder='little')", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python3 binary integer to bytes [SEP] def __init__(self, baken_file=None):         \"\"\"Initialise a new `Bakens` object.\"\"\"         super(Bakens, self).__init__()         if baken_file:             self.import_locations(baken_file)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python3 binary integer to bytes [SEP] def i2b(self, pkt, x):         \"\"\"Convert internal value to internal value\"\"\"         if type(x) is str:           x = bytes([ ord(i) for i in x ])         return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python3 binary integer to bytes [SEP] def _check_and_convert_bools(self):         \"\"\"Replace boolean variables by the characters 'F'/'T'         \"\"\"         replacements = {             True: 'T',             False: 'F',         }          for key in self.bools:             if isinstance(self[key], bool):                 self[key] = replacements[self[key]]", "target": 0, "target_options": ["no match", "match"]}
{"input": "x y z normalize vector python [SEP] def _z(self, x):     \"\"\"Standardize input `x` to a unit normal.\"\"\"     with tf.name_scope(\"standardize\"):       return (x - self.loc) / self.scale", "target": 1, "target_options": ["no_match", "match"]}
{"input": "x y z normalize vector python [SEP] def fix_header_comment(filename, timestamp):     \"\"\"Fixes the header-comment of the given file.\"\"\"     # Fix input file.     name = os.path.basename( filename )     for line in fileinput.input( filename, inplace=1, mode=\"rU\" ):         # If header-comment already contains anything for '$Id$', remove it.         line = re.sub(r'\\$Id:[^$]+\\$', r'$Id$', line.rstrip())         # Replace '$Id$' by a string containing the file's name (and a timestamp)!         line = re.sub(re.escape(r'$Id$'), r'$Id: ' + name + r' ' + timestamp.isoformat() + r' $', line.rstrip())         print(line)", "target": 0, "target_options": ["no match", "match"]}
{"input": "x y z normalize vector python [SEP] def normalize(data):     \"\"\"     Function to normalize data to have mean 0 and unity standard deviation     (also called z-transform)               Parameters     ----------     data : numpy.ndarray               Returns     -------     numpy.ndarray         z-transform of input array          \"\"\"     data = data.astype(float)     data -= data.mean()          return data / data.std()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "x y z normalize vector python [SEP] def pretty_dict_str(d, indent=2):     \"\"\"shows JSON indented representation of d\"\"\"     b = StringIO()     write_pretty_dict_str(b, d, indent=indent)     return b.getvalue()", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to test of a list contains something in python [SEP] def _check_elements_equal(lst):     \"\"\"     Returns true if all of the elements in the list are equal.     \"\"\"     assert isinstance(lst, list), \"Input value must be a list.\"     return not lst or lst.count(lst[0]) == len(lst)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to test of a list contains something in python [SEP] def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to test of a list contains something in python [SEP] def isin(value, values):     \"\"\" Check that value is in values \"\"\"     for i, v in enumerate(value):         if v not in np.array(values)[:, i]:             return False     return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to test of a list contains something in python [SEP] def skip_connection_distance(a, b):     \"\"\"The distance between two skip-connections.\"\"\"     if a[2] != b[2]:         return 1.0     len_a = abs(a[1] - a[0])     len_b = abs(b[1] - b[0])     return (abs(a[0] - b[0]) + abs(len_a - len_b)) / (max(a[0], b[0]) + max(len_a, len_b))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python take tuple as an input return new tuple as output [SEP] def compose_all(tups):   \"\"\"Compose all given tuples together.\"\"\"   from . import ast  # I weep for humanity   return functools.reduce(lambda x, y: x.compose(y), map(ast.make_tuple, tups), ast.make_tuple({}))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python take tuple as an input return new tuple as output [SEP] def plot_target(target, ax):     \"\"\"Ajoute la target au plot\"\"\"     ax.scatter(target[0], target[1], target[2], c=\"red\", s=80)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python take tuple as an input return new tuple as output [SEP] def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python take tuple as an input return new tuple as output [SEP] def S(self):         \"\"\":obj:`numpy.ndarray` : The 3x3 scaling matrix for this projection         \"\"\"         S = np.array([[self._plane_width / self._vol_width, 0, 0],                       [0, self._plane_height / self._vol_height, 0],                       [0, 0, self._depth_scale / self._vol_depth]])         return S", "target": 0, "target_options": ["no match", "match"]}
{"input": "python strip args before running function [SEP] def gpp(argv=None):     \"\"\"Shortcut function for running the previewing command.\"\"\"     if argv is None:         argv = sys.argv[1:]     argv.insert(0, 'preview')     return main(argv)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python strip args before running function [SEP] def _remove_invalid_char(s):     \"\"\"Remove invalid and dangerous characters from a string.\"\"\"      s = ''.join([i if ord(i) >= 32 and ord(i) < 127 else '' for i in s])     s = s.translate(dict.fromkeys(map(ord, \"_%~#\\\\{}\\\":\")))     return s", "target": 0, "target_options": ["no match", "match"]}
{"input": "python strip args before running function [SEP] def argument_search(self):         \"\"\"             Uses the command line arguments to fill the search function and call it.         \"\"\"         arguments, _ = self.argparser.parse_known_args()         return self.search(**vars(arguments))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python strip args before running function [SEP] def isInt(num):     \"\"\"Returns true if `num` is (sort of) an integer.     >>> isInt(3) == isInt(3.0) == 1     True     >>> isInt(3.2)     False     >>> import numpy     >>> isInt(numpy.array(1))     True     >>> isInt(numpy.array([1]))     False     \"\"\"     try:         len(num) # FIXME fails for Numeric but Numeric is obsolete     except:         try:             return (num - math.floor(num) == 0) == True         except: return False     else: return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "test django api in python shell [SEP] def test(*args):     \"\"\"     Run unit tests.     \"\"\"     subprocess.call([\"py.test-2.7\"] + list(args))     subprocess.call([\"py.test-3.4\"] + list(args))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "test django api in python shell [SEP] def prt_js(js, sort_keys=True, indent=4):     \"\"\"Print Json in pretty format.     There's a standard module pprint, can pretty print python dict and list.     But it doesn't support sorted key. That why we need this func.      Usage::          >>> from weatherlab.lib.dataIO.js import prt_js         >>> prt_js({\"a\": 1, \"b\": 2})         {             \"a\": 1,             \"b\": 2         }      **中文文档**      以人类可读的方式打印可Json化的Python对象。     \"\"\"     print(js2str(js, sort_keys, indent))", "target": 0, "target_options": ["no match", "match"]}
{"input": "test django api in python shell [SEP] def build_suite(args):     \"\"\"Build a test suite by loading TAP files or a TAP stream.\"\"\"     loader = Loader()     if len(args.files) == 0 or args.files[0] == \"-\":         suite = loader.load_suite_from_stdin()     else:         suite = loader.load(args.files)     return suite", "target": 1, "target_options": ["no_match", "match"]}
{"input": "test django api in python shell [SEP] def _remove_duplicates(objects):     \"\"\"Removes duplicate objects.      http://www.peterbe.com/plog/uniqifiers-benchmark.     \"\"\"     seen, uniq = set(), []     for obj in objects:         obj_id = id(obj)         if obj_id in seen:             continue         seen.add(obj_id)         uniq.append(obj)     return uniq", "target": 0, "target_options": ["no match", "match"]}
{"input": "check to see if a value in dictionary is empty in python [SEP] def is_valid_row(cls, row):         \"\"\"Indicates whether or not the given row contains valid data.\"\"\"         for k in row.keys():             if row[k] is None:                 return False         return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check to see if a value in dictionary is empty in python [SEP] def eof(fd):     \"\"\"Determine if end-of-file is reached for file fd.\"\"\"     b = fd.read(1)     end = len(b) == 0     if not end:         curpos = fd.tell()         fd.seek(curpos - 1)     return end", "target": 0, "target_options": ["no match", "match"]}
{"input": "check to see if a value in dictionary is empty in python [SEP] def contains_empty(features):     \"\"\"Check features data are not empty      :param features: The features data to check.     :type features: list of numpy arrays.      :return: True if one of the array is empty, False else.      \"\"\"     if not features:         return True     for feature in features:         if feature.shape[0] == 0:             return True     return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check to see if a value in dictionary is empty in python [SEP] def is_square_matrix(mat):     \"\"\"Test if an array is a square matrix.\"\"\"     mat = np.array(mat)     if mat.ndim != 2:         return False     shape = mat.shape     return shape[0] == shape[1]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python print a tuple without trailing comma [SEP] def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python print a tuple without trailing comma [SEP] def to_bytes(s, encoding=\"utf-8\"):     \"\"\"Convert a string to bytes.\"\"\"     if isinstance(s, six.binary_type):         return s     if six.PY3:         return bytes(s, encoding)     return s.encode(encoding)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python print a tuple without trailing comma [SEP] def imt2tup(string):     \"\"\"     >>> imt2tup('PGA')     ('PGA',)     >>> imt2tup('SA(1.0)')     ('SA', 1.0)     >>> imt2tup('SA(1)')     ('SA', 1.0)     \"\"\"     s = string.strip()     if not s.endswith(')'):         # no parenthesis, PGA is considered the same as PGA()         return (s,)     name, rest = s.split('(', 1)     return (name,) + tuple(float(x) for x in ast.literal_eval(rest[:-1] + ','))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python print a tuple without trailing comma [SEP] def gtype_to_python(gtype):         \"\"\"Map a gtype to the name of the Python type we use to represent it.          \"\"\"          fundamental = gobject_lib.g_type_fundamental(gtype)          if gtype in GValue._gtype_to_python:             return GValue._gtype_to_python[gtype]         if fundamental in GValue._gtype_to_python:             return GValue._gtype_to_python[fundamental]         return '<unknown type>'", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to make something repeat print [SEP] def stdoutwriteline(*args):     \"\"\"     @type args: tuple     @return: None     \"\"\"     s = \"\"      for i in args:         s += str(i) + \" \"      s = s.strip()     sys.stdout.write(str(s) + \"\\n\")     sys.stdout.flush()      return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to make something repeat print [SEP] def run_time() -> timedelta:     \"\"\"      :return:     \"\"\"      delta = start_time if start_time else datetime.utcnow()     return datetime.utcnow() - delta", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to make something repeat print [SEP] def _display(self, layout):         \"\"\"launch layouts display\"\"\"         print(file=self.out)         TextWriter().format(layout, self.out)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to make something repeat print [SEP] def compose_all(tups):   \"\"\"Compose all given tuples together.\"\"\"   from . import ast  # I weep for humanity   return functools.reduce(lambda x, y: x.compose(y), map(ast.make_tuple, tups), ast.make_tuple({}))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to index arrays in python [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to index arrays in python [SEP] def u16le_list_to_byte_list(data):     \"\"\"! @brief Convert a halfword array into a byte array\"\"\"     byteData = []     for h in data:         byteData.extend([h & 0xff, (h >> 8) & 0xff])     return byteData", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to index arrays in python [SEP] def _transform_triple_numpy(x):     \"\"\"Transform triple index into a 1-D numpy array.\"\"\"     return np.array([x.head, x.relation, x.tail], dtype=np.int64)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to index arrays in python [SEP] def set_name(self, name):         \"\"\"Set the module name to a 6 byte string          If the string is too short it is appended with space characters.         \"\"\"          if len(name) > 6:             raise ArgumentError(\"Name must be at most 6 characters long\", name=name)          if len(name) < 6:             name += ' '*(6 - len(name))          self.name = name", "target": 0, "target_options": ["no match", "match"]}
{"input": "sort by column and value condition python [SEP] def sort_data(data, cols):     \"\"\"Sort `data` rows and order columns\"\"\"     return data.sort_values(cols)[cols + ['value']].reset_index(drop=True)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "sort by column and value condition python [SEP] def _vars_match(self):         \"\"\"Regular expression to match playbook variable.\"\"\"         return re.compile(             r'#([A-Za-z]+)'  # match literal (#App) at beginning of String             r':([\\d]+)'  # app id (:7979)             r':([A-Za-z0-9_\\.\\-\\[\\]]+)'  # variable name (:variable_name)             r'!(StringArray|BinaryArray|KeyValueArray'  # variable type (array)             r'|TCEntityArray|TCEnhancedEntityArray'  # variable type (array)             r'|String|Binary|KeyValue|TCEntity|TCEnhancedEntity'  # variable type             r'|(?:(?!String)(?!Binary)(?!KeyValue)'  # non matching for custom             r'(?!TCEntity)(?!TCEnhancedEntity)'  # non matching for custom             r'[A-Za-z0-9_-]+))'  # variable type (custom)         )", "target": 0, "target_options": ["no match", "match"]}
{"input": "sort by column and value condition python [SEP] def first(series, order_by=None):     \"\"\"     Returns the first value of a series.      Args:         series (pandas.Series): column to summarize.      Kwargs:         order_by: a pandas.Series or list of series (can be symbolic) to order             the input series by before summarization.     \"\"\"      if order_by is not None:         series = order_series_by(series, order_by)     first_s = series.iloc[0]     return first_s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "sort by column and value condition python [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to change a sinlge value in a python list [SEP] def _fill_array_from_list(the_list, the_array):         \"\"\"Fill an `array` from a `list`\"\"\"         for i, val in enumerate(the_list):             the_array[i] = val         return the_array", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to change a sinlge value in a python list [SEP] def latest_commit(self) -> git.Commit:         \"\"\"         :return: latest commit         :rtype: git.Commit object         \"\"\"         latest_commit: git.Commit = self.repo.head.commit         LOGGER.debug('latest commit: %s', latest_commit)         return latest_commit", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to change a sinlge value in a python list [SEP] def flatten(l, types=(list, float)):     \"\"\"     Flat nested list of lists into a single list.     \"\"\"     l = [item if isinstance(item, types) else [item] for item in l]     return [item for sublist in l for item in sublist]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to change a sinlge value in a python list [SEP] def call_out(command):   \"\"\"   Run the given command (with shell=False) and return a tuple of   (int returncode, str output). Strip the output of enclosing whitespace.   \"\"\"   # start external command process   p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)    # get outputs   out, _ = p.communicate()    return p.returncode, out.strip()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python test time part of code [SEP] def timeit(output):     \"\"\"     If output is string, then print the string and also time used     \"\"\"     b = time.time()     yield     print output, 'time used: %.3fs' % (time.time()-b)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python test time part of code [SEP] def stop(self) -> None:         \"\"\"Stops the analysis as soon as possible.\"\"\"         if self._stop and not self._posted_kork:             self._stop()             self._stop = None", "target": 0, "target_options": ["no match", "match"]}
{"input": "python test time part of code [SEP] def timespan(start_time):     \"\"\"Return time in milliseconds from start_time\"\"\"      timespan = datetime.datetime.now() - start_time     timespan_ms = timespan.total_seconds() * 1000     return timespan_ms", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python test time part of code [SEP] def get_data_table(filename):   \"\"\"Returns a DataTable instance built from either the filename, or STDIN if filename is None.\"\"\"   with get_file_object(filename, \"r\") as rf:     return DataTable(list(csv.reader(rf)))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python beautifulsoup check self with selector [SEP] def selected(self):         \"\"\"         Check whether all the matched elements are selected.          Returns:             bool         \"\"\"         query_results = self.map(lambda el: el.is_selected(), 'selected').results         if query_results:             return all(query_results)         return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python beautifulsoup check self with selector [SEP] def flushed_print(*args, **kwargs):     \"\"\"     Use to replace print(*args, flush=True) that doesn't exist for python<3.3     \"\"\"     print(*args, **kwargs)     file = kwargs.get('file', sys.stdout)     file.flush() if file is not None else sys.stdout.flush()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python beautifulsoup check self with selector [SEP] def _css_select(soup, css_selector):         \"\"\" Returns the content of the element pointed by the CSS selector,         or an empty string if not found \"\"\"         selection = soup.select(css_selector)         if len(selection) > 0:             if hasattr(selection[0], 'text'):                 retour = selection[0].text.strip()             else:                 retour = \"\"         else:             retour = \"\"         return retour", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python beautifulsoup check self with selector [SEP] def compose_all(tups):   \"\"\"Compose all given tuples together.\"\"\"   from . import ast  # I weep for humanity   return functools.reduce(lambda x, y: x.compose(y), map(ast.make_tuple, tups), ast.make_tuple({}))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to get compiled python file [SEP] def get_code(module):     \"\"\"     Compile and return a Module's code object.     \"\"\"     fp = open(module.path)     try:         return compile(fp.read(), str(module.name), 'exec')     finally:         fp.close()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to get compiled python file [SEP] def remove_dups(seq):     \"\"\"remove duplicates from a sequence, preserving order\"\"\"     seen = set()     seen_add = seen.add     return [x for x in seq if not (x in seen or seen_add(x))]", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to get compiled python file [SEP] def execfile(fname, variables):     \"\"\" This is builtin in python2, but we have to roll our own on py3. \"\"\"     with open(fname) as f:         code = compile(f.read(), fname, 'exec')         exec(code, variables)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to get compiled python file [SEP] def _build_url(self, shorten=True):         \"\"\"Build the url for a cable ratings page\"\"\"         self.url = URL_FORMAT.format(*self._get_url_params(shorten=shorten))", "target": 0, "target_options": ["no match", "match"]}
{"input": "check if df is empty python [SEP] def contains_empty(features):     \"\"\"Check features data are not empty      :param features: The features data to check.     :type features: list of numpy arrays.      :return: True if one of the array is empty, False else.      \"\"\"     if not features:         return True     for feature in features:         if feature.shape[0] == 0:             return True     return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check if df is empty python [SEP] def replaceNewlines(string, newlineChar): \t\"\"\"There's probably a way to do this with string functions but I was lazy. \t\tReplace all instances of \\r or \\n in a string with something else.\"\"\" \tif newlineChar in string: \t\tsegments = string.split(newlineChar) \t\tstring = \"\" \t\tfor segment in segments: \t\t\tstring += segment \treturn string", "target": 0, "target_options": ["no match", "match"]}
{"input": "check if df is empty python [SEP] def empty(self):         \"\"\"         Indicator whether DataFrame is empty.          True if DataFrame is entirely empty (no items), meaning any of the         axes are of length 0.          Returns         -------         bool             If DataFrame is empty, return True, if not return False.          See Also         --------         Series.dropna         DataFrame.dropna          Notes         -----         If DataFrame contains only NaNs, it is still not considered empty. See         the example below.          Examples         --------         An example of an actual empty DataFrame. Notice the index is empty:          >>> df_empty = pd.DataFrame({'A' : []})         >>> df_empty         Empty DataFrame         Columns: [A]         Index: []         >>> df_empty.empty         True          If we only have NaNs in our DataFrame, it is not considered empty! We         will need to drop the NaNs to make the DataFrame empty:          >>> df = pd.DataFrame({'A' : [np.nan]})         >>> df             A         0 NaN         >>> df.empty         False         >>> df.dropna().empty         True         \"\"\"         return any(len(self._get_axis(a)) == 0 for a in self._AXIS_ORDERS)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check if df is empty python [SEP] def rgba_bytes_tuple(self, x):         \"\"\"Provides the color corresponding to value `x` in the         form of a tuple (R,G,B,A) with int values between 0 and 255.         \"\"\"         return tuple(int(u*255.9999) for u in self.rgba_floats_tuple(x))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to count the total elements in a set python [SEP] def most_common(items):     \"\"\"     Wanted functionality from Counters (new in Python 2.7).     \"\"\"     counts = {}     for i in items:         counts.setdefault(i, 0)         counts[i] += 1     return max(six.iteritems(counts), key=operator.itemgetter(1))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to count the total elements in a set python [SEP] def shutdown(self):         \"\"\"close socket, immediately.\"\"\"         if self.sock:             self.sock.close()             self.sock = None             self.connected = False", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to count the total elements in a set python [SEP] def _most_common(iterable):     \"\"\"Returns the most common element in `iterable`.\"\"\"     data = Counter(iterable)     return max(data, key=data.__getitem__)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to count the total elements in a set python [SEP] def hex2rgb(value):     \"\"\"Converts a hexadeximal color string to an RGB 3-tuple      EXAMPLE     -------     >>> hex2rgb('#0000FF')     (0, 0, 255)     \"\"\"     value = value.lstrip('#')     lv = len(value)     return tuple(int(value[i:i+lv//3], 16) for i in range(0, lv, lv//3))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python for loop, incremental range [SEP] def frange(start, stop, step, precision):     \"\"\"A generator that will generate a range of floats.\"\"\"     value = start     while round(value, precision) < stop:         yield round(value, precision)         value += step", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python for loop, incremental range [SEP] def _stdin_(p):     \"\"\"Takes input from user. Works for Python 2 and 3.\"\"\"     _v = sys.version[0]     return input(p) if _v is '3' else raw_input(p)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python for loop, incremental range [SEP] def _accumulate(sequence, func):     \"\"\"     Python2 accumulate implementation taken from     https://docs.python.org/3/library/itertools.html#itertools.accumulate     \"\"\"     iterator = iter(sequence)     total = next(iterator)     yield total     for element in iterator:         total = func(total, element)         yield total", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python for loop, incremental range [SEP] def chunks(data, size):     \"\"\"     Get chink for dict, copy as-is from https://stackoverflow.com/a/8290508/6753144     \"\"\"     it = iter(data)     for i in range(0, len(data), size):         yield {k: data[k] for k in islice(it, size)}", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to transform an object to integer in python [SEP] def FormatDescriptorToPython(i):     \"\"\"     Format a descriptor into a form which can be used as a python attribute      example::          >>> FormatDescriptorToPython('(Ljava/lang/Long; Ljava/lang/Long; Z Z)V')         'Ljava_lang_LongLjava_lang_LongZZV      :param i: name to transform     :rtype: str     \"\"\"      i = i.replace(\"/\", \"_\")     i = i.replace(\";\", \"\")     i = i.replace(\"[\", \"\")     i = i.replace(\"(\", \"\")     i = i.replace(\")\", \"\")     i = i.replace(\" \", \"\")     i = i.replace(\"$\", \"\")      return i", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to transform an object to integer in python [SEP] def add_suffix(fullname, suffix):     \"\"\" Add suffix to a full file name\"\"\"     name, ext = os.path.splitext(fullname)     return name + '_' + suffix + ext", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to transform an object to integer in python [SEP] def data_format_value(self):         \"\"\"         :return: The data type of the data component as integer value.         \"\"\"         try:             if self._part:                 value = self._part.data_format             else:                 value = self._buffer.pixel_format         except InvalidParameterException:             value = self._node_map.PixelFormat.value         return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to transform an object to integer in python [SEP] def _escape(self, s):         \"\"\"Escape bad characters for regular expressions.          Similar to `re.escape` but allows '%' to pass through.          \"\"\"         for ch, r_ch in self.ESCAPE_SETS:             s = s.replace(ch, r_ch)         return s", "target": 0, "target_options": ["no match", "match"]}
{"input": "python insert byte into byte array [SEP] def bytes_to_bits(bytes_):     \"\"\"Convert bytes to a list of bits     \"\"\"     res = []     for x in bytes_:         if not isinstance(x, int):             x = ord(x)         res += byte_to_bits(x)     return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python insert byte into byte array [SEP] def _str_to_list(s):     \"\"\"Converts a comma separated string to a list\"\"\"     _list = s.split(\",\")     return list(map(lambda i: i.lstrip(), _list))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python insert byte into byte array [SEP] def u16le_list_to_byte_list(data):     \"\"\"! @brief Convert a halfword array into a byte array\"\"\"     byteData = []     for h in data:         byteData.extend([h & 0xff, (h >> 8) & 0xff])     return byteData", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python insert byte into byte array [SEP] def pause_splitter(s):     \"\"\"\"\"\"      s = s.strip()     s = re.sub('([:;]|--+)', '\\g<1>\\n', s)     s = s.split('\\n')     s = [sent for sents in s for sent in sent_splitter.tokenize(sents)]     return s", "target": 0, "target_options": ["no match", "match"]}
{"input": "python envirment env dict [SEP] def exec_function(ast, globals_map):     \"\"\"Execute a python code object in the given environment.      Args:       globals_map: Dictionary to use as the globals context.     Returns:       locals_map: Dictionary of locals from the environment after execution.     \"\"\"     locals_map = globals_map     exec ast in globals_map, locals_map     return locals_map", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python envirment env dict [SEP] def cmd(send, msg, args):     \"\"\"'Inspects a bot attribute.      Syntax: {command} <attr>      \"\"\"     if not hasattr(args['handler'], msg):         send(\"That attribute was not found in the handler.\")         return     send(str(getattr(args['handler'], msg)))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python envirment env dict [SEP] def _get_env():     \"\"\"Extracts the environment PYTHONPATH and appends the current sys.path to     those.\"\"\"     env = dict(os.environ)     env[\"PYTHONPATH\"] = os.pathsep.join(sys.path)     return env", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python envirment env dict [SEP] def print_report(self):         \"\"\"         Print Compare report.          :return: None         \"\"\"         report = compare_report_print(             self.sorted, self.scores, self.best_name)         print(report)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to check if a file is in a directory [SEP] def isdir(s):     \"\"\"Return true if the pathname refers to an existing directory.\"\"\"     try:         st = os.stat(s)     except os.error:         return False     return stat.S_ISDIR(st.st_mode)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to check if a file is in a directory [SEP] def blocking(func, *args, **kwargs):     \"\"\"Run a function that uses blocking IO.      The function is run in the IO thread pool.     \"\"\"     pool = get_io_pool()     fut = pool.submit(func, *args, **kwargs)     return fut.result()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to check if a file is in a directory [SEP] def is_executable(path):   \"\"\"Returns whether a path names an existing executable file.\"\"\"   return os.path.isfile(path) and os.access(path, os.X_OK)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to check if a file is in a directory [SEP] def stylize(text, styles, reset=True):     \"\"\"conveniently styles your text as and resets ANSI codes at its end.\"\"\"     terminator = attr(\"reset\") if reset else \"\"     return \"{}{}{}\".format(\"\".join(styles), text, terminator)", "target": 0, "target_options": ["no match", "match"]}
{"input": "print particular lines in csv using python [SEP] def csvpretty(csvfile: csvfile=sys.stdin):     \"\"\" Pretty print a CSV file. \"\"\"     shellish.tabulate(csv.reader(csvfile))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "print particular lines in csv using python [SEP] def stdoutwriteline(*args):     \"\"\"     @type args: tuple     @return: None     \"\"\"     s = \"\"      for i in args:         s += str(i) + \" \"      s = s.strip()     sys.stdout.write(str(s) + \"\\n\")     sys.stdout.flush()      return s", "target": 0, "target_options": ["no match", "match"]}
{"input": "print particular lines in csv using python [SEP] def tsv_escape(x: Any) -> str:     \"\"\"     Escape data for tab-separated value (TSV) format.     \"\"\"     if x is None:         return \"\"     x = str(x)     return x.replace(\"\\t\", \"\\\\t\").replace(\"\\n\", \"\\\\n\")", "target": 1, "target_options": ["no_match", "match"]}
{"input": "print particular lines in csv using python [SEP] def calculate_bbox_area(bbox, rows, cols):     \"\"\"Calculate the area of a bounding box in pixels.\"\"\"     bbox = denormalize_bbox(bbox, rows, cols)     x_min, y_min, x_max, y_max = bbox[:4]     area = (x_max - x_min) * (y_max - y_min)     return area", "target": 0, "target_options": ["no match", "match"]}
{"input": "python 3d array reflection [SEP] def recarray(self):         \"\"\"Returns data as :class:`numpy.recarray`.\"\"\"         return numpy.rec.fromrecords(self.records, names=self.names)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python 3d array reflection [SEP] def as_csv(self):         \"\"\"Return a CSV representation as a string\"\"\"          from io import StringIO          s = StringIO()         w = csv.writer(s)         for row in self.rows:             w.writerow(row)          return s.getvalue()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python 3d array reflection [SEP] def dump_nparray(self, obj, class_name=numpy_ndarray_class_name):         \"\"\"         ``numpy.ndarray`` dumper.         \"\"\"         return {\"$\" + class_name: self._json_convert(obj.tolist())}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python 3d array reflection [SEP] def __init__(self, baken_file=None):         \"\"\"Initialise a new `Bakens` object.\"\"\"         super(Bakens, self).__init__()         if baken_file:             self.import_locations(baken_file)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to skip a line starting with # while reading a file line by line in python [SEP] def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:     \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"     for line in file_like:         line = line.rstrip('\\r\\n')         if line:             yield line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to skip a line starting with # while reading a file line by line in python [SEP] def __eq__(self, other):         \"\"\"         Returns +true+ if the other object is a MIME::Type and the content         types match.         \"\"\"         return isinstance(other, self.__class__) and cmp(self, other) == 0", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to skip a line starting with # while reading a file line by line in python [SEP] def file_lines(bblfile:str) -> iter:     \"\"\"Yield lines found in given file\"\"\"     with open(bblfile) as fd:         yield from (line.rstrip() for line in fd if line.rstrip())", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to skip a line starting with # while reading a file line by line in python [SEP] def replaceNewlines(string, newlineChar): \t\"\"\"There's probably a way to do this with string functions but I was lazy. \t\tReplace all instances of \\r or \\n in a string with something else.\"\"\" \tif newlineChar in string: \t\tsegments = string.split(newlineChar) \t\tstring = \"\" \t\tfor segment in segments: \t\t\tstring += segment \treturn string", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to ensure a file is a text file [SEP] def is_readable(filename):     \"\"\"Check if file is a regular file and is readable.\"\"\"     return os.path.isfile(filename) and os.access(filename, os.R_OK)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to ensure a file is a text file [SEP] async def login(         username: str, password: str, brand: str,         websession: ClientSession = None) -> API:     \"\"\"Log in to the API.\"\"\"     api = API(brand, websession)     await api.authenticate(username, password)     return api", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to ensure a file is a text file [SEP] def read_file(path):     \"\"\"     Read file to string.      Arguments:         path (str): Source.     \"\"\"     with open(must_exist(path)) as infile:         r = infile.read()     return r", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to ensure a file is a text file [SEP] def resize(src, size, interpolation=cv2.INTER_LINEAR):     \"\"\"Decode image from str buffer.     Wrapper for cv2.imresize that uses mx.nd.NDArray      Parameters     ----------     src : NDArray         image in (width, height, channels)     size : tuple         target size in (width, height)     interpolation : int         same as interpolation for cv2.imresize      Returns     -------     img : NDArray         resized image     \"\"\"     hdl = NDArrayHandle()     check_call(_LIB.MXCVResize(src.handle, mx_uint(size[0]), mx_uint(size[1]),                                interpolation, ctypes.byref(hdl)))     return mx.nd.NDArray(hdl)", "target": 0, "target_options": ["no match", "match"]}
{"input": "function to check valid number in python [SEP] def validate_non_negative_integer(option, value):     \"\"\"Validate that 'value' is a positive integer or 0.     \"\"\"     val = validate_integer(option, value)     if val < 0:         raise ValueError(\"The value of %s must be \"                          \"a non negative integer\" % (option,))     return val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "function to check valid number in python [SEP] def hex2rgb(value):     \"\"\"Converts a hexadeximal color string to an RGB 3-tuple      EXAMPLE     -------     >>> hex2rgb('#0000FF')     (0, 0, 255)     \"\"\"     value = value.lstrip('#')     lv = len(value)     return tuple(int(value[i:i+lv//3], 16) for i in range(0, lv, lv//3))", "target": 0, "target_options": ["no match", "match"]}
{"input": "function to check valid number in python [SEP] def validate_positive_integer(option, value):     \"\"\"Validate that 'value' is a positive integer, which does not include 0.     \"\"\"     val = validate_integer(option, value)     if val <= 0:         raise ValueError(\"The value of %s must be \"                          \"a positive integer\" % (option,))     return val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "function to check valid number in python [SEP] def move_file(source, dest):      \"\"\"      Move file from *source* to *dest*      If file is a Python script, also rename .pyc and .pyo files if any      \"\"\"      import shutil      shutil.copy(source, dest)      remove_file(source)", "target": 0, "target_options": ["no match", "match"]}
{"input": "close all sockets python [SEP] def close(self):         \"\"\"Close the connection.\"\"\"         if self.sock:             self.sock.close()         self.sock = 0         self.eof = 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "close all sockets python [SEP] def unique(self, values):         \"\"\"Place each entry in a table, while asserting that each entry occurs once\"\"\"         _, count = self.count()         if not np.array_equiv(count, 1):             raise ValueError(\"Not every entry in the table is assigned a unique value\")         return self.sum(values)", "target": 0, "target_options": ["no match", "match"]}
{"input": "close all sockets python [SEP] def connected_socket(address, timeout=3):     \"\"\" yields a connected socket \"\"\"     sock = socket.create_connection(address, timeout)     yield sock     sock.close()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "close all sockets python [SEP] def elapsed_time_from(start_time):     \"\"\"calculate time delta from latched time and current time\"\"\"     time_then = make_time(start_time)     time_now = datetime.utcnow().replace(microsecond=0)     if time_then is None:         return     delta_t = time_now - time_then     return delta_t", "target": 0, "target_options": ["no match", "match"]}
{"input": "python strings remove characters that are not numeric [SEP] def _remove_invalid_char(s):     \"\"\"Remove invalid and dangerous characters from a string.\"\"\"      s = ''.join([i if ord(i) >= 32 and ord(i) < 127 else '' for i in s])     s = s.translate(dict.fromkeys(map(ord, \"_%~#\\\\{}\\\":\")))     return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python strings remove characters that are not numeric [SEP] def require_root(fn):     \"\"\"     Decorator to make sure, that user is root.     \"\"\"     @wraps(fn)     def xex(*args, **kwargs):         assert os.geteuid() == 0, \\             \"You have to be root to run function '%s'.\" % fn.__name__         return fn(*args, **kwargs)      return xex", "target": 0, "target_options": ["no match", "match"]}
{"input": "python strings remove characters that are not numeric [SEP] def clean_text(text):     \"\"\"Clean text before parsing.\"\"\"     # Replace a few nasty unicode characters with their ASCII equivalent     maps = {u'×': u'x', u'–': u'-', u'−': '-'}     for element in maps:         text = text.replace(element, maps[element])      # Replace genitives     text = re.sub(r'(?<=\\w)\\'s\\b|(?<=\\w)s\\'(?!\\w)', '  ', text)      logging.debug(u'Clean text: \"%s\"', text)      return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python strings remove characters that are not numeric [SEP] def main(idle):     \"\"\"Any normal python logic which runs a loop. Can take arguments.\"\"\"     while True:          LOG.debug(\"Sleeping for {0} seconds.\".format(idle))         time.sleep(idle)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to trim spaces in python regex [SEP] def detokenize(s):     \"\"\" Detokenize a string by removing spaces before punctuation.\"\"\"     print(s)     s = re.sub(\"\\s+([;:,\\.\\?!])\", \"\\\\1\", s)     s = re.sub(\"\\s+(n't)\", \"\\\\1\", s)     return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to trim spaces in python regex [SEP] def getSystemVariable(self, remote, name):         \"\"\"Get single system variable from CCU / Homegear\"\"\"         if self._server is not None:             return self._server.getSystemVariable(remote, name)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to trim spaces in python regex [SEP] def strip_spaces(s):     \"\"\" Strip excess spaces from a string \"\"\"     return u\" \".join([c for c in s.split(u' ') if c])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to trim spaces in python regex [SEP] def yaml_to_param(obj, name): \t\"\"\" \tReturn the top-level element of a document sub-tree containing the \tYAML serialization of a Python object. \t\"\"\" \treturn from_pyvalue(u\"yaml:%s\" % name, unicode(yaml.dump(obj)))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python terminate a pool [SEP] def blocking(func, *args, **kwargs):     \"\"\"Run a function that uses blocking IO.      The function is run in the IO thread pool.     \"\"\"     pool = get_io_pool()     fut = pool.submit(func, *args, **kwargs)     return fut.result()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python terminate a pool [SEP] def arc_negative(self, x, y, radius, start_angle, end_angle):         \"\"\"draw arc going clockwise from start_angle to end_angle\"\"\"         self._add_instruction(\"arc_negative\", x, y, radius, start_angle, end_angle)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python terminate a pool [SEP] def _ReturnConnection(self): \t\t\"\"\" \t\tReturns a connection back to the pool \t\t \t\t@author: Nick Verbeck \t\t@since: 9/7/2008 \t\t\"\"\" \t\tif self.conn is not None: \t\t\tif self.connInfo.commitOnEnd is True or self.commitOnEnd is True: \t\t\t\tself.conn.Commit() \t\t\t\t\t \t\t\tPool().returnConnection(self.conn) \t\t\tself.conn = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python terminate a pool [SEP] def strip_codes(s: Any) -> str:     \"\"\" Strip all color codes from a string.         Returns empty string for \"falsey\" inputs.     \"\"\"     return codepat.sub('', str(s) if (s or (s == 0)) else '')", "target": 0, "target_options": ["no match", "match"]}
{"input": "lower case to upper care the entire list in python [SEP] def format(self):         \"\"\"         Return a well formatted list. Basicaly, it's sort a list and remove duplicate.          :return: A sorted, without duplicate, list.         :rtype: list         \"\"\"          try:             return sorted(list(set(self.main_list)), key=str.lower)          except TypeError:  # pragma: no cover             return self.main_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "lower case to upper care the entire list in python [SEP] def get_single_item(d):     \"\"\"Get an item from a dict which contains just one item.\"\"\"     assert len(d) == 1, 'Single-item dict must have just one item, not %d.' % len(d)     return next(six.iteritems(d))", "target": 0, "target_options": ["no match", "match"]}
{"input": "lower case to upper care the entire list in python [SEP] def natural_sort(list_to_sort: Iterable[str]) -> List[str]:     \"\"\"     Sorts a list of strings case insensitively as well as numerically.      For example: ['a1', 'A2', 'a3', 'A11', 'a22']      To sort a list in place, don't call this method, which makes a copy. Instead, do this:      my_list.sort(key=natural_keys)      :param list_to_sort: the list being sorted     :return: the list sorted naturally     \"\"\"     return sorted(list_to_sort, key=natural_keys)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "lower case to upper care the entire list in python [SEP] def safe_int_conv(number):     \"\"\"Safely convert a single number to integer.\"\"\"     try:         return int(np.array(number).astype(int, casting='safe'))     except TypeError:         raise ValueError('cannot safely convert {} to integer'.format(number))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python math to slice an integer [SEP] def getbyteslice(self, start, end):         \"\"\"Direct access to byte data.\"\"\"         c = self._rawarray[start:end]         return c", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python math to slice an integer [SEP] def url_to_image(url):     \"\"\"     Fetch an image from url and convert it into a Pillow Image object     \"\"\"     r = requests.get(url)     image = StringIO(r.content)     return image", "target": 0, "target_options": ["no match", "match"]}
{"input": "python math to slice an integer [SEP] def _fix_index(self, index):         \"\"\"         :param slice index:         \"\"\"         stop, start = index.stop, index.start         if start is None:             start = 0         if stop is None:             stop = len(self)         return start, stop", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python math to slice an integer [SEP] def plot_target(target, ax):     \"\"\"Ajoute la target au plot\"\"\"     ax.scatter(target[0], target[1], target[2], c=\"red\", s=80)", "target": 0, "target_options": ["no match", "match"]}
{"input": "ahow to plot different colors in boxplot in python [SEP] def plot_target(target, ax):     \"\"\"Ajoute la target au plot\"\"\"     ax.scatter(target[0], target[1], target[2], c=\"red\", s=80)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "ahow to plot different colors in boxplot in python [SEP] def chunks(data, size):     \"\"\"     Get chink for dict, copy as-is from https://stackoverflow.com/a/8290508/6753144     \"\"\"     it = iter(data)     for i in range(0, len(data), size):         yield {k: data[k] for k in islice(it, size)}", "target": 0, "target_options": ["no match", "match"]}
{"input": "ahow to plot different colors in boxplot in python [SEP] def color_text_boxes(ax, labels, colors, color_arrow=True):     \"\"\"Color text boxes.      Instead of this function, one can pass annotate_kwargs and plot_kwargs to     plot_line_ids function.     \"\"\"     assert len(labels) == len(colors), \\         \"Equal no. of colors and lables must be given\"     boxes = ax.findobj(mpl.text.Annotation)     box_labels = lineid_plot.unique_labels(labels)     for box in boxes:         l = box.get_label()         try:             loc = box_labels.index(l)         except ValueError:             continue  # No changes for this box         box.set_color(colors[loc])         if color_arrow:             box.arrow_patch.set_color(colors[loc])      ax.figure.canvas.draw()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "ahow to plot different colors in boxplot in python [SEP] def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]:     \"\"\" Helper for iterating only nonempty lines without line breaks\"\"\"     for line in file_like:         line = line.rstrip('\\r\\n')         if line:             yield line", "target": 0, "target_options": ["no match", "match"]}
{"input": "python str time day of month no leading zero [SEP] def get_month_start(day=None):     \"\"\"Returns the first day of the given month.\"\"\"     day = add_timezone(day or datetime.date.today())     return day.replace(day=1)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python str time day of month no leading zero [SEP] def transpose(table):     \"\"\"     transpose matrix     \"\"\"     t = []     for i in range(0, len(table[0])):         t.append([row[i] for row in table])     return t", "target": 0, "target_options": ["no match", "match"]}
{"input": "python str time day of month no leading zero [SEP] def last_midnight():     \"\"\"     return a datetime of last mid-night     \"\"\"     now = datetime.now()     return datetime(now.year, now.month, now.day)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python str time day of month no leading zero [SEP] def add_lines(self, txt, indent=0):         \"\"\"Adds a list of lines.          The list can be indented with the optional argument 'indent'.         \"\"\"         for line in txt:             self.add_line(line, indent)", "target": 0, "target_options": ["no match", "match"]}
{"input": "copy special rows of matrix in python [SEP] def extract(self):         \"\"\"         Creates a copy of this tabarray in the form of a numpy ndarray.          Useful if you want to do math on array elements, e.g. if you have a          subset of the columns that are all numerical, you can construct a          numerical matrix and do matrix operations.          \"\"\"         return np.vstack([self[r] for r in self.dtype.names]).T.squeeze()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "copy special rows of matrix in python [SEP] def byte2bit_string(data):     \"\"\"     >>> byte2bit_string(\"H\")     '00010010'      >>> byte2bit_string(0x55)     '10101010'     \"\"\"     if isinstance(data, basestring):         assert len(data) == 1         data = ord(data)      bits = '{0:08b}'.format(data)     bits = bits[::-1]     return bits", "target": 0, "target_options": ["no match", "match"]}
{"input": "copy special rows of matrix in python [SEP] def lengths( self ):         \"\"\"         The cell lengths.          Args:             None          Returns:             (np.array(a,b,c)): The cell lengths.         \"\"\"         return( np.array( [ math.sqrt( sum( row**2 ) ) for row in self.matrix ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "copy special rows of matrix in python [SEP] def contains_empty(features):     \"\"\"Check features data are not empty      :param features: The features data to check.     :type features: list of numpy arrays.      :return: True if one of the array is empty, False else.      \"\"\"     if not features:         return True     for feature in features:         if feature.shape[0] == 0:             return True     return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "command prompt input python [SEP] def _stdin_(p):     \"\"\"Takes input from user. Works for Python 2 and 3.\"\"\"     _v = sys.version[0]     return input(p) if _v is '3' else raw_input(p)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "command prompt input python [SEP] def ytickvals(self, values, index=1):         \"\"\"Set the tick values.          Parameters         ----------         values : array-like          Returns         -------         Chart          \"\"\"         self.layout['yaxis' + str(index)]['tickvals'] = values         return self", "target": 0, "target_options": ["no match", "match"]}
{"input": "command prompt input python [SEP] def read_stdin():     \"\"\" Read text from stdin, and print a helpful message for ttys. \"\"\"     if sys.stdin.isatty() and sys.stdout.isatty():         print('\\nReading from stdin until end of file (Ctrl + D)...')      return sys.stdin.read()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "command prompt input python [SEP] def indicate_last(items):     \"\"\"     iterate through list and indicate which item is the last, intended to     assist tree displays of hierarchical content.      :return: yielding (<bool>, <item>) where bool is True only on last entry     :rtype: generator     \"\"\"     last_index = len(items) - 1     for (i, item) in enumerate(items):         yield (i == last_index, item)", "target": 0, "target_options": ["no match", "match"]}
{"input": "average of a range random python [SEP] def _gauss(mean: int, sigma: int) -> int:         \"\"\"         Creates a variation from a base value          Args:             mean: base value             sigma: gaussian sigma          Returns: random value          \"\"\"         return int(random.gauss(mean, sigma))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "average of a range random python [SEP] def test3():     \"\"\"Test the multiprocess     \"\"\"     import time          p = MVisionProcess()     p.start()     time.sleep(5)     p.stop()", "target": 0, "target_options": ["no match", "match"]}
{"input": "average of a range random python [SEP] def frange(start, stop, step, precision):     \"\"\"A generator that will generate a range of floats.\"\"\"     value = start     while round(value, precision) < stop:         yield round(value, precision)         value += step", "target": 1, "target_options": ["no_match", "match"]}
{"input": "average of a range random python [SEP] def print_yaml(o):     \"\"\"Pretty print an object as YAML.\"\"\"     print(yaml.dump(o, default_flow_style=False, indent=4, encoding='utf-8'))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to downcase every alternate character in a string in python [SEP] def to_pascal_case(s):     \"\"\"Transform underscore separated string to pascal case      \"\"\"     return re.sub(r'(?!^)_([a-zA-Z])', lambda m: m.group(1).upper(), s.capitalize())", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to downcase every alternate character in a string in python [SEP] def flatten_list(x: List[Any]) -> List[Any]:     \"\"\"     Converts a list of lists into a flat list.          Args:         x: list of lists       Returns:         flat list              As per     http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python      \"\"\"  # noqa     return [item for sublist in x for item in sublist]", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to downcase every alternate character in a string in python [SEP] def to_snake_case(name):     \"\"\" Given a name in camelCase return in snake_case \"\"\"     s1 = FIRST_CAP_REGEX.sub(r'\\1_\\2', name)     return ALL_CAP_REGEX.sub(r'\\1_\\2', s1).lower()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to downcase every alternate character in a string in python [SEP] def S(self):         \"\"\":obj:`numpy.ndarray` : The 3x3 scaling matrix for this projection         \"\"\"         S = np.array([[self._plane_width / self._vol_width, 0, 0],                       [0, self._plane_height / self._vol_height, 0],                       [0, 0, self._depth_scale / self._vol_depth]])         return S", "target": 0, "target_options": ["no match", "match"]}
{"input": "python check viarable type [SEP] def is_integer(obj):     \"\"\"Is this an integer.      :param object obj:     :return:     \"\"\"     if PYTHON3:         return isinstance(obj, int)     return isinstance(obj, (int, long))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python check viarable type [SEP] def info(self, text): \t\t\"\"\" Ajout d'un message de log de type INFO \"\"\" \t\tself.logger.info(\"{}{}\".format(self.message_prefix, text))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python check viarable type [SEP] def isreal(obj):     \"\"\"     Test if the argument is a real number (float or integer).      :param obj: Object     :type  obj: any      :rtype: boolean     \"\"\"     return (         (obj is not None)         and (not isinstance(obj, bool))         and isinstance(obj, (int, float))     )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python check viarable type [SEP] def is_integer(obj):     \"\"\"Is this an integer.      :param object obj:     :return:     \"\"\"     if PYTHON3:         return isinstance(obj, int)     return isinstance(obj, (int, long))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python sort second item in a list of tuples [SEP] def pairwise(iterable):     \"\"\"From itertools cookbook. [a, b, c, ...] -> (a, b), (b, c), ...\"\"\"     first, second = tee(iterable)     next(second, None)     return zip(first, second)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python sort second item in a list of tuples [SEP] def array_dim(arr):     \"\"\"Return the size of a multidimansional array.     \"\"\"     dim = []     while True:         try:             dim.append(len(arr))             arr = arr[0]         except TypeError:             return dim", "target": 0, "target_options": ["no match", "match"]}
{"input": "python sort second item in a list of tuples [SEP] def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python sort second item in a list of tuples [SEP] def _fill_array_from_list(the_list, the_array):         \"\"\"Fill an `array` from a `list`\"\"\"         for i, val in enumerate(the_list):             the_array[i] = val         return the_array", "target": 0, "target_options": ["no match", "match"]}
{"input": "python add parser as subparser [SEP] def sub(name, func,**kwarg):     \"\"\" Add subparser      \"\"\"     sp = subparsers.add_parser(name, **kwarg)     sp.set_defaults(func=func)     sp.arg = sp.add_argument     return sp", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python add parser as subparser [SEP] def _is_bit(obj):     \"\"\"Determine if obj is a bit\"\"\"     # If there is a bit type this could be replaced by isinstance.     if isinstance(obj, tuple) and len(obj) == 2:         if isinstance(obj[0], Register) and isinstance(obj[1], int) and obj[1] < len(obj[0]):             return True     return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "python add parser as subparser [SEP] def addSubparser(subparsers, subcommand, description):     \"\"\"     Add a subparser with subcommand to the subparsers object     \"\"\"     parser = subparsers.add_parser(         subcommand, description=description, help=description)     return parser", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python add parser as subparser [SEP] def split(s):   \"\"\"Uses dynamic programming to infer the location of spaces in a string without spaces.\"\"\"   l = [_split(x) for x in _SPLIT_RE.split(s)]   return [item for sublist in l for item in sublist]", "target": 0, "target_options": ["no match", "match"]}
{"input": "unsplit a splitted sentence in python [SEP] def pause_splitter(s):     \"\"\"\"\"\"      s = s.strip()     s = re.sub('([:;]|--+)', '\\g<1>\\n', s)     s = s.split('\\n')     s = [sent for sents in s for sent in sent_splitter.tokenize(sents)]     return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "unsplit a splitted sentence in python [SEP] def string_to_int( s ):   \"\"\"Convert a string of bytes into an integer, as per X9.62.\"\"\"   result = 0   for c in s:     if not isinstance(c, int): c = ord( c )     result = 256 * result + c   return result", "target": 0, "target_options": ["no match", "match"]}
{"input": "unsplit a splitted sentence in python [SEP] def split_into_sentences(s):   \"\"\"Split text into list of sentences.\"\"\"   s = re.sub(r\"\\s+\", \" \", s)   s = re.sub(r\"[\\\\.\\\\?\\\\!]\", \"\\n\", s)   return s.split(\"\\n\")", "target": 1, "target_options": ["no_match", "match"]}
{"input": "unsplit a splitted sentence in python [SEP] def safe_unicode(string):     \"\"\"If Python 2, replace non-ascii characters and return encoded string.\"\"\"     if not PY3:         uni = string.replace(u'\\u2019', \"'\")         return uni.encode('utf-8')              return string", "target": 0, "target_options": ["no match", "match"]}
{"input": "smooth plot in in python [SEP] def smooth_array(array, amount=1):     \"\"\"      Returns the nearest-neighbor (+/- amount) smoothed array.     This does not modify the array or slice off the funny end points.      \"\"\"     if amount==0: return array      # we have to store the old values in a temp array to keep the     # smoothing from affecting the smoothing     new_array = _n.array(array)      for n in range(len(array)):         new_array[n] = smooth(array, n, amount)      return new_array", "target": 1, "target_options": ["no_match", "match"]}
{"input": "smooth plot in in python [SEP] def text(self):         \"\"\"         Return the String assosicated with the current text         \"\"\"         if self.m_name == -1 or self.m_event != TEXT:             return ''          return self.sb[self.m_name]", "target": 0, "target_options": ["no match", "match"]}
{"input": "smooth plot in in python [SEP] def smooth(polylines):     \"\"\"     smooth every polyline using spline interpolation     \"\"\"     for c in polylines:         if len(c) < 9:             # smoothing wouldn't make sense here             continue         x = c[:, 0]         y = c[:, 1]          t = np.arange(x.shape[0], dtype=float)         t /= t[-1]         x = UnivariateSpline(t, x)(t)         y = UnivariateSpline(t, y)(t)         c[:, 0] = x         c[:, 1] = y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "smooth plot in in python [SEP] def _tuple_repr(data):     \"\"\"Return a repr() for a list/tuple\"\"\"     if len(data) == 1:         return \"(%s,)\" % rpr(data[0])     else:         return \"(%s)\" % \", \".join([rpr(x) for x in data])", "target": 0, "target_options": ["no match", "match"]}
{"input": "python slice array to sub array [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python slice array to sub array [SEP] def intToBin(i):     \"\"\" Integer to two bytes \"\"\"     # divide in two parts (bytes)     i1 = i % 256     i2 = int(i / 256)     # make string (little endian)     return i.to_bytes(2, byteorder='little')", "target": 0, "target_options": ["no match", "match"]}
{"input": "python slice array to sub array [SEP] def torecarray(*args, **kwargs):     \"\"\"     Convenient shorthand for ``toarray(*args, **kwargs).view(np.recarray)``.      \"\"\"      import numpy as np     return toarray(*args, **kwargs).view(np.recarray)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python slice array to sub array [SEP] def is_agent_listening(self, host, port):         \"\"\"         Check if the Instana Agent is listening on <host> and <port>.         \"\"\"         try:             rv = False             url = \"http://%s:%s/\" % (host, port)             response = self.client.get(url, timeout=0.8)              server_header = response.headers[\"Server\"]             if server_header == AGENT_HEADER:                 logger.debug(\"Host agent found on %s:%d\" % (host, port))                 rv = True             else:                 logger.debug(\"...something is listening on %s:%d but it's not the Instana Agent: %s\"                              % (host, port, server_header))         except (requests.ConnectTimeout, requests.ConnectionError):             logger.debug(\"No host agent listening on %s:%d\" % (host, port))             rv = False         finally:             return rv", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to run multiple python scripts [SEP] def load_files(files):     \"\"\"Load and execute a python file.\"\"\"      for py_file in files:         LOG.debug(\"exec %s\", py_file)         execfile(py_file, globals(), locals())", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to run multiple python scripts [SEP] def cmd(send, msg, args):     \"\"\"'Inspects a bot attribute.      Syntax: {command} <attr>      \"\"\"     if not hasattr(args['handler'], msg):         send(\"That attribute was not found in the handler.\")         return     send(str(getattr(args['handler'], msg)))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to run multiple python scripts [SEP] def stub_main():     \"\"\"setuptools blah: it still can't run a module as a script entry_point\"\"\"     from google.apputils import run_script_module     import butcher.main     run_script_module.RunScriptModule(butcher.main)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to run multiple python scripts [SEP] def list2dict(list_of_options):     \"\"\"Transforms a list of 2 element tuples to a dictionary\"\"\"     d = {}     for key, value in list_of_options:         d[key] = value     return d", "target": 0, "target_options": ["no match", "match"]}
{"input": "python switch test if variable exists [SEP] def has_attribute(module_name, attribute_name):     \"\"\"Is this attribute present?\"\"\"     init_file = '%s/__init__.py' % module_name     return any(         [attribute_name in init_line for init_line in open(init_file).readlines()]     )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python switch test if variable exists [SEP] def fix_header_comment(filename, timestamp):     \"\"\"Fixes the header-comment of the given file.\"\"\"     # Fix input file.     name = os.path.basename( filename )     for line in fileinput.input( filename, inplace=1, mode=\"rU\" ):         # If header-comment already contains anything for '$Id$', remove it.         line = re.sub(r'\\$Id:[^$]+\\$', r'$Id$', line.rstrip())         # Replace '$Id$' by a string containing the file's name (and a timestamp)!         line = re.sub(re.escape(r'$Id$'), r'$Id: ' + name + r' ' + timestamp.isoformat() + r' $', line.rstrip())         print(line)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python switch test if variable exists [SEP] def column_exists(cr, table, column):     \"\"\" Check whether a certain column exists \"\"\"     cr.execute(         'SELECT count(attname) FROM pg_attribute '         'WHERE attrelid = '         '( SELECT oid FROM pg_class WHERE relname = %s ) '         'AND attname = %s',         (table, column))     return cr.fetchone()[0] == 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python switch test if variable exists [SEP] def is_valid_row(cls, row):         \"\"\"Indicates whether or not the given row contains valid data.\"\"\"         for k in row.keys():             if row[k] is None:                 return False         return True", "target": 0, "target_options": ["no match", "match"]}
{"input": "prompt the user for a username and a password in a function in python [SEP] def get_auth():     \"\"\"Get authentication.\"\"\"     import getpass     user = input(\"User Name: \")  # noqa     pswd = getpass.getpass('Password: ')     return Github(user, pswd)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "prompt the user for a username and a password in a function in python [SEP] def write_file(writer, filename):   \"\"\"Write all of lines from file using the writer.\"\"\"   for line in txt_line_iterator(filename):     writer.write(line)     writer.write(\"\\n\")", "target": 0, "target_options": ["no match", "match"]}
{"input": "prompt the user for a username and a password in a function in python [SEP] def authenticate_user(scope, user=[None], password=[None]):     \"\"\"     Like authenticate(), but logs in using the given user and password.     If a user and password are not given, the function uses the same     user and password that were used at the last login attempt; it is     an error if no such attempt was made before.      :type  user: string     :param user: A username.     :type  password: string     :param password: A password.     \"\"\"     conn = scope.get('__connection__')     user = user[0]     if user is None:         conn.app_authenticate()     else:         account = Account(user, password[0])         conn.app_authenticate(account)     return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "prompt the user for a username and a password in a function in python [SEP] def indicate_last(items):     \"\"\"     iterate through list and indicate which item is the last, intended to     assist tree displays of hierarchical content.      :return: yielding (<bool>, <item>) where bool is True only on last entry     :rtype: generator     \"\"\"     last_index = len(items) - 1     for (i, item) in enumerate(items):         yield (i == last_index, item)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python script how to exit [SEP] def _quit(self, *args):         \"\"\" quit crash \"\"\"         self.logger.warn('Bye!')         sys.exit(self.exit())", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python script how to exit [SEP] def csvpretty(csvfile: csvfile=sys.stdin):     \"\"\" Pretty print a CSV file. \"\"\"     shellish.tabulate(csv.reader(csvfile))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python script how to exit [SEP] def exit(exit_code=0):   r\"\"\"A function to support exiting from exit hooks.    Could also be used to exit from the calling scripts in a thread safe manner.   \"\"\"   core.processExitHooks()    if state.isExitHooked and not hasattr(sys, 'exitfunc'): # The function is called from the exit hook     sys.stderr.flush()     sys.stdout.flush()     os._exit(exit_code) #pylint: disable=W0212    sys.exit(exit_code)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python script how to exit [SEP] def QA_util_datetime_to_strdate(dt):     \"\"\"     :param dt:  pythone datetime.datetime     :return:  1999-02-01 string type     \"\"\"     strdate = \"%04d-%02d-%02d\" % (dt.year, dt.month, dt.day)     return strdate", "target": 0, "target_options": ["no match", "match"]}
{"input": "iterate through one of the keys in json python [SEP] def __iter__(self):         \"\"\"class iterator which yields a key/value pair\"\"\"         if self._json_dict is None:             self.__init()         for k,v in self._json_dict.items():             yield (k,v)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "iterate through one of the keys in json python [SEP] def isin(value, values):     \"\"\" Check that value is in values \"\"\"     for i, v in enumerate(value):         if v not in np.array(values)[:, i]:             return False     return True", "target": 0, "target_options": ["no match", "match"]}
{"input": "iterate through one of the keys in json python [SEP] def iter_items(iterable):     \"\"\" Iterate through all items (key-value pairs) within an iterable     dictionary-like object. If the object has a `keys` method, this is     used along with `__getitem__` to yield each pair in turn. If no     `keys` method exists, each iterable element is assumed to be a     2-tuple of key and value.     \"\"\"     if hasattr(iterable, \"keys\"):         for key in iterable.keys():             yield key, iterable[key]     else:         for key, value in iterable:             yield key, value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "iterate through one of the keys in json python [SEP] def obj_in_list_always(target_list, obj):     \"\"\"     >>> l = [1,1,1]     >>> obj_in_list_always(l, 1)     True     >>> l.append(2)     >>> obj_in_list_always(l, 1)     False     \"\"\"     for item in set(target_list):         if item is not obj:             return False     return True", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to write float32 in python [SEP] def write_double(self, number):         \"\"\" Writes a double to the underlying output file as a 8-byte value. \"\"\"         buf = pack(self.byte_order + \"d\", number)         self.write(buf)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to write float32 in python [SEP] def _parse_tuple_string(argument):         \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"         if isinstance(argument, str):             return tuple(int(p.strip()) for p in argument.split(','))         return argument", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to write float32 in python [SEP] def write_float(self, f):         \"\"\"         Writes a 4 byte float to the stream.          @param f: 4 byte float         @type f: C{float}         @raise TypeError: Unexpected type for float C{f}.         \"\"\"         if type(f) is not float:             raise TypeError('expected a float (got:%r)' % (type(f),))          self.write(struct.pack(\"%sf\" % self.endian, f))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to write float32 in python [SEP] def c_str(string):     \"\"\"\"Convert a python string to C string.\"\"\"     if not isinstance(string, str):         string = string.decode('ascii')     return ctypes.c_char_p(string.encode('utf-8'))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to call c sharelib function from pythong [SEP] def main(ctx, connection):     \"\"\"Command line interface for PyBEL.\"\"\"     ctx.obj = Manager(connection=connection)     ctx.obj.bind()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to call c sharelib function from pythong [SEP] def dmap(fn, record):     \"\"\"map for a directory\"\"\"     values = (fn(v) for k, v in record.items())     return dict(itertools.izip(record, values))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to call c sharelib function from pythong [SEP] def start(self):         \"\"\"Start the import thread.\"\"\"         self.t = threading.Thread(target=self._run, name=\"ray_import_thread\")         # Making the thread a daemon causes it to exit         # when the main thread exits.         self.t.daemon = True         self.t.start()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to call c sharelib function from pythong [SEP] def partition(list_, columns=2):     \"\"\"     Break a list into ``columns`` number of columns.     \"\"\"      iter_ = iter(list_)     columns = int(columns)     rows = []      while True:         row = []         for column_number in range(1, columns + 1):             try:                 value = six.next(iter_)             except StopIteration:                 pass             else:                 row.append(value)          if not row:             return rows         rows.append(row)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python check dictionary key equality with string [SEP] def __contains__(self, key):         \"\"\"         Invoked when determining whether a specific key is in the dictionary         using `key in d`.          The key is looked up case-insensitively.         \"\"\"         k = self._real_key(key)         return k in self._data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python check dictionary key equality with string [SEP] def get_all_files(folder):     \"\"\"     Generator that loops through all absolute paths of the files within folder      Parameters     ----------     folder: str     Root folder start point for recursive search.      Yields     ------     fpath: str     Absolute path of one file in the folders     \"\"\"     for path, dirlist, filelist in os.walk(folder):         for fn in filelist:             yield op.join(path, fn)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python check dictionary key equality with string [SEP] def __eq__(self, other):         \"\"\"         Returns true if both objects are equal         \"\"\"         if not isinstance(other, ApiKeyUpdateReq):             return False          return self.__dict__ == other.__dict__", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python check dictionary key equality with string [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 0, "target_options": ["no match", "match"]}
{"input": "iterate over a number in python [SEP] def frange(start, stop, step, precision):     \"\"\"A generator that will generate a range of floats.\"\"\"     value = start     while round(value, precision) < stop:         yield round(value, precision)         value += step", "target": 1, "target_options": ["no_match", "match"]}
{"input": "iterate over a number in python [SEP] def lengths( self ):         \"\"\"         The cell lengths.          Args:             None          Returns:             (np.array(a,b,c)): The cell lengths.         \"\"\"         return( np.array( [ math.sqrt( sum( row**2 ) ) for row in self.matrix ] ) )", "target": 0, "target_options": ["no match", "match"]}
{"input": "iterate over a number in python [SEP] def log_gen() -> Iterator[int]:     \"\"\"Logarithmic generator.     \"\"\"     y = 1     while True:         adder = max(1, math.pow(10, int(math.log10(y))))         yield int(y)         y = y + int(adder)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "iterate over a number in python [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 0, "target_options": ["no match", "match"]}
{"input": "adding an axis to a passed in figure python [SEP] def set_axis_options(self, row, column, text):         \"\"\"Set additionnal options as plain text.\"\"\"          subplot = self.get_subplot_at(row, column)         subplot.set_axis_options(text)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "adding an axis to a passed in figure python [SEP] def MultiArgMax(x):   \"\"\"   Get tuple (actually a generator) of indices where the max value of   array x occurs. Requires that x have a max() method, as x.max()   (in the case of NumPy) is much faster than max(x).   For a simpler, faster argmax when there is only a single maximum entry,   or when knowing only the first index where the maximum occurs,   call argmax() on a NumPy array.    :param x: Any sequence that has a max() method.   :returns: Generator with the indices where the max value occurs.   \"\"\"   m = x.max()   return (i for i, v in enumerate(x) if v == m)", "target": 0, "target_options": ["no match", "match"]}
{"input": "adding an axis to a passed in figure python [SEP] def horizontal_line(ax, scale, i, **kwargs):     \"\"\"     Draws the i-th horizontal line parallel to the lower axis.      Parameters     ----------     ax: Matplotlib AxesSubplot         The subplot to draw on.     scale: float, 1.0         Simplex scale size.     i: float         The index of the line to draw     kwargs: Dictionary         Any kwargs to pass through to Matplotlib.     \"\"\"      p1 = (0, i, scale - i)     p2 = (scale - i, i, 0)     line(ax, p1, p2, **kwargs)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "adding an axis to a passed in figure python [SEP] def stringify_dict_contents(dct):     \"\"\"Turn dict keys and values into native strings.\"\"\"     return {         str_if_nested_or_str(k): str_if_nested_or_str(v)         for k, v in dct.items()     }", "target": 0, "target_options": ["no match", "match"]}
{"input": "python determine if path is file or directory [SEP] def valid_file(path: str) -> bool:     \"\"\"     Verifies that a string path actually exists and is a file      :param path: The path to verify     :return: **True** if path exist and is a file     \"\"\"     path = Path(path).expanduser()     log.debug(\"checking if %s is a valid file\", path)     return path.exists() and path.is_file()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python determine if path is file or directory [SEP] def _stdin_(p):     \"\"\"Takes input from user. Works for Python 2 and 3.\"\"\"     _v = sys.version[0]     return input(p) if _v is '3' else raw_input(p)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python determine if path is file or directory [SEP] def is_readable_dir(path):   \"\"\"Returns whether a path names an existing directory we can list and read files from.\"\"\"   return os.path.isdir(path) and os.access(path, os.R_OK) and os.access(path, os.X_OK)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python determine if path is file or directory [SEP] def from_dict(cls, d):         \"\"\"         Makes XcFunc obey the general json interface used in pymatgen for easier serialization.         \"\"\"         return cls(xc=d.get(\"xc\"), x=d.get(\"x\"), c=d.get(\"c\"))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python folding multiple strings [SEP] def split(s):   \"\"\"Uses dynamic programming to infer the location of spaces in a string without spaces.\"\"\"   l = [_split(x) for x in _SPLIT_RE.split(s)]   return [item for sublist in l for item in sublist]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python folding multiple strings [SEP] def list2string (inlist,delimit=' '):     \"\"\" Converts a 1D list to a single long string for file output, using the string.join function.  Usage:   list2string (inlist,delimit=' ') Returns: the string created from inlist \"\"\"     stringlist = [makestr(_) for _ in inlist]     return string.join(stringlist,delimit)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python folding multiple strings [SEP] def clean_strings(iterable):     \"\"\"     Take a list of strings and clear whitespace      on each one. If a value in the list is not a      string pass it through untouched.      Args:         iterable: mixed list      Returns:          mixed list     \"\"\"     retval = []     for val in iterable:         try:             retval.append(val.strip())         except(AttributeError):             retval.append(val)     return retval", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python folding multiple strings [SEP] def draw_image(self, ax, image):         \"\"\"Process a matplotlib image object and call renderer.draw_image\"\"\"         self.renderer.draw_image(imdata=utils.image_to_base64(image),                                  extent=image.get_extent(),                                  coordinates=\"data\",                                  style={\"alpha\": image.get_alpha(),                                         \"zorder\": image.get_zorder()},                                  mplobj=image)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python sniff url filter [SEP] def strip_querystring(url):     \"\"\"Remove the querystring from the end of a URL.\"\"\"     p = six.moves.urllib.parse.urlparse(url)     return p.scheme + \"://\" + p.netloc + p.path", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python sniff url filter [SEP] def callprint(self, cmd, shell=None, lock_file=None, nofail=False, container=None):         \"\"\"         Prints the command, and then executes it, then prints the memory use and         return code of the command.          Uses python's subprocess.Popen() to execute the given command. The shell argument is simply         passed along to Popen(). You should use shell=False (default) where possible, because this enables memory         profiling. You should use shell=True if you require shell functions like redirects (>) or stars (*), but this         will prevent the script from monitoring memory use. The pipes (|) will be used to split the command into         subprocesses run within python, so the memory profiling is possible.          cmd can also be a series (a dict object) of multiple commands, which will be run in succession.          :param str | Iterable[str] cmd: Bash command(s) to be run.         :param str lock_file: a lock file name         :param bool nofail: Should the pipeline bail on a nonzero return from a process? Default: False             Nofail can be used to implement non-essential parts of the pipeline; if these processes fail,             they will not cause the pipeline to bail out.         :param bool shell: if the command should be run it its own shell, default: None (will try             to determine based on the command)         :param container: Named Docker container in which to execute.         :param container: str         \"\"\"         # The Popen shell argument works like this:         # if shell=False, then we format the command (with split()) to be a list of command and its arguments.         # Split the command to use shell=False;         # leave it together to use shell=True;          def get_mem_child_sum(proc):             try:                 # get children processes                 children = proc.children(recursive=True)                 # get RSS memory of each child proc and sum all                 mem_sum = sum([x.memory_info().rss for x in children])                 # return in gigs                 return mem_sum/1e9             except (psutil.NoSuchProcess, psutil.ZombieProcess) as e:                 print(e)                 print(\"Warning: couldn't add memory use for process: {}\".format(proc.pid))                 return 0           def display_memory(memval):             return None if memval < 0 else \"{}GB\".format(round(memval, 3))          def make_dict(command):             a, s = (command, True) if check_shell(command, shell) else (shlex.split(command), False)             return dict(args=a, stdout=subprocess.PIPE, shell=s)          if container:             cmd = \"docker exec \" + container + \" \" + cmd          param_list = [make_dict(c) for c in split_by_pipes(cmd)] \\             if check_shell_pipes(cmd) else [dict(args=cmd, stdout=None, shell=True)]          proc_name = get_proc_name(cmd)          # stop_times = []         processes = []         running_processes = []         start_time = time.time()         for i in range(len(param_list)):             running_processes.append(i)             if i == 0:                 processes.append(psutil.Popen(preexec_fn=os.setpgrp, **param_list[i]))             else:                 param_list[i][\"stdin\"] = processes[i - 1].stdout                 processes.append(psutil.Popen(preexec_fn=os.setpgrp, **param_list[i]))              self.procs[processes[-1].pid] = {                 \"proc_name\": proc_name,                 \"subproc_name\" : get_proc_name(param_list[i][\"args\"]),                 \"start_time\": start_time,                 \"container\": container,                 \"p\": processes[-1]             }          self._report_command(cmd, [x.pid for x in processes])             # Capture the subprocess output in <pre> tags to make it format nicely             # if the markdown log file is displayed as HTML.         print(\"<pre>\")          local_maxmems = [-1] * len(running_processes)         returncodes = [None] * len(running_processes)          if not self.wait:             print(\"</pre>\")             ids = [x.pid for x in processes]             print (\"Not waiting for subprocess(es): \" + str(ids))             return [0, -1]          def proc_wrapup(i):             \"\"\"             :param i: internal ID number of the subprocess             \"\"\"             returncode = processes[i].returncode             current_pid = processes[i].pid              info = \"Process {pid} returned {ret}; memory: {mem}. \".format(                 pid=current_pid,                  ret=processes[i].returncode,                 mem=display_memory(local_maxmems[i]))                          # report process profile             self._report_profile(self.procs[current_pid][\"proc_name\"], lock_file, time.time() - self.procs[current_pid][\"start_time\"], local_maxmems[i])              # Remove this as a running subprocess             del self.procs[current_pid]             running_processes.remove(i)              returncodes[i] = returncode             return info           sleeptime = .0001         info = \"\"         while running_processes:             for i in running_processes:                 local_maxmems[i] = max(local_maxmems[i], (get_mem_child_sum(processes[i])))                 self.peak_memory = max(self.peak_memory, local_maxmems[i])                 if not self._attend_process(processes[i], sleeptime):                     info += proc_wrapup(i)              # the sleeptime is extremely short at the beginning and gets longer exponentially              # (+ constant to prevent copious checks at the very beginning)             # = more precise mem tracing for short processes             sleeptime = min((sleeptime + 0.25) * 3 , 60/len(processes))          # All jobs are done, print a final closing and job info         stop_time = time.time()         info += \" Elapsed: \" + str(datetime.timedelta(seconds=self.time_elapsed(start_time))) + \".\"         info += \" Peak memory: {pipe}.\".format(pipe=display_memory(self.peak_memory))          print(\"</pre>\")         print(info)          for rc in returncodes:             if rc != 0:                 msg = \"Subprocess returned nonzero result. Check above output for details\"                 self._triage_error(SubprocessError(msg), nofail)            return [returncodes, local_maxmems]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python sniff url filter [SEP] def clean_url(url):     \"\"\"     Remove params, query and fragment parts from URL so that `os.path.basename`     and `os.path.splitext` can work correctly.      @param url: URL to clean.     @type url: str      @return: Cleaned URL.     @rtype: str     \"\"\"     parsed = urlparse(url.strip())     reconstructed = ParseResult(         parsed.scheme, parsed.netloc, parsed.path,         params='', query='', fragment='')     return reconstructed.geturl()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python sniff url filter [SEP] def show(self, title=''):         \"\"\"         Display Bloch sphere and corresponding data sets.         \"\"\"         self.render(title=title)         if self.fig:             plt.show(self.fig)", "target": 0, "target_options": ["no match", "match"]}
{"input": "check if a file can be coied python [SEP] def file_read(filename):     \"\"\"Read a file and close it.  Returns the file source.\"\"\"     fobj = open(filename,'r');     source = fobj.read();     fobj.close()     return source", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check if a file can be coied python [SEP] def search_on(self, *fields, **query):         \"\"\"         Search for query on given fields.          Query modifier can be one of these:             * exact             * contains             * startswith             * endswith             * range             * lte             * gte          Args:             \\*fields (str): Field list to be searched on             \\*\\*query:  Search query. While it's implemented as \\*\\*kwargs              we only support one (first) keyword argument.          Returns:             Self. Queryset object.          Examples:             >>> Person.objects.search_on('name', 'surname', contains='john')             >>> Person.objects.search_on('name', 'surname', startswith='jo')         \"\"\"         search_type = list(query.keys())[0]         parsed_query = self._parse_query_modifier(search_type, query[search_type], False)         self.add_query([(\"OR_QRY\", dict([(f, parsed_query) for f in fields]), True)])", "target": 0, "target_options": ["no match", "match"]}
{"input": "check if a file can be coied python [SEP] def read_file(path):     \"\"\"     Read file to string.      Arguments:         path (str): Source.     \"\"\"     with open(must_exist(path)) as infile:         r = infile.read()     return r", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check if a file can be coied python [SEP] def convertToNative(self, aVal):         \"\"\" Convert to native bool; interpret certain strings. \"\"\"         if aVal is None:             return None         if isinstance(aVal, bool): return aVal         # otherwise interpret strings         return str(aVal).lower() in ('1','on','yes','true')", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to count uniques python series [SEP] def remove_dups(seq):     \"\"\"remove duplicates from a sequence, preserving order\"\"\"     seen = set()     seen_add = seen.add     return [x for x in seq if not (x in seen or seen_add(x))]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to count uniques python series [SEP] def to_snake_case(name):     \"\"\" Given a name in camelCase return in snake_case \"\"\"     s1 = FIRST_CAP_REGEX.sub(r'\\1_\\2', name)     return ALL_CAP_REGEX.sub(r'\\1_\\2', s1).lower()", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to count uniques python series [SEP] def unique(seq):     \"\"\"Helper function to include only unique monomials in a basis.\"\"\"     seen = {}     result = []     for item in seq:         marker = item         if marker in seen:             continue         seen[marker] = 1         result.append(item)     return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to count uniques python series [SEP] def get_matrix(self):         \"\"\"  Use numpy to create a real matrix object from the data          :return: the matrix representation of the fvm         \"\"\"         return np.array([ self.get_row_list(i) for i in range(self.row_count()) ])", "target": 0, "target_options": ["no match", "match"]}
{"input": "python numpy array logical indexing [SEP] def is_bool_matrix(l):     r\"\"\"Checks if l is a 2D numpy array of bools      \"\"\"     if isinstance(l, np.ndarray):         if l.ndim == 2 and (l.dtype == bool):             return True     return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python numpy array logical indexing [SEP] def kill_mprocess(process):     \"\"\"kill process     Args:         process - Popen object for process     \"\"\"     if process and proc_alive(process):         process.terminate()         process.communicate()     return not proc_alive(process)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python numpy array logical indexing [SEP] def maskIndex(self):         \"\"\" Returns a boolean index with True if the value is masked.              Always has the same shape as the maksedArray.data, event if the mask is a single boolan.         \"\"\"         if isinstance(self.mask, bool):             return np.full(self.data.shape, self.mask, dtype=np.bool)         else:             return self.mask", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python numpy array logical indexing [SEP] def cleanup(self):         \"\"\"Forcefully delete objects from memory          In an ideal world, this shouldn't be necessary. Garbage         collection guarantees that anything without reference         is automatically removed.          However, because this application is designed to be run         multiple times from the same interpreter process, extra         case must be taken to ensure there are no memory leaks.          Explicitly deleting objects shines a light on where objects         may still be referenced in the form of an error. No errors         means this was uneccesary, but that's ok.          \"\"\"          for instance in self.context:             del(instance)          for plugin in self.plugins:             del(plugin)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python get all index string match [SEP] def match_all_in(self, matches, item):         \"\"\"Matches all matches to elements of item.\"\"\"         for i, match in enumerate(matches):             self.match(match, item + \"[\" + str(i) + \"]\")", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python get all index string match [SEP] def _prune(self):         \"\"\"Primitive way to keep dict in sync with RB.\"\"\"         delkeys = [k for k in self.keys() if k not in self.__ringbuffer]         for k in delkeys:  # necessary because dict is changed during iterations             super(KRingbuffer,self).__delitem__(k)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python get all index string match [SEP] def regex_matches_to_indexed_words(matches):     \"\"\"Transforms tokensregex and semgrex matches to indexed words.     :param matches: unprocessed regex matches     :return: flat array of indexed words     \"\"\"     words = [dict(v, **dict([('sentence', i)]))              for i, s in enumerate(matches['sentences'])              for k, v in s.items() if k != 'length']     return words", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python get all index string match [SEP] def dedupe_list(l):     \"\"\"Remove duplicates from a list preserving the order.      We might be tempted to use the list(set(l)) idiom, but it doesn't preserve     the order, which hinders testability and does not work for lists with     unhashable elements.     \"\"\"     result = []      for el in l:         if el not in result:             result.append(el)      return result", "target": 0, "target_options": ["no match", "match"]}
{"input": "python filename as string [SEP] def __str__(self):         \"\"\"Return a string representation of the RedditContentObject.\"\"\"         retval = self.__unicode__()         if not six.PY3:             retval = retval.encode('utf-8')         return retval", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python filename as string [SEP] def yaml_to_param(obj, name): \t\"\"\" \tReturn the top-level element of a document sub-tree containing the \tYAML serialization of a Python object. \t\"\"\" \treturn from_pyvalue(u\"yaml:%s\" % name, unicode(yaml.dump(obj)))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python filename as string [SEP] def __str__(self): \t\t\"\"\" Convert to string  \t\t:return: str \t\t\"\"\" \t\taddress = [\"{:02x}\".format(int(x)) for x in self.__address] \t\treturn ':'.join(address)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python filename as string [SEP] def acquire_nix(lock_file):  # pragma: no cover     \"\"\"Acquire a lock file on linux or osx.\"\"\"     fd = os.open(lock_file, OPEN_MODE)      try:         fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)     except (IOError, OSError):         os.close(fd)     else:         return fd", "target": 0, "target_options": ["no match", "match"]}
{"input": "python check if root [SEP] def require_root(fn):     \"\"\"     Decorator to make sure, that user is root.     \"\"\"     @wraps(fn)     def xex(*args, **kwargs):         assert os.geteuid() == 0, \\             \"You have to be root to run function '%s'.\" % fn.__name__         return fn(*args, **kwargs)      return xex", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python check if root [SEP] def _vars_match(self):         \"\"\"Regular expression to match playbook variable.\"\"\"         return re.compile(             r'#([A-Za-z]+)'  # match literal (#App) at beginning of String             r':([\\d]+)'  # app id (:7979)             r':([A-Za-z0-9_\\.\\-\\[\\]]+)'  # variable name (:variable_name)             r'!(StringArray|BinaryArray|KeyValueArray'  # variable type (array)             r'|TCEntityArray|TCEnhancedEntityArray'  # variable type (array)             r'|String|Binary|KeyValue|TCEntity|TCEnhancedEntity'  # variable type             r'|(?:(?!String)(?!Binary)(?!KeyValue)'  # non matching for custom             r'(?!TCEntity)(?!TCEnhancedEntity)'  # non matching for custom             r'[A-Za-z0-9_-]+))'  # variable type (custom)         )", "target": 0, "target_options": ["no match", "match"]}
{"input": "python check if root [SEP] def __init__(self, pidfile, daemonize=True, root=False, root_chk_argv=True, stdin=\"/dev/null\", stdout=\"/dev/null\", stderr=\"/dev/null\"): \t\t\"\"\" \t\tMake our daemon instance. \t\tpidfile: the file we're going to store the process id in. ex: /tmp/matt-daemon.pid \t\troot:    does this script require root? True if it does, False if it doesn't. Will be enforced. \t\troot_chk_argv:  does the script require '--requires-root' in sys.argv to run as root? (usage is good) \t\tstdin:   where the script gets stdin from. \"/dev/null\", \"/dev/stdin\", etc. \t\tstdout:  where the script writes stdout. \"/dev/null\", \"/dev/stdout\", etc. \t\tstderr:  where the script writes stderr. \"/dev/null\", \"/dev/stderr\", etc. \t\t\"\"\" \t\t# Enforce root usage or non-usage. \t\tRootCheck.check(root, check_argv=root_chk_argv) \t\tself.pidfile = pidfile \t\tself.should_daemonize = daemonize \t\tself.stdin = stdin \t\tself.stdout = stdout \t\tself.stderr = stderr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python check if root [SEP] def is_agent_listening(self, host, port):         \"\"\"         Check if the Instana Agent is listening on <host> and <port>.         \"\"\"         try:             rv = False             url = \"http://%s:%s/\" % (host, port)             response = self.client.get(url, timeout=0.8)              server_header = response.headers[\"Server\"]             if server_header == AGENT_HEADER:                 logger.debug(\"Host agent found on %s:%d\" % (host, port))                 rv = True             else:                 logger.debug(\"...something is listening on %s:%d but it's not the Instana Agent: %s\"                              % (host, port, server_header))         except (requests.ConnectTimeout, requests.ConnectionError):             logger.debug(\"No host agent listening on %s:%d\" % (host, port))             rv = False         finally:             return rv", "target": 0, "target_options": ["no match", "match"]}
{"input": "remove tuples that repeat python [SEP] def remove_dups(seq):     \"\"\"remove duplicates from a sequence, preserving order\"\"\"     seen = set()     seen_add = seen.add     return [x for x in seq if not (x in seen or seen_add(x))]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove tuples that repeat python [SEP] def read_img(path):     \"\"\" Reads image specified by path into numpy.ndarray\"\"\"     img = cv2.resize(cv2.imread(path, 0), (80, 30)).astype(np.float32) / 255     img = np.expand_dims(img.transpose(1, 0), 0)     return img", "target": 0, "target_options": ["no match", "match"]}
{"input": "remove tuples that repeat python [SEP] def remove_duplicates(lst):     \"\"\"     Emulate what a Python ``set()`` does, but keeping the element's order.     \"\"\"     dset = set()     return [l for l in lst if l not in dset and not dset.add(l)]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove tuples that repeat python [SEP] def _prune(self):         \"\"\"Primitive way to keep dict in sync with RB.\"\"\"         delkeys = [k for k in self.keys() if k not in self.__ringbuffer]         for k in delkeys:  # necessary because dict is changed during iterations             super(KRingbuffer,self).__delitem__(k)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python count count number of roles in column [SEP] def is_dimension(self):         \"\"\"Return true if the colum is a dimension\"\"\"         from ambry.valuetype.core import ROLE         return self.role == ROLE.DIMENSION", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python count count number of roles in column [SEP] def norm_vec(vector):     \"\"\"Normalize the length of a vector to one\"\"\"     assert len(vector) == 3     v = np.array(vector)     return v/np.sqrt(np.sum(v**2))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python count count number of roles in column [SEP] def is_label(self):         \"\"\"Return true if the colum is a dimension\"\"\"         from ambry.valuetype.core import ROLE         return self.role == ROLE.LABEL", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python count count number of roles in column [SEP] def read_mm_header(fd, byte_order, dtype, count):     \"\"\"Read MM_HEADER tag from file and return as numpy.rec.array.\"\"\"     return numpy.rec.fromfile(fd, MM_HEADER, 1, byteorder=byte_order)[0]", "target": 0, "target_options": ["no match", "match"]}
{"input": "python format float as tring [SEP] def floor(self):     \"\"\"Round `x` and `y` down to integers.\"\"\"     return Point(int(math.floor(self.x)), int(math.floor(self.y)))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python format float as tring [SEP] def parse_command_args():     \"\"\"Command line parser.\"\"\"     parser = argparse.ArgumentParser(description='Register PB devices.')     parser.add_argument('num_pb', type=int,                         help='Number of PBs devices to register.')     return parser.parse_args()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python format float as tring [SEP] def realized_pnl(self):         \"\"\"         [float] 平仓盈亏         \"\"\"         return sum(position.realized_pnl for position in six.itervalues(self._positions))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python format float as tring [SEP] def main(idle):     \"\"\"Any normal python logic which runs a loop. Can take arguments.\"\"\"     while True:          LOG.debug(\"Sleeping for {0} seconds.\".format(idle))         time.sleep(idle)", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to rename a file on c drive in order to download python [SEP] def move_file(source, dest):      \"\"\"      Move file from *source* to *dest*      If file is a Python script, also rename .pyc and .pyo files if any      \"\"\"      import shutil      shutil.copy(source, dest)      remove_file(source)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to rename a file on c drive in order to download python [SEP] def end(self):         \"\"\"Generate the closing part\"\"\"         for depth in xrange(len(self.names) - 1, -1, -1):             self.out_f.write('{0}}}\\n'.format(self.prefix(depth)))", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to rename a file on c drive in order to download python [SEP] def case_insensitive_rename(src, dst):     \"\"\"A hack to allow us to rename paths in a case-insensitive filesystem like HFS.\"\"\"     temp_dir = tempfile.mkdtemp()     shutil.rmtree(temp_dir)     shutil.move(src, temp_dir)     shutil.move(temp_dir, dst)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to rename a file on c drive in order to download python [SEP] def correspond(text):     \"\"\"Communicate with the child process without closing stdin.\"\"\"     if text:         subproc.stdin.write(text)     subproc.stdin.flush()     return get_lines()", "target": 0, "target_options": ["no match", "match"]}
{"input": "python check if window is active win32 [SEP] def title(msg):     \"\"\"Sets the title of the console window.\"\"\"     if sys.platform.startswith(\"win\"):         ctypes.windll.kernel32.SetConsoleTitleW(tounicode(msg))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python check if window is active win32 [SEP] def _fill_array_from_list(the_list, the_array):         \"\"\"Fill an `array` from a `list`\"\"\"         for i, val in enumerate(the_list):             the_array[i] = val         return the_array", "target": 0, "target_options": ["no match", "match"]}
{"input": "python check if window is active win32 [SEP] def ResetConsoleColor() -> bool:     \"\"\"     Reset to the default text color on console window.     Return bool, True if succeed otherwise False.     \"\"\"     if sys.stdout:         sys.stdout.flush()     bool(ctypes.windll.kernel32.SetConsoleTextAttribute(_ConsoleOutputHandle, _DefaultConsoleColor))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python check if window is active win32 [SEP] def remove_bad(string):     \"\"\"     remove problem characters from string     \"\"\"     remove = [':', ',', '(', ')', ' ', '|', ';', '\\'']     for c in remove:         string = string.replace(c, '_')     return string", "target": 0, "target_options": ["no match", "match"]}
{"input": "using dictionaries to prove password username combinations in python [SEP] def check_auth(username, pwd):     \"\"\"This function is called to check if a username /     password combination is valid.     \"\"\"     cfg = get_current_config()     return username == cfg[\"dashboard_httpauth\"].split(         \":\")[0] and pwd == cfg[\"dashboard_httpauth\"].split(\":\")[1]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "using dictionaries to prove password username combinations in python [SEP] def __contains__(self, key):         \"\"\" Tests if a key is contained in the store.              May test againsts self.defaults              :param str value: Value         \"\"\"         if self._haveKey(key) or key in self.defaults:             return True         else:             return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "using dictionaries to prove password username combinations in python [SEP] def check_auth(email, password):     \"\"\"Check if a username/password combination is valid.     \"\"\"     try:         user = User.get(User.email == email)     except User.DoesNotExist:         return False     return password == user.password", "target": 1, "target_options": ["no_match", "match"]}
{"input": "using dictionaries to prove password username combinations in python [SEP] def listfolder(p):     \"\"\"     generator of list folder in the path.     folders only     \"\"\"     for entry in scandir.scandir(p):         if entry.is_dir():             yield entry.name", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to delete last items on a list [SEP] def list_move_to_front(l,value='other'):     \"\"\"if the value is in the list, move it to the front and return it.\"\"\"     l=list(l)     if value in l:         l.remove(value)         l.insert(0,value)     return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to delete last items on a list [SEP] def print_yaml(o):     \"\"\"Pretty print an object as YAML.\"\"\"     print(yaml.dump(o, default_flow_style=False, indent=4, encoding='utf-8'))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to delete last items on a list [SEP] def _poplast(self):         \"\"\"For avoiding lock during inserting to keep maxlen\"\"\"          try:             tup = self.data.pop()         except IndexError as ex:             ex.args = ('DEPQ is already empty',)             raise          self_items = self.items          try:             self_items[tup[0]] -= 1             if self_items[tup[0]] == 0:                 del self_items[tup[0]]         except TypeError:             r = repr(tup[0])             self_items[r] -= 1             if self_items[r] == 0:                 del self_items[r]          return tup", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to delete last items on a list [SEP] def created_today(self):         \"\"\"Return True if created today.\"\"\"         if self.datetime.date() == datetime.today().date():             return True         return False", "target": 0, "target_options": ["no match", "match"]}
{"input": "get rid of spaces between coding in a list python [SEP] def split_strings_in_list_retain_spaces(orig_list):     \"\"\"     Function to split every line in a list, and retain spaces for a rejoin     :param orig_list: Original list     :return:         A List with split lines      \"\"\"     temp_list = list()     for line in orig_list:         line_split = __re.split(r'(\\s+)', line)         temp_list.append(line_split)      return temp_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get rid of spaces between coding in a list python [SEP] def quote(self, s):         \"\"\"Return a shell-escaped version of the string s.\"\"\"          if six.PY2:             from pipes import quote         else:             from shlex import quote          return quote(s)", "target": 0, "target_options": ["no match", "match"]}
{"input": "get rid of spaces between coding in a list python [SEP] def strip_spaces(s):     \"\"\" Strip excess spaces from a string \"\"\"     return u\" \".join([c for c in s.split(u' ') if c])", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get rid of spaces between coding in a list python [SEP] def _saferound(value, decimal_places):     \"\"\"     Rounds a float value off to the desired precision     \"\"\"     try:         f = float(value)     except ValueError:         return ''     format = '%%.%df' % decimal_places     return format % f", "target": 0, "target_options": ["no match", "match"]}
{"input": "make html tag italics in python [SEP] def stylize(text, styles, reset=True):     \"\"\"conveniently styles your text as and resets ANSI codes at its end.\"\"\"     terminator = attr(\"reset\") if reset else \"\"     return \"{}{}{}\".format(\"\".join(styles), text, terminator)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "make html tag italics in python [SEP] def _column(arr, indexes):     \"\"\" Returns a column with given indexes from a deep array      For example, if the array is a matrix and indexes is a single int, will     return arr[:,indexes]. If the array is an order 3 tensor and indexes is a     pair of ints, will return arr[:,indexes[0],indexes[1]], etc.      \"\"\"     if arr.ndim == 2 and types.is_int(indexes):         return arr[:, indexes]     elif arr.ndim == 3 and len(indexes) == 2:         return arr[:, indexes[0], indexes[1]]     else:         raise NotImplementedError('Only supporting arrays of dimension 2 and 3 as yet.')", "target": 0, "target_options": ["no match", "match"]}
{"input": "make html tag italics in python [SEP] def draw_header(self, stream, header):         \"\"\"Draw header with underline\"\"\"         stream.writeln('=' * (len(header) + 4))         stream.writeln('| ' + header + ' |')         stream.writeln('=' * (len(header) + 4))         stream.writeln()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "make html tag italics in python [SEP] def __exit__(self, type, value, traceback):         \"\"\"When the `with` statement ends.\"\"\"          if not self.asarfile:             return          self.asarfile.close()         self.asarfile = None", "target": 0, "target_options": ["no match", "match"]}
{"input": "python read all lines in a text file [SEP] def txt_line_iterator(path):   \"\"\"Iterate through lines of file.\"\"\"   with tf.gfile.Open(path) as f:     for line in f:       yield line.strip()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python read all lines in a text file [SEP] def fix_header_comment(filename, timestamp):     \"\"\"Fixes the header-comment of the given file.\"\"\"     # Fix input file.     name = os.path.basename( filename )     for line in fileinput.input( filename, inplace=1, mode=\"rU\" ):         # If header-comment already contains anything for '$Id$', remove it.         line = re.sub(r'\\$Id:[^$]+\\$', r'$Id$', line.rstrip())         # Replace '$Id$' by a string containing the file's name (and a timestamp)!         line = re.sub(re.escape(r'$Id$'), r'$Id: ' + name + r' ' + timestamp.isoformat() + r' $', line.rstrip())         print(line)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python read all lines in a text file [SEP] def write_file(writer, filename):   \"\"\"Write all of lines from file using the writer.\"\"\"   for line in txt_line_iterator(filename):     writer.write(line)     writer.write(\"\\n\")", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python read all lines in a text file [SEP] def stringify_dict_contents(dct):     \"\"\"Turn dict keys and values into native strings.\"\"\"     return {         str_if_nested_or_str(k): str_if_nested_or_str(v)         for k, v in dct.items()     }", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to remove new lines in python [SEP] def text_remove_empty_lines(text):     \"\"\"     Whitespace normalization:        - Strip empty lines       - Strip trailing whitespace     \"\"\"     lines = [ line.rstrip()  for line in text.splitlines()  if line.strip() ]     return \"\\n\".join(lines)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to remove new lines in python [SEP] def string_to_int( s ):   \"\"\"Convert a string of bytes into an integer, as per X9.62.\"\"\"   result = 0   for c in s:     if not isinstance(c, int): c = ord( c )     result = 256 * result + c   return result", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to remove new lines in python [SEP] def fix_line_breaks(s):     \"\"\"     Convert \\r\\n and \\r to \\n chars. Strip any leading or trailing whitespace     on each line. Remove blank lines.     \"\"\"     l = s.splitlines()     x = [i.strip() for i in l]     x = [i for i in x if i]  # remove blank lines     return \"\\n\".join(x)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to remove new lines in python [SEP] def example_view():     text = request.args.get('text', 'http://www.youtube.com/watch?v=nda_OSWeyn8')     html = request.args.get('html', \"\"\" <p>This is a test</p> <p>http://www.youtube.com/watch?v=nda_OSWeyn8</p> <p>This will get rendered as a link: http://www.youtube.com/watch?v=nda_OSWeyn8</p> <p>This will not be modified: <a href=\"http://www.google.com/\">http://www.youtube.com/watch?v=nda_OSWeyn8</a></p>     \"\"\")     return render_template('example.html', text=text, html=html)", "target": 0, "target_options": ["no match", "match"]}
{"input": "python strcut to namedtuple [SEP] def dictify(a_named_tuple):     \"\"\"Transform a named tuple into a dictionary\"\"\"     return dict((s, getattr(a_named_tuple, s)) for s in a_named_tuple._fields)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python strcut to namedtuple [SEP] def find_geom(geom, geoms):     \"\"\"     Returns the index of a geometry in a list of geometries avoiding     expensive equality checks of `in` operator.     \"\"\"     for i, g in enumerate(geoms):         if g is geom:             return i", "target": 0, "target_options": ["no match", "match"]}
{"input": "python strcut to namedtuple [SEP] def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python strcut to namedtuple [SEP] def rand_elem(seq, n=None):     \"\"\"returns a random element from seq n times. If n is None, it continues indefinitly\"\"\"     return map(random.choice, repeat(seq, n) if n is not None else repeat(seq))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python paths to dict [SEP] def list2dict(lst):     \"\"\"Takes a list of (key,value) pairs and turns it into a dict.\"\"\"      dic = {}     for k,v in lst: dic[k] = v     return dic", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python paths to dict [SEP] def file_read(filename):     \"\"\"Read a file and close it.  Returns the file source.\"\"\"     fobj = open(filename,'r');     source = fobj.read();     fobj.close()     return source", "target": 0, "target_options": ["no match", "match"]}
{"input": "python paths to dict [SEP] def str_dict(some_dict):     \"\"\"Convert dict of ascii str/unicode to dict of str, if necessary\"\"\"     return {str(k): str(v) for k, v in some_dict.items()}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python paths to dict [SEP] def copy(self):         \"\"\"Return a copy of this list with each element copied to new memory         \"\"\"         out = type(self)()         for series in self:             out.append(series.copy())         return out", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to run python function every certain amount of time [SEP] def repeat(f, dt=1/60):     \"\"\" 重复执行函数f，时间间隔dt \"\"\"     stop(f)     pyglet.clock.schedule_interval(f, dt)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to run python function every certain amount of time [SEP] def round_to_int(number, precision):     \"\"\"Round a number to a precision\"\"\"     precision = int(precision)     rounded = (int(number) + precision / 2) // precision * precision     return rounded", "target": 0, "target_options": ["no match", "match"]}
{"input": "how to run python function every certain amount of time [SEP] def main(idle):     \"\"\"Any normal python logic which runs a loop. Can take arguments.\"\"\"     while True:          LOG.debug(\"Sleeping for {0} seconds.\".format(idle))         time.sleep(idle)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how to run python function every certain amount of time [SEP] def myreplace(astr, thefind, thereplace):     \"\"\"in string astr replace all occurences of thefind with thereplace\"\"\"     alist = astr.split(thefind)     new_s = alist.split(thereplace)     return new_s", "target": 0, "target_options": ["no match", "match"]}
{"input": "pull items randomly from lists in python [SEP] def get_randomized_guid_sample(self, item_count):         \"\"\" Fetch a subset of randomzied GUIDs from the whitelist \"\"\"         dataset = self.get_whitelist()         random.shuffle(dataset)         return dataset[:item_count]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "pull items randomly from lists in python [SEP] def strToBool(val):     \"\"\"     Helper function to turn a string representation of \"true\" into     boolean True.     \"\"\"     if isinstance(val, str):         val = val.lower()      return val in ['true', 'on', 'yes', True]", "target": 0, "target_options": ["no match", "match"]}
{"input": "pull items randomly from lists in python [SEP] def rand_elem(seq, n=None):     \"\"\"returns a random element from seq n times. If n is None, it continues indefinitly\"\"\"     return map(random.choice, repeat(seq, n) if n is not None else repeat(seq))", "target": 1, "target_options": ["no_match", "match"]}
{"input": "pull items randomly from lists in python [SEP] def flatten_list(l):     \"\"\" Nested lists to single-level list, does not split strings\"\"\"     return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to change list into string [SEP] def list2string (inlist,delimit=' '):     \"\"\" Converts a 1D list to a single long string for file output, using the string.join function.  Usage:   list2string (inlist,delimit=' ') Returns: the string created from inlist \"\"\"     stringlist = [makestr(_) for _ in inlist]     return string.join(stringlist,delimit)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to change list into string [SEP] def strip_spaces(x):     \"\"\"     Strips spaces     :param x:     :return:     \"\"\"     x = x.replace(b' ', b'')     x = x.replace(b'\\t', b'')     return x", "target": 0, "target_options": ["no match", "match"]}
{"input": "python how to change list into string [SEP] def list_to_str(list, separator=','):     \"\"\"     >>> list = [0, 0, 7]     >>> list_to_str(list)     '0,0,7'     \"\"\"     list = [str(x) for x in list]     return separator.join(list)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python how to change list into string [SEP] def gray2bgr(img):     \"\"\"Convert a grayscale image to BGR image.      Args:         img (ndarray or str): The input image.      Returns:         ndarray: The converted BGR image.     \"\"\"     img = img[..., None] if img.ndim == 2 else img     out_img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)     return out_img", "target": 0, "target_options": ["no match", "match"]}
{"input": "elasticsearch python return all index name [SEP] def get_model_index_properties(instance, index):     \"\"\"Return the list of properties specified for a model in an index.\"\"\"     mapping = get_index_mapping(index)     doc_type = instance._meta.model_name.lower()     return list(mapping[\"mappings\"][doc_type][\"properties\"].keys())", "target": 1, "target_options": ["no_match", "match"]}
{"input": "elasticsearch python return all index name [SEP] def __is__(cls, s):         \"\"\"Test if string matches this argument's format.\"\"\"         return s.startswith(cls.delims()[0]) and s.endswith(cls.delims()[1])", "target": 0, "target_options": ["no match", "match"]}
{"input": "elasticsearch python return all index name [SEP] def get_indexes(self, schema, **kwargs):         \"\"\"         get all the indexes          schema -- Schema()          return -- dict -- the indexes in {indexname: fields} format         \"\"\"         with self.connection(**kwargs) as connection:             kwargs['connection'] = connection             return self._get_indexes(schema, **kwargs)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "elasticsearch python return all index name [SEP] def _remove_dict_keys_with_value(dict_, val):   \"\"\"Removes `dict` keys which have have `self` as value.\"\"\"   return {k: v for k, v in dict_.items() if v is not val}", "target": 0, "target_options": ["no match", "match"]}
{"input": "python celery worker shutdown after start [SEP] def shutdown(self):         \"\"\"         Shutdown the client and all of its managed resources:          - the workers         - the scheduler threads          :return: None         \"\"\"         self._storage.clear()         self._scheduler.shutdown(wait=False)         self._workers.shutdown(wait=False)", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python celery worker shutdown after start [SEP] def dotproduct(X, Y):     \"\"\"Return the sum of the element-wise product of vectors x and y.     >>> dotproduct([1, 2, 3], [1000, 100, 10])     1230     \"\"\"     return sum([x * y for x, y in zip(X, Y)])", "target": 0, "target_options": ["no match", "match"]}
{"input": "python celery worker shutdown after start [SEP] def _shutdown_minions(self):         \"\"\"         send the SIGNINT signal to each worker in the pool.         \"\"\"         setproctitle('pyres_manager: Waiting on children to shutdown.')         for minion in self._workers.values():             minion.terminate()             minion.join()", "target": 1, "target_options": ["no_match", "match"]}
{"input": "python celery worker shutdown after start [SEP] def A(*a):     \"\"\"convert iterable object into numpy array\"\"\"     return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "target": 0, "target_options": ["no match", "match"]}
