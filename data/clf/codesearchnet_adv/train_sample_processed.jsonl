{"code": "def extract_current_routine ( page , stations ) : current_routines = CURRENT_ROUTINE_PATTERN . findall ( page . text ( ) ) if not current_routines : return terminal_station = stations [ 'stations' ] [ - 1 ] for routine in current_routines : if _ ( routine [ 0 ] ) == terminal_station : distance = int ( routine [ 1 ] ) stations_to_this_dir = stations [ 'terminal' ] [ terminal_station ] waiting_station = _ ( page ( '.now .stateName' ) . val ( ) ) idx = stations_to_this_dir . index ( waiting_station ) bus_station = stations_to_this_dir [ idx - distance + 1 ] return { 'destinate_station' : terminal_station , 'bus_station' : bus_station , 'waiting_station' : waiting_station , 'distance' : distance }", "docstring": "Extract current routine information from page .", "idx": 74551}
{"code": "def set_sampled_topics ( self , sampled_topics ) : assert sampled_topics . dtype == np . int and len ( sampled_topics . shape ) <= 2 if len ( sampled_topics . shape ) == 1 : self . sampled_topics = sampled_topics . reshape ( 1 , sampled_topics . shape [ 0 ] ) else : self . sampled_topics = sampled_topics self . samples = self . sampled_topics . shape [ 0 ] self . tt = self . tt_comp ( self . sampled_topics ) self . dt = self . dt_comp ( self . sampled_topics )", "docstring": "Allocate sampled topics to the documents rather than estimate them . Automatically generate term - topic and document - topic matrices .", "idx": 210934}
{"code": "def _get_nics ( vm_ ) : nics = [ ] if 'public_lan' in vm_ : firewall_rules = [ ] # Set LAN to public if it already exists, otherwise create a new # public LAN. if 'public_firewall_rules' in vm_ : firewall_rules = _get_firewall_rules ( vm_ [ 'public_firewall_rules' ] ) nic = NIC ( lan = set_public_lan ( int ( vm_ [ 'public_lan' ] ) ) , name = 'public' , firewall_rules = firewall_rules ) if 'public_ips' in vm_ : nic . ips = _get_ip_addresses ( vm_ [ 'public_ips' ] ) nics . append ( nic ) if 'private_lan' in vm_ : firewall_rules = [ ] if 'private_firewall_rules' in vm_ : firewall_rules = _get_firewall_rules ( vm_ [ 'private_firewall_rules' ] ) nic = NIC ( lan = int ( vm_ [ 'private_lan' ] ) , name = 'private' , firewall_rules = firewall_rules ) if 'private_ips' in vm_ : nic . ips = _get_ip_addresses ( vm_ [ 'private_ips' ] ) if 'nat' in vm_ and 'private_ips' not in vm_ : nic . nat = vm_ [ 'nat' ] nics . append ( nic ) return nics", "docstring": "Create network interfaces on appropriate LANs as defined in cloud profile .", "idx": 176729}
{"code": "def ip2long ( ip ) : if not validate_ip ( ip ) : return None quads = ip . split ( '.' ) if len ( quads ) == 1 : # only a network quad quads = quads + [ 0 , 0 , 0 ] elif len ( quads ) < 4 : # partial form, last supplied quad is host address, rest is network host = quads [ - 1 : ] quads = quads [ : - 1 ] + [ 0 , ] * ( 4 - len ( quads ) ) + host lngip = 0 for q in quads : lngip = ( lngip << 8 ) | int ( q ) return lngip", "docstring": "Convert a dotted - quad ip address to a network byte order 32 - bit integer .", "idx": 188495}
{"code": "def _resolve_entity ( mo ) : ent = mo . group ( \"entity\" ) s = mo . group ( ) if s . startswith ( '&#' ) : if s [ 2 ] in 'xX' : radix = 16 else : radix = 10 try : num = int ( ent , radix ) except ( ValueError , OverflowError ) : return u'' else : num = name2codepoint . get ( ent ) if num is None or num < 0 : # unknown entity -> ignore return u'' try : return unichr ( num ) except ValueError : return u''", "docstring": "Resolve a HTML entity .", "idx": 196039}
{"code": "def generate_telesign_headers ( customer_id , api_key , method_name , resource , url_encoded_fields , date_rfc2616 = None , nonce = None , user_agent = None , content_type = None ) : if date_rfc2616 is None : date_rfc2616 = formatdate ( usegmt = True ) if nonce is None : nonce = str ( uuid . uuid4 ( ) ) if not content_type : content_type = \"application/x-www-form-urlencoded\" if method_name in ( \"POST\" , \"PUT\" ) else \"\" auth_method = \"HMAC-SHA256\" string_to_sign_builder = [ \"{method}\" . format ( method = method_name ) ] string_to_sign_builder . append ( \"\\n{content_type}\" . format ( content_type = content_type ) ) string_to_sign_builder . append ( \"\\n{date}\" . format ( date = date_rfc2616 ) ) string_to_sign_builder . append ( \"\\nx-ts-auth-method:{auth_method}\" . format ( auth_method = auth_method ) ) string_to_sign_builder . append ( \"\\nx-ts-nonce:{nonce}\" . format ( nonce = nonce ) ) if content_type and url_encoded_fields : string_to_sign_builder . append ( \"\\n{fields}\" . format ( fields = url_encoded_fields ) ) string_to_sign_builder . append ( \"\\n{resource}\" . format ( resource = resource ) ) string_to_sign = \"\" . join ( string_to_sign_builder ) signer = hmac . new ( b64decode ( api_key ) , string_to_sign . encode ( \"utf-8\" ) , sha256 ) signature = b64encode ( signer . digest ( ) ) . decode ( \"utf-8\" ) authorization = \"TSA {customer_id}:{signature}\" . format ( customer_id = customer_id , signature = signature ) headers = { \"Authorization\" : authorization , \"Date\" : date_rfc2616 , \"Content-Type\" : content_type , \"x-ts-auth-method\" : auth_method , \"x-ts-nonce\" : nonce } if user_agent : headers [ 'User-Agent' ] = user_agent return headers", "docstring": "Generates the TeleSign REST API headers used to authenticate requests .", "idx": 63485}
{"code": "def calcTightAnchors ( args , d , patches ) : centerPoint = ( int ( args . worldSize / 2 ) , int ( args . worldSize / 2 ) ) anchors = [ ] if patches == 0 : pass elif patches == 1 : anchors . append ( centerPoint ) elif patches % 2 == 0 : dsout = int ( ( patches - 2 ) // 2 ) + 1 add_anchors ( centerPoint , d , dsout , anchors , True ) if d != 0 : anchors = list ( set ( anchors ) ) anchors . sort ( ) if dsout != 1 : return ( anchors + calcTightAnchors ( args , d , patches - 2 ) ) [ : patches * patches ] # to cut off the extras in the case where d=0 else : # Note - an odd number of args.patchesPerSide requires that there be # a patch at the centerpoint dsout = int ( ( patches - 1 ) // 2 ) add_anchors ( centerPoint , d , dsout , anchors , False ) if dsout != 1 : return anchors + calcTightAnchors ( d , patches - 2 ) return anchors", "docstring": "Recursively generates the number of anchor points specified in the patches argument such that all patches are d cells away from their nearest neighbors .", "idx": 90051}
{"code": "def drop ( self , auth , resource , defer = False ) : return self . _call ( 'drop' , auth , [ resource ] , defer )", "docstring": "Deletes the specified resource .", "idx": 7310}
{"code": "def _try_dump_cnt ( self ) : now = time . time ( ) if now - self . _last_dump_cnt > 60 : self . _last_dump_cnt = now self . _dump_cnt ( ) self . _print_counter_log ( )", "docstring": "Dump counters every 60 seconds", "idx": 169705}
{"code": "def display_buffer ( self , buffer , redraw = True ) : logger . debug ( \"display buffer %r\" , buffer ) self . buffer_movement_history . append ( buffer ) self . current_buffer = buffer self . _set_main_widget ( buffer . widget , redraw = redraw )", "docstring": "display provided buffer", "idx": 208554}
