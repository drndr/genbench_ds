{"repo": "bcho/gzbus", "path": "gzbus/extract.py", "func_name": "extract_current_routine", "original_string": "def extract_current_routine(page, stations):\n    '''Extract current routine information from page.\n\n    :param page: crawled page.\n    :param stations: bus stations list. See `~extract_stations`.\n    '''\n    current_routines = CURRENT_ROUTINE_PATTERN.findall(page.text())\n    if not current_routines:\n        return\n\n    terminal_station = stations['stations'][-1]\n    for routine in current_routines:\n        if _(routine[0]) == terminal_station:\n            distance = int(routine[1])\n    stations_to_this_dir = stations['terminal'][terminal_station]\n\n    waiting_station = _(page('.now .stateName').val())\n    idx = stations_to_this_dir.index(waiting_station)\n    bus_station = stations_to_this_dir[idx - distance + 1]\n\n    return {\n        'destinate_station': terminal_station,\n        'bus_station': bus_station,\n        'waiting_station': waiting_station,\n        'distance': distance\n    }", "language": "python", "code": "def extract_current_routine(page, stations):\n    '''Extract current routine information from page.\n\n    :param page: crawled page.\n    :param stations: bus stations list. See `~extract_stations`.\n    '''\n    current_routines = CURRENT_ROUTINE_PATTERN.findall(page.text())\n    if not current_routines:\n        return\n\n    terminal_station = stations['stations'][-1]\n    for routine in current_routines:\n        if _(routine[0]) == terminal_station:\n            distance = int(routine[1])\n    stations_to_this_dir = stations['terminal'][terminal_station]\n\n    waiting_station = _(page('.now .stateName').val())\n    idx = stations_to_this_dir.index(waiting_station)\n    bus_station = stations_to_this_dir[idx - distance + 1]\n\n    return {\n        'destinate_station': terminal_station,\n        'bus_station': bus_station,\n        'waiting_station': waiting_station,\n        'distance': distance\n    }", "code_tokens": ["def", "extract_current_routine", "(", "page", ",", "stations", ")", ":", "current_routines", "=", "CURRENT_ROUTINE_PATTERN", ".", "findall", "(", "page", ".", "text", "(", ")", ")", "if", "not", "current_routines", ":", "return", "terminal_station", "=", "stations", "[", "'stations'", "]", "[", "-", "1", "]", "for", "routine", "in", "current_routines", ":", "if", "_", "(", "routine", "[", "0", "]", ")", "==", "terminal_station", ":", "distance", "=", "int", "(", "routine", "[", "1", "]", ")", "stations_to_this_dir", "=", "stations", "[", "'terminal'", "]", "[", "terminal_station", "]", "waiting_station", "=", "_", "(", "page", "(", "'.now .stateName'", ")", ".", "val", "(", ")", ")", "idx", "=", "stations_to_this_dir", ".", "index", "(", "waiting_station", ")", "bus_station", "=", "stations_to_this_dir", "[", "idx", "-", "distance", "+", "1", "]", "return", "{", "'destinate_station'", ":", "terminal_station", ",", "'bus_station'", ":", "bus_station", ",", "'waiting_station'", ":", "waiting_station", ",", "'distance'", ":", "distance", "}"], "docstring": "Extract current routine information from page.\n\n    :param page: crawled page.\n    :param stations: bus stations list. See `~extract_stations`.", "docstring_tokens": ["Extract", "current", "routine", "information", "from", "page", "."], "sha": "4dd2cc2e5068331d0f4bed885cf999a1d107b8b4", "url": "https://github.com/bcho/gzbus/blob/4dd2cc2e5068331d0f4bed885cf999a1d107b8b4/gzbus/extract.py#L46-L71", "partition": "train", "idx": 74551}
{"repo": "alan-turing-institute/topic-modelling-tools", "path": "topicmodels/LDA/gibbs.py", "func_name": "LDAGibbs.set_sampled_topics", "original_string": "def set_sampled_topics(self, sampled_topics):\n\n        \"\"\"\n        Allocate sampled topics to the documents rather than estimate them.\n        Automatically generate term-topic and document-topic matrices.\n        \"\"\"\n\n        assert sampled_topics.dtype == np.int and \\\n            len(sampled_topics.shape) <= 2\n\n        if len(sampled_topics.shape) == 1:\n            self.sampled_topics = \\\n                sampled_topics.reshape(1, sampled_topics.shape[0])\n        else:\n            self.sampled_topics = sampled_topics\n\n        self.samples = self.sampled_topics.shape[0]\n\n        self.tt = self.tt_comp(self.sampled_topics)\n        self.dt = self.dt_comp(self.sampled_topics)", "language": "python", "code": "def set_sampled_topics(self, sampled_topics):\n\n        \"\"\"\n        Allocate sampled topics to the documents rather than estimate them.\n        Automatically generate term-topic and document-topic matrices.\n        \"\"\"\n\n        assert sampled_topics.dtype == np.int and \\\n            len(sampled_topics.shape) <= 2\n\n        if len(sampled_topics.shape) == 1:\n            self.sampled_topics = \\\n                sampled_topics.reshape(1, sampled_topics.shape[0])\n        else:\n            self.sampled_topics = sampled_topics\n\n        self.samples = self.sampled_topics.shape[0]\n\n        self.tt = self.tt_comp(self.sampled_topics)\n        self.dt = self.dt_comp(self.sampled_topics)", "code_tokens": ["def", "set_sampled_topics", "(", "self", ",", "sampled_topics", ")", ":", "assert", "sampled_topics", ".", "dtype", "==", "np", ".", "int", "and", "len", "(", "sampled_topics", ".", "shape", ")", "<=", "2", "if", "len", "(", "sampled_topics", ".", "shape", ")", "==", "1", ":", "self", ".", "sampled_topics", "=", "sampled_topics", ".", "reshape", "(", "1", ",", "sampled_topics", ".", "shape", "[", "0", "]", ")", "else", ":", "self", ".", "sampled_topics", "=", "sampled_topics", "self", ".", "samples", "=", "self", ".", "sampled_topics", ".", "shape", "[", "0", "]", "self", ".", "tt", "=", "self", ".", "tt_comp", "(", "self", ".", "sampled_topics", ")", "self", ".", "dt", "=", "self", ".", "dt_comp", "(", "self", ".", "sampled_topics", ")"], "docstring": "Allocate sampled topics to the documents rather than estimate them.\n        Automatically generate term-topic and document-topic matrices.", "docstring_tokens": ["Allocate", "sampled", "topics", "to", "the", "documents", "rather", "than", "estimate", "them", ".", "Automatically", "generate", "term", "-", "topic", "and", "document", "-", "topic", "matrices", "."], "sha": "f0cf90cdd06f1072e824b446f201c7469b9de5df", "url": "https://github.com/alan-turing-institute/topic-modelling-tools/blob/f0cf90cdd06f1072e824b446f201c7469b9de5df/topicmodels/LDA/gibbs.py#L69-L88", "partition": "train", "idx": 210934}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/profitbricks.py", "func_name": "_get_nics", "original_string": "def _get_nics(vm_):\n    '''\n    Create network interfaces on appropriate LANs as defined in cloud profile.\n    '''\n    nics = []\n    if 'public_lan' in vm_:\n        firewall_rules = []\n        # Set LAN to public if it already exists, otherwise create a new\n        # public LAN.\n        if 'public_firewall_rules' in vm_:\n            firewall_rules = _get_firewall_rules(vm_['public_firewall_rules'])\n        nic = NIC(lan=set_public_lan(int(vm_['public_lan'])),\n                  name='public',\n                  firewall_rules=firewall_rules)\n        if 'public_ips' in vm_:\n            nic.ips = _get_ip_addresses(vm_['public_ips'])\n        nics.append(nic)\n\n    if 'private_lan' in vm_:\n        firewall_rules = []\n        if 'private_firewall_rules' in vm_:\n            firewall_rules = _get_firewall_rules(vm_['private_firewall_rules'])\n        nic = NIC(lan=int(vm_['private_lan']),\n                  name='private',\n                  firewall_rules=firewall_rules)\n        if 'private_ips' in vm_:\n            nic.ips = _get_ip_addresses(vm_['private_ips'])\n        if 'nat' in vm_ and 'private_ips' not in vm_:\n            nic.nat = vm_['nat']\n        nics.append(nic)\n    return nics", "language": "python", "code": "def _get_nics(vm_):\n    '''\n    Create network interfaces on appropriate LANs as defined in cloud profile.\n    '''\n    nics = []\n    if 'public_lan' in vm_:\n        firewall_rules = []\n        # Set LAN to public if it already exists, otherwise create a new\n        # public LAN.\n        if 'public_firewall_rules' in vm_:\n            firewall_rules = _get_firewall_rules(vm_['public_firewall_rules'])\n        nic = NIC(lan=set_public_lan(int(vm_['public_lan'])),\n                  name='public',\n                  firewall_rules=firewall_rules)\n        if 'public_ips' in vm_:\n            nic.ips = _get_ip_addresses(vm_['public_ips'])\n        nics.append(nic)\n\n    if 'private_lan' in vm_:\n        firewall_rules = []\n        if 'private_firewall_rules' in vm_:\n            firewall_rules = _get_firewall_rules(vm_['private_firewall_rules'])\n        nic = NIC(lan=int(vm_['private_lan']),\n                  name='private',\n                  firewall_rules=firewall_rules)\n        if 'private_ips' in vm_:\n            nic.ips = _get_ip_addresses(vm_['private_ips'])\n        if 'nat' in vm_ and 'private_ips' not in vm_:\n            nic.nat = vm_['nat']\n        nics.append(nic)\n    return nics", "code_tokens": ["def", "_get_nics", "(", "vm_", ")", ":", "nics", "=", "[", "]", "if", "'public_lan'", "in", "vm_", ":", "firewall_rules", "=", "[", "]", "# Set LAN to public if it already exists, otherwise create a new", "# public LAN.", "if", "'public_firewall_rules'", "in", "vm_", ":", "firewall_rules", "=", "_get_firewall_rules", "(", "vm_", "[", "'public_firewall_rules'", "]", ")", "nic", "=", "NIC", "(", "lan", "=", "set_public_lan", "(", "int", "(", "vm_", "[", "'public_lan'", "]", ")", ")", ",", "name", "=", "'public'", ",", "firewall_rules", "=", "firewall_rules", ")", "if", "'public_ips'", "in", "vm_", ":", "nic", ".", "ips", "=", "_get_ip_addresses", "(", "vm_", "[", "'public_ips'", "]", ")", "nics", ".", "append", "(", "nic", ")", "if", "'private_lan'", "in", "vm_", ":", "firewall_rules", "=", "[", "]", "if", "'private_firewall_rules'", "in", "vm_", ":", "firewall_rules", "=", "_get_firewall_rules", "(", "vm_", "[", "'private_firewall_rules'", "]", ")", "nic", "=", "NIC", "(", "lan", "=", "int", "(", "vm_", "[", "'private_lan'", "]", ")", ",", "name", "=", "'private'", ",", "firewall_rules", "=", "firewall_rules", ")", "if", "'private_ips'", "in", "vm_", ":", "nic", ".", "ips", "=", "_get_ip_addresses", "(", "vm_", "[", "'private_ips'", "]", ")", "if", "'nat'", "in", "vm_", "and", "'private_ips'", "not", "in", "vm_", ":", "nic", ".", "nat", "=", "vm_", "[", "'nat'", "]", "nics", ".", "append", "(", "nic", ")", "return", "nics"], "docstring": "Create network interfaces on appropriate LANs as defined in cloud profile.", "docstring_tokens": ["Create", "network", "interfaces", "on", "appropriate", "LANs", "as", "defined", "in", "cloud", "profile", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/profitbricks.py#L703-L733", "partition": "train", "idx": 176729}
{"repo": "bd808/python-iptools", "path": "iptools/ipv4.py", "func_name": "ip2long", "original_string": "def ip2long(ip):\n    \"\"\"Convert a dotted-quad ip address to a network byte order 32-bit\n    integer.\n\n\n    >>> ip2long('127.0.0.1')\n    2130706433\n    >>> ip2long('127.1')\n    2130706433\n    >>> ip2long('127')\n    2130706432\n    >>> ip2long('127.0.0.256') is None\n    True\n\n\n    :param ip: Dotted-quad ip address (eg. '127.0.0.1').\n    :type ip: str\n    :returns: Network byte order 32-bit integer or ``None`` if ip is invalid.\n    \"\"\"\n    if not validate_ip(ip):\n        return None\n    quads = ip.split('.')\n    if len(quads) == 1:\n        # only a network quad\n        quads = quads + [0, 0, 0]\n    elif len(quads) < 4:\n        # partial form, last supplied quad is host address, rest is network\n        host = quads[-1:]\n        quads = quads[:-1] + [0, ] * (4 - len(quads)) + host\n\n    lngip = 0\n    for q in quads:\n        lngip = (lngip << 8) | int(q)\n    return lngip", "language": "python", "code": "def ip2long(ip):\n    \"\"\"Convert a dotted-quad ip address to a network byte order 32-bit\n    integer.\n\n\n    >>> ip2long('127.0.0.1')\n    2130706433\n    >>> ip2long('127.1')\n    2130706433\n    >>> ip2long('127')\n    2130706432\n    >>> ip2long('127.0.0.256') is None\n    True\n\n\n    :param ip: Dotted-quad ip address (eg. '127.0.0.1').\n    :type ip: str\n    :returns: Network byte order 32-bit integer or ``None`` if ip is invalid.\n    \"\"\"\n    if not validate_ip(ip):\n        return None\n    quads = ip.split('.')\n    if len(quads) == 1:\n        # only a network quad\n        quads = quads + [0, 0, 0]\n    elif len(quads) < 4:\n        # partial form, last supplied quad is host address, rest is network\n        host = quads[-1:]\n        quads = quads[:-1] + [0, ] * (4 - len(quads)) + host\n\n    lngip = 0\n    for q in quads:\n        lngip = (lngip << 8) | int(q)\n    return lngip", "code_tokens": ["def", "ip2long", "(", "ip", ")", ":", "if", "not", "validate_ip", "(", "ip", ")", ":", "return", "None", "quads", "=", "ip", ".", "split", "(", "'.'", ")", "if", "len", "(", "quads", ")", "==", "1", ":", "# only a network quad", "quads", "=", "quads", "+", "[", "0", ",", "0", ",", "0", "]", "elif", "len", "(", "quads", ")", "<", "4", ":", "# partial form, last supplied quad is host address, rest is network", "host", "=", "quads", "[", "-", "1", ":", "]", "quads", "=", "quads", "[", ":", "-", "1", "]", "+", "[", "0", ",", "]", "*", "(", "4", "-", "len", "(", "quads", ")", ")", "+", "host", "lngip", "=", "0", "for", "q", "in", "quads", ":", "lngip", "=", "(", "lngip", "<<", "8", ")", "|", "int", "(", "q", ")", "return", "lngip"], "docstring": "Convert a dotted-quad ip address to a network byte order 32-bit\n    integer.\n\n\n    >>> ip2long('127.0.0.1')\n    2130706433\n    >>> ip2long('127.1')\n    2130706433\n    >>> ip2long('127')\n    2130706432\n    >>> ip2long('127.0.0.256') is None\n    True\n\n\n    :param ip: Dotted-quad ip address (eg. '127.0.0.1').\n    :type ip: str\n    :returns: Network byte order 32-bit integer or ``None`` if ip is invalid.", "docstring_tokens": ["Convert", "a", "dotted", "-", "quad", "ip", "address", "to", "a", "network", "byte", "order", "32", "-", "bit", "integer", "."], "sha": "5d3fae0056297540355bb7c6c112703cfaa4b6ce", "url": "https://github.com/bd808/python-iptools/blob/5d3fae0056297540355bb7c6c112703cfaa4b6ce/iptools/ipv4.py#L356-L389", "partition": "train", "idx": 188495}
{"repo": "wummel/linkchecker", "path": "linkcheck/HtmlParser/__init__.py", "func_name": "_resolve_entity", "original_string": "def _resolve_entity (mo):\n    \"\"\"\n    Resolve a HTML entity.\n\n    @param mo: matched _entity_re object with a \"entity\" match group\n    @type mo: MatchObject instance\n    @return: resolved entity char, or empty string on error\n    @rtype: unicode string\n    \"\"\"\n    ent = mo.group(\"entity\")\n    s = mo.group()\n    if s.startswith('&#'):\n        if s[2] in 'xX':\n            radix = 16\n        else:\n            radix = 10\n        try:\n            num = int(ent, radix)\n        except (ValueError, OverflowError):\n            return u''\n    else:\n        num = name2codepoint.get(ent)\n    if num is None or num < 0:\n        # unknown entity -> ignore\n        return u''\n    try:\n        return unichr(num)\n    except ValueError:\n        return u''", "language": "python", "code": "def _resolve_entity (mo):\n    \"\"\"\n    Resolve a HTML entity.\n\n    @param mo: matched _entity_re object with a \"entity\" match group\n    @type mo: MatchObject instance\n    @return: resolved entity char, or empty string on error\n    @rtype: unicode string\n    \"\"\"\n    ent = mo.group(\"entity\")\n    s = mo.group()\n    if s.startswith('&#'):\n        if s[2] in 'xX':\n            radix = 16\n        else:\n            radix = 10\n        try:\n            num = int(ent, radix)\n        except (ValueError, OverflowError):\n            return u''\n    else:\n        num = name2codepoint.get(ent)\n    if num is None or num < 0:\n        # unknown entity -> ignore\n        return u''\n    try:\n        return unichr(num)\n    except ValueError:\n        return u''", "code_tokens": ["def", "_resolve_entity", "(", "mo", ")", ":", "ent", "=", "mo", ".", "group", "(", "\"entity\"", ")", "s", "=", "mo", ".", "group", "(", ")", "if", "s", ".", "startswith", "(", "'&#'", ")", ":", "if", "s", "[", "2", "]", "in", "'xX'", ":", "radix", "=", "16", "else", ":", "radix", "=", "10", "try", ":", "num", "=", "int", "(", "ent", ",", "radix", ")", "except", "(", "ValueError", ",", "OverflowError", ")", ":", "return", "u''", "else", ":", "num", "=", "name2codepoint", ".", "get", "(", "ent", ")", "if", "num", "is", "None", "or", "num", "<", "0", ":", "# unknown entity -> ignore", "return", "u''", "try", ":", "return", "unichr", "(", "num", ")", "except", "ValueError", ":", "return", "u''"], "docstring": "Resolve a HTML entity.\n\n    @param mo: matched _entity_re object with a \"entity\" match group\n    @type mo: MatchObject instance\n    @return: resolved entity char, or empty string on error\n    @rtype: unicode string", "docstring_tokens": ["Resolve", "a", "HTML", "entity", "."], "sha": "c2ce810c3fb00b895a841a7be6b2e78c64e7b042", "url": "https://github.com/wummel/linkchecker/blob/c2ce810c3fb00b895a841a7be6b2e78c64e7b042/linkcheck/HtmlParser/__init__.py#L170-L198", "partition": "train", "idx": 196039}
{"repo": "TeleSign/python_telesign", "path": "telesign/rest.py", "func_name": "RestClient.generate_telesign_headers", "original_string": "def generate_telesign_headers(customer_id,\n                                  api_key,\n                                  method_name,\n                                  resource,\n                                  url_encoded_fields,\n                                  date_rfc2616=None,\n                                  nonce=None,\n                                  user_agent=None,\n                                  content_type=None):\n        \"\"\"\n        Generates the TeleSign REST API headers used to authenticate requests.\n\n        Creates the canonicalized string_to_sign and generates the HMAC signature. This is used to authenticate requests\n        against the TeleSign REST API.\n\n        See https://developer.telesign.com/docs/authentication for detailed API documentation.\n\n        :param customer_id: Your account customer_id.\n        :param api_key: Your account api_key.\n        :param method_name: The HTTP method name of the request as a upper case string, should be one of 'POST', 'GET',\n            'PUT' or 'DELETE'.\n        :param resource: The partial resource URI to perform the request against, as a string.\n        :param url_encoded_fields: HTTP body parameters to perform the HTTP request with, must be a urlencoded string.\n        :param date_rfc2616: The date and time of the request formatted in rfc 2616, as a string.\n        :param nonce: A unique cryptographic nonce for the request, as a string.\n        :param user_agent: (optional) User Agent associated with the request, as a string.\n        :param content_type: (optional) ContentType of the request, as a string.\n        :return: The TeleSign authentication headers.\n        \"\"\"\n        if date_rfc2616 is None:\n            date_rfc2616 = formatdate(usegmt=True)\n\n        if nonce is None:\n            nonce = str(uuid.uuid4())\n        \n        if not content_type:\n            content_type = \"application/x-www-form-urlencoded\" if method_name in (\"POST\", \"PUT\") else \"\"\n\n        auth_method = \"HMAC-SHA256\"\n\n        string_to_sign_builder = [\"{method}\".format(method=method_name)]\n\n        string_to_sign_builder.append(\"\\n{content_type}\".format(content_type=content_type))\n\n        string_to_sign_builder.append(\"\\n{date}\".format(date=date_rfc2616))\n\n        string_to_sign_builder.append(\"\\nx-ts-auth-method:{auth_method}\".format(auth_method=auth_method))\n\n        string_to_sign_builder.append(\"\\nx-ts-nonce:{nonce}\".format(nonce=nonce))\n\n        if content_type and url_encoded_fields:\n            string_to_sign_builder.append(\"\\n{fields}\".format(fields=url_encoded_fields))\n\n        string_to_sign_builder.append(\"\\n{resource}\".format(resource=resource))\n\n        string_to_sign = \"\".join(string_to_sign_builder)\n\n        signer = hmac.new(b64decode(api_key), string_to_sign.encode(\"utf-8\"), sha256)\n        signature = b64encode(signer.digest()).decode(\"utf-8\")\n\n        authorization = \"TSA {customer_id}:{signature}\".format(\n            customer_id=customer_id,\n            signature=signature)\n\n        headers = {\n            \"Authorization\": authorization,\n            \"Date\": date_rfc2616,\n            \"Content-Type\": content_type,\n            \"x-ts-auth-method\": auth_method,\n            \"x-ts-nonce\": nonce\n        }\n\n        if user_agent:\n            headers['User-Agent'] = user_agent\n\n        return headers", "language": "python", "code": "def generate_telesign_headers(customer_id,\n                                  api_key,\n                                  method_name,\n                                  resource,\n                                  url_encoded_fields,\n                                  date_rfc2616=None,\n                                  nonce=None,\n                                  user_agent=None,\n                                  content_type=None):\n        \"\"\"\n        Generates the TeleSign REST API headers used to authenticate requests.\n\n        Creates the canonicalized string_to_sign and generates the HMAC signature. This is used to authenticate requests\n        against the TeleSign REST API.\n\n        See https://developer.telesign.com/docs/authentication for detailed API documentation.\n\n        :param customer_id: Your account customer_id.\n        :param api_key: Your account api_key.\n        :param method_name: The HTTP method name of the request as a upper case string, should be one of 'POST', 'GET',\n            'PUT' or 'DELETE'.\n        :param resource: The partial resource URI to perform the request against, as a string.\n        :param url_encoded_fields: HTTP body parameters to perform the HTTP request with, must be a urlencoded string.\n        :param date_rfc2616: The date and time of the request formatted in rfc 2616, as a string.\n        :param nonce: A unique cryptographic nonce for the request, as a string.\n        :param user_agent: (optional) User Agent associated with the request, as a string.\n        :param content_type: (optional) ContentType of the request, as a string.\n        :return: The TeleSign authentication headers.\n        \"\"\"\n        if date_rfc2616 is None:\n            date_rfc2616 = formatdate(usegmt=True)\n\n        if nonce is None:\n            nonce = str(uuid.uuid4())\n        \n        if not content_type:\n            content_type = \"application/x-www-form-urlencoded\" if method_name in (\"POST\", \"PUT\") else \"\"\n\n        auth_method = \"HMAC-SHA256\"\n\n        string_to_sign_builder = [\"{method}\".format(method=method_name)]\n\n        string_to_sign_builder.append(\"\\n{content_type}\".format(content_type=content_type))\n\n        string_to_sign_builder.append(\"\\n{date}\".format(date=date_rfc2616))\n\n        string_to_sign_builder.append(\"\\nx-ts-auth-method:{auth_method}\".format(auth_method=auth_method))\n\n        string_to_sign_builder.append(\"\\nx-ts-nonce:{nonce}\".format(nonce=nonce))\n\n        if content_type and url_encoded_fields:\n            string_to_sign_builder.append(\"\\n{fields}\".format(fields=url_encoded_fields))\n\n        string_to_sign_builder.append(\"\\n{resource}\".format(resource=resource))\n\n        string_to_sign = \"\".join(string_to_sign_builder)\n\n        signer = hmac.new(b64decode(api_key), string_to_sign.encode(\"utf-8\"), sha256)\n        signature = b64encode(signer.digest()).decode(\"utf-8\")\n\n        authorization = \"TSA {customer_id}:{signature}\".format(\n            customer_id=customer_id,\n            signature=signature)\n\n        headers = {\n            \"Authorization\": authorization,\n            \"Date\": date_rfc2616,\n            \"Content-Type\": content_type,\n            \"x-ts-auth-method\": auth_method,\n            \"x-ts-nonce\": nonce\n        }\n\n        if user_agent:\n            headers['User-Agent'] = user_agent\n\n        return headers", "code_tokens": ["def", "generate_telesign_headers", "(", "customer_id", ",", "api_key", ",", "method_name", ",", "resource", ",", "url_encoded_fields", ",", "date_rfc2616", "=", "None", ",", "nonce", "=", "None", ",", "user_agent", "=", "None", ",", "content_type", "=", "None", ")", ":", "if", "date_rfc2616", "is", "None", ":", "date_rfc2616", "=", "formatdate", "(", "usegmt", "=", "True", ")", "if", "nonce", "is", "None", ":", "nonce", "=", "str", "(", "uuid", ".", "uuid4", "(", ")", ")", "if", "not", "content_type", ":", "content_type", "=", "\"application/x-www-form-urlencoded\"", "if", "method_name", "in", "(", "\"POST\"", ",", "\"PUT\"", ")", "else", "\"\"", "auth_method", "=", "\"HMAC-SHA256\"", "string_to_sign_builder", "=", "[", "\"{method}\"", ".", "format", "(", "method", "=", "method_name", ")", "]", "string_to_sign_builder", ".", "append", "(", "\"\\n{content_type}\"", ".", "format", "(", "content_type", "=", "content_type", ")", ")", "string_to_sign_builder", ".", "append", "(", "\"\\n{date}\"", ".", "format", "(", "date", "=", "date_rfc2616", ")", ")", "string_to_sign_builder", ".", "append", "(", "\"\\nx-ts-auth-method:{auth_method}\"", ".", "format", "(", "auth_method", "=", "auth_method", ")", ")", "string_to_sign_builder", ".", "append", "(", "\"\\nx-ts-nonce:{nonce}\"", ".", "format", "(", "nonce", "=", "nonce", ")", ")", "if", "content_type", "and", "url_encoded_fields", ":", "string_to_sign_builder", ".", "append", "(", "\"\\n{fields}\"", ".", "format", "(", "fields", "=", "url_encoded_fields", ")", ")", "string_to_sign_builder", ".", "append", "(", "\"\\n{resource}\"", ".", "format", "(", "resource", "=", "resource", ")", ")", "string_to_sign", "=", "\"\"", ".", "join", "(", "string_to_sign_builder", ")", "signer", "=", "hmac", ".", "new", "(", "b64decode", "(", "api_key", ")", ",", "string_to_sign", ".", "encode", "(", "\"utf-8\"", ")", ",", "sha256", ")", "signature", "=", "b64encode", "(", "signer", ".", "digest", "(", ")", ")", ".", "decode", "(", "\"utf-8\"", ")", "authorization", "=", "\"TSA {customer_id}:{signature}\"", ".", "format", "(", "customer_id", "=", "customer_id", ",", "signature", "=", "signature", ")", "headers", "=", "{", "\"Authorization\"", ":", "authorization", ",", "\"Date\"", ":", "date_rfc2616", ",", "\"Content-Type\"", ":", "content_type", ",", "\"x-ts-auth-method\"", ":", "auth_method", ",", "\"x-ts-nonce\"", ":", "nonce", "}", "if", "user_agent", ":", "headers", "[", "'User-Agent'", "]", "=", "user_agent", "return", "headers"], "docstring": "Generates the TeleSign REST API headers used to authenticate requests.\n\n        Creates the canonicalized string_to_sign and generates the HMAC signature. This is used to authenticate requests\n        against the TeleSign REST API.\n\n        See https://developer.telesign.com/docs/authentication for detailed API documentation.\n\n        :param customer_id: Your account customer_id.\n        :param api_key: Your account api_key.\n        :param method_name: The HTTP method name of the request as a upper case string, should be one of 'POST', 'GET',\n            'PUT' or 'DELETE'.\n        :param resource: The partial resource URI to perform the request against, as a string.\n        :param url_encoded_fields: HTTP body parameters to perform the HTTP request with, must be a urlencoded string.\n        :param date_rfc2616: The date and time of the request formatted in rfc 2616, as a string.\n        :param nonce: A unique cryptographic nonce for the request, as a string.\n        :param user_agent: (optional) User Agent associated with the request, as a string.\n        :param content_type: (optional) ContentType of the request, as a string.\n        :return: The TeleSign authentication headers.", "docstring_tokens": ["Generates", "the", "TeleSign", "REST", "API", "headers", "used", "to", "authenticate", "requests", "."], "sha": "f0c2e4373dc8d685e1a7d65444b5e55955c340cb", "url": "https://github.com/TeleSign/python_telesign/blob/f0c2e4373dc8d685e1a7d65444b5e55955c340cb/telesign/rest.py#L77-L152", "partition": "train", "idx": 63485}
{"repo": "emilydolson/avida-spatial-tools", "path": "avidaspatial/environment_file_components.py", "func_name": "calcTightAnchors", "original_string": "def calcTightAnchors(args, d, patches):\n    \"\"\"\n    Recursively generates the number of anchor points specified in the\n    patches argument, such that all patches are d cells away\n    from their nearest neighbors.\n    \"\"\"\n    centerPoint = (int(args.worldSize/2), int(args.worldSize/2))\n    anchors = []\n    if patches == 0:\n        pass\n\n    elif patches == 1:\n        anchors.append(centerPoint)\n\n    elif patches % 2 == 0:\n        dsout = int((patches-2)//2) + 1\n        add_anchors(centerPoint, d, dsout, anchors, True)\n        if d != 0:\n            anchors = list(set(anchors))\n        anchors.sort()\n        if dsout != 1:\n            return (anchors +\n                    calcTightAnchors(args, d, patches-2)\n                    )[:patches*patches]\n            # to cut off the extras in the case where d=0\n\n    else:\n        # Note - an odd number of args.patchesPerSide requires that there be\n        # a patch at the centerpoint\n        dsout = int((patches-1)//2)\n        add_anchors(centerPoint, d, dsout, anchors, False)\n        if dsout != 1:\n            return anchors + calcTightAnchors(d, patches-2)\n\n    return anchors", "language": "python", "code": "def calcTightAnchors(args, d, patches):\n    \"\"\"\n    Recursively generates the number of anchor points specified in the\n    patches argument, such that all patches are d cells away\n    from their nearest neighbors.\n    \"\"\"\n    centerPoint = (int(args.worldSize/2), int(args.worldSize/2))\n    anchors = []\n    if patches == 0:\n        pass\n\n    elif patches == 1:\n        anchors.append(centerPoint)\n\n    elif patches % 2 == 0:\n        dsout = int((patches-2)//2) + 1\n        add_anchors(centerPoint, d, dsout, anchors, True)\n        if d != 0:\n            anchors = list(set(anchors))\n        anchors.sort()\n        if dsout != 1:\n            return (anchors +\n                    calcTightAnchors(args, d, patches-2)\n                    )[:patches*patches]\n            # to cut off the extras in the case where d=0\n\n    else:\n        # Note - an odd number of args.patchesPerSide requires that there be\n        # a patch at the centerpoint\n        dsout = int((patches-1)//2)\n        add_anchors(centerPoint, d, dsout, anchors, False)\n        if dsout != 1:\n            return anchors + calcTightAnchors(d, patches-2)\n\n    return anchors", "code_tokens": ["def", "calcTightAnchors", "(", "args", ",", "d", ",", "patches", ")", ":", "centerPoint", "=", "(", "int", "(", "args", ".", "worldSize", "/", "2", ")", ",", "int", "(", "args", ".", "worldSize", "/", "2", ")", ")", "anchors", "=", "[", "]", "if", "patches", "==", "0", ":", "pass", "elif", "patches", "==", "1", ":", "anchors", ".", "append", "(", "centerPoint", ")", "elif", "patches", "%", "2", "==", "0", ":", "dsout", "=", "int", "(", "(", "patches", "-", "2", ")", "//", "2", ")", "+", "1", "add_anchors", "(", "centerPoint", ",", "d", ",", "dsout", ",", "anchors", ",", "True", ")", "if", "d", "!=", "0", ":", "anchors", "=", "list", "(", "set", "(", "anchors", ")", ")", "anchors", ".", "sort", "(", ")", "if", "dsout", "!=", "1", ":", "return", "(", "anchors", "+", "calcTightAnchors", "(", "args", ",", "d", ",", "patches", "-", "2", ")", ")", "[", ":", "patches", "*", "patches", "]", "# to cut off the extras in the case where d=0", "else", ":", "# Note - an odd number of args.patchesPerSide requires that there be", "# a patch at the centerpoint", "dsout", "=", "int", "(", "(", "patches", "-", "1", ")", "//", "2", ")", "add_anchors", "(", "centerPoint", ",", "d", ",", "dsout", ",", "anchors", ",", "False", ")", "if", "dsout", "!=", "1", ":", "return", "anchors", "+", "calcTightAnchors", "(", "d", ",", "patches", "-", "2", ")", "return", "anchors"], "docstring": "Recursively generates the number of anchor points specified in the\n    patches argument, such that all patches are d cells away\n    from their nearest neighbors.", "docstring_tokens": ["Recursively", "generates", "the", "number", "of", "anchor", "points", "specified", "in", "the", "patches", "argument", "such", "that", "all", "patches", "are", "d", "cells", "away", "from", "their", "nearest", "neighbors", "."], "sha": "7beb0166ccefad5fa722215b030ac2a53d62b59e", "url": "https://github.com/emilydolson/avida-spatial-tools/blob/7beb0166ccefad5fa722215b030ac2a53d62b59e/avidaspatial/environment_file_components.py#L133-L167", "partition": "train", "idx": 90051}
{"repo": "exosite-labs/pyonep", "path": "pyonep/onep.py", "func_name": "OnepV1.drop", "original_string": "def drop(self, auth, resource, defer=False):\n        \"\"\" Deletes the specified resource.\n\n        Args:\n            auth: <cik>\n            resource: <ResourceID>\n        \"\"\"\n        return self._call('drop', auth, [resource], defer)", "language": "python", "code": "def drop(self, auth, resource, defer=False):\n        \"\"\" Deletes the specified resource.\n\n        Args:\n            auth: <cik>\n            resource: <ResourceID>\n        \"\"\"\n        return self._call('drop', auth, [resource], defer)", "code_tokens": ["def", "drop", "(", "self", ",", "auth", ",", "resource", ",", "defer", "=", "False", ")", ":", "return", "self", ".", "_call", "(", "'drop'", ",", "auth", ",", "[", "resource", "]", ",", "defer", ")"], "docstring": "Deletes the specified resource.\n\n        Args:\n            auth: <cik>\n            resource: <ResourceID>", "docstring_tokens": ["Deletes", "the", "specified", "resource", "."], "sha": "d27b621b00688a542e0adcc01f3e3354c05238a1", "url": "https://github.com/exosite-labs/pyonep/blob/d27b621b00688a542e0adcc01f3e3354c05238a1/pyonep/onep.py#L310-L317", "partition": "train", "idx": 7310}
{"repo": "binux/pyspider", "path": "pyspider/scheduler/scheduler.py", "func_name": "Scheduler._try_dump_cnt", "original_string": "def _try_dump_cnt(self):\n        '''Dump counters every 60 seconds'''\n        now = time.time()\n        if now - self._last_dump_cnt > 60:\n            self._last_dump_cnt = now\n            self._dump_cnt()\n            self._print_counter_log()", "language": "python", "code": "def _try_dump_cnt(self):\n        '''Dump counters every 60 seconds'''\n        now = time.time()\n        if now - self._last_dump_cnt > 60:\n            self._last_dump_cnt = now\n            self._dump_cnt()\n            self._print_counter_log()", "code_tokens": ["def", "_try_dump_cnt", "(", "self", ")", ":", "now", "=", "time", ".", "time", "(", ")", "if", "now", "-", "self", ".", "_last_dump_cnt", ">", "60", ":", "self", ".", "_last_dump_cnt", "=", "now", "self", ".", "_dump_cnt", "(", ")", "self", ".", "_print_counter_log", "(", ")"], "docstring": "Dump counters every 60 seconds", "docstring_tokens": ["Dump", "counters", "every", "60", "seconds"], "sha": "3fccfabe2b057b7a56d4a4c79dc0dd6cd2239fe9", "url": "https://github.com/binux/pyspider/blob/3fccfabe2b057b7a56d4a4c79dc0dd6cd2239fe9/pyspider/scheduler/scheduler.py#L622-L628", "partition": "train", "idx": 169705}
{"repo": "TomasTomecek/sen", "path": "sen/tui/ui.py", "func_name": "UI.display_buffer", "original_string": "def display_buffer(self, buffer, redraw=True):\n        \"\"\"\n        display provided buffer\n\n        :param buffer: Buffer\n        :return:\n        \"\"\"\n        logger.debug(\"display buffer %r\", buffer)\n        self.buffer_movement_history.append(buffer)\n        self.current_buffer = buffer\n        self._set_main_widget(buffer.widget, redraw=redraw)", "language": "python", "code": "def display_buffer(self, buffer, redraw=True):\n        \"\"\"\n        display provided buffer\n\n        :param buffer: Buffer\n        :return:\n        \"\"\"\n        logger.debug(\"display buffer %r\", buffer)\n        self.buffer_movement_history.append(buffer)\n        self.current_buffer = buffer\n        self._set_main_widget(buffer.widget, redraw=redraw)", "code_tokens": ["def", "display_buffer", "(", "self", ",", "buffer", ",", "redraw", "=", "True", ")", ":", "logger", ".", "debug", "(", "\"display buffer %r\"", ",", "buffer", ")", "self", ".", "buffer_movement_history", ".", "append", "(", "buffer", ")", "self", ".", "current_buffer", "=", "buffer", "self", ".", "_set_main_widget", "(", "buffer", ".", "widget", ",", "redraw", "=", "redraw", ")"], "docstring": "display provided buffer\n\n        :param buffer: Buffer\n        :return:", "docstring_tokens": ["display", "provided", "buffer"], "sha": "239b4868125814e8bf5527708119fc08b35f6cc0", "url": "https://github.com/TomasTomecek/sen/blob/239b4868125814e8bf5527708119fc08b35f6cc0/sen/tui/ui.py#L106-L116", "partition": "train", "idx": 208554}
