{"input": "Writes a Boolean to the stream . [CODESPLIT] def writeBoolean ( self , n ) : t = TYPE_BOOL_TRUE if n is False : t = TYPE_BOOL_FALSE self . stream . write ( t )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns system clipboard contents . [CODESPLIT] def paste ( xsel = False ) : selection = \"primary\" if xsel else \"clipboard\" try : return subprocess . Popen ( [ \"xclip\" , \"-selection\" , selection , \"-o\" ] , stdout = subprocess . PIPE ) . communicate ( ) [ 0 ] . decode ( \"utf-8\" ) except OSError as why : raise XclipNotFound", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty print a dict as a JSON with colors if pygments is present . [CODESPLIT] def _format_json ( data , theme ) : output = json . dumps ( data , indent = 2 , sort_keys = True ) if pygments and sys . stdout . isatty ( ) : style = get_style_by_name ( theme ) formatter = Terminal256Formatter ( style = style ) return pygments . highlight ( output , JsonLexer ( ) , formatter ) return output", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a absolute path in the file system . [CODESPLIT] def create_path ( path ) : import os if not os . path . exists ( path ) : os . makedirs ( path )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert an object to either a scalar or a row or column vector . [CODESPLIT] def _vector_or_scalar ( x , type = 'row' ) : if isinstance ( x , ( list , tuple ) ) : x = np . array ( x ) if isinstance ( x , np . ndarray ) : assert x . ndim == 1 if type == 'column' : x = x [ : , None ] return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a property of the experiment by name . [CODESPLIT] def experiment_property ( prop ) : exp = experiment ( session ) p = getattr ( exp , prop ) return success_response ( field = prop , data = p , request_type = prop )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return ( first channel data sample frequency sample width ) from a . wav file . [CODESPLIT] def data_from_file ( file ) : fp = wave . open ( file , 'r' ) data = fp . readframes ( fp . getnframes ( ) ) channels = fp . getnchannels ( ) freq = fp . getframerate ( ) bits = fp . getsampwidth ( ) # Unpack bytes -- warning currently only tested with 16 bit wavefiles. 32 # bit not supported. data = struct . unpack ( ( '%sh' % fp . getnframes ( ) ) * channels , data ) # Only use first channel channel1 = [ ] n = 0 for d in data : if n % channels == 0 : channel1 . append ( d ) n += 1 fp . close ( ) return ( channel1 , freq , bits )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a range of source numbers as well as a dictionary containing the numbers of each source returns a dictionary containing tuples of the start and end index for each source variable type . [CODESPLIT] def source_range ( start , end , nr_var_dict ) : return OrderedDict ( ( k , e - s ) for k , ( s , e ) in source_range_tuple ( start , end , nr_var_dict ) . iteritems ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return time in milliseconds from start_time [CODESPLIT] def timespan ( start_time ) : timespan = datetime . datetime . now ( ) - start_time timespan_ms = timespan . total_seconds ( ) * 1000 return timespan_ms", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list with no repeated elements . [CODESPLIT] def get_uniques ( l ) : result = [ ] for i in l : if i not in result : result . append ( i ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap interpolate_1d for deprecated interp . [CODESPLIT] def interp ( x , xp , * args , * * kwargs ) : return interpolate_1d ( x , xp , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Serializes a numpy array to a compressed base64 string [CODESPLIT] def _array2cstr ( arr ) : out = StringIO ( ) np . save ( out , arr ) return b64encode ( out . getvalue ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the percentile of a list of values . [CODESPLIT] def percentile ( values , k ) : if not values : return None values . sort ( ) index = ( len ( values ) * ( float ( k ) / 100 ) ) - 1 return values [ int ( math . ceil ( index ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "String hash ( djb2 ) with consistency between py2 / py3 and persistency between runs ( unlike hash ) . [CODESPLIT] def _string_hash ( s ) : h = 5381 for c in s : h = h * 33 + ord ( c ) return h", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transforation matrix from rotation matrix and translation vector . [CODESPLIT] def transform_from_rot_trans ( R , t ) : R = R . reshape ( 3 , 3 ) t = t . reshape ( 3 , 1 ) return np . vstack ( ( np . hstack ( [ R , t ] ) , [ 0 , 0 , 0 , 1 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Encode a python boolean ( True / False ) . [CODESPLIT] def _encode_bool ( name , value , dummy0 , dummy1 ) : return b\"\\x08\" + name + ( value and b\"\\x01\" or b\"\\x00\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Project points into 3d from 2d points . [CODESPLIT] def transform_to_3d ( points , normal , z = 0 ) : d = np . cross ( normal , ( 0 , 0 , 1 ) ) M = rotation_matrix ( d ) transformed_points = M . dot ( points . T ) . T + z return transformed_points", "target": 1, "target_options": ["no_match", "match"]}
{"input": "HTTP response for forbidden access ( status code 403 ) [CODESPLIT] def HttpResponse403 ( request , template = KEY_AUTH_403_TEMPLATE , content = KEY_AUTH_403_CONTENT , content_type = KEY_AUTH_403_CONTENT_TYPE ) : return AccessFailedResponse ( request , template , content , content_type , status = 403 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": return : list (( option value ) ... ) pairs of all items in the given section [CODESPLIT] def items ( self , section_name ) : return [ ( k , v ) for k , v in super ( GitConfigParser , self ) . items ( section_name ) if k != '__name__' ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the magnitude of a vector . [CODESPLIT] def mag ( z ) : if isinstance ( z [ 0 ] , np . ndarray ) : return np . array ( list ( map ( np . linalg . norm , z ) ) ) else : return np . linalg . norm ( z )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a ConfigParser to a dictionary . [CODESPLIT] def config_parser_to_dict ( config_parser ) : response = { } for section in config_parser . sections ( ) : for option in config_parser . options ( section ) : response . setdefault ( section , { } ) [ option ] = config_parser . get ( section , option ) return response", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handle the + operator . [CODESPLIT] def __add__ ( self , other ) : return self . _handle_type ( other ) ( self . value + other . value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Connect to MySQL with retries . [CODESPLIT] def connect_mysql ( host , port , user , password , database ) : return pymysql . connect ( host = host , port = port , user = user , passwd = password , db = database )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a connected Bitbucket session [CODESPLIT] def connect ( url , username , password ) : bb_session = stashy . connect ( url , username , password ) logger . info ( 'Connected to: %s as %s' , url , username ) return bb_session", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a blank row with only an index value to self . df . This is done inplace . [CODESPLIT] def add_blank_row ( self , label ) : col_labels = self . df . columns blank_item = pd . Series ( { } , index = col_labels , name = label ) # use .loc to add in place (append won't do that) self . df . loc [ blank_item . name ] = blank_item return self . df", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Stop and remove the container if it exists . [CODESPLIT] def teardown ( self ) : while self . _http_clients : self . _http_clients . pop ( ) . close ( ) if self . created : self . halt ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Put curly brackets round an indented text [CODESPLIT] def dumped ( text , level , indent = 2 ) : return indented ( \"{\\n%s\\n}\" % indented ( text , level + 1 , indent ) or \"None\" , level , indent ) + \"\\n\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a context manager that ensures code runs within action s context . [CODESPLIT] def context ( self ) : parent = _ACTION_CONTEXT . set ( self ) try : yield self finally : _ACTION_CONTEXT . reset ( parent )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format a Python object into a pretty - printed representation . [CODESPLIT] def pformat ( object , indent = 1 , width = 80 , depth = None ) : return PrettyPrinter ( indent = indent , width = width , depth = depth ) . pformat ( object )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Temporarily replace sys . argv with current arguments [CODESPLIT] def replace_sys_args ( new_args ) : # Replace sys.argv arguments # for module import old_args = sys . argv sys . argv = new_args try : yield finally : sys . argv = old_args", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a object and produces a dict - like representation [CODESPLIT] def serialize ( obj ) : if isinstance ( obj , list ) : return [ serialize ( o ) for o in obj ] return GenericSerializer ( ModelProviderImpl ( ) ) . serialize ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Advances to next line . [CODESPLIT] def advance_one_line ( self ) : current_line = self . _current_token . line_number while current_line == self . _current_token . line_number : self . _current_token = ConfigParser . Token ( * next ( self . _token_generator ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "given a root directory for the swagger statics and a swagger json path return back a swagger html designed to use those values . [CODESPLIT] def generate_swagger_html ( swagger_static_root , swagger_json_url ) : tmpl = _get_template ( \"swagger.html\" ) return tmpl . render ( swagger_root = swagger_static_root , swagger_json_url = swagger_json_url )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Step over the next statement [CODESPLIT] def do_next ( self , args ) : self . _do_print_from_last_cmd = True self . _interp . step_over ( ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If the number of columns matches we can concatenate two LabeldMatrices with the + operator . [CODESPLIT] def __add__ ( self , other ) : assert self . matrix . shape [ 1 ] == other . matrix . shape [ 1 ] return LabeledMatrix ( np . concatenate ( [ self . matrix , other . matrix ] , axis = 0 ) , self . labels )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Interpolated flux at a given wavelength ( calls np . interp ) . [CODESPLIT] def get_line_flux ( line_wave , wave , flux , * * kwargs ) : return np . interp ( line_wave , wave , flux , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sends a message to websocket . [CODESPLIT] def send ( message , request_context = None , binary = False ) : if binary : return uwsgi . websocket_send_binary ( message , request_context ) return uwsgi . websocket_send ( message , request_context )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Try to get a number out of a string and cast it . [CODESPLIT] def get_number ( s , cast = int ) : import string d = \"\" . join ( x for x in str ( s ) if x in string . digits ) return cast ( d )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "gets a horiztonal line [CODESPLIT] def get_hline ( ) : return Window ( width = LayoutDimension . exact ( 1 ) , height = LayoutDimension . exact ( 1 ) , content = FillControl ( '-' , token = Token . Line ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "parse cookies str to dict : param cookies : cookies str : type cookies : str : return : cookie dict : rtype : dict [CODESPLIT] def parse_cookies_str ( cookies ) : cookie_dict = { } for record in cookies . split ( \";\" ) : key , value = record . strip ( ) . split ( \"=\" , 1 ) cookie_dict [ key ] = value return cookie_dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a name in camelCase return in snake_case [CODESPLIT] def to_snake_case ( name ) : s1 = FIRST_CAP_REGEX . sub ( r'\\1_\\2' , name ) return ALL_CAP_REGEX . sub ( r'\\1_\\2' , s1 ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Populates an object s attributes using the provided dict [CODESPLIT] def populate_obj ( obj , attrs ) : for k , v in attrs . iteritems ( ) : setattr ( obj , k , v )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dictionary of words and word counts in a string . [CODESPLIT] def wordfreq ( text , is_filename = False ) : if is_filename : with open ( text ) as f : text = f . read ( ) freqs = { } for word in text . split ( ) : lword = word . lower ( ) freqs [ lword ] = freqs . get ( lword , 0 ) + 1 return freqs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Copy a file whole from input to output . [CODESPLIT] def copyFile ( input , output , replace = None ) : _found = findFile ( output ) if not _found or ( _found and replace ) : shutil . copy2 ( input , output )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Push a new value into heap . [CODESPLIT] def push ( h , x ) : h . push ( x ) up ( h , h . size ( ) - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Paste before cursor . [CODESPLIT] def yank ( event ) : event . current_buffer . paste_clipboard_data ( event . cli . clipboard . get_data ( ) , count = event . arg , paste_mode = PasteMode . EMACS )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert an image by applying a contour [CODESPLIT] def filter_contour ( imageFile , opFile ) : im = Image . open ( imageFile ) im1 = im . filter ( ImageFilter . CONTOUR ) im1 . save ( opFile )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Counts the word frequences in a list of sentences . [CODESPLIT] def count ( lines ) : words = [ w for l in lines for w in l . strip ( ) . split ( ) ] return Counter ( words )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "apply a function to all non - dict values in a dictionary [CODESPLIT] def dictapply ( d , fn ) : for k , v in d . items ( ) : if isinstance ( v , dict ) : v = dictapply ( v , fn ) else : d [ k ] = fn ( v ) return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return count of replicas of given partition . [CODESPLIT] def count_replica ( self , partition ) : return sum ( 1 for b in partition . replicas if b in self . brokers )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get range for parameters for examples or false branching . [CODESPLIT] def visit_Name ( self , node ) : return self . add ( node , self . result [ node . id ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create directory with template for topic of the current environment [CODESPLIT] def mkdir ( dir , enter ) : if not os . path . exists ( dir ) : os . makedirs ( dir )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rotate a 3D vector using quaternion algebra . [CODESPLIT] def qrot ( vector , quaternion ) : t = 2 * np . cross ( quaternion [ 1 : ] , vector ) v_rot = vector + quaternion [ 0 ] * t + np . cross ( quaternion [ 1 : ] , t ) return v_rot", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like netCDF4 . chartostring but faster and more flexible . [CODESPLIT] def _numpy_char_to_bytes ( arr ) : # based on: http://stackoverflow.com/a/10984878/809705 arr = np . array ( arr , copy = False , order = 'C' ) dtype = 'S' + str ( arr . shape [ - 1 ] ) return arr . view ( dtype ) . reshape ( arr . shape [ : - 1 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a csv and returns a List of Dicts with keys given by header row . [CODESPLIT] def csv_to_dicts ( file , header = None ) : with open ( file ) as csvfile : return [ row for row in csv . DictReader ( csvfile , fieldnames = header ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a list of coords for 3 points Compute the area of this triangle . [CODESPLIT] def get_tri_area ( pts ) : a , b , c = pts [ 0 ] , pts [ 1 ] , pts [ 2 ] v1 = np . array ( b ) - np . array ( a ) v2 = np . array ( c ) - np . array ( a ) area_tri = abs ( sp . linalg . norm ( sp . cross ( v1 , v2 ) ) / 2 ) return area_tri", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a n + 1 dim one - hot array from n dim int - categorical array . [CODESPLIT] def one_hot ( x , size , dtype = np . float32 ) : return np . array ( x [ ... , np . newaxis ] == np . arange ( size ) , dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Round a number to a precision [CODESPLIT] def round_to_int ( number , precision ) : precision = int ( precision ) rounded = ( int ( number ) + precision / 2 ) // precision * precision return rounded", "target": 1, "target_options": ["no_match", "match"]}
{"input": "helpful in situations where browser / app may recognize Unicode encoding in the \\ u0b8e type syntax but not actual unicode glyph / code - point [CODESPLIT] def to_unicode_repr ( _letter ) : # Python 2-3 compatible return u\"u'\" + u\"\" . join ( [ u\"\\\\u%04x\" % ord ( l ) for l in _letter ] ) + u\"'\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a absolute path in the file system . [CODESPLIT] def create_path ( path ) : import os if not os . path . exists ( path ) : os . makedirs ( path )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Python 3 input () / Python 2 raw_input () [CODESPLIT] def string_input ( prompt = '' ) : v = sys . version [ 0 ] if v == '3' : return input ( prompt ) else : return raw_input ( prompt )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a ctypes double pointer array to a numpy array . [CODESPLIT] def cfloat64_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_double ) ) : return np . fromiter ( cptr , dtype = np . float64 , count = length ) else : raise RuntimeError ( 'Expected double pointer' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prompts the user for yes or no . [CODESPLIT] def yn_prompt ( msg , default = True ) : ret = custom_prompt ( msg , [ \"y\" , \"n\" ] , \"y\" if default else \"n\" ) if ret == \"y\" : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "launch layouts display [CODESPLIT] def _display ( self , layout ) : print ( file = self . out ) TextWriter ( ) . format ( layout , self . out )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": API : public [CODESPLIT] def assert_list ( self , putative_list , expected_type = string_types , key_arg = None ) : return assert_list ( putative_list , expected_type , key_arg = key_arg , raise_type = lambda msg : TargetDefinitionException ( self , msg ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a random ( i . e . unique ) string identifier [CODESPLIT] def _get_random_id ( ) : symbols = string . ascii_uppercase + string . ascii_lowercase + string . digits return '' . join ( random . choice ( symbols ) for _ in range ( 15 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a single list from an asynchronous sequence . [CODESPLIT] async def list ( source ) : result = [ ] async with streamcontext ( source ) as streamer : async for item in streamer : result . append ( item ) yield result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print a dictionary of attributes in the DOT format [CODESPLIT] def _attrprint ( d , delimiter = ', ' ) : return delimiter . join ( ( '\"%s\"=\"%s\"' % item ) for item in sorted ( d . items ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the next scheduled time by creating a crontab object with a cron string [CODESPLIT] def get_next_scheduled_time ( cron_string ) : itr = croniter . croniter ( cron_string , datetime . utcnow ( ) ) return itr . get_next ( datetime )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r A function to support exiting from exit hooks . [CODESPLIT] def exit ( exit_code = 0 ) : core . processExitHooks ( ) if state . isExitHooked and not hasattr ( sys , 'exitfunc' ) : # The function is called from the exit hook sys . stderr . flush ( ) sys . stdout . flush ( ) os . _exit ( exit_code ) #pylint: disable=W0212 sys . exit ( exit_code )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the dot product of the given vectors . [CODESPLIT] def dot_product ( self , other ) : return self . x * other . x + self . y * other . y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If soft_exit is True we use sys . exit () ; otherwise os_exit will be used to end the process . [CODESPLIT] def reloader_thread ( softexit = False ) : while RUN_RELOADER : if code_changed ( ) : # force reload if softexit : sys . exit ( 3 ) else : os . _exit ( 3 ) time . sleep ( 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts list to string with comma separated values . For string is no - op . [CODESPLIT] def list_to_csv ( value ) : if isinstance ( value , ( list , tuple , set ) ) : value = \",\" . join ( value ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterative mean . [CODESPLIT] def average ( iterator ) : count = 0 total = 0 for num in iterator : count += 1 total += num return float ( total ) / count", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a ctypes int pointer array to a numpy array . [CODESPLIT] def cint32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int32 ) ) : return np . fromiter ( cptr , dtype = np . int32 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get all instances matching a tag . [CODESPLIT] def _aws_get_instance_by_tag ( region , name , tag , raw ) : client = boto3 . session . Session ( ) . client ( 'ec2' , region ) matching_reservations = client . describe_instances ( Filters = [ { 'Name' : tag , 'Values' : [ name ] } ] ) . get ( 'Reservations' , [ ] ) instances = [ ] [ [ instances . append ( _aws_instance_from_dict ( region , instance , raw ) ) # pylint: disable=expression-not-assigned for instance in reservation . get ( 'Instances' ) ] for reservation in matching_reservations if reservation ] return instances", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialize Log Analytics data client for use with CLI . [CODESPLIT] def loganalytics_data_plane_client ( cli_ctx , _ ) : from . vendored_sdks . loganalytics import LogAnalyticsDataClient from azure . cli . core . _profile import Profile profile = Profile ( cli_ctx = cli_ctx ) cred , _ , _ = profile . get_login_credentials ( resource = \"https://api.loganalytics.io\" ) return LogAnalyticsDataClient ( cred )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a ctypes float pointer array to a numpy array . [CODESPLIT] def cfloat32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_float ) ) : return np . fromiter ( cptr , dtype = np . float32 , count = length ) else : raise RuntimeError ( 'Expected float pointer' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts text that may be camelcased into an underscored format [CODESPLIT] def underscore ( text ) : return UNDERSCORE [ 1 ] . sub ( r'\\1_\\2' , UNDERSCORE [ 0 ] . sub ( r'\\1_\\2' , text ) ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a ctypes int pointer array to a numpy array . [CODESPLIT] def cint8_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int8 ) ) : return np . fromiter ( cptr , dtype = np . int8 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns an built - in stop - list for the language as a set of words . [CODESPLIT] def get_stoplist ( language ) : file_path = os . path . join ( \"stoplists\" , \"%s.txt\" % language ) try : stopwords = pkgutil . get_data ( \"justext\" , file_path ) except IOError : raise ValueError ( \"Stoplist for language '%s' is missing. \" \"Please use function 'get_stoplists' for complete list of stoplists \" \"and feel free to contribute by your own stoplist.\" % language ) return frozenset ( w . decode ( \"utf8\" ) . lower ( ) for w in stopwords . splitlines ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "attempt to draw str on screen and ignore errors if they occur [CODESPLIT] def add_str ( window , line_num , str ) : try : window . addstr ( line_num , 0 , str ) except curses . error : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns all rows from a cursor as a dict ( rather than a headerless table ) [CODESPLIT] def dictfetchall ( cursor ) : desc = cursor . description return [ dict ( zip ( [ col [ 0 ] for col in desc ] , row ) ) for row in cursor . fetchall ( ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Internal function to read an XML file [CODESPLIT] def xmltreefromfile ( filename ) : try : return ElementTree . parse ( filename , ElementTree . XMLParser ( collect_ids = False ) ) except TypeError : return ElementTree . parse ( filename , ElementTree . XMLParser ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all rows from a cursor as a dict . [CODESPLIT] def _dictfetchall ( self , cursor ) : columns = [ col [ 0 ] for col in cursor . description ] return [ dict ( zip ( columns , row ) ) for row in cursor . fetchall ( ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Beta distirbution probability density function . [CODESPLIT] def beta_pdf ( x , a , b ) : bc = 1 / beta ( a , b ) fc = x ** ( a - 1 ) sc = ( 1 - x ) ** ( b - 1 ) return bc * fc * sc", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove unwanted results from queryset [CODESPLIT] def filter_out ( queryset , setting_name ) : kwargs = helpers . get_settings ( ) . get ( setting_name , { } ) . get ( 'FILTER_OUT' , { } ) queryset = queryset . exclude ( * * kwargs ) return queryset", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Integer to two bytes [CODESPLIT] def intToBin ( i ) : # divide in two parts (bytes) i1 = i % 256 i2 = int ( i / 256 ) # make string (little endian) return i . to_bytes ( 2 , byteorder = 'little' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is an object iterable like a list ( and not a string ) ? [CODESPLIT] def listlike ( obj ) : return hasattr ( obj , \"__iter__\" ) and not issubclass ( type ( obj ) , str ) and not issubclass ( type ( obj ) , unicode )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Probability density function ( normal distribution ) [CODESPLIT] def pdf ( x , mu , std ) : return ( 1.0 / ( std * sqrt ( 2 * pi ) ) ) * np . exp ( - ( x - mu ) ** 2 / ( 2 * std ** 2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a C array using the given string . [CODESPLIT] def bytes_to_c_array ( data ) : chars = [ \"'{}'\" . format ( encode_escape ( i ) ) for i in decode_escape ( data ) ] return ', ' . join ( chars ) + ', 0'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calcuate mean datetime from datetime list [CODESPLIT] def mean_date ( dt_list ) : dt_list_sort = sorted ( dt_list ) dt_list_sort_rel = [ dt - dt_list_sort [ 0 ] for dt in dt_list_sort ] avg_timedelta = sum ( dt_list_sort_rel , timedelta ( ) ) / len ( dt_list_sort_rel ) return dt_list_sort [ 0 ] + avg_timedelta", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rotates an image by deg degrees [CODESPLIT] def rotate_img ( im , deg , mode = cv2 . BORDER_CONSTANT , interpolation = cv2 . INTER_AREA ) : r , c ,  * _ = im . shape M = cv2 . getRotationMatrix2D ( ( c // 2 , r // 2 ) , deg , 1 ) return cv2 . warpAffine ( im , M , ( c , r ) , borderMode = mode , flags = cv2 . WARP_FILL_OUTLIERS + interpolation )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates the cosine similarity between this vector and another vector . [CODESPLIT] def similarity ( self , other ) : if self . magnitude == 0 or other . magnitude == 0 : return 0 return self . dot ( other ) / self . magnitude", "target": 1, "target_options": ["no_match", "match"]}
{"input": "cv2 Image of current window screen [CODESPLIT] def screen_cv2 ( self ) : pil_image = self . screen . convert ( 'RGB' ) cv2_image = np . array ( pil_image ) pil_image . close ( ) # Convert RGB to BGR \n cv2_image = cv2_image [ : , : , : : - 1 ] return cv2_image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "consider the distance between two mapPoints ignoring all terrain pathing issues [CODESPLIT] def direct2dDistance ( self , point ) : if not isinstance ( point , MapPoint ) : return 0.0 return ( ( self . x - point . x ) ** 2 + ( self . y - point . y ) ** 2 ) ** ( 0.5 ) # simple distance formula", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get unique constraints info [CODESPLIT] def _model_unique ( ins ) : unique = [ ] for t in ins . tables : for c in t . constraints : if isinstance ( c , UniqueConstraint ) : unique . append ( tuple ( col . key for col in c . columns ) ) return unique", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Integer dots per inch for the width of this image . Defaults to 72 when not present in the file as is often the case . [CODESPLIT] def horz_dpi ( self ) : pHYs = self . _chunks . pHYs if pHYs is None : return 72 return self . _dpi ( pHYs . units_specifier , pHYs . horz_px_per_unit )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "calculates a rough guess of runtime based on product of parameters [CODESPLIT] def estimate_complexity ( self , x , y , z , n ) : num_calculations = x * y * z * n run_time = num_calculations / 100000 # a 2014 PC does about 100k calcs in a second (guess based on prior logs) return self . show_time_as_short_string ( run_time )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Weeks start are fixes at Monday for now . [CODESPLIT] def weekly ( date = datetime . date . today ( ) ) : return date - datetime . timedelta ( days = date . weekday ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "inverse hyperbolic sine transformation [CODESPLIT] def inh ( table ) : t = [ ] for i in table : t . append ( np . ndarray . tolist ( np . arcsinh ( i ) ) ) return t", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a generator which creates the next value in the range on demand [CODESPLIT] def daterange ( start , end , delta = timedelta ( days = 1 ) , lower = Interval . CLOSED , upper = Interval . OPEN ) : date_interval = Interval ( lower = lower , lower_value = start , upper_value = end , upper = upper ) current = start if start in date_interval else start + delta while current in date_interval : yield current current = current + delta", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coroutine called by MapAsync . It s wrapping the call of run_in_executor to run the synchronous function as thread [CODESPLIT] async def _thread_coro ( self , * args ) : return await self . _loop . run_in_executor ( self . _executor , self . _function , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a new datetime . datetime object with values that represent a start of a month . : param val : Date to ... : type val : datetime . datetime | datetime . date : rtype : datetime . datetime [CODESPLIT] def start_of_month ( val ) : if type ( val ) == date : val = datetime . fromordinal ( val . toordinal ( ) ) return start_of_day ( val ) . replace ( day = 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call an external binary and return its stdout . [CODESPLIT] def check_output ( args , env = None , sp = subprocess ) : log . debug ( 'calling %s with env %s' , args , env ) output = sp . check_output ( args = args , env = env ) log . debug ( 'output: %r' , output ) return output", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a datetime to a millisecond accuracy timestamp [CODESPLIT] def datetime_to_ms ( dt ) : seconds = calendar . timegm ( dt . utctimetuple ( ) ) return seconds * 1000 + int ( dt . microsecond / 1000 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retries function until it doesn t raise an EINTR error [CODESPLIT] def retry_on_signal ( function ) : while True : try : return function ( ) except EnvironmentError , e : if e . errno != errno . EINTR : raise", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert naive datetime to timezone - aware datetime [CODESPLIT] def datetime_to_timezone ( date , tz = \"UTC\" ) : if not date . tzinfo : date = date . replace ( tzinfo = timezone ( get_timezone ( ) ) ) return date . astimezone ( timezone ( tz ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run unit tests . [CODESPLIT] def test ( * args ) : subprocess . call ( [ \"py.test-2.7\" ] + list ( args ) ) subprocess . call ( [ \"py.test-3.4\" ] + list ( args ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts Timestamp to datetime . [CODESPLIT] def ToDatetime ( self ) : return datetime . utcfromtimestamp ( self . seconds + self . nanos / float ( _NANOS_PER_SECOND ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Localize a datetime object to local time . [CODESPLIT] def localize ( dt ) : if dt . tzinfo is UTC : return ( dt + LOCAL_UTC_OFFSET ) . replace ( tzinfo = None ) # No TZ info so not going to assume anything, return as-is. return dt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Callback for updating target progress [CODESPLIT] def percent_cb ( name , complete , total ) : logger . debug ( \"{}: {} transferred out of {}\" . format ( name , sizeof_fmt ( complete ) , sizeof_fmt ( total ) ) ) progress . update_target ( name , complete , total )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a : py : class : datetime . datetime instance representing the current time . [CODESPLIT] def now ( self ) : if self . use_utc : return datetime . datetime . utcnow ( ) else : return datetime . datetime . now ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform underscore separated string to pascal case [CODESPLIT] def to_pascal_case ( s ) : return re . sub ( r'(?!^)_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , s . capitalize ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a : py : class : datetime . datetime instance representing the current time . [CODESPLIT] def now ( self ) : if self . use_utc : return datetime . datetime . utcnow ( ) else : return datetime . datetime . now ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert native python datetime . date object to a format supported by the API [CODESPLIT] def _convert_date_to_dict ( field_date ) : return { DAY : field_date . day , MONTH : field_date . month , YEAR : field_date . year }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts Timestamp to datetime . [CODESPLIT] def ToDatetime ( self ) : return datetime . utcfromtimestamp ( self . seconds + self . nanos / float ( _NANOS_PER_SECOND ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts an ARRAY string stored in the database back into a Numpy array . [CODESPLIT] def convert_array ( array ) : out = io . BytesIO ( array ) out . seek ( 0 ) return np . load ( out )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse ISO8601 timestamps given by github API . [CODESPLIT] def parse_timestamp ( timestamp ) : dt = dateutil . parser . parse ( timestamp ) return dt . astimezone ( dateutil . tz . tzutc ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add an object to Javascript . [CODESPLIT] def add_to_js ( self , name , var ) : frame = self . page ( ) . mainFrame ( ) frame . addToJavaScriptWindowObject ( name , var )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a datetime object of a given timestamp ( in local tz ) . [CODESPLIT] def fromtimestamp ( cls , timestamp ) : d = cls . utcfromtimestamp ( timestamp ) return d . astimezone ( localtz ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A function to generate the latex representation of sympy expressions . [CODESPLIT] def print_latex ( o ) : if can_print_latex ( o ) : s = latex ( o , mode = 'plain' ) s = s . replace ( '\\\\dag' , '\\\\dagger' ) s = s . strip ( '$' ) return '$$%s$$' % s # Fallback to the string printer return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert numpy s datetime64 to datetime [CODESPLIT] def datetime64_to_datetime ( dt ) : dt64 = np . datetime64 ( dt ) ts = ( dt64 - np . datetime64 ( '1970-01-01T00:00:00' ) ) / np . timedelta64 ( 1 , 's' ) return datetime . datetime . utcfromtimestamp ( ts )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A buffer of a given value in a flat ( minibatch - indexed ) format [CODESPLIT] def batch_tensor ( self , name ) : if name in self . transition_tensors : return tensor_util . merge_first_two_dims ( self . transition_tensors [ name ] ) else : return self . rollout_tensors [ name ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A basic check of if the program is running in interactive mode [CODESPLIT] def isInteractive ( ) : if sys . stdout . isatty ( ) and os . name != 'nt' : #Hopefully everything but ms supports '\\r' try : import threading except ImportError : return False else : return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates symbolic link for either operating system . http : // stackoverflow . com / questions / 6260149 / os - symlink - support - in - windows [CODESPLIT] def create_symlink ( source , link_name ) : os_symlink = getattr ( os , \"symlink\" , None ) if isinstance ( os_symlink , collections . Callable ) : os_symlink ( source , link_name ) else : import ctypes csl = ctypes . windll . kernel32 . CreateSymbolicLinkW csl . argtypes = ( ctypes . c_wchar_p , ctypes . c_wchar_p , ctypes . c_uint32 ) csl . restype = ctypes . c_ubyte flags = 1 if os . path . isdir ( source ) else 0 if csl ( link_name , source , flags ) == 0 : raise ctypes . WinError ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator to explicitly mark functions that are exposed in a lib . [CODESPLIT] def export ( defn ) : globals ( ) [ defn . __name__ ] = defn __all__ . append ( defn . __name__ ) return defn", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Thin wrapper around ElementTree . parse [CODESPLIT] def parse ( source , remove_comments = True , * * kw ) : return ElementTree . parse ( source , SourceLineParser ( ) , * * kw )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Makes the passed decorators to support optional args . [CODESPLIT] def decorator ( func ) : def wrapper ( __decorated__ = None , * Args , * * KwArgs ) : if __decorated__ is None : # the decorator has some optional arguments. return lambda _func : func ( _func , * Args , * * KwArgs ) else : return func ( __decorated__ , * Args , * * KwArgs ) return wrap ( wrapper , func )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns a dictionary of arg_name : default_values for the input function [CODESPLIT] def get_default_args ( func ) : args , varargs , keywords , defaults = getargspec_no_self ( func ) return dict ( zip ( args [ - len ( defaults ) : ] , defaults ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function which returns an array with the Intervals boundaries . [CODESPLIT] def _interval_to_bound_points ( array ) : array_boundaries = np . array ( [ x . left for x in array ] ) array_boundaries = np . concatenate ( ( array_boundaries , np . array ( [ array [ - 1 ] . right ] ) ) ) return array_boundaries", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform actions before parent main window is closed [CODESPLIT] def closing_plugin ( self , cancelable = False ) : self . dialog_manager . close_all ( ) self . shell . exit_interpreter ( ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Local test . [CODESPLIT] def test ( ) : from spyder . utils . qthelpers import qapplication app = qapplication ( ) dlg = ProjectDialog ( None ) dlg . show ( ) sys . exit ( app . exec_ ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete a label by name . [CODESPLIT] def del_label ( self , name ) : labels_tag = self . root [ 0 ] labels_tag . remove ( self . _find_label ( name ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes underscores and capitalizes the neighbouring character [CODESPLIT] def mixedcase ( path ) : words = path . split ( '_' ) return words [ 0 ] + '' . join ( word . title ( ) for word in words [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "delete all the eggs in the directory specified [CODESPLIT] def delete_all_eggs ( self ) : path_to_delete = os . path . join ( self . egg_directory , \"lib\" , \"python\" ) if os . path . exists ( path_to_delete ) : shutil . rmtree ( path_to_delete )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return system CPU times as a namedtuple . [CODESPLIT] def get_system_cpu_times ( ) : user , nice , system , idle = _psutil_osx . get_system_cpu_times ( ) return _cputimes_ntuple ( user , nice , system , idle )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes documents from Solr [CODESPLIT] def remove ( self , document_id , namespace , timestamp ) : self . solr . delete ( id = u ( document_id ) , commit = ( self . auto_commit_interval == 0 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a str to object supporting buffer API and update a hash with it . [CODESPLIT] def update_hash_from_str ( hsh , str_input ) : byte_input = str ( str_input ) . encode ( \"UTF-8\" ) hsh . update ( byte_input )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility function to create regexp for matching escaped separators in strings . [CODESPLIT] def make_regex ( separator ) : return re . compile ( r'(?:' + re . escape ( separator ) + r')?((?:[^' + re . escape ( separator ) + r'\\\\]|\\\\.)+)' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform a named tuple into a dictionary [CODESPLIT] def dictify ( a_named_tuple ) : return dict ( ( s , getattr ( a_named_tuple , s ) ) for s in a_named_tuple . _fields )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Allow \\ n . join ( ... ) statements to work in Py2 and Py3 . : param sep : : param joinable : : return : [CODESPLIT] def _py2_and_3_joiner ( sep , joinable ) : if ISPY3 : sep = bytes ( sep , DEFAULT_ENCODING ) joined = sep . join ( joinable ) return joined . decode ( DEFAULT_ENCODING ) if ISPY3 else joined", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a python string to C string . [CODESPLIT] def c_str ( string ) : if not isinstance ( string , str ) : string = string . decode ( 'ascii' ) return ctypes . c_char_p ( string . encode ( 'utf-8' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check for semicolons at the end of lines . [CODESPLIT] def endline_semicolon_check ( self , original , loc , tokens ) : return self . check_strict ( \"semicolon at end of line\" , original , loc , tokens )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert datetime / str to date : param arg : : return : [CODESPLIT] def _datetime_to_date ( arg ) : _arg = parse ( arg ) if isinstance ( _arg , datetime . datetime ) : _arg = _arg . date ( ) return _arg", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the highest priority Processing Block from the queue . [CODESPLIT] def get ( self ) : with self . _mutex : entry = self . _queue . pop ( ) del self . _block_map [ entry [ 2 ] ] return entry [ 2 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deserialize the object from a JSON string . [CODESPLIT] def from_json ( cls , json_str ) : d = json . loads ( json_str ) return cls . from_dict ( d )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Upgrade all packages skip obsoletes if obsoletes = 0 in yum . conf . [CODESPLIT] def update ( kernel = False ) : manager = MANAGER cmds = { 'yum -y --color=never' : { False : '--exclude=kernel* update' , True : 'update' } } cmd = cmds [ manager ] [ kernel ] run_as_root ( \"%(manager)s %(cmd)s\" % locals ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Guess string encoding . [CODESPLIT] def guess_encoding ( text , default = DEFAULT_ENCODING ) : result = chardet . detect ( text ) return normalize_result ( result , default = default )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Join the given iterable with [CODESPLIT] def commajoin_as_strings ( iterable ) : return _ ( u',' ) . join ( ( six . text_type ( i ) for i in iterable ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if the running system s terminal supports color and False otherwise . [CODESPLIT] def supports_color ( ) : unsupported_platform = ( sys . platform in ( 'win32' , 'Pocket PC' ) ) # isatty is not always implemented, #6223. is_a_tty = hasattr ( sys . stdout , 'isatty' ) and sys . stdout . isatty ( ) if unsupported_platform or not is_a_tty : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts seconds float to hh : mm : ss . ssssss format . [CODESPLIT] def seconds_to_hms ( seconds ) : hours = int ( seconds / 3600.0 ) minutes = int ( ( seconds / 60.0 ) % 60.0 ) secs = float ( seconds % 60.0 ) return \"{0:02d}:{1:02d}:{2:02.6f}\" . format ( hours , minutes , secs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Invoked when determining whether a specific key is in the dictionary using key in d . [CODESPLIT] def __contains__ ( self , key ) : k = self . _real_key ( key ) return k in self . _data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string to a pythonized parameter . [CODESPLIT] def get_truetype ( value ) : if value in [ \"true\" , \"True\" , \"y\" , \"Y\" , \"yes\" ] : return True if value in [ \"false\" , \"False\" , \"n\" , \"N\" , \"no\" ] : return False if value . isdigit ( ) : return int ( value ) return str ( value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make sure an object is JSON - serializable Use this to return errors and other info that does not need to be deserialized or does not contain important app data . Best for returning error info and such [CODESPLIT] def Serializable ( o ) : if isinstance ( o , ( str , dict , int ) ) : return o else : try : json . dumps ( o ) return o except Exception : LOG . debug ( \"Got a non-serilizeable object: %s\" % o ) return o . __repr__ ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uniform ( key value ) iteration on a dict or ( idx value ) on a list . [CODESPLIT] def uniform_iterator ( sequence ) : if isinstance ( sequence , abc . Mapping ) : return six . iteritems ( sequence ) else : return enumerate ( sequence )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Guess the input type of the parameter based off the default value if unknown use text [CODESPLIT] def _guess_type ( val ) : if isinstance ( val , bool ) : return \"choice\" elif isinstance ( val , int ) : return \"number\" elif isinstance ( val , float ) : return \"number\" elif isinstance ( val , str ) : return \"text\" elif hasattr ( val , 'read' ) : return \"file\" else : return \"text\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "When converting Spark SQL records to Pandas DataFrame the inferred data type may be wrong . This method gets the corrected data type for Pandas if that type may be inferred uncorrectly . [CODESPLIT] def _to_corrected_pandas_type ( dt ) : import numpy as np if type ( dt ) == ByteType : return np . int8 elif type ( dt ) == ShortType : return np . int16 elif type ( dt ) == IntegerType : return np . int32 elif type ( dt ) == FloatType : return np . float32 else : return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates col_widths in code_array [CODESPLIT] def _xls2col_widths ( self , worksheet , tab ) : for col in xrange ( worksheet . ncols ) : try : xls_width = worksheet . colinfo_map [ col ] . width pys_width = self . xls_width2pys_width ( xls_width ) self . code_array . col_widths [ col , tab ] = pys_width except KeyError : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a copy of a dictionary with all keys converted to snake case . This is just calls to_snake_case on each of the keys in the dictionary and returns a new dictionary . [CODESPLIT] def keys_to_snake_case ( camel_case_dict ) : return dict ( ( to_snake_case ( key ) , value ) for ( key , value ) in camel_case_dict . items ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coerce value to an JSON - compatible representation . [CODESPLIT] def _bytes_to_json ( value ) : if isinstance ( value , bytes ) : value = base64 . standard_b64encode ( value ) . decode ( \"ascii\" ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a hash of the contents of a dictionary [CODESPLIT] def dict_hash ( dct ) : dct_s = json . dumps ( dct , sort_keys = True ) try : m = md5 ( dct_s ) except TypeError : m = md5 ( dct_s . encode ( ) ) return m . hexdigest ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert an int of form yyyymmdd to a python date object . [CODESPLIT] def int_to_date ( date ) : year = date // 10 ** 4 month = date % 10 ** 4 // 10 ** 2 day = date % 10 ** 2 return datetime . date ( year , month , day )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like dict . update but does not overwrite items [CODESPLIT] def dict_update_newkeys ( dict_ , dict2 ) : for key , val in six . iteritems ( dict2 ) : if key not in dict_ : dict_ [ key ] = val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "update () extends rather than replaces existing key lists . [CODESPLIT] def update ( self , other_dict ) : for key , value in iter_multi_items ( other_dict ) : MultiDict . add ( self , key , value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check to see if the internet is on by pinging a set address . : param address : the IP or address to hit : return : a boolean - true if can be reached false if not . [CODESPLIT] def _internet_on ( address ) : try : urllib2 . urlopen ( address , timeout = 1 ) return True except urllib2 . URLError as err : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wraps the given dictionary such that the given fallback function will be called when a nonexistent key is accessed . [CODESPLIT] def _defaultdict ( dct , fallback = _illegal_character ) : out = defaultdict ( lambda : fallback ) for k , v in six . iteritems ( dct ) : out [ k ] = v return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check configuration file type is JSON Return a boolean indicating wheather the file is JSON format or not [CODESPLIT] def is_json_file ( filename , show_warnings = False ) : try : config_dict = load_config ( filename , file_type = \"json\" ) is_json = True except : is_json = False return ( is_json )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes dict keys which have have self as value . [CODESPLIT] def _remove_dict_keys_with_value ( dict_ , val ) : return { k : v for k , v in dict_ . items ( ) if v is not val }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Hook : for checking commit message . [CODESPLIT] def post_commit_hook ( argv ) : _ , stdout , _ = run ( \"git log -1 --format=%B HEAD\" ) message = \"\\n\" . join ( stdout ) options = { \"allow_empty\" : True } if not _check_message ( message , options ) : click . echo ( \"Commit message errors (fix with 'git commit --amend').\" , file = sys . stderr ) return 1 # it should not fail with exit return 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a target dct and a dict of { key : default value } pairs calls setdefault for all of those pairs . [CODESPLIT] def setdefaults ( dct , defaults ) : for key in defaults : dct . setdefault ( key , defaults [ key ] ) return dct", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Indicate whether the specified image file is valid or not . [CODESPLIT] def is_image_file_valid ( file_path_name ) : # Image.verify is only implemented for PNG images, and it only verifies # the CRC checksum in the image.  The only way to check from within # Pillow is to load the image in a try/except and check the error.  If # as much info as possible is from the image is needed, # ``ImageFile.LOAD_TRUNCATED_IMAGES=True`` needs to bet set and it # will attempt to parse as much as possible. try : with Image . open ( file_path_name ) as image : image . load ( ) except IOError : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Banana banana [CODESPLIT] def dict_to_html_attrs ( dict_ ) : res = ' ' . join ( '%s=\"%s\"' % ( k , v ) for k , v in dict_ . items ( ) ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if the file is binary [CODESPLIT] def is_binary ( filename ) : with open ( filename , 'rb' ) as fp : data = fp . read ( 1024 ) if not data : return False if b'\\0' in data : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a dict to a querystring suitable to be appended to a URL . [CODESPLIT] def dict_to_querystring ( dictionary ) : s = u\"\" for d in dictionary . keys ( ) : s = unicode . format ( u\"{0}{1}={2}&\" , s , d , dictionary [ d ] ) return s [ : - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns true if all of the elements in the list are equal . [CODESPLIT] def _check_elements_equal ( lst ) : assert isinstance ( lst , list ) , \"Input value must be a list.\" return not lst or lst . count ( lst [ 0 ] ) == len ( lst )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a dict to a querystring suitable to be appended to a URL . [CODESPLIT] def dict_to_querystring ( dictionary ) : s = u\"\" for d in dictionary . keys ( ) : s = unicode . format ( u\"{0}{1}={2}&\" , s , d , dictionary [ d ] ) return s [ : - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns true if all of the elements in the list are equal . [CODESPLIT] def _check_elements_equal ( lst ) : assert isinstance ( lst , list ) , \"Input value must be a list.\" return not lst or lst . count ( lst [ 0 ] ) == len ( lst )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like dict but does not hold any null values . [CODESPLIT] def nonull_dict ( self ) : return { k : v for k , v in six . iteritems ( self . dict ) if v and k != '_codes' }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Primary entry point to turn kwargs into properties [CODESPLIT] def updateFromKwargs ( self , properties , kwargs , collector , * * unused ) : properties [ self . name ] = self . getFromKwargs ( kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the unit tests . [CODESPLIT] def test ( ) : import unittest tests = unittest . TestLoader ( ) . discover ( 'tests' ) unittest . TextTestRunner ( verbosity = 2 ) . run ( tests )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "gets a horiztonal line [CODESPLIT] def get_hline ( ) : return Window ( width = LayoutDimension . exact ( 1 ) , height = LayoutDimension . exact ( 1 ) , content = FillControl ( '-' , token = Token . Line ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a group exists [CODESPLIT] def group_exists ( groupname ) : try : grp . getgrnam ( groupname ) group_exists = True except KeyError : group_exists = False return group_exists", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Syncs the information from this item to the tree and view . [CODESPLIT] def sync ( self , recursive = False ) : self . syncTree ( recursive = recursive ) self . syncView ( recursive = recursive )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if two images have the same height and width ( and optionally channels ) . [CODESPLIT] def is_same_shape ( self , other_im , check_channels = False ) : if self . height == other_im . height and self . width == other_im . width : if check_channels and self . channels != other_im . channels : return False return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the distance between two XYPoints . [CODESPLIT] def get_distance_between_two_points ( self , one , two ) : dx = one . x - two . x dy = one . y - two . y return math . sqrt ( dx * dx + dy * dy )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if two images have the same height and width ( and optionally channels ) . [CODESPLIT] def is_same_shape ( self , other_im , check_channels = False ) : if self . height == other_im . height and self . width == other_im . width : if check_channels and self . channels != other_im . channels : return False return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Whether the item is a placeholder or contains a placeholder . [CODESPLIT] def _not_none ( items ) : if not isinstance ( items , ( tuple , list ) ) : items = ( items , ) return all ( item is not _none for item in items )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete build directory and all its contents . [CODESPLIT] def delete ( build_folder ) : if _meta_ . del_build in [ \"on\" , \"ON\" ] and os . path . exists ( build_folder ) : shutil . rmtree ( build_folder )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if there s something to read on stdin ( posix version ) . [CODESPLIT] def _stdin_ready_posix ( ) : infds , outfds , erfds = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return bool ( infds )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a JsonResponse . Make sure you have django installed first . [CODESPLIT] def json_response ( data , status = 200 ) : from django . http import JsonResponse return JsonResponse ( data = data , status = status , safe = isinstance ( data , dict ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return whether an object is a path . [CODESPLIT] def _is_path ( s ) : if isinstance ( s , string_types ) : try : return op . exists ( s ) except ( OSError , ValueError ) : return False else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Copy docstring from existing object to the decorated callable . [CODESPLIT] def see_doc ( obj_with_doc ) : def decorator ( fn ) : fn . __doc__ = obj_with_doc . __doc__ return fn return decorator", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Whether the currently selected calibration stimulus type is the calibration curve [CODESPLIT] def isToneCal ( self ) : return self . ui . calTypeCmbbx . currentIndex ( ) == self . ui . calTypeCmbbx . count ( ) - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert RA hours minutes seconds into an angle in degrees . [CODESPLIT] def hmsToDeg ( h , m , s ) : return h * degPerHMSHour + m * degPerHMSMin + s * degPerHMSSec", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets the caption_found and plot_found variables to False . [CODESPLIT] def prepare ( doc ) : doc . caption_found = False doc . plot_found = False doc . listings_counter = 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check that the key is a string or bytestring . [CODESPLIT] def validate ( key ) : if not isinstance ( key , ( str , bytes ) ) : raise KeyError ( 'Key must be of type str or bytes, found type {}' . format ( type ( key ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flushes the prompt before requesting the input [CODESPLIT] def _normal_prompt ( self ) : sys . stdout . write ( self . __get_ps1 ( ) ) sys . stdout . flush ( ) return safe_input ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the depth of the longest branch of the tree [CODESPLIT] def maxDepth ( self , currentDepth = 0 ) : if not any ( ( self . left , self . right ) ) : return currentDepth result = 0 for child in ( self . left , self . right ) : if child : result = max ( result , child . maxDepth ( currentDepth + 1 ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if obj is a sequence but not a string or bytes . [CODESPLIT] def is_sequence ( obj ) : return isinstance ( obj , Sequence ) and not ( isinstance ( obj , str ) or BinaryClass . is_valid_type ( obj ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if the given string starts with one of the prefixes in the given list otherwise return False . [CODESPLIT] def starts_with_prefix_in_list ( text , prefixes ) : for prefix in prefixes : if text . startswith ( prefix ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty print an object as YAML . [CODESPLIT] def print_yaml ( o ) : print ( yaml . dump ( o , default_flow_style = False , indent = 4 , encoding = 'utf-8' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deserializes a JSONified : obj : numpy . ndarray that was created using numpy s : obj : save function . [CODESPLIT] def deserialize_ndarray_npy ( d ) : with io . BytesIO ( ) as f : f . write ( json . loads ( d [ 'npy' ] ) . encode ( 'latin-1' ) ) f . seek ( 0 ) return np . load ( f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check the text . [CODESPLIT] def check ( text ) : err = \"misc.currency\" msg = u\"Incorrect use of symbols in {}.\" symbols = [ \"\\$[\\d]* ?(?:dollars|usd|us dollars)\" ] return existence_check ( text , symbols , err , msg )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is an object iterable like a list ( and not a string ) ? [CODESPLIT] def listlike ( obj ) : return hasattr ( obj , \"__iter__\" ) and not issubclass ( type ( obj ) , str ) and not issubclass ( type ( obj ) , unicode )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pre foregin_keys potrbejeme pre z nazvu tabulky zistit class tak si to namapujme [CODESPLIT] def _map_table_name ( self , model_names ) : for model in model_names : if isinstance ( model , tuple ) : model = model [ 0 ] try : model_cls = getattr ( self . models , model ) self . table_to_class [ class_mapper ( model_cls ) . tables [ 0 ] . name ] = model except AttributeError : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine whether a system service is available [CODESPLIT] def service_available ( service_name ) : try : subprocess . check_output ( [ 'service' , service_name , 'status' ] , stderr = subprocess . STDOUT ) . decode ( 'UTF-8' ) except subprocess . CalledProcessError as e : return b'unrecognized service' not in e . output else : return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of all keys in the dictionary . [CODESPLIT] def keys ( self ) : all_keys = [ k . decode ( 'utf-8' ) for k , v in self . rdb . hgetall ( self . session_hash ) . items ( ) ] return all_keys", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Do all elements of x have a type from types? [CODESPLIT] def _valid_other_type ( x , types ) : return all ( any ( isinstance ( el , t ) for t in types ) for el in np . ravel ( x ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make text tex safe [CODESPLIT] def escape_tex ( value ) : newval = value for pattern , replacement in LATEX_SUBS : newval = pattern . sub ( replacement , newval ) return newval", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a dtype is a subclass of the numpy datetime types [CODESPLIT] def is_datetime_like ( dtype ) : return ( np . issubdtype ( dtype , np . datetime64 ) or np . issubdtype ( dtype , np . timedelta64 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a context manager that hides the cursor while inside it and makes it visible on leaving . [CODESPLIT] def hidden_cursor ( self ) : self . stream . write ( self . hide_cursor ) try : yield finally : self . stream . write ( self . normal_cursor )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine whether a system service is available [CODESPLIT] def service_available ( service_name ) : try : subprocess . check_output ( [ 'service' , service_name , 'status' ] , stderr = subprocess . STDOUT ) . decode ( 'UTF-8' ) except subprocess . CalledProcessError as e : return b'unrecognized service' not in e . output else : return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Copy element from sequence member from mapping . [CODESPLIT] def copy ( doc , dest , src ) : return Target ( doc ) . copy ( dest , src ) . document", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determines whether the passed value is a string safe for 2 / 3 . [CODESPLIT] def is_string ( val ) : try : basestring except NameError : return isinstance ( val , str ) return isinstance ( val , basestring )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read helper method [CODESPLIT] def read_from_file ( file_path , encoding = \"utf-8\" ) : with codecs . open ( file_path , \"r\" , encoding ) as f : return f . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if there s something to read on stdin ( posix version ) . [CODESPLIT] def _stdin_ready_posix ( ) : infds , outfds , erfds = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return bool ( infds )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if the user is rooted . [CODESPLIT] def _is_root ( ) : import os import ctypes try : return os . geteuid ( ) == 0 except AttributeError : return ctypes . windll . shell32 . IsUserAnAdmin ( ) != 0 return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Build descriptor for Enum instance . [CODESPLIT] def describe_enum_value ( enum_value ) : enum_value_descriptor = EnumValueDescriptor ( ) enum_value_descriptor . name = six . text_type ( enum_value . name ) enum_value_descriptor . number = enum_value . number return enum_value_descriptor", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if the given user is in all given groups [CODESPLIT] def user_in_all_groups ( user , groups ) : return user_is_superuser ( user ) or all ( user_in_group ( user , group ) for group in groups )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of the ( name value ) pairs of the enum . [CODESPLIT] def items ( self ) : return [ ( value_descriptor . name , value_descriptor . number ) for value_descriptor in self . _enum_type . values ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get the number of quartets as n - choose - k . This is used in equal splits to decide whether a split should be exhaustively sampled or randomly sampled . Edges near tips can be exhaustive while highly nested edges probably have too many quartets [CODESPLIT] def n_choose_k ( n , k ) : return int ( reduce ( MUL , ( Fraction ( n - i , i + 1 ) for i in range ( k ) ) , 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "All values for this enum : return : list of tuples [CODESPLIT] def items ( cls ) : return [ cls . PRECIPITATION , cls . WIND , cls . TEMPERATURE , cls . PRESSURE ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tiny hparams suitable for CIFAR / etc . [CODESPLIT] def revnet_164_cifar ( ) : hparams = revnet_cifar_base ( ) hparams . bottleneck = True hparams . num_channels = [ 16 , 32 , 64 ] hparams . num_layers_per_block = [ 8 , 8 , 8 ] return hparams", "target": 1, "target_options": ["no_match", "match"]}
{"input": "All values for this enum : return : list of tuples [CODESPLIT] def items ( cls ) : return [ cls . PRECIPITATION , cls . WIND , cls . TEMPERATURE , cls . PRESSURE ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Data parallel CIFAR parameters . [CODESPLIT] def mtf_image_transformer_cifar_mp_4x ( ) : hparams = mtf_image_transformer_base_cifar ( ) hparams . mesh_shape = \"model:4;batch:8\" hparams . layout = \"batch:batch;d_ff:model;heads:model\" hparams . batch_size = 32 hparams . num_heads = 8 hparams . d_ff = 8192 return hparams", "target": 1, "target_options": ["no_match", "match"]}
{"input": "sets the aspect ratio of the current zoom level of the imshow image [CODESPLIT] def image_set_aspect ( aspect = 1.0 , axes = \"gca\" ) : if axes is \"gca\" : axes = _pylab . gca ( ) e = axes . get_images ( ) [ 0 ] . get_extent ( ) axes . set_aspect ( abs ( ( e [ 1 ] - e [ 0 ] ) / ( e [ 3 ] - e [ 2 ] ) ) / aspect )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flush all items from cache . [CODESPLIT] def Flush ( self ) : while self . _age : node = self . _age . PopLeft ( ) self . KillObject ( node . data ) self . _hash = dict ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove decoded instruction from instruction cache [CODESPLIT] def invalidate_cache ( cpu , address , size ) : cache = cpu . instruction_cache for offset in range ( size ) : if address + offset in cache : del cache [ address + offset ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a byte value to boolean ( 0 or 1 ) if the global flag strictBool is True [CODESPLIT] def convertToBool ( ) : if not OPTIONS . strictBool . value : return [ ] REQUIRES . add ( 'strictbool.asm' ) result = [ ] result . append ( 'pop af' ) result . append ( 'call __NORMALIZE_BOOLEAN' ) result . append ( 'push af' ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize value between min and max values . It also clips the values so that you cannot have values higher or lower than 0 - 1 . [CODESPLIT] def normalize ( x , min_value , max_value ) : x = ( x - min_value ) / ( max_value - min_value ) return clip ( x , 0 , 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prepares the exception for re - raising with reraise method . [CODESPLIT] def prepare_for_reraise ( error , exc_info = None ) : if not hasattr ( error , \"_type_\" ) : if exc_info is None : exc_info = sys . exc_info ( ) error . _type_ = exc_info [ 0 ] error . _traceback = exc_info [ 2 ] return error", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Close all files but the current one [CODESPLIT] def close_all_but_this ( self ) : self . close_all_right ( ) for i in range ( 0 , self . get_stack_count ( ) - 1 ) : self . close_file ( 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get Callable for specified string ( for GUI - based editing ) [CODESPLIT] def eval_in_system_namespace ( self , exec_str ) : ns = self . cmd_namespace try : return eval ( exec_str , ns ) except Exception as e : self . logger . warning ( 'Could not execute %s, gave error %s' , exec_str , e ) return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shutdown and close the Socket . [CODESPLIT] def _close_socket ( self ) : try : self . socket . shutdown ( socket . SHUT_RDWR ) except ( OSError , socket . error ) : pass self . socket . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Makes sure obj is a unicode string . [CODESPLIT] def get_unicode_str ( obj ) : if isinstance ( obj , six . text_type ) : return obj if isinstance ( obj , six . binary_type ) : return obj . decode ( \"utf-8\" , errors = \"ignore\" ) return six . text_type ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Close all files but the current one [CODESPLIT] def close_all_but_this ( self ) : self . close_all_right ( ) for i in range ( 0 , self . get_stack_count ( ) - 1 ) : self . close_file ( 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function used to fit the exponential decay . [CODESPLIT] def exp_fit_fun ( x , a , tau , c ) : # pylint: disable=invalid-name return a * np . exp ( - x / tau ) + c", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Finds the value in arr that value is closest to [CODESPLIT] def _findNearest ( arr , value ) : arr = np . array ( arr ) # find nearest value in array idx = ( abs ( arr - value ) ) . argmin ( ) return arr [ idx ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalized Gaussian [CODESPLIT] def gauss_pdf ( x , mu , sigma ) : return 1 / np . sqrt ( 2 * np . pi ) / sigma * np . exp ( - ( x - mu ) ** 2 / 2. / sigma ** 2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve contents of each page of PDF [CODESPLIT] def resources ( self ) : return [ self . pdf . getPage ( i ) for i in range ( self . pdf . getNumPages ( ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "\\ kills the child and exits [CODESPLIT] def cli_command_quit ( self , msg ) : if self . state == State . RUNNING and self . sprocess and self . sprocess . proc : self . sprocess . proc . kill ( ) else : sys . exit ( 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the dotproduct between self and another vector . [CODESPLIT] def dot ( self , w ) : return sum ( [ x * y for x , y in zip ( self , w ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print in color . [CODESPLIT] def printc ( cls , txt , color = colors . red ) : print ( cls . color_txt ( txt , color ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if file a is newer than file b and decide whether or not to update file b . Can generalize to two lists . [CODESPLIT] def need_update ( a , b ) : a = listify ( a ) b = listify ( b ) return any ( ( not op . exists ( x ) ) for x in b ) or all ( ( os . stat ( x ) . st_size == 0 for x in b ) ) or any ( is_newer_file ( x , y ) for x in a for y in b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The cell lengths . [CODESPLIT] def lengths ( self ) : return ( np . array ( [ math . sqrt ( sum ( row ** 2 ) ) for row in self . matrix ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "create random string of selected size [CODESPLIT] def random_str ( size = 10 ) : return '' . join ( random . choice ( string . ascii_lowercase ) for _ in range ( size ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of tuples specifying the column name and type [CODESPLIT] def get_table_columns ( dbconn , tablename ) : cur = dbconn . cursor ( ) cur . execute ( \"PRAGMA table_info('%s');\" % tablename ) info = cur . fetchall ( ) cols = [ ( i [ 1 ] , i [ 2 ] ) for i in info ] return cols", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Emulate what a Python set () does but keeping the element s order . [CODESPLIT] def remove_duplicates ( lst ) : dset = set ( ) return [ l for l in lst if l not in dset and not dset . add ( l ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function bound to event of selection in the Combobox calls callback if callable : param args : Tkinter event [CODESPLIT] def _on_select ( self , * args ) : if callable ( self . __callback ) : self . __callback ( self . selection )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function computes the one - dimensional n - point discrete Fourier Transform ( DFT ) of a real - valued array by means of an efficient algorithm called the Fast Fourier Transform ( FFT ) . Please refer to https : // docs . scipy . org / doc / numpy / reference / generated / numpy . fft . rfft . html for further details . [CODESPLIT] def fft_spectrum ( frames , fft_points = 512 ) : SPECTRUM_VECTOR = np . fft . rfft ( frames , n = fft_points , axis = - 1 , norm = None ) return np . absolute ( SPECTRUM_VECTOR )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "move to util_iter [CODESPLIT] def isetdiff_flags ( list1 , list2 ) : set2 = set ( list2 ) return ( item not in set2 for item in list1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test two dictionary is equal on values . ( ignore order ) [CODESPLIT] def is_same_dict ( d1 , d2 ) : for k , v in d1 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d2 [ k ] ) else : assert d1 [ k ] == d2 [ k ] for k , v in d2 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d1 [ k ] ) else : assert d1 [ k ] == d2 [ k ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fill file at [CODESPLIT] def file_writelines_flush_sync ( path , lines ) : fp = open ( path , 'w' ) try : fp . writelines ( lines ) flush_sync_file_object ( fp ) finally : fp . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a function that checks whether a scalar or array is of a given kind ( e . g . float int datetime timedelta ) . [CODESPLIT] def make_kind_check ( python_types , numpy_kind ) : def check ( value ) : if hasattr ( value , 'dtype' ) : return value . dtype . kind == numpy_kind return isinstance ( value , python_types ) return check", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if a file is empty or not . [CODESPLIT] def file_empty ( fp ) : # for python 2 we need to use a homemade peek() if six . PY2 : contents = fp . read ( ) fp . seek ( 0 ) return not bool ( contents ) else : return not fp . peek ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a single boolean for arg1 == arg2 even for numpy arrays using element - wise comparison . [CODESPLIT] def all_equal ( arg1 , arg2 ) : if all ( hasattr ( el , '_infinitely_iterable' ) for el in [ arg1 , arg2 ] ) : return arg1 == arg2 try : return all ( a1 == a2 for a1 , a2 in zip ( arg1 , arg2 ) ) except TypeError : return arg1 == arg2", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is a compatibility function that takes a C { float } and converts it to an C { int } if the values are equal . [CODESPLIT] def _check_for_int ( x ) : try : y = int ( x ) except ( OverflowError , ValueError ) : pass else : # There is no way in AMF0 to distinguish between integers and floats if x == x and y == x : return y return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prefill form with data . [CODESPLIT] def fill_form ( form , data ) : for ( key , value ) in data . items ( ) : if hasattr ( form , key ) : if isinstance ( value , dict ) : fill_form ( getattr ( form , key ) , value ) else : getattr ( form , key ) . data = value return form", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if invoking supplied clang - apply - replacements binary works . [CODESPLIT] def check_clang_apply_replacements_binary ( args ) : try : subprocess . check_call ( [ args . clang_apply_replacements_binary , '--version' ] ) except : print ( 'Unable to run clang-apply-replacements. Is clang-apply-replacements ' 'binary correctly specified?' , file = sys . stderr ) traceback . print_exc ( ) sys . exit ( 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "if we have a compatible fill_value and arr dtype then fill [CODESPLIT] def _maybe_fill ( arr , fill_value = np . nan ) : if _isna_compat ( arr , fill_value ) : arr . fill ( fill_value ) return arr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract a ALZIP archive . [CODESPLIT] def extract_alzip ( archive , compression , cmd , verbosity , interactive , outdir ) : return [ cmd , '-d' , outdir , archive ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get longitudes from cartesian coordinates . [CODESPLIT] def get_lons_from_cartesian ( x__ , y__ ) : return rad2deg ( arccos ( x__ / sqrt ( x__ ** 2 + y__ ** 2 ) ) ) * sign ( y__ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Alternate name for filter so as to not collide with the built - in python filter operator . [CODESPLIT] def filter_ ( stream_spec , filter_name , * args , * * kwargs ) : return filter ( stream_spec , filter_name , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the stationary distribution of states . [CODESPLIT] def get_stationary_distribution ( self ) : # The stationary distribution is proportional to the left-eigenvector # associated with the largest eigenvalue (i.e., 1) of the transition # matrix. check_is_fitted ( self , \"transmat_\" ) eigvals , eigvecs = np . linalg . eig ( self . transmat_ . T ) eigvec = np . real_if_close ( eigvecs [ : , np . argmax ( eigvals ) ] ) return eigvec / eigvec . sum ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply the coefficients from a linear fit to an array of x y positions . [CODESPLIT] def apply_fit ( xy , coeffs ) : x_new = coeffs [ 0 ] [ 2 ] + coeffs [ 0 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 0 ] [ 1 ] * xy [ : , 1 ] y_new = coeffs [ 1 ] [ 2 ] + coeffs [ 1 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 1 ] [ 1 ] * xy [ : , 1 ] return x_new , y_new", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Squared Euclidean distance between the rows of X and Y . [CODESPLIT] def _tf_squared_euclidean ( X , Y ) : return tf . reduce_sum ( tf . pow ( tf . subtract ( X , Y ) , 2 ) , axis = 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Standard euclidean distance . [CODESPLIT] def euclidean ( x , y ) : result = 0.0 for i in range ( x . shape [ 0 ] ) : result += ( x [ i ] - y [ i ] ) ** 2 return np . sqrt ( result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Memory efficient function for loading a table from a FITS file . [CODESPLIT] def create_table_from_fits ( fitsfile , hduname , colnames = None ) : if colnames is None : return Table . read ( fitsfile , hduname ) cols = [ ] with fits . open ( fitsfile , memmap = True ) as h : for k in colnames : data = h [ hduname ] . data . field ( k ) cols += [ Column ( name = k , data = data ) ] return Table ( cols )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the largest real value h such that all elements in x are integer multiples of h . [CODESPLIT] def _gcd_array ( X ) : greatest_common_divisor = 0.0 for x in X : greatest_common_divisor = _gcd ( greatest_common_divisor , x ) return greatest_common_divisor", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run lint checks using flake8 . [CODESPLIT] def lint ( args ) : application = get_current_application ( ) if not args : args = [ application . name , 'tests' ] args = [ 'flake8' ] + list ( args ) run . main ( args , standalone_mode = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convenient shorthand for toarray ( * args ** kwargs ) . view ( np . recarray ) . [CODESPLIT] def torecarray ( * args , * * kwargs ) : import numpy as np return toarray ( * args , * * kwargs ) . view ( np . recarray )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shortcut fot boolean like fields [CODESPLIT] def _type_bool ( label , default = False ) : return label , abstractSearch . nothing , abstractRender . boolen , default", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Join list of columns into a string for a SQL query [CODESPLIT] def join_cols ( cols ) : return \", \" . join ( [ i for i in cols ] ) if isinstance ( cols , ( list , tuple , set ) ) else cols", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pull a form value from the request . [CODESPLIT] def parse_form ( self , req , name , field ) : return core . get_value ( req . POST , name , field )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def cors_header ( func ) : @ wraps ( func ) def wrapper ( self , request , * args , * * kwargs ) : res = func ( self , request , * args , * * kwargs ) request . setHeader ( 'Access-Control-Allow-Origin' , '*' ) request . setHeader ( 'Access-Control-Allow-Headers' , 'Content-Type, Access-Control-Allow-Headers, Authorization, X-Requested-With' ) return res return wrapper", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Probability density function ( normal distribution ) [CODESPLIT] def pdf ( x , mu , std ) : return ( 1.0 / ( std * sqrt ( 2 * pi ) ) ) * np . exp ( - ( x - mu ) ** 2 / ( 2 * std ** 2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handles the specified flask request for one of the POST URLS Invokes the specified endpoint to generate a response . [CODESPLIT] def handleFlaskPostRequest ( flaskRequest , endpoint ) : if flaskRequest . method == \"POST\" : return handleHttpPost ( flaskRequest , endpoint ) elif flaskRequest . method == \"OPTIONS\" : return handleHttpOptions ( ) else : raise exceptions . MethodNotAllowedException ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Probability density function ( normal distribution ) [CODESPLIT] def pdf ( x , mu , std ) : return ( 1.0 / ( std * sqrt ( 2 * pi ) ) ) * np . exp ( - ( x - mu ) ** 2 / ( 2 * std ** 2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator which adds correct MIME type for python source to the decorated bottle API function . [CODESPLIT] def python_mime ( fn ) : @ wraps ( fn ) def python_mime_decorator ( * args , * * kwargs ) : response . content_type = \"text/x-python\" return fn ( * args , * * kwargs ) return python_mime_decorator", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Spawns a kafka continuous consumer thread [CODESPLIT] def _spawn_kafka_consumer_thread ( self ) : self . logger . debug ( \"Spawn kafka consumer thread\" \"\" ) self . _consumer_thread = Thread ( target = self . _consumer_loop ) self . _consumer_thread . setDaemon ( True ) self . _consumer_thread . start ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a HttpResponse whose content is a Javascript file representing a list of links to flatpages . [CODESPLIT] def flatpages_link_list ( request ) : from django . contrib . flatpages . models import FlatPage link_list = [ ( page . title , page . url ) for page in FlatPage . objects . all ( ) ] return render_to_link_list ( link_list )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets the user enter max and min values of where the raster points should appear on the y - axis [CODESPLIT] def values ( self ) : lower = float ( self . lowerSpnbx . value ( ) ) upper = float ( self . upperSpnbx . value ( ) ) return ( lower , upper )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper for executing many SQL calls on my connection . [CODESPLIT] def sqlmany ( self , stringname , * args ) : if hasattr ( self , 'alchemist' ) : return getattr ( self . alchemist . many , stringname ) ( * args ) s = self . strings [ stringname ] return self . connection . cursor ( ) . executemany ( s , args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convolve 2d gaussian . [CODESPLIT] def convolve_gaussian_2d ( image , gaussian_kernel_1d ) : result = scipy . ndimage . filters . correlate1d ( image , gaussian_kernel_1d , axis = 0 ) result = scipy . ndimage . filters . correlate1d ( result , gaussian_kernel_1d , axis = 1 ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs the function asynchronously taking care of exceptions . [CODESPLIT] def asynchronous ( function , event ) : thread = Thread ( target = synchronous , args = ( function , event ) ) thread . daemon = True thread . start ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "HTTP response for forbidden access ( status code 403 ) [CODESPLIT] def HttpResponse403 ( request , template = KEY_AUTH_403_TEMPLATE , content = KEY_AUTH_403_CONTENT , content_type = KEY_AUTH_403_CONTENT_TYPE ) : return AccessFailedResponse ( request , template , content , content_type , status = 403 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates the cosine similarity between this vector and another vector . [CODESPLIT] def similarity ( self , other ) : if self . magnitude == 0 or other . magnitude == 0 : return 0 return self . dot ( other ) / self . magnitude", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the path to the javascript bundle [CODESPLIT] def default_static_path ( ) : fdir = os . path . dirname ( __file__ ) return os . path . abspath ( os . path . join ( fdir , '../assets/' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generates a count of the number of times each unique item appears in a list [CODESPLIT] def count_list ( the_list ) : count = the_list . count result = [ ( item , count ( item ) ) for item in set ( the_list ) ] result . sort ( ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a float returns a rounded int . Should give the same result on both Py2 / 3 [CODESPLIT] def intround ( value ) : return int ( decimal . Decimal . from_float ( value ) . to_integral_value ( decimal . ROUND_HALF_EVEN ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert datetime / str to date : param arg : : return : [CODESPLIT] def _datetime_to_date ( arg ) : _arg = parse ( arg ) if isinstance ( _arg , datetime . datetime ) : _arg = _arg . date ( ) return _arg", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reimplement Qt method to send focus change notification [CODESPLIT] def focusInEvent ( self , event ) : self . focus_changed . emit ( ) return super ( PageControlWidget , self ) . focusInEvent ( event )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create directory with template for topic of the current environment [CODESPLIT] def mkdir ( dir , enter ) : if not os . path . exists ( dir ) : os . makedirs ( dir )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a n + 1 dim one - hot array from n dim int - categorical array . [CODESPLIT] def one_hot ( x , size , dtype = np . float32 ) : return np . array ( x [ ... , np . newaxis ] == np . arange ( size ) , dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate all matches found within a string for a regex and yield each match as a string [CODESPLIT] def iter_finds ( regex_obj , s ) : if isinstance ( regex_obj , str ) : for m in re . finditer ( regex_obj , s ) : yield m . group ( ) else : for m in regex_obj . finditer ( s ) : yield m . group ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert 3 3 a matrix to 6 element s list ( see Tauxe 1998 ) [CODESPLIT] def a2s ( a ) : s = np . zeros ( ( 6 , ) , 'f' ) # make the a matrix for i in range ( 3 ) : s [ i ] = a [ i ] [ i ] s [ 3 ] = a [ 0 ] [ 1 ] s [ 4 ] = a [ 1 ] [ 2 ] s [ 5 ] = a [ 0 ] [ 2 ] return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Similar to #itertools . chain . from_iterable () . [CODESPLIT] def concat ( cls , iterables ) : def generator ( ) : for it in iterables : for element in it : yield element return cls ( generator ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "From : http : // stackoverflow . com / questions / 13062300 / convert - a - dict - to - sorted - dict - in - python [CODESPLIT] def format_result ( input ) : items = list ( iteritems ( input ) ) return OrderedDict ( sorted ( items , key = lambda x : x [ 0 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Bulk insert or update . [CODESPLIT] def bulk_query ( self , query , * multiparams ) : with self . get_connection ( ) as conn : conn . bulk_query ( query , * multiparams )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param S : set of words : returns : trie containing all words from S : complexity : linear in total word sizes from S [CODESPLIT] def Trie ( S ) : T = None for w in S : T = add ( T , w ) return T", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Daemonize the running process . [CODESPLIT] def go_to_background ( ) : try : if os . fork ( ) : sys . exit ( ) except OSError as errmsg : LOGGER . error ( 'Fork failed: {0}' . format ( errmsg ) ) sys . exit ( 'Fork failed' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a unique ID that is somewhat guaranteed to be unique among all instances running at the same time . [CODESPLIT] def generate_unique_host_id ( ) : host = \".\" . join ( reversed ( socket . gethostname ( ) . split ( \".\" ) ) ) pid = os . getpid ( ) return \"%s.%d\" % ( host , pid )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the cleaned_data of the form everything should already be valid [CODESPLIT] def compress ( self , data_list ) : data = { } if data_list : return dict ( ( f . name , data_list [ i ] ) for i , f in enumerate ( self . form ) ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Drops and re - creates the SQL schema [CODESPLIT] def init_db ( ) : db . drop_all ( ) db . configure_mappers ( ) db . create_all ( ) db . session . commit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": type s str [CODESPLIT] def safe_format ( s , * * kwargs ) : return string . Formatter ( ) . vformat ( s , ( ) , defaultdict ( str , * * kwargs ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialise sets used for uniqueness checking . [CODESPLIT] def _init_unique_sets ( self ) : ks = dict ( ) for t in self . _unique_checks : key = t [ 0 ] ks [ key ] = set ( ) # empty set return ks", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print a formatted straight line . [CODESPLIT] def straight_line_show ( title , length = 100 , linestyle = \"=\" , pad = 0 ) : print ( StrTemplate . straight_line ( title = title , length = length , linestyle = linestyle , pad = pad ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make script_path executable . [CODESPLIT] def make_executable ( script_path ) : status = os . stat ( script_path ) os . chmod ( script_path , status . st_mode | stat . S_IEXEC )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert a code sequence to HTML [CODESPLIT] def make_html_code ( self , lines ) : line = code_header + '\\n' for l in lines : line = line + html_quote ( l ) + '\\n' return line + code_footer", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a 3x3 cross - product matrix from a 3 - element vector . [CODESPLIT] def cross_product_matrix ( vec ) : return np . array ( [ [ 0 , - vec [ 2 ] , vec [ 1 ] ] , [ vec [ 2 ] , 0 , - vec [ 0 ] ] , [ - vec [ 1 ] , vec [ 0 ] , 0 ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "expects a _n . array returns the global minimum of ( value - array ) ^2 [CODESPLIT] def index_nearest ( value , array ) : a = ( array - value ) ** 2 return index ( a . min ( ) , a )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "main entry point for the jardiff CLI [CODESPLIT] def main ( args = sys . argv ) : parser = create_optparser ( args [ 0 ] ) return cli ( parser . parse_args ( args [ 1 : ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Free the underlying C array [CODESPLIT] def free ( self ) : if self . _ptr is None : return Gauged . array_free ( self . ptr ) FloatArray . ALLOCATIONS -= 1 self . _ptr = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Connect to FTP server login and return an ftplib . FTP instance . [CODESPLIT] def connect ( ) : ftp_class = ftplib . FTP if not SSL else ftplib . FTP_TLS ftp = ftp_class ( timeout = TIMEOUT ) ftp . connect ( HOST , PORT ) ftp . login ( USER , PASSWORD ) if SSL : ftp . prot_p ( ) # secure data connection return ftp", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the path to a newly created temporary file . [CODESPLIT] def tmpfile ( prefix , direc ) : return tempfile . mktemp ( prefix = prefix , suffix = '.pdb' , dir = direc )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Connect and login to an FTP server and return ftplib . FTP object . [CODESPLIT] def connect ( host , port , username , password ) : # Instantiate ftplib client session = ftplib . FTP ( ) # Connect to host without auth session . connect ( host , port ) # Authenticate connection session . login ( username , password ) return session", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a list unique retaining order of initial appearance . [CODESPLIT] def unique_list ( lst ) : uniq = [ ] for item in lst : if item not in uniq : uniq . append ( item ) return uniq", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Connect to FTP server login and return an ftplib . FTP instance . [CODESPLIT] def connect ( ) : ftp_class = ftplib . FTP if not SSL else ftplib . FTP_TLS ftp = ftp_class ( timeout = TIMEOUT ) ftp . connect ( HOST , PORT ) ftp . login ( USER , PASSWORD ) if SSL : ftp . prot_p ( ) # secure data connection return ftp", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function used to fit the exponential decay . [CODESPLIT] def exp_fit_fun ( x , a , tau , c ) : # pylint: disable=invalid-name return a * np . exp ( - x / tau ) + c", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param sequence : Any sequence whose elements can be evaluated as booleans . : returns : true if all elements of the sequence satisfy True and x . [CODESPLIT] def All ( sequence ) : return bool ( reduce ( lambda x , y : x and y , sequence , True ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initial state of the network [CODESPLIT] def zero_state ( self , batch_size ) : return torch . zeros ( batch_size , self . state_dim , dtype = torch . float32 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the fully - qualified name of a function . [CODESPLIT] def _fullname ( o ) : return o . __module__ + \".\" + o . __name__ if o . __module__ else o . __name__", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create the root index . [CODESPLIT] def create_index ( config ) : filename = pathlib . Path ( config . cache_path ) / \"index.json\" index = { \"version\" : __version__ } with open ( filename , \"w\" ) as out : out . write ( json . dumps ( index , indent = 2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determines if a list is sorted [CODESPLIT] def issorted ( list_ , op = operator . le ) : return all ( op ( list_ [ ix ] , list_ [ ix + 1 ] ) for ix in range ( len ( list_ ) - 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "determines whether the card number is valid . [CODESPLIT] def is_valid ( number ) : n = str ( number ) if not n . isdigit ( ) : return False return int ( n [ - 1 ] ) == get_check_digit ( n [ : - 1 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform an underscore_case string to a mixedCase string [CODESPLIT] def us2mc ( string ) : return re . sub ( r'_([a-z])' , lambda m : ( m . group ( 1 ) . upper ( ) ) , string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a CSV SampleSheet to YAML run_info format . [CODESPLIT] def csv2yaml ( in_file , out_file = None ) : if out_file is None : out_file = \"%s.yaml\" % os . path . splitext ( in_file ) [ 0 ] barcode_ids = _generate_barcode_ids ( _read_input_csv ( in_file ) ) lanes = _organize_lanes ( _read_input_csv ( in_file ) , barcode_ids ) with open ( out_file , \"w\" ) as out_handle : out_handle . write ( yaml . safe_dump ( lanes , default_flow_style = False ) ) return out_file", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Computes average length of words [CODESPLIT] def get_average_length_of_string ( strings ) : if not strings : return 0 return sum ( len ( word ) for word in strings ) / len ( strings )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print emphasized good the given txt message [CODESPLIT] def good ( txt ) : print ( \"%s# %s%s%s\" % ( PR_GOOD_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "move the cursor to the given co - ordinates . Co - ordinates are 1 based as listed in the status area of the terminal . [CODESPLIT] def move_to ( self , ypos , xpos ) : # the screen's co-ordinates are 1 based, but the command is 0 based xpos -= 1 ypos -= 1 self . exec_command ( \"MoveCursor({0}, {1})\" . format ( ypos , xpos ) . encode ( \"ascii\" ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a object into dictionary with all of its readable attributes . [CODESPLIT] def dict_from_object ( obj : object ) : # If object is a dict instance, no need to convert. return ( obj if isinstance ( obj , dict ) else { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( '_' ) } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip excess spaces from a string [CODESPLIT] def strip_spaces ( s ) : return u\" \" . join ( [ c for c in s . split ( u' ' ) if c ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a scatter plot . [CODESPLIT] def scatter ( self , * args , * * kwargs ) : cls = _make_class ( ScatterVisual , _default_marker = kwargs . pop ( 'marker' , None ) , ) return self . _add_item ( cls , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Download file from S3 Bucket [CODESPLIT] def download_file_from_bucket ( self , bucket , file_path , key ) : with open ( file_path , 'wb' ) as data : self . __s3 . download_fileobj ( bucket , key , data ) return file_path", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return BGR image read by opencv [CODESPLIT] def imdecode ( image_path ) : import os assert os . path . exists ( image_path ) , image_path + ' not found' im = cv2 . imread ( image_path ) return im", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute a normal python statement in user namespace . [CODESPLIT] def ex ( self , cmd ) : with self . builtin_trap : exec cmd in self . user_global_ns , self . user_ns", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses dynamic programming to infer the location of spaces in a string without spaces . [CODESPLIT] def split ( s ) : l = [ _split ( x ) for x in _SPLIT_RE . split ( s ) ] return [ item for sublist in l for item in sublist ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert datetime to julian date [CODESPLIT] def dt2jd ( dt ) : a = ( 14 - dt . month ) // 12 y = dt . year + 4800 - a m = dt . month + 12 * a - 3 return dt . day + ( ( 153 * m + 2 ) // 5 ) + 365 * y + y // 4 - y // 100 + y // 400 - 32045", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns Gaussian smoothed image . [CODESPLIT] def smooth_gaussian ( image , sigma = 1 ) : return scipy . ndimage . filters . gaussian_filter ( image , sigma = sigma , mode = \"nearest\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coerce value to an JSON - compatible representation . [CODESPLIT] def _time_to_json ( value ) : if isinstance ( value , datetime . time ) : value = value . isoformat ( ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Computes the unnormalized PDF of the normal distribution . [CODESPLIT] def EvalGaussianPdf ( x , mu , sigma ) : return scipy . stats . norm . pdf ( x , mu , sigma )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts bokehJS timestamp to datetime64 . [CODESPLIT] def convert_timestamp ( timestamp ) : datetime = dt . datetime . utcfromtimestamp ( timestamp / 1000. ) return np . datetime64 ( datetime . replace ( tzinfo = None ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to easily create the proper json formated string from a list of strs : param cmd_list : list of strings : return : str json formatted [CODESPLIT] def _make_cmd_list ( cmd_list ) : cmd = '' for i in cmd_list : cmd = cmd + '\"' + i + '\",' cmd = cmd [ : - 1 ] return cmd", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates the accuracy of the tree by comparing the model predictions to the dataset ( TP + TN ) / ( TP + TN + FP + FN ) == ( T / ( T + F )) [CODESPLIT] def accuracy ( self ) : sub_observed = np . array ( [ self . observed . metadata [ i ] for i in self . observed . arr ] ) return float ( ( self . model_predictions ( ) == sub_observed ) . sum ( ) ) / self . data_size", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate JSONLD file from biolink schema [CODESPLIT] def cli ( yamlfile , format , context ) : print ( JSONLDGenerator ( yamlfile , format ) . serialize ( context = context ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A standard compound hash . [CODESPLIT] def double_sha256 ( data ) : return bytes_as_revhex ( hashlib . sha256 ( hashlib . sha256 ( data ) . digest ( ) ) . digest ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the list of unique cantons sorted by name . [CODESPLIT] def get_cantons ( self ) : return sorted ( list ( set ( [ location . canton for location in self . get_locations ( ) . values ( ) ] ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns a dictionary of arg_name : default_values for the input function [CODESPLIT] def get_default_args ( func ) : args , varargs , keywords , defaults = getargspec_no_self ( func ) return dict ( zip ( args [ - len ( defaults ) : ] , defaults ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns given method name . [CODESPLIT] def get_method_name ( method ) : name = get_object_name ( method ) if name . startswith ( \"__\" ) and not name . endswith ( \"__\" ) : name = \"_{0}{1}\" . format ( get_object_name ( method . im_class ) , name ) return name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add the default arguments to the parser . [CODESPLIT] def _add_default_arguments ( parser ) : parser . add_argument ( '-c' , '--config' , action = 'store' , dest = 'config' , help = 'Path to the configuration file' ) parser . add_argument ( '-f' , '--foreground' , action = 'store_true' , dest = 'foreground' , help = 'Run the application interactively' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the names of all callable attributes of an object [CODESPLIT] def get_methods ( * objs ) : return set ( attr for obj in objs for attr in dir ( obj ) if not attr . startswith ( '_' ) and callable ( getattr ( obj , attr ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": return : list (( option value ) ... ) pairs of all items in the given section [CODESPLIT] def items ( self , section_name ) : return [ ( k , v ) for k , v in super ( GitConfigParser , self ) . items ( section_name ) if k != '__name__' ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a list of point objects ( which must have x and y fields ) . Returns a list of 3 - tuples : the indices of the points that form a Delaunay triangle . [CODESPLIT] def computeDelaunayTriangulation ( points ) : siteList = SiteList ( points ) context = Context ( ) context . triangulate = True voronoi ( siteList , context ) return context . triangles", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return list of the key property names for a class [CODESPLIT] def get_keys_from_class ( cc ) : return [ prop . name for prop in cc . properties . values ( ) if 'key' in prop . qualifiers ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes the venv by name [CODESPLIT] def rm ( venv_name ) : inenv = InenvManager ( ) venv = inenv . get_venv ( venv_name ) click . confirm ( \"Delete dir {}\" . format ( venv . path ) ) shutil . rmtree ( venv . path )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return names of all the addressable columns ( including foreign keys ) referenced in user supplied model [CODESPLIT] def columns ( self ) : res = [ col [ 'name' ] for col in self . column_definitions ] res . extend ( [ col [ 'name' ] for col in self . foreign_key_definitions ] ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove all non - MagIC columns from all tables . [CODESPLIT] def remove_non_magic_cols ( self ) : for table_name in self . tables : table = self . tables [ table_name ] table . remove_non_magic_cols_from_table ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get object from string reference . [CODESPLIT] def get_obj ( ref ) : oid = int ( ref ) return server . id2ref . get ( oid ) or server . id2obj [ oid ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the angle between two points . [CODESPLIT] def angle ( x0 , y0 , x1 , y1 ) : return degrees ( atan2 ( y1 - y0 , x1 - x0 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove duplicates from an iterable preserving the order . [CODESPLIT] def delete_duplicates ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tries to guess extension for a mimetype . [CODESPLIT] def guess_extension ( amimetype , normalize = False ) : ext = _mimes . guess_extension ( amimetype ) if ext and normalize : # Normalize some common magic mis-interpreation ext = { '.asc' : '.txt' , '.obj' : '.bin' } . get ( ext , ext ) from invenio . legacy . bibdocfile . api_normalizer import normalize_format return normalize_format ( ext ) return ext", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete the session and clear temporary directories [CODESPLIT] def reset ( ) : shutil . rmtree ( session [ 'img_input_dir' ] ) shutil . rmtree ( session [ 'img_output_dir' ] ) session . clear ( ) return jsonify ( ok = 'true' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list of all the image s colors . [CODESPLIT] def get_colors ( img ) : w , h = img . size return [ color [ : 3 ] for count , color in img . convert ( 'RGB' ) . getcolors ( w * h ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine memory specifications of the machine . [CODESPLIT] def memory ( ) : mem_info = dict ( ) for k , v in psutil . virtual_memory ( ) . _asdict ( ) . items ( ) : mem_info [ k ] = int ( v ) return mem_info", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform check_array ( X ) after removing infinite values ( numpy . inf ) from the given distance matrix . [CODESPLIT] def check_precomputed_distance_matrix ( X ) : tmp = X . copy ( ) tmp [ np . isinf ( tmp ) ] = 1 check_array ( tmp )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates and returns a month number basing on PESEL standard . [CODESPLIT] def calculate_month ( birth_date ) : year = int ( birth_date . strftime ( '%Y' ) ) month = int ( birth_date . strftime ( '%m' ) ) + ( ( int ( year / 100 ) - 14 ) % 5 ) * 20 return month", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a string composed of elements in inlist with each element separated by delimiter . Used by function writedelimited . Use \\ t for tab - delimiting . [CODESPLIT] def linedelimited ( inlist , delimiter ) : outstr = '' for item in inlist : if type ( item ) != StringType : item = str ( item ) outstr = outstr + item + delimiter outstr = outstr [ 0 : - 1 ] return outstr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the month start date a nd end date [CODESPLIT] def get_month_start_end_day ( ) : t = date . today ( ) n = mdays [ t . month ] return ( date ( t . year , t . month , 1 ) , date ( t . year , t . month , n ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Dequeue a record and return item . [CODESPLIT] def dequeue ( self , block = True ) : return self . queue . get ( block , self . queue_get_timeout )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extracts the real value to be returned from the wrapping callable . [CODESPLIT] def return_value ( self , * args , * * kwargs ) : self . _called ( ) return self . _return_value ( * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the default stream encoding if not found . [CODESPLIT] def get_best_encoding ( stream ) : rv = getattr ( stream , 'encoding' , None ) or sys . getdefaultencoding ( ) if is_ascii_encoding ( rv ) : return 'utf-8' return rv", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return this path as a relative path based from the current working directory . [CODESPLIT] def relpath ( self ) : cwd = self . __class__ ( os . getcwdu ( ) ) return cwd . relpathto ( self )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if we are on a Lyon machine [CODESPLIT] def we_are_in_lyon ( ) : import socket try : hostname = socket . gethostname ( ) ip = socket . gethostbyname ( hostname ) except socket . gaierror : return False return ip . startswith ( \"134.158.\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates the distance between two points on earth . [CODESPLIT] def _calculate_distance ( latlon1 , latlon2 ) : lat1 , lon1 = latlon1 lat2 , lon2 = latlon2 dlon = lon2 - lon1 dlat = lat2 - lat1 R = 6371 # radius of the earth in kilometers a = np . sin ( dlat / 2 ) ** 2 + np . cos ( lat1 ) * np . cos ( lat2 ) * ( np . sin ( dlon / 2 ) ) ** 2 c = 2 * np . pi * R * np . arctan2 ( np . sqrt ( a ) , np . sqrt ( 1 - a ) ) / 180 return c", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if all the args are functions and / or subroutines [CODESPLIT] def is_callable ( * p ) : import symbols return all ( isinstance ( x , symbols . FUNCTION ) for x in p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine whether two strings are equivalent . [CODESPLIT] def eqstr ( a , b ) : return bool ( libspice . eqstr_c ( stypes . stringToCharP ( a ) , stypes . stringToCharP ( b ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get element by name [CODESPLIT] def get_by ( self , name ) : return next ( ( item for item in self if item . name == name ) , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validate a parameter dict against a parameter schema from an ocrd - tool . json [CODESPLIT] def validate ( self , * args , * * kwargs ) : # pylint: disable=arguments-differ return super ( ParameterValidator , self ) . _validate ( * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the parent directory of a filename . [CODESPLIT] def get_parent_dir ( name ) : parent_dir = os . path . dirname ( os . path . dirname ( name ) ) if parent_dir : return parent_dir return os . path . abspath ( '.' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Similar to : attr : . Guild . me except it may return the : class : . ClientUser in private message contexts . [CODESPLIT] def me ( self ) : return self . guild . me if self . guild is not None else self . bot . user", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the size in bytes . [CODESPLIT] def get_size_in_bytes ( self , handle ) : fpath = self . _fpath_from_handle ( handle ) return os . stat ( fpath ) . st_size", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns all existing guestbook records . [CODESPLIT] def show_guestbook ( ) : cursor = flask . g . db . execute ( 'SELECT name, message FROM entry ORDER BY id DESC;' ) entries = [ { 'name' : row [ 0 ] , 'message' : row [ 1 ] } for row in cursor . fetchall ( ) ] return jinja2 . Template ( LAYOUT ) . render ( entries = entries )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the first day of the given month . [CODESPLIT] def get_month_start ( day = None ) : day = add_timezone ( day or datetime . date . today ( ) ) return day . replace ( day = 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the HEAD commit SHA1 of repository in current dir . [CODESPLIT] def get_last_commit ( git_path = None ) : if git_path is None : git_path = GIT_PATH line = get_last_commit_line ( git_path ) revision_id = line . split ( ) [ 1 ] return revision_id", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty print a CSV file . [CODESPLIT] def csvpretty ( csvfile : csvfile = sys . stdin ) : shellish . tabulate ( csv . reader ( csvfile ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the size of a multidimansional array . [CODESPLIT] def array_dim ( arr ) : dim = [ ] while True : try : dim . append ( len ( arr ) ) arr = arr [ 0 ] except TypeError : return dim", "target": 1, "target_options": ["no_match", "match"]}
{"input": "split string into list of strings by specified number . [CODESPLIT] def _split_str ( s , n ) : length = len ( s ) return [ s [ i : i + n ] for i in range ( 0 , length , n ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the approximate size of the queue ( not reliable! ) . [CODESPLIT] def qsize ( self ) : self . mutex . acquire ( ) n = self . _qsize ( ) self . mutex . release ( ) return n", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a file is a static file ( which should be copied rather than compiled using Jinja2 ) . [CODESPLIT] def is_static ( self , filename ) : if self . staticpaths is None : # We're not using static file support return False for path in self . staticpaths : if filename . startswith ( path ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of the ( name value ) pairs of the enum . [CODESPLIT] def items ( self ) : return [ ( value_descriptor . name , value_descriptor . number ) for value_descriptor in self . _enum_type . values ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Collect and serve static files . [CODESPLIT] def serve_static ( request , path , insecure = False , * * kwargs ) : # Follow the same logic Django uses for determining access to the # static-serving view. if not django_settings . DEBUG and not insecure : raise ImproperlyConfigured ( \"The staticfiles view can only be used in \" \"debug mode or if the --insecure \" \"option of 'runserver' is used\" ) if not settings . PIPELINE_ENABLED and settings . PIPELINE_COLLECTOR_ENABLED : # Collect only the requested file, in order to serve the result as # fast as possible. This won't interfere with the template tags in any # way, as those will still cause Django to collect all media. default_collector . collect ( request , files = [ path ] ) return serve ( request , path , document_root = django_settings . STATIC_ROOT , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "All values for this enum : return : list of tuples [CODESPLIT] def items ( cls ) : return [ cls . PRECIPITATION , cls . WIND , cls . TEMPERATURE , cls . PRESSURE ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Go to the end of the current line and create a new line [CODESPLIT] def go_to_new_line ( self ) : self . stdkey_end ( False , False ) self . insert_text ( self . get_line_separator ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a sorted list of all system font names [CODESPLIT] def get_font_list ( ) : font_map = pangocairo . cairo_font_map_get_default ( ) font_list = [ f . get_name ( ) for f in font_map . list_families ( ) ] font_list . sort ( ) return font_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of dictionaries which are sorted for only unique entries . [CODESPLIT] def unique_list_dicts ( dlist , key ) : return list ( dict ( ( val [ key ] , val ) for val in dlist ) . values ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove decoded instruction from instruction cache [CODESPLIT] def invalidate_cache ( cpu , address , size ) : cache = cpu . instruction_cache for offset in range ( size ) : if address + offset in cache : del cache [ address + offset ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the local ip of this device [CODESPLIT] def _get_local_ip ( ) : return set ( [ x [ 4 ] [ 0 ] for x in socket . getaddrinfo ( socket . gethostname ( ) , 80 , socket . AF_INET ) ] ) . pop ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a copy of a dictionary with all keys converted to snake case . This is just calls to_snake_case on each of the keys in the dictionary and returns a new dictionary . [CODESPLIT] def keys_to_snake_case ( camel_case_dict ) : return dict ( ( to_snake_case ( key ) , value ) for ( key , value ) in camel_case_dict . items ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieves a list of member - like objects ( members or properties ) that are publically exposed . [CODESPLIT] def get_public_members ( obj ) : return { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( \"_\" ) and not hasattr ( getattr ( obj , attr ) , '__call__' ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Timer used for calculate time elapsed [CODESPLIT] def timer ( ) : if sys . platform == \"win32\" : default_timer = time . clock else : default_timer = time . time return default_timer ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get the current month s last day : param year : default to current year : param month : default to current month : return : month s last day [CODESPLIT] def last_day ( year = _year , month = _month ) : last_day = calendar . monthrange ( year , month ) [ 1 ] return datetime . date ( year = year , month = month , day = last_day )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns the unit tangent vector of the segment at t ( centered at the origin and expressed as a complex number ) . [CODESPLIT] def unit_tangent ( self , t ) : dseg = self . derivative ( t ) return dseg / abs ( dseg )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns names of object columns in the DataFrame . [CODESPLIT] def get_obj_cols ( df ) : obj_cols = [ ] for idx , dt in enumerate ( df . dtypes ) : if dt == 'object' or is_category ( dt ) : obj_cols . append ( df . columns . values [ idx ] ) return obj_cols", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates Camera . aspect to match the viewport s aspect ratio . [CODESPLIT] def match_aspect_to_viewport ( self ) : viewport = self . viewport self . aspect = float ( viewport . width ) / viewport . height", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove duplicates in a list . [CODESPLIT] def _uniquify ( _list ) : seen = set ( ) result = [ ] for x in _list : if x not in seen : result . append ( x ) seen . add ( x ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format a duration in seconds . [CODESPLIT] def fmt_duration ( secs ) : return ' ' . join ( fmt . human_duration ( secs , 0 , precision = 2 , short = True ) . strip ( ) . split ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return module * modname * base path [CODESPLIT] def get_module_path ( modname ) : return osp . abspath ( osp . dirname ( sys . modules [ modname ] . __file__ ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a hash of a NumPy array . [CODESPLIT] def np_hash ( a ) : if a is None : return hash ( None ) # Ensure that hashes are equal whatever the ordering in memory (C or # Fortran) a = np . ascontiguousarray ( a ) # Compute the digest and return a decimal int return int ( hashlib . sha1 ( a . view ( a . dtype ) ) . hexdigest ( ) , 16 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return pinyin of string the string must be unicode [CODESPLIT] def get ( s , delimiter = '' , format = \"diacritical\" ) : return delimiter . join ( _pinyin_generator ( u ( s ) , format = format ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the eigvals of mat and then find the center eigval difference . [CODESPLIT] def center_eigenvalue_diff ( mat ) : N = len ( mat ) evals = np . sort ( la . eigvals ( mat ) ) diff = np . abs ( evals [ N / 2 ] - evals [ N / 2 - 1 ] ) return diff", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a property by name [CODESPLIT] def get_property_by_name ( pif , name ) : return next ( ( x for x in pif . properties if x . name == name ) , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the size of a file - like object . [CODESPLIT] def get_file_size ( fileobj ) : currpos = fileobj . tell ( ) fileobj . seek ( 0 , 2 ) total_size = fileobj . tell ( ) fileobj . seek ( currpos ) return total_size", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the eigvals of mat and then find the center eigval difference . [CODESPLIT] def center_eigenvalue_diff ( mat ) : N = len ( mat ) evals = np . sort ( la . eigvals ( mat ) ) diff = np . abs ( evals [ N / 2 ] - evals [ N / 2 - 1 ] ) return diff", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Estimates the memory of the supplied array in bytes [CODESPLIT] def array_bytes ( array ) : return np . product ( array . shape ) * np . dtype ( array . dtype ) . itemsize", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clear all indexes in the es core [CODESPLIT] def clear_es ( ) : # TODO: should receive a catalog slug. ESHypermap . es . indices . delete ( ESHypermap . index_name , ignore = [ 400 , 404 ] ) LOGGER . debug ( 'Elasticsearch: Index cleared' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract the boundaries from a list of indexes [CODESPLIT] def get_idx_rect ( index_list ) : rows , cols = list ( zip ( * [ ( i . row ( ) , i . column ( ) ) for i in index_list ] ) ) return ( min ( rows ) , max ( rows ) , min ( cols ) , max ( cols ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return list - lookalike of representation string of objects [CODESPLIT] def __repr__ ( self ) : strings = [ ] for currItem in self : strings . append ( \"%s\" % currItem ) return \"(%s)\" % ( \", \" . join ( strings ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Provide the root module of a TF - 2 . 0 API for use within TensorBoard . [CODESPLIT] def tf2 ( ) : # Import the `tf` compat API from this file and check if it's already TF 2.0. if tf . __version__ . startswith ( '2.' ) : return tf elif hasattr ( tf , 'compat' ) and hasattr ( tf . compat , 'v2' ) : # As a fallback, try `tensorflow.compat.v2` if it's defined. return tf . compat . v2 raise ImportError ( 'cannot import tensorflow 2.0 API' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a string containing comma separated email addresses into a list of email addresses . [CODESPLIT] def split_addresses ( email_string_list ) : return [ f for f in [ s . strip ( ) for s in email_string_list . split ( \",\" ) ] if f ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Encode a python boolean ( True / False ) . [CODESPLIT] def _encode_bool ( name , value , dummy0 , dummy1 ) : return b\"\\x08\" + name + ( value and b\"\\x01\" or b\"\\x00\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the index of an element in the list . [CODESPLIT] def get_list_index ( lst , index_or_name ) : if isinstance ( index_or_name , six . integer_types ) : return index_or_name return lst . index ( index_or_name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if cursor is on bottom right corner of a hot spot . [CODESPLIT] def get_bottomrect_idx ( self , pos ) : for i , r in enumerate ( self . link_bottom_rects ) : if r . Contains ( pos ) : return i return - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert datetime to epoch seconds . [CODESPLIT] def _dt_to_epoch ( dt ) : try : epoch = dt . timestamp ( ) except AttributeError : # py2 epoch = ( dt - datetime ( 1970 , 1 , 1 ) ) . total_seconds ( ) return epoch", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the absolute position of table top [CODESPLIT] def table_top_abs ( self ) : table_height = np . array ( [ 0 , 0 , self . table_full_size [ 2 ] ] ) return string_to_array ( self . floor . get ( \"pos\" ) ) + table_height", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Plots the epsilon residuals for the variogram fit . [CODESPLIT] def plot_epsilon_residuals ( self ) : fig = plt . figure ( ) ax = fig . add_subplot ( 111 ) ax . scatter ( range ( self . epsilon . size ) , self . epsilon , c = 'k' , marker = '*' ) ax . axhline ( y = 0.0 ) plt . show ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a property by name [CODESPLIT] def get_property_by_name ( pif , name ) : return next ( ( x for x in pif . properties if x . name == name ) , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "sets the aspect ratio of the current zoom level of the imshow image [CODESPLIT] def image_set_aspect ( aspect = 1.0 , axes = \"gca\" ) : if axes is \"gca\" : axes = _pylab . gca ( ) e = axes . get_images ( ) [ 0 ] . get_extent ( ) axes . set_aspect ( abs ( ( e [ 1 ] - e [ 0 ] ) / ( e [ 3 ] - e [ 2 ] ) ) / aspect )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like a bulk : meth : forceput . [CODESPLIT] def forceupdate ( self , * args , * * kw ) : self . _update ( False , self . _ON_DUP_OVERWRITE , * args , * * kw )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the MachineGuid from HKEY_LOCAL_MACHINE \\ Software \\ Microsoft \\ Cryptography \\ MachineGuid [CODESPLIT] def get_nt_system_uid ( ) : try : import _winreg as winreg except ImportError : import winreg lm = winreg . ConnectRegistry ( None , winreg . HKEY_LOCAL_MACHINE ) try : key = winreg . OpenKey ( lm , r\"Software\\Microsoft\\Cryptography\" ) try : return winreg . QueryValueEx ( key , \"MachineGuid\" ) [ 0 ] finally : key . Close ( ) finally : lm . Close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the element with the specified ID . [CODESPLIT] def get_element_with_id ( self , id ) : # Should we maintain a hashmap of ids to make this more efficient? Probably overkill. # TODO: Elements can contain nested elements (captions, footnotes, table cells, etc.) return next ( ( el for el in self . elements if el . id == id ) , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The Euclidean distance between two vectors . [CODESPLIT] def vector_distance ( a , b ) : a = np . array ( a ) b = np . array ( b ) return np . linalg . norm ( a - b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The url of this window [CODESPLIT] def url ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . url", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Square of the euclidean distance [CODESPLIT] def euclidean ( c1 , c2 ) : diffs = ( ( i - j ) for i , j in zip ( c1 , c2 ) ) return sum ( x * x for x in diffs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return current free memory on the machine for windows . [CODESPLIT] def get_free_memory_win ( ) : stat = MEMORYSTATUSEX ( ) ctypes . windll . kernel32 . GlobalMemoryStatusEx ( ctypes . byref ( stat ) ) return int ( stat . ullAvailPhys / 1024 / 1024 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Evaluate the XPath expression in the given context . [CODESPLIT] def xpathEvalExpression ( self , str ) : ret = libxml2mod . xmlXPathEvalExpression ( str , self . _o ) if ret is None : raise xpathError ( 'xmlXPathEvalExpression() failed' ) return xpathObjectRet ( ret )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the string name of an enum value . [CODESPLIT] def EnumValueName ( self , enum , value ) : return self . enum_types_by_name [ enum ] . values_by_number [ value ] . name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the volume group extent count . [CODESPLIT] def extent_count ( self ) : self . open ( ) count = lvm_vg_get_extent_count ( self . handle ) self . close ( ) return count", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return whether two objects are equal via recursion using : func : numpy . array_equal for comparing numpy arays . [CODESPLIT] def numpy_aware_eq ( a , b ) : if isinstance ( a , np . ndarray ) or isinstance ( b , np . ndarray ) : return np . array_equal ( a , b ) if ( ( isinstance ( a , Iterable ) and isinstance ( b , Iterable ) ) and not isinstance ( a , str ) and not isinstance ( b , str ) ) : if len ( a ) != len ( b ) : return False return all ( numpy_aware_eq ( x , y ) for x , y in zip ( a , b ) ) return a == b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The title of this window [CODESPLIT] def title ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . title", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return type may come from any boolop operand . [CODESPLIT] def visit_BoolOp ( self , node ) : return sum ( ( self . visit ( value ) for value in node . values ) , [ ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the text for the given root node ( xml . dom . minidom ) . [CODESPLIT] def __get_xml_text ( root ) : txt = \"\" for e in root . childNodes : if ( e . nodeType == e . TEXT_NODE ) : txt += e . data return txt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the given code line by line with printing as list of lines and return variable ans . [CODESPLIT] def runcode ( code ) : for line in code : print ( '# ' + line ) exec ( line , globals ( ) ) print ( '# return ans' ) return ans", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This parallel fetcher uses gevent one uses gevent [CODESPLIT] def fetch_event ( urls ) : rs = ( grequests . get ( u ) for u in urls ) return [ content . json ( ) for content in grequests . map ( rs ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return evidence codes in order shown in code2name . [CODESPLIT] def get_order ( self , codes ) : return sorted ( codes , key = lambda e : [ self . ev2idx . get ( e ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "takes flags returns indexes of True values [CODESPLIT] def equal ( list1 , list2 ) : return [ item1 == item2 for item1 , item2 in broadcast_zip ( list1 , list2 ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute the SQL command and return the data rows as tuples [CODESPLIT] def select ( self , cmd , * args , * * kwargs ) : self . cursor . execute ( cmd , * args , * * kwargs ) return self . cursor . fetchall ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Go to parent directory [CODESPLIT] def go_to_parent_directory ( self ) : self . chdir ( osp . abspath ( osp . join ( getcwd_or_home ( ) , os . pardir ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A small helper function to convert a string to a numeric value if appropriate [CODESPLIT] def _convert_to_float_if_possible ( s ) : try : ret = float ( s ) except ( ValueError , TypeError ) : ret = s return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "g [CODESPLIT] def _top ( self ) : # Goto top of the list self . top . body . focus_position = 2 if self . compact is False else 0 self . top . keypress ( self . size , \"\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function used to fit the exponential decay . [CODESPLIT] def exp_fit_fun ( x , a , tau , c ) : # pylint: disable=invalid-name return a * np . exp ( - x / tau ) + c", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts from a Minigo coordinate to a GTP coordinate . [CODESPLIT] def to_gtp ( coord ) : if coord is None : return 'pass' y , x = coord return '{}{}' . format ( _GTP_COLUMNS [ x ] , go . N - y )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the last n results ( or possibly less if not found ) . Note that the last results are not necessarily the best ones! Depending on the search type . [CODESPLIT] def searchlast ( self , n = 10 ) : solutions = deque ( [ ] , n ) for solution in self : solutions . append ( solution ) return solutions", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transforms dataframe to json response [CODESPLIT] def to_json ( df , state_index , color_index , fills ) : records = { } for i , row in df . iterrows ( ) : records [ row [ state_index ] ] = { \"fillKey\" : row [ color_index ] } return { \"data\" : records , \"fills\" : fills }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "create a graphviz graph from text [CODESPLIT] def _text_to_graphiz ( self , text ) : dot = Source ( text , format = 'svg' ) return dot . pipe ( ) . decode ( 'utf-8' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list of all the image s colors . [CODESPLIT] def get_colors ( img ) : w , h = img . size return [ color [ : 3 ] for count , color in img . convert ( 'RGB' ) . getcolors ( w * h ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Round a time DOWN to half nearest half - hour . [CODESPLIT] def _round_half_hour ( record ) : k = record . datetime + timedelta ( minutes = - ( record . datetime . minute % 30 ) ) return datetime ( k . year , k . month , k . day , k . hour , k . minute , 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return zero - th element of a one - element data container . [CODESPLIT] def get_X0 ( X ) : if pandas_available and isinstance ( X , pd . DataFrame ) : assert len ( X ) == 1 x = np . array ( X . iloc [ 0 ] ) else : x , = X return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Enables multithreading support in Xlib and PyGTK . See the module docstring for more info . : Parameters : gtk : bool May be set to False to skip the PyGTK module . [CODESPLIT] def threads_init ( gtk = True ) : # enable X11 multithreading x11 . XInitThreads ( ) if gtk : from gtk . gdk import threads_init threads_init ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print security object information for a pdf document [CODESPLIT] def security ( self ) : return { k : v for i in self . pdf . resolvedObjects . items ( ) for k , v in i [ 1 ] . items ( ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Enable event loop integration with Gtk3 ( gir bindings ) . [CODESPLIT] def enable_gtk3 ( self , app = None ) : from pydev_ipython . inputhookgtk3 import create_inputhook_gtk3 self . set_inputhook ( create_inputhook_gtk3 ( self . _stdin_file ) ) self . _current_gui = GUI_GTK", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take arrays a and b and form the dot product between the last axis of a and the first of b . [CODESPLIT] def dot ( a , b ) : b = numpy . asarray ( b ) return numpy . dot ( a , b . reshape ( b . shape [ 0 ] , - 1 ) ) . reshape ( a . shape [ : - 1 ] + b . shape [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Guess string encoding . [CODESPLIT] def guess_encoding ( text , default = DEFAULT_ENCODING ) : result = chardet . detect ( text ) return normalize_result ( result , default = default )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform check_array ( X ) after removing infinite values ( numpy . inf ) from the given distance matrix . [CODESPLIT] def check_precomputed_distance_matrix ( X ) : tmp = X . copy ( ) tmp [ np . isinf ( tmp ) ] = 1 check_array ( tmp )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compress a file returning the new filename ( . gz ) [CODESPLIT] def __gzip ( filename ) : zipname = filename + '.gz' file_pointer = open ( filename , 'rb' ) zip_pointer = gzip . open ( zipname , 'wb' ) zip_pointer . writelines ( file_pointer ) file_pointer . close ( ) zip_pointer . close ( ) return zipname", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Allows to open the hdf5 file with specified cache size [CODESPLIT] def create_h5py_with_large_cache ( filename , cache_size_mb ) : # h5py does not allow to control the cache size from the high level # we employ the workaround # sources: #http://stackoverflow.com/questions/14653259/how-to-set-cache-settings-while-using-h5py-high-level-interface #https://groups.google.com/forum/#!msg/h5py/RVx1ZB6LpE4/KH57vq5yw2AJ propfaid = h5py . h5p . create ( h5py . h5p . FILE_ACCESS ) settings = list ( propfaid . get_cache ( ) ) settings [ 2 ] = 1024 * 1024 * cache_size_mb propfaid . set_cache ( * settings ) fid = h5py . h5f . create ( filename , flags = h5py . h5f . ACC_EXCL , fapl = propfaid ) fin = h5py . File ( fid ) return fin", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Computes 2D spectrum frequencies . [CODESPLIT] def rfft2d_freqs ( h , w ) : fy = np . fft . fftfreq ( h ) [ : , None ] # when we have an odd input dimension we need to keep one additional # frequency and later cut off 1 pixel if w % 2 == 1 : fx = np . fft . fftfreq ( w ) [ : w // 2 + 2 ] else : fx = np . fft . fftfreq ( w ) [ : w // 2 + 1 ] return np . sqrt ( fx * fx + fy * fy )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the md5 hash of the given file - object [CODESPLIT] def md5_hash_file ( fh ) : md5 = hashlib . md5 ( ) while True : data = fh . read ( 8192 ) if not data : break md5 . update ( data ) return md5 . hexdigest ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "a normal old python function to return the Nth fibonacci number . [CODESPLIT] def software_fibonacci ( n ) : a , b = 0 , 1 for i in range ( n ) : a , b = b , a + b return a", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a hdf5 file into a dictionary [CODESPLIT] def h5ToDict ( h5 , readH5pyDataset = True ) : h = h5py . File ( h5 , \"r\" ) ret = unwrapArray ( h , recursive = True , readH5pyDataset = readH5pyDataset ) if readH5pyDataset : h . close ( ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A function to vend the current zipfile if any [CODESPLIT] def current_zipfile ( ) : if zipfile . is_zipfile ( sys . argv [ 0 ] ) : fd = open ( sys . argv [ 0 ] , \"rb\" ) return zipfile . ZipFile ( fd )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "stupid windows . converts the backslash to forwardslash for consistency [CODESPLIT] def __unixify ( self , s ) : return os . path . normpath ( s ) . replace ( os . sep , \"/\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initializes an stdin input reader . [CODESPLIT] def __init__ ( self , encoding = 'utf-8' ) : super ( StdinInputReader , self ) . __init__ ( sys . stdin , encoding = encoding )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a leading hash # at the beginning of every line in the source . [CODESPLIT] def _add_hash ( source ) : source = '\\n' . join ( '# ' + line . rstrip ( ) for line in source . splitlines ( ) ) return source", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply a function in parallel to each element of the input [CODESPLIT] def apply ( f , obj , * args , * * kwargs ) : return vectorize ( f ) ( obj , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A standard compound hash . [CODESPLIT] def double_sha256 ( data ) : return bytes_as_revhex ( hashlib . sha256 ( hashlib . sha256 ( data ) . digest ( ) ) . digest ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transpose the columns into rows remove all of the rows that are empty after the first cell then transpose back . The result is that columns that have a header but no data in the body are removed assuming the header is the first row . [CODESPLIT] def drop_empty ( rows ) : return zip ( * [ col for col in zip ( * rows ) if bool ( filter ( bool , col [ 1 : ] ) ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Push item onto heap maintaining the heap invariant . [CODESPLIT] def heappush_max ( heap , item ) : heap . append ( item ) _siftdown_max ( heap , 0 , len ( heap ) - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a string containing comma separated email addresses into a list of email addresses . [CODESPLIT] def split_addresses ( email_string_list ) : return [ f for f in [ s . strip ( ) for s in email_string_list . split ( \",\" ) ] if f ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "why is this not in heapq [CODESPLIT] def _heappush_max ( heap , item ) : heap . append ( item ) heapq . _siftdown_max ( heap , 0 , len ( heap ) - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "copy the dict filter_keywords [CODESPLIT] def _remove_keywords ( d ) : return { k : v for k , v in iteritems ( d ) if k not in RESERVED }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform list into a maxheap in - place in O ( len ( x )) time . [CODESPLIT] def _heapify_max ( x ) : n = len ( x ) for i in reversed ( range ( n // 2 ) ) : _siftup_max ( x , i )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a copy of seq without duplicates . [CODESPLIT] def uniq ( seq ) : seen = set ( ) return [ x for x in seq if str ( x ) not in seen and not seen . add ( str ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pop the heap value from the heap . [CODESPLIT] def pop ( h ) : n = h . size ( ) - 1 h . swap ( 0 , n ) down ( h , 0 , n ) return h . pop ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace all the ocurrences ( in a file ) of a string with another value . [CODESPLIT] def replace_all ( filepath , searchExp , replaceExp ) : for line in fileinput . input ( filepath , inplace = 1 ) : if searchExp in line : line = line . replace ( searchExp , replaceExp ) sys . stdout . write ( line )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Use the plotter as callable . [CODESPLIT] def __call__ ( self , kind : Optional [ str ] = None , * * kwargs ) : return plot ( self . histogram , kind = kind , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a percentile range from an array of values . [CODESPLIT] def ci ( a , which = 95 , axis = None ) : p = 50 - which / 2 , 50 + which / 2 return percentiles ( a , p , axis )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pixel data type . [CODESPLIT] def dtype ( self ) : try : return self . data . dtype except AttributeError : return numpy . dtype ( '%s%d' % ( self . _sample_type , self . _sample_bytes ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Search tuple array by index and value : param t : tuple array : param i : index of the value in each tuple : param v : value : return : the first tuple in the array with the specific index / value [CODESPLIT] def tuple_search ( t , i , v ) : for e in t : if e [ i ] == v : return e return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like from pairs but combines duplicate key values into arrays : param pairs : : return : [CODESPLIT] def from_pairs_to_array_values ( pairs ) : result = { } for pair in pairs : result [ pair [ 0 ] ] = concat ( prop_or ( [ ] , pair [ 0 ] , result ) , [ pair [ 1 ] ] ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the area of a polygon given as x ( ... ) y ( ... ) Implementation of Shoelace formula [CODESPLIT] def area ( x , y ) : # http://stackoverflow.com/questions/24467972/calculate-area-of-polygon-given-x-y-coordinates return 0.5 * np . abs ( np . dot ( x , np . roll ( y , 1 ) ) - np . dot ( y , np . roll ( x , 1 ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the the super function . [CODESPLIT] def _getSuperFunc ( self , s , func ) : return getattr ( super ( self . cls ( ) , s ) , func . __name__ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert axis coordinate to bin index . [CODESPLIT] def val_to_bin ( edges , x ) : ibin = np . digitize ( np . array ( x , ndmin = 1 ) , edges ) - 1 return ibin", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert axis coordinate to bin index . [CODESPLIT] def val_to_bin ( edges , x ) : ibin = np . digitize ( np . array ( x , ndmin = 1 ) , edges ) - 1 return ibin", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compare by iteration [CODESPLIT] def compare ( dicts ) : common_members = { } common_keys = reduce ( lambda x , y : x & y , map ( dict . keys , dicts ) ) for k in common_keys : common_members [ k ] = list ( reduce ( lambda x , y : x & y , [ set ( d [ k ] ) for d in dicts ] ) ) return common_members", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts bokehJS timestamp to datetime64 . [CODESPLIT] def convert_timestamp ( timestamp ) : datetime = dt . datetime . utcfromtimestamp ( timestamp / 1000. ) return np . datetime64 ( datetime . replace ( tzinfo = None ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Official way to get the extension of compiled files ( . pyc or . pyo ) [CODESPLIT] def _get_compiled_ext ( ) : for ext , mode , typ in imp . get_suffixes ( ) : if typ == imp . PY_COMPILED : return ext", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def list_add_capitalize ( l ) : nl = [ ] for i in l : nl . append ( i ) if hasattr ( i , \"capitalize\" ) : nl . append ( i . capitalize ( ) ) return list ( set ( nl ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "inverse hyperbolic sine transformation [CODESPLIT] def inh ( table ) : t = [ ] for i in table : t . append ( np . ndarray . tolist ( np . arcsinh ( i ) ) ) return t", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert to camel case . [CODESPLIT] def to_camel_case ( text ) : split = text . split ( '_' ) return split [ 0 ] + \"\" . join ( x . title ( ) for x in split [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calcuates the median value in a [CODESPLIT] def median ( lst ) : #: http://stackoverflow.com/a/24101534 sortedLst = sorted ( lst ) lstLen = len ( lst ) index = ( lstLen - 1 ) // 2 if ( lstLen % 2 ) : return sortedLst [ index ] else : return ( sortedLst [ index ] + sortedLst [ index + 1 ] ) / 2.0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns whether error is likely to be retryable . [CODESPLIT] def _IsRetryable ( error ) : if not isinstance ( error , MySQLdb . OperationalError ) : return False if not error . args : return False code = error . args [ 0 ] return code in _RETRYABLE_ERRORS", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate all matches found within a string for a regex and yield each match as a string [CODESPLIT] def iter_finds ( regex_obj , s ) : if isinstance ( regex_obj , str ) : for m in re . finditer ( regex_obj , s ) : yield m . group ( ) else : for m in regex_obj . finditer ( s ) : yield m . group ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determines if a system process identifer exists in process table . [CODESPLIT] def pid_exists ( pid ) : try : os . kill ( pid , 0 ) except OSError as exc : return exc . errno == errno . EPERM else : return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get all the prime factor of given integer [CODESPLIT] def getPrimeFactors ( n ) : lo = [ 1 ] n2 = n // 2 k = 2 for k in range ( 2 , n2 + 1 ) : if ( n // k ) * k == n : lo . append ( k ) return lo + [ n , ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a numpy dtype determines whether it is a string . Returns True if the dtype is string or unicode . [CODESPLIT] def _isstring ( dtype ) : return dtype . type == numpy . unicode_ or dtype . type == numpy . string_", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find rightmost value less than x . [CODESPLIT] def find_lt ( a , x ) : i = bs . bisect_left ( a , x ) if i : return i - 1 raise ValueError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if a point is within this polygonal region [CODESPLIT] def is_in ( self , point_x , point_y ) : point_array = array ( ( ( point_x , point_y ) , ) ) vertices = array ( self . points ) winding = self . inside_rule == \"winding\" result = points_in_polygon ( point_array , vertices , winding ) return result [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the cR statistic for the variogram fit ( see [ 1 ] ) . [CODESPLIT] def calc_cR ( Q2 , sigma ) : return Q2 * np . exp ( np . sum ( np . log ( sigma ** 2 ) ) / sigma . shape [ 0 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if the given type is a builtin one . [CODESPLIT] def is_builtin_type ( tp ) : return hasattr ( __builtins__ , tp . __name__ ) and tp is getattr ( __builtins__ , tp . __name__ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply the coefficients from a linear fit to an array of x y positions . [CODESPLIT] def apply_fit ( xy , coeffs ) : x_new = coeffs [ 0 ] [ 2 ] + coeffs [ 0 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 0 ] [ 1 ] * xy [ : , 1 ] y_new = coeffs [ 1 ] [ 2 ] + coeffs [ 1 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 1 ] [ 1 ] * xy [ : , 1 ] return x_new , y_new", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Forget all loaded coordinates . [CODESPLIT] def forget_coords ( self ) : self . w . ntotal . set_text ( '0' ) self . coords_dict . clear ( ) self . redo ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function flatten given nested list . Argument : nested list Returns : flat list [CODESPLIT] def flat_list ( lst ) : if isinstance ( lst , list ) : for item in lst : for i in flat_list ( item ) : yield i else : yield lst", "target": 1, "target_options": ["no_match", "match"]}
{"input": "exit without breaking pipes . [CODESPLIT] def safe_exit ( output ) : try : sys . stdout . write ( output ) sys . stdout . flush ( ) except IOError : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flip an image horizontally or vertically . [CODESPLIT] def imflip ( img , direction = 'horizontal' ) : assert direction in [ 'horizontal' , 'vertical' ] if direction == 'horizontal' : return np . flip ( img , axis = 1 ) else : return np . flip ( img , axis = 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of dicionaries . See set_order . [CODESPLIT] def get_order ( self ) : return [ dict ( reverse = r [ 0 ] , key = r [ 1 ] ) for r in self . get_model ( ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Horizontally flip the given PIL Image . [CODESPLIT] def hflip ( img ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) return img . transpose ( Image . FLIP_LEFT_RIGHT )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create directory with template for topic of the current environment [CODESPLIT] def mkdir ( dir , enter ) : if not os . path . exists ( dir ) : os . makedirs ( dir )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the number of documents the specified term appears in . [CODESPLIT] def get_document_frequency ( self , term ) : if term not in self . _terms : raise IndexError ( TERM_DOES_NOT_EXIST ) else : return len ( self . _terms [ term ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cleanup the activty lifecycle listener [CODESPLIT] def destroy ( self ) : if self . widget : self . set_active ( False ) super ( AndroidBarcodeView , self ) . destroy ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Because there are dependencies that depend on other dependencies are created lists into other lists . Thus creating this loop create one - dimensional list and remove double packages from dependencies . [CODESPLIT] def one_for_all ( self , deps ) : requires , dependencies = [ ] , [ ] deps . reverse ( ) # Inverting the list brings the # dependencies in order to be installed. requires = Utils ( ) . dimensional_list ( deps ) dependencies = Utils ( ) . remove_dbs ( requires ) return dependencies", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Download the given JSON file and pretty - print before we output it . [CODESPLIT] def download_json ( local_filename , url , clobber = False ) : with open ( local_filename , 'w' ) as json_file : json_file . write ( json . dumps ( requests . get ( url ) . json ( ) , sort_keys = True , indent = 2 , separators = ( ',' , ': ' ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a password is valid [CODESPLIT] def is_password_valid ( password ) : pattern = re . compile ( r\"^.{4,75}$\" ) return bool ( pattern . match ( password ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalized Gaussian [CODESPLIT] def gauss_pdf ( x , mu , sigma ) : return 1 / np . sqrt ( 2 * np . pi ) / sigma * np . exp ( - ( x - mu ) ** 2 / 2. / sigma ** 2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalized Gaussian [CODESPLIT] def gauss_pdf ( x , mu , sigma ) : return 1 / np . sqrt ( 2 * np . pi ) / sigma * np . exp ( - ( x - mu ) ** 2 / 2. / sigma ** 2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Go to the end of the current line and create a new line [CODESPLIT] def go_to_new_line ( self ) : self . stdkey_end ( False , False ) self . insert_text ( self . get_line_separator ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Send a command string to gdb . [CODESPLIT] def ExecuteRaw ( self , position , command ) : self . EnsureGdbPosition ( position [ 0 ] , None , None ) return gdb . execute ( command , to_string = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print warning about interrupt and empty the job queue . [CODESPLIT] def finish ( ) : out . warn ( \"Interrupted!\" ) for t in threads : t . stop ( ) jobs . clear ( ) out . warn ( \"Waiting for download threads to finish.\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return random lognormal variates . [CODESPLIT] def rlognormal ( mu , tau , size = None ) : return np . random . lognormal ( mu , np . sqrt ( 1. / tau ) , size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a latitude longitude and a distance in miles calculate the co - ordinates of the bounding box 2 * miles on long each side with the given co - ordinates at the center . [CODESPLIT] def calculate_boundingbox ( lng , lat , miles ) : latChange = change_in_latitude ( miles ) latSouth = lat - latChange latNorth = lat + latChange lngChange = change_in_longitude ( lat , miles ) lngWest = lng + lngChange lngEast = lng - lngChange return ( lngWest , latSouth , lngEast , latNorth )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A quick and dirty way to get a unique string [CODESPLIT] def uniqueID ( size = 6 , chars = string . ascii_uppercase + string . digits ) : return '' . join ( random . choice ( chars ) for x in xrange ( size ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Represent string / bytes s as base64 omitting newlines [CODESPLIT] def toBase64 ( s ) : if isinstance ( s , str ) : s = s . encode ( \"utf-8\" ) return binascii . b2a_base64 ( s ) [ : - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return random disposition point . [CODESPLIT] def _rndPointDisposition ( dx , dy ) : x = int ( random . uniform ( - dx , dx ) ) y = int ( random . uniform ( - dy , dy ) ) return ( x , y )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the size of a multidimansional array . [CODESPLIT] def array_dim ( arr ) : dim = [ ] while True : try : dim . append ( len ( arr ) ) arr = arr [ 0 ] except TypeError : return dim", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Emit a sine wave at the given frequency . [CODESPLIT] def sine_wave ( frequency ) : xs = tf . reshape ( tf . range ( _samples ( ) , dtype = tf . float32 ) , [ 1 , _samples ( ) , 1 ] ) ts = xs / FLAGS . sample_rate return tf . sin ( 2 * math . pi * frequency * ts )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a random ( i . e . unique ) string identifier [CODESPLIT] def _get_random_id ( ) : symbols = string . ascii_uppercase + string . ascii_lowercase + string . digits return '' . join ( random . choice ( symbols ) for _ in range ( 15 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Step over the next statement [CODESPLIT] def do_next ( self , args ) : self . _do_print_from_last_cmd = True self . _interp . step_over ( ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A quick and dirty way to get a unique string [CODESPLIT] def uniqueID ( size = 6 , chars = string . ascii_uppercase + string . digits ) : return '' . join ( random . choice ( chars ) for x in xrange ( size ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes the write permissions for the given file for owner groups and others . [CODESPLIT] def make_file_read_only ( file_path ) : old_permissions = os . stat ( file_path ) . st_mode os . chmod ( file_path , old_permissions & ~ WRITE_PERMISSIONS )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the angle between two points . [CODESPLIT] def angle ( x0 , y0 , x1 , y1 ) : return degrees ( atan2 ( y1 - y0 , x1 - x0 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a copy of the dictionary . [CODESPLIT] def copy ( self ) : result = NocaseDict ( ) result . _data = self . _data . copy ( ) # pylint: disable=protected-access return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Does openat read - only then does fdopen to get a file object [CODESPLIT] def fopenat ( base_fd , path ) : return os . fdopen ( openat ( base_fd , path , os . O_RDONLY ) , 'rb' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dict of vars for the given class including all ancestors . [CODESPLIT] def vars_class ( cls ) : return dict ( chain . from_iterable ( vars ( cls ) . items ( ) for cls in reversed ( cls . __mro__ ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flat nested list of lists into a single list . [CODESPLIT] def flatten ( l , types = ( list , float ) ) : l = [ item if isinstance ( item , types ) else [ item ] for item in l ] return [ item for sublist in l for item in sublist ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calcuate mean datetime from datetime list [CODESPLIT] def mean_date ( dt_list ) : dt_list_sort = sorted ( dt_list ) dt_list_sort_rel = [ dt - dt_list_sort [ 0 ] for dt in dt_list_sort ] avg_timedelta = sum ( dt_list_sort_rel , timedelta ( ) ) / len ( dt_list_sort_rel ) return dt_list_sort [ 0 ] + avg_timedelta", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a tuple containing all elements of tup plus elem . [CODESPLIT] def _ensure_element ( tup , elem ) : try : return tup , tup . index ( elem ) except ValueError : return tuple ( chain ( tup , ( elem , ) ) ) , len ( tup )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The number of bits per sample in the audio encoding ( an int ) . Only available for certain file formats ( zero where unavailable ) . [CODESPLIT] def bitdepth ( self ) : if hasattr ( self . mgfile . info , 'bits_per_sample' ) : return self . mgfile . info . bits_per_sample return 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string from a form into an Enum value . [CODESPLIT] def to_python ( self , value ) : if value is None : return value if isinstance ( value , self . enum ) : return value return self . enum [ value ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns names of object columns in the DataFrame . [CODESPLIT] def get_obj_cols ( df ) : obj_cols = [ ] for idx , dt in enumerate ( df . dtypes ) : if dt == 'object' or is_category ( dt ) : obj_cols . append ( df . columns . values [ idx ] ) return obj_cols", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads the date from a string in the format YYYY / MM / DD and returns : class : datetime . date [CODESPLIT] def _read_date_from_string ( str1 ) : full_date = [ int ( x ) for x in str1 . split ( '/' ) ] return datetime . date ( full_date [ 0 ] , full_date [ 1 ] , full_date [ 2 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Merge all columns and place text string in widened cell . [CODESPLIT] def wr_row_mergeall ( self , worksheet , txtstr , fmt , row_idx ) : hdridxval = len ( self . hdrs ) - 1 worksheet . merge_range ( row_idx , 0 , row_idx , hdridxval , txtstr , fmt ) return row_idx + 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns all dates between two dates . [CODESPLIT] def dates_in_range ( start_date , end_date ) : return [ start_date + timedelta ( n ) for n in range ( int ( ( end_date - start_date ) . days ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sort input filename list by datetime [CODESPLIT] def sort_fn_list ( fn_list ) : dt_list = get_dt_list ( fn_list ) fn_list_sort = [ fn for ( dt , fn ) in sorted ( zip ( dt_list , fn_list ) ) ] return fn_list_sort", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Because standard distinct used on the all fields are very slow and works only with PostgreSQL database this method provides alternative to the standard distinct method . : return : qs with unique objects [CODESPLIT] def fast_distinct ( self ) : return self . model . objects . filter ( pk__in = self . values_list ( 'pk' , flat = True ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A helper to create a proxy method in a class . [CODESPLIT] def Proxy ( f ) : def Wrapped ( self , * args ) : return getattr ( self , f ) ( * args ) return Wrapped", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts XY point from Spherical Mercator EPSG : 900913 to lat / lon in WGS84 Datum [CODESPLIT] def metres2latlon ( mx , my , origin_shift = 2 * pi * 6378137 / 2.0 ) : lon = ( mx / origin_shift ) * 180.0 lat = ( my / origin_shift ) * 180.0 lat = 180 / pi * ( 2 * atan ( exp ( lat * pi / 180.0 ) ) - pi / 2.0 ) return lat , lon", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is to support iterators over a file - like object . [CODESPLIT] def next ( self ) : # File-like object. result = self . readline ( ) if result == self . _empty_buffer : raise StopIteration return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the md5 hash for a file . [CODESPLIT] def get_md5_for_file ( file ) : md5 = hashlib . md5 ( ) while True : data = file . read ( md5 . block_size ) if not data : break md5 . update ( data ) return md5 . hexdigest ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return the first n sentences with highest ranking [CODESPLIT] def _rank ( self , ranking , n ) : return nlargest ( n , ranking , key = ranking . get )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete all indexes for the database [CODESPLIT] def drop_indexes ( self ) : LOG . warning ( \"Dropping all indexe\" ) for collection_name in INDEXES : LOG . warning ( \"Dropping all indexes for collection name %s\" , collection_name ) self . db [ collection_name ] . drop_indexes ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the last object in file . [CODESPLIT] def last ( self ) : # End of file self . __file . seek ( 0 , 2 ) # Get the last struct data = self . get ( self . length - 1 ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Debug a single doctest docstring in argument src [CODESPLIT] def debug_src ( src , pm = False , globs = None ) : testsrc = script_from_examples ( src ) debug_script ( testsrc , pm , globs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last n rows in the table [CODESPLIT] def get_last_row ( dbconn , tablename , n = 1 , uuid = None ) : return fetch ( dbconn , tablename , n , uuid , end = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Saves this training state to fname . [CODESPLIT] def save ( self , fname : str ) : with open ( fname , \"wb\" ) as fp : pickle . dump ( self , fp )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the display length of a string . This can differ from the character length if the string contains wide characters . [CODESPLIT] def display_len ( text ) : text = unicodedata . normalize ( 'NFD' , text ) return sum ( char_width ( char ) for char in text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convenience method that works with all 2 . x versions of Python to determine whether or not something is stringlike . [CODESPLIT] def isString ( s ) : try : return isinstance ( s , unicode ) or isinstance ( s , basestring ) except NameError : return isinstance ( s , str )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function that gets relative path to the filename [CODESPLIT] def rel_path ( filename ) : return os . path . join ( os . getcwd ( ) , os . path . dirname ( __file__ ) , filename )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Local test . [CODESPLIT] def test ( ) : from spyder . utils . qthelpers import qapplication app = qapplication ( ) dlg = ProjectDialog ( None ) dlg . show ( ) sys . exit ( app . exec_ ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns given method name . [CODESPLIT] def get_method_name ( method ) : name = get_object_name ( method ) if name . startswith ( \"__\" ) and not name . endswith ( \"__\" ) : name = \"_{0}{1}\" . format ( get_object_name ( method . im_class ) , name ) return name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a random array with a fixed seed . [CODESPLIT] def const_rand ( size , seed = 23980 ) : old_seed = np . random . seed ( ) np . random . seed ( seed ) out = np . random . rand ( size ) np . random . seed ( old_seed ) return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return a list of methods on this class for executing actions . methods are return as a list of ( name func ) tuples [CODESPLIT] def get_action_methods ( self ) : return [ ( name , getattr ( self , name ) ) for name , _ in Action . get_command_types ( ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the number of rows of the main dataframe [CODESPLIT] def count_ ( self ) : try : num = len ( self . df . index ) except Exception as e : self . err ( e , \"Can not count data\" ) return return num", "target": 1, "target_options": ["no_match", "match"]}
{"input": "POST to an object . [CODESPLIT] def post_object_async ( self , path , * * kwds ) : return self . do_request_async ( self . api_url + path , 'POST' , * * kwds )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return first occurrence matching f otherwise None [CODESPLIT] def findfirst ( f , coll ) : result = list ( dropwhile ( f , coll ) ) return result [ 0 ] if result else None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a background thread for httpd and serve forever [CODESPLIT] def start ( self ) : self . _process = threading . Thread ( target = self . _background_runner ) self . _process . start ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a background thread for httpd and serve forever [CODESPLIT] def start ( self ) : self . _process = threading . Thread ( target = self . _background_runner ) self . _process . start ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pull a querystring value from the request . [CODESPLIT] def parse_querystring ( self , req , name , field ) : return core . get_value ( req . args , name , field )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Monkey - patch urllib3 with SecureTransport - backed SSL - support . [CODESPLIT] def inject_into_urllib3 ( ) : util . ssl_ . SSLContext = SecureTransportContext util . HAS_SNI = HAS_SNI util . ssl_ . HAS_SNI = HAS_SNI util . IS_SECURETRANSPORT = True util . ssl_ . IS_SECURETRANSPORT = True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format a duration in seconds . [CODESPLIT] def fmt_duration ( secs ) : return ' ' . join ( fmt . human_duration ( secs , 0 , precision = 2 , short = True ) . strip ( ) . split ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a default value if a file does not exist [CODESPLIT] def file_or_default ( path , default , function = None ) : try : result = file_get_contents ( path ) if function != None : return function ( result ) return result except IOError as e : if e . errno == errno . ENOENT : return default raise", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return start and end date of this quarter . [CODESPLIT] def this_quarter ( ) : since = TODAY + delta ( day = 1 ) while since . month % 3 != 0 : since -= delta ( months = 1 ) until = since + delta ( months = 3 ) return Date ( since ) , Date ( until )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to turn a string representation of true into boolean True . [CODESPLIT] def strToBool ( val ) : if isinstance ( val , str ) : val = val . lower ( ) return val in [ 'true' , 'on' , 'yes' , True ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the first day of the given month . [CODESPLIT] def get_month_start ( day = None ) : day = add_timezone ( day or datetime . date . today ( ) ) return day . replace ( day = 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clean the argument value to eliminate None or Falsy values if needed . [CODESPLIT] def clear_list_value ( self , value ) : # Don't go any further: this value is empty. if not value : return self . empty_value # Clean empty items if wanted if self . clean_empty : value = [ v for v in value if v ] return value or self . empty_value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the given command ( with shell = False ) and return a tuple of ( int returncode str output ) . Strip the output of enclosing whitespace . [CODESPLIT] def call_out ( command ) : # start external command process p = subprocess . Popen ( command , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) # get outputs out , _ = p . communicate ( ) return p . returncode , out . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determines if value value is empty . Keyword arguments : value str -- the value of the associated field to compare [CODESPLIT] def run ( self , value ) : if self . pass_ and not value . strip ( ) : return True if not value : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get width of a string in the current font [CODESPLIT] def _string_width ( self , s ) : s = str ( s ) w = 0 for i in s : w += self . character_widths [ i ] return w * self . font_size / 1000.0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convenience method that works with all 2 . x versions of Python to determine whether or not something is stringlike . [CODESPLIT] def isString ( s ) : try : return isinstance ( s , unicode ) or isinstance ( s , basestring ) except NameError : return isinstance ( s , str )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses box coordinates to crop an image without resizing it first . [CODESPLIT] def crop_box ( im , box = False , * * kwargs ) : if box : im = im . crop ( box ) return im", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize a field to a ( min max ) exposure range default is ( 0 255 ) . ( min max ) exposure values . Invert the image if requested . [CODESPLIT] def normalize ( im , invert = False , scale = None , dtype = np . float64 ) : if dtype not in { np . float16 , np . float32 , np . float64 } : raise ValueError ( 'dtype must be numpy.float16, float32, or float64.' ) out = im . astype ( 'float' ) . copy ( ) scale = scale or ( 0.0 , 255.0 ) l , u = ( float ( i ) for i in scale ) out = ( out - l ) / ( u - l ) if invert : out = - out + ( out . max ( ) + out . min ( ) ) return out . astype ( dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the 1 - based index of the last item on this page . [CODESPLIT] def end_index ( self ) : paginator = self . paginator # Special case for the last page because there can be orphans. if self . number == paginator . num_pages : return paginator . count return ( self . number - 1 ) * paginator . per_page + paginator . first_page", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a filtered image after applying the Fourier - space filters [CODESPLIT] def filtered_image ( self , im ) : q = np . fft . fftn ( im ) for k , v in self . filters : q [ k ] -= v return np . real ( np . fft . ifftn ( q ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last n rows in the table [CODESPLIT] def get_last_row ( dbconn , tablename , n = 1 , uuid = None ) : return fetch ( dbconn , tablename , n , uuid , end = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove duplicates from an iterable preserving the order . [CODESPLIT] def delete_duplicates ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cast uint32 RGB image to 4 uint8 channels . [CODESPLIT] def uint32_to_uint8 ( cls , img ) : return np . flipud ( img . view ( dtype = np . uint8 ) . reshape ( img . shape + ( 4 , ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve a User object by ID . [CODESPLIT] def get_user_by_id ( self , id ) : return self . db_adapter . get_object ( self . UserClass , id = id )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs the function asynchronously taking care of exceptions . [CODESPLIT] def asynchronous ( function , event ) : thread = Thread ( target = synchronous , args = ( function , event ) ) thread . daemon = True thread . start ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Enforces a process memory limit . [CODESPLIT] def _EnforceProcessMemoryLimit ( self , memory_limit ) : # Resource is not supported on Windows. if resource : if memory_limit is None : memory_limit = 4 * 1024 * 1024 * 1024 elif memory_limit == 0 : memory_limit = resource . RLIM_INFINITY resource . setrlimit ( resource . RLIMIT_DATA , ( memory_limit , memory_limit ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check availability for a number of domains . Returns a dictionary mapping the domain names to their statuses as a string ( active / free ) . [CODESPLIT] def check_many ( self , domains ) : return dict ( ( item . domain , item . status ) for item in self . check_domain_request ( domains ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ends an indentation block leaving an empty line afterwards [CODESPLIT] def end_block ( self ) : self . current_indent -= 1 # If we did not add a new line automatically yet, now it's the time! if not self . auto_added_line : self . writeln ( ) self . auto_added_line = True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert kmodel s weights to bigdl format . We are supposing the order is the same as the execution order . : param kmodel : keras model : return : list of ndarray [CODESPLIT] def get_weights_from_kmodel ( kmodel ) : layers_with_weights = [ layer for layer in kmodel . layers if layer . weights ] bweights = [ ] for klayer in layers_with_weights : # bws would be [weights, bias] or [weights] bws = WeightsConverter . get_bigdl_weights_from_klayer ( klayer ) for w in bws : bweights . append ( w ) return bweights", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get tuple ( actually a generator ) of indices where the max value of array x occurs . Requires that x have a max () method as x . max () ( in the case of NumPy ) is much faster than max ( x ) . For a simpler faster argmax when there is only a single maximum entry or when knowing only the first index where the maximum occurs call argmax () on a NumPy array . [CODESPLIT] def MultiArgMax ( x ) : m = x . max ( ) return ( i for i , v in enumerate ( x ) if v == m )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the MachineGuid from HKEY_LOCAL_MACHINE \\ Software \\ Microsoft \\ Cryptography \\ MachineGuid [CODESPLIT] def get_nt_system_uid ( ) : try : import _winreg as winreg except ImportError : import winreg lm = winreg . ConnectRegistry ( None , winreg . HKEY_LOCAL_MACHINE ) try : key = winreg . OpenKey ( lm , r\"Software\\Microsoft\\Cryptography\" ) try : return winreg . QueryValueEx ( key , \"MachineGuid\" ) [ 0 ] finally : key . Close ( ) finally : lm . Close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialize . [CODESPLIT] def __init__ ( self , find , subcon ) : Subconstruct . __init__ ( self , subcon ) self . find = find", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Finds all coordinate variables in a dataset . [CODESPLIT] def find_coord_vars ( ncds ) : coord_vars = [ ] for d in ncds . dimensions : if d in ncds . variables and ncds . variables [ d ] . dimensions == ( d , ) : coord_vars . append ( ncds . variables [ d ] ) return coord_vars", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the name of the function f s keyword argument parameter if it exists otherwise None [CODESPLIT] def get_func_posargs_name ( f ) : sigparams = inspect . signature ( f ) . parameters for p in sigparams : if sigparams [ p ] . kind == inspect . Parameter . VAR_POSITIONAL : return sigparams [ p ] . name return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if git command is available . [CODESPLIT] def check_git ( ) : try : with open ( os . devnull , \"wb\" ) as devnull : subprocess . check_call ( [ \"git\" , \"--version\" ] , stdout = devnull , stderr = devnull ) except : raise RuntimeError ( \"Please make sure git is installed and on your path.\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a random positive integer ( for a Django PositiveIntegerField ) [CODESPLIT] def positive_integer ( anon , obj , field , val ) : return anon . faker . positive_integer ( field = field )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap a function as a method . [CODESPLIT] def method ( func ) : attr = abc . abstractmethod ( func ) attr . __imethod__ = True return attr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get zero - indexed line from an open file - like . [CODESPLIT] def get_lines ( handle , line ) : for i , l in enumerate ( handle ) : if i == line : return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "I convert strings into integers floats and strings! [CODESPLIT] def type_converter ( text ) : if text . isdigit ( ) : return int ( text ) , int try : return float ( text ) , float except ValueError : return text , STRING_TYPE", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a absolute path in the file system . [CODESPLIT] def create_path ( path ) : import os if not os . path . exists ( path ) : os . makedirs ( path )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if value is an integer . [CODESPLIT] def is_int ( value ) : if isinstance ( value , bool ) : return False try : int ( value ) return True except ( ValueError , TypeError ) : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a hdf5 file into a dictionary [CODESPLIT] def h5ToDict ( h5 , readH5pyDataset = True ) : h = h5py . File ( h5 , \"r\" ) ret = unwrapArray ( h , recursive = True , readH5pyDataset = readH5pyDataset ) if readH5pyDataset : h . close ( ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert an int of form yyyymmdd to a python date object . [CODESPLIT] def int_to_date ( date ) : year = date // 10 ** 4 month = date % 10 ** 4 // 10 ** 2 day = date % 10 ** 2 return datetime . date ( year , month , day )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Scipy norm function [CODESPLIT] def norm ( x , mu , sigma = 1.0 ) : return stats . norm ( loc = mu , scale = sigma ) . pdf ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A basic check of if the program is running in interactive mode [CODESPLIT] def isInteractive ( ) : if sys . stdout . isatty ( ) and os . name != 'nt' : #Hopefully everything but ms supports '\\r' try : import threading except ImportError : return False else : return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds noise to Y [CODESPLIT] def add_noise ( Y , sigma ) : return Y + np . random . normal ( 0 , sigma , Y . shape )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A datetime - version that takes datetime object list as x_axis [CODESPLIT] def spline_interpolate_by_datetime ( datetime_axis , y_axis , datetime_new_axis ) : numeric_datetime_axis = [ totimestamp ( a_datetime ) for a_datetime in datetime_axis ] numeric_datetime_new_axis = [ totimestamp ( a_datetime ) for a_datetime in datetime_new_axis ] return spline_interpolate ( numeric_datetime_axis , y_axis , numeric_datetime_new_axis )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Invert mapping of dictionary ( i . e . map values to list of keys ) [CODESPLIT] def invertDictMapping ( d ) : inv_map = { } for k , v in d . items ( ) : inv_map [ v ] = inv_map . get ( v , [ ] ) inv_map [ v ] . append ( k ) return inv_map", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return n size lists from a given list l [CODESPLIT] def chunk_list ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check Validity of an IP address [CODESPLIT] def is_valid_ip ( ip_address ) : valid = True try : socket . inet_aton ( ip_address . strip ( ) ) except : valid = False return valid", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Any normal python logic which runs a loop . Can take arguments . [CODESPLIT] def main ( idle ) : while True : LOG . debug ( \"Sleeping for {0} seconds.\" . format ( idle ) ) time . sleep ( idle )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Makes the list have unique items only and maintains the order [CODESPLIT] def unique ( _list ) : ret = [ ] for item in _list : if item not in ret : ret . append ( item ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialise sets used for uniqueness checking . [CODESPLIT] def _init_unique_sets ( self ) : ks = dict ( ) for t in self . _unique_checks : key = t [ 0 ] ks [ key ] = set ( ) # empty set return ks", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if var is a list or a tuple ( but not a string! ) [CODESPLIT] def is_a_sequence ( var , allow_none = False ) : return isinstance ( var , ( list , tuple ) ) or ( var is None and allow_none )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a sequence or scalar according to the input indicating if the values are not null . [CODESPLIT] def _notnull ( expr ) : if isinstance ( expr , SequenceExpr ) : return NotNull ( _input = expr , _data_type = types . boolean ) elif isinstance ( expr , Scalar ) : return NotNull ( _input = expr , _value_type = types . boolean )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "dictionary of conversion [CODESPLIT] def conv_dict ( self ) : return dict ( integer = self . integer , real = self . real , no_type = self . no_type )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get all the prime factor of given integer [CODESPLIT] def getPrimeFactors ( n ) : lo = [ 1 ] n2 = n // 2 k = 2 for k in range ( 2 , n2 + 1 ) : if ( n // k ) * k == n : lo . append ( k ) return lo + [ n , ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "gets a horiztonal line [CODESPLIT] def get_hline ( ) : return Window ( width = LayoutDimension . exact ( 1 ) , height = LayoutDimension . exact ( 1 ) , content = FillControl ( '-' , token = Token . Line ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Whether path is a directory to which the user has write access . [CODESPLIT] def _writable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . W_OK )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if * path * is a directory [CODESPLIT] def isdir ( path , * * kwargs ) : import os . path return os . path . isdir ( path , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Checks if l is a numpy array of floats ( any dimension [CODESPLIT] def is_float_array ( l ) : if isinstance ( l , np . ndarray ) : if l . dtype . kind == 'f' : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "in string astr replace all occurences of thefind with thereplace [CODESPLIT] def myreplace ( astr , thefind , thereplace ) : alist = astr . split ( thefind ) new_s = alist . split ( thereplace ) return new_s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "test if object is a list or tuple [CODESPLIT] def is_iter_non_string ( obj ) : if isinstance ( obj , list ) or isinstance ( obj , tuple ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns number rounded to digits digits . [CODESPLIT] def round_to_x_digits ( number , digits ) : return round ( number * math . pow ( 10 , digits ) ) / math . pow ( 10 , digits )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pop the head off the iterator and return it . [CODESPLIT] def __next__ ( self ) : res = self . _head self . _fill ( ) if res is None : raise StopIteration ( ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Center all lines of the text . It is assumed that all lines width is smaller then B { width } because the line width will not be checked . Args : text ( str ) : Text to wrap . width ( int ) : Maximum number of characters per line . Returns : str : Centered text . [CODESPLIT] def center_text ( text , width = 80 ) : centered = [ ] for line in text . splitlines ( ) : centered . append ( line . center ( width ) ) return \"\\n\" . join ( centered )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is to support iterators over a file - like object . [CODESPLIT] def next ( self ) : # File-like object. result = self . readline ( ) if result == self . _empty_buffer : raise StopIteration return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility function which converts lists to tuples . [CODESPLIT] def as_tuple ( self , value ) : if isinstance ( value , list ) : value = tuple ( value ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a reversed iterable over the items in the dictionary . Items are iterated over in their reverse sort order . [CODESPLIT] def __reversed__ ( self ) : _dict = self . _dict return iter ( ( key , _dict [ key ] ) for key in reversed ( self . _list ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a generator that spits an iteratable into n - sized chunks . The last chunk may have less than n elements . [CODESPLIT] def split_every ( n , iterable ) : items = iter ( iterable ) return itertools . takewhile ( bool , ( list ( itertools . islice ( items , n ) ) for _ in itertools . count ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flatten a nested list . [CODESPLIT] def flatten ( l ) : return sum ( map ( flatten , l ) , [ ] ) if isinstance ( l , list ) or isinstance ( l , tuple ) else [ l ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield directory file names . [CODESPLIT] def directory_files ( path ) : for entry in os . scandir ( path ) : if not entry . name . startswith ( '.' ) and entry . is_file ( ) : yield entry . name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap itertools . groupby to make life easier . [CODESPLIT] def group_by ( iterable , key_func ) : groups = ( list ( sub ) for key , sub in groupby ( iterable , key_func ) ) return zip ( groups , groups )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine the path to the virtualenv python [CODESPLIT] def get_python ( ) : if sys . platform == 'win32' : python = path . join ( VE_ROOT , 'Scripts' , 'python.exe' ) else : python = path . join ( VE_ROOT , 'bin' , 'python' ) return python", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Render a template into a response . [CODESPLIT] def render_template ( template_name , * * context ) : tmpl = jinja_env . get_template ( template_name ) context [ \"url_for\" ] = url_for return Response ( tmpl . render ( context ) , mimetype = \"text/html\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Select rows where the given field is None . [CODESPLIT] def selectnone ( table , field , complement = False ) : return select ( table , field , lambda v : v is None , complement = complement )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Join helper [CODESPLIT] def _join ( verb ) : data = pd . merge ( verb . x , verb . y , * * verb . kwargs ) # Preserve x groups if isinstance ( verb . x , GroupedDataFrame ) : data . plydata_groups = list ( verb . x . plydata_groups ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string to a null - terminated bytes object . [CODESPLIT] def stn ( s , length , encoding , errors ) : s = s . encode ( encoding , errors ) return s [ : length ] + ( length - len ( s ) ) * NUL", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Join the list of images into the out file [CODESPLIT] def join_images ( img_files , out_file ) : images = [ PIL . Image . open ( f ) for f in img_files ] joined = PIL . Image . new ( 'RGB' , ( sum ( i . size [ 0 ] for i in images ) , max ( i . size [ 1 ] for i in images ) ) ) left = 0 for img in images : joined . paste ( im = img , box = ( left , 0 ) ) left = left + img . size [ 0 ] joined . save ( out_file )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "helper function used for joins builds left and right join list for join function [CODESPLIT] def get_join_cols ( by_entry ) : left_cols = [ ] right_cols = [ ] for col in by_entry : if isinstance ( col , str ) : left_cols . append ( col ) right_cols . append ( col ) else : left_cols . append ( col [ 0 ] ) right_cols . append ( col [ 1 ] ) return left_cols , right_cols", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make matrix unweighted diagonally dominant using the Laplacian . [CODESPLIT] def _to_diagonally_dominant ( mat ) : mat += np . diag ( np . sum ( mat != 0 , axis = 1 ) + 0.01 ) return mat", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Allow \\ n . join ( ... ) statements to work in Py2 and Py3 . : param sep : : param joinable : : return : [CODESPLIT] def _py2_and_3_joiner ( sep , joinable ) : if ISPY3 : sep = bytes ( sep , DEFAULT_ENCODING ) joined = sep . join ( joinable ) return joined . decode ( DEFAULT_ENCODING ) if ISPY3 else joined", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Traverses the object and sets the supplied attribute on the object . Supports Dimensioned and DimensionedPlot types . [CODESPLIT] def traverse_setter ( obj , attribute , value ) : obj . traverse ( lambda x : setattr ( x , attribute , value ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add an object to Javascript . [CODESPLIT] def add_to_js ( self , name , var ) : frame = self . page ( ) . mainFrame ( ) frame . addToJavaScriptWindowObject ( name , var )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a key from S3 [CODESPLIT] def read_key ( self , key , bucket_name = None ) : obj = self . get_key ( key , bucket_name ) return obj . get ( ) [ 'Body' ] . read ( ) . decode ( 'utf-8' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Dump Python object as JSON string . [CODESPLIT] def dump_json ( obj ) : return simplejson . dumps ( obj , ignore_nan = True , default = json_util . default )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Opens the file and reads the value [CODESPLIT] def get_property ( self , filename ) : with open ( self . filepath ( filename ) ) as f : return f . read ( ) . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "shows JSON indented representation of d [CODESPLIT] def pretty_dict_str ( d , indent = 2 ) : b = StringIO ( ) write_pretty_dict_str ( b , d , indent = indent ) return b . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the help text ( signature + docstring ) for a command ( function ) . [CODESPLIT] def help_for_command ( command ) : help_text = pydoc . text . document ( command ) # remove backspaces return re . subn ( '.\\\\x08' , '' , help_text ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Saves the dictionary in json format : param fname : file to save to [CODESPLIT] def save ( self , fname ) : with open ( fname , 'wb' ) as f : json . dump ( self , f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rewrite a file adding a line to its beginning . [CODESPLIT] def prepend_line ( filepath , line ) : with open ( filepath ) as f : lines = f . readlines ( ) lines . insert ( 0 , line ) with open ( filepath , 'w' ) as f : f . writelines ( lines )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Squash self . out into string . [CODESPLIT] def build_output ( self , fout ) : fout . write ( '\\n' . join ( [ s for s in self . out ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "JSON serializer for objects not serializable by default json code [CODESPLIT] def json_serial ( obj ) : if isinstance ( obj , LegipyModel ) : return obj . to_json ( ) elif isinstance ( obj , ( datetime . date , datetime . datetime ) ) : return obj . isoformat ( ) raise TypeError ( \"Type {0} not serializable\" . format ( repr ( type ( obj ) ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple function to add two numbers [CODESPLIT] def generic_add ( a , b ) : logger . debug ( 'Called generic_add({}, {})' . format ( a , b ) ) return a + b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert JSON string to an ordered defaultdict . [CODESPLIT] def _unjsonify ( x , isattributes = False ) : if isattributes : obj = json . loads ( x ) return dict_class ( obj ) return json . loads ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform relative pathnames into absolute pathnames . [CODESPLIT] def get_absolute_path ( * args ) : directory = os . path . dirname ( os . path . abspath ( __file__ ) ) return os . path . join ( directory , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Queries should be a list of GraphQL objects [CODESPLIT] def graphql_queries_to_json ( * queries ) : rtn = { } for i , query in enumerate ( queries ) : rtn [ \"q{}\" . format ( i ) ] = query . value return json . dumps ( rtn )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Center all lines of the text . It is assumed that all lines width is smaller then B { width } because the line width will not be checked . Args : text ( str ) : Text to wrap . width ( int ) : Maximum number of characters per line . Returns : str : Centered text . [CODESPLIT] def center_text ( text , width = 80 ) : centered = [ ] for line in text . splitlines ( ) : centered . append ( line . center ( width ) ) return \"\\n\" . join ( centered )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Center all lines of the text . It is assumed that all lines width is smaller then B { width } because the line width will not be checked . Args : text ( str ) : Text to wrap . width ( int ) : Maximum number of characters per line . Returns : str : Centered text . [CODESPLIT] def center_text ( text , width = 80 ) : centered = [ ] for line in text . splitlines ( ) : centered . append ( line . center ( width ) ) return \"\\n\" . join ( centered )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A background thread to kill the process if it takes too long . [CODESPLIT] def timeout_thread_handler ( timeout , stop_event ) : stop_happened = stop_event . wait ( timeout ) if stop_happened is False : print ( \"Killing program due to %f second timeout\" % timeout ) os . _exit ( 2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Copies a file from * src * to * dst * including meta data except for permission bits . [CODESPLIT] def copy_no_perm ( src , dst ) : shutil . copy ( src , dst ) perm = os . stat ( dst ) . st_mode shutil . copystat ( src , dst ) os . chmod ( dst , perm )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Use this function to store data in a JSON file . [CODESPLIT] def store_data ( data ) : with open ( url_json_path ) as json_file : try : json_file_data = load ( json_file ) json_file_data . update ( data ) except ( AttributeError , JSONDecodeError ) : json_file_data = data with open ( url_json_path , 'w' ) as json_file : dump ( json_file_data , json_file , indent = 4 , sort_keys = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flatten dict with defined key join symbol . [CODESPLIT] def flatten_dict_join_keys ( dct , join_symbol = \" \" ) : return dict ( flatten_dict ( dct , join = lambda a , b : a + join_symbol + b ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add text to filename keeping the extension in place For example when adding a timestamp to the filename [CODESPLIT] def filename_addstring ( filename , text ) : fn , ext = os . path . splitext ( filename ) return fn + text + ext", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return the last stack element and delete it from the list [CODESPLIT] def pop ( self ) : if not self . empty ( ) : val = self . stack [ - 1 ] del self . stack [ - 1 ] return val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cosine interpolation [CODESPLIT] def interpolate_logscale_single ( start , end , coefficient ) : return np . exp ( np . log ( start ) + ( np . log ( end ) - np . log ( start ) ) * coefficient )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Looks at the files in a git root directory and grabs the last modified timestamp [CODESPLIT] def get_last_modified_timestamp ( self ) : cmd = \"find . -print0 | xargs -0 stat -f '%T@ %p' | sort -n | tail -1 | cut -f2- -d' '\" ps = subprocess . Popen ( cmd , shell = True , stdout = subprocess . PIPE , stderr = subprocess . STDOUT ) output = ps . communicate ( ) [ 0 ] print output", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes input from user . Works for Python 2 and 3 . [CODESPLIT] def _stdin_ ( p ) : _v = sys . version [ 0 ] return input ( p ) if _v is '3' else raw_input ( p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a nested list and returns the size of each dimension followed by the element type in the list [CODESPLIT] def get_list_dimensions ( _list ) : if isinstance ( _list , list ) or isinstance ( _list , tuple ) : return [ len ( _list ) ] + get_list_dimensions ( _list [ 0 ] ) return [ ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "sort a list of files by filename only ignoring the directory names [CODESPLIT] def sort_filenames ( filenames ) : basenames = [ os . path . basename ( x ) for x in filenames ] indexes = [ i [ 0 ] for i in sorted ( enumerate ( basenames ) , key = lambda x : x [ 1 ] ) ] return [ filenames [ x ] for x in indexes ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "1 - farthest apart ( same number of words all diff ) . 0 - same [CODESPLIT] def levenshtein_distance_metric ( a , b ) : return ( levenshtein_distance ( a , b ) / ( 2.0 * max ( len ( a ) , len ( b ) , 1 ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator to run a function with timing info . [CODESPLIT] def timed ( log = sys . stderr , limit = 2.0 ) : return lambda func : timeit ( func , log , limit )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert the parameter into a dictionary before calling jsonp if it s not already one [CODESPLIT] def dict_jsonp ( param ) : if not isinstance ( param , dict ) : param = dict ( param ) return jsonp ( param )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterate through lines of file . [CODESPLIT] def txt_line_iterator ( path ) : with tf . gfile . Open ( path ) as f : for line in f : yield line . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the total size of all elements in objects . [CODESPLIT] def get_size ( objects ) : res = 0 for o in objects : try : res += _getsizeof ( o ) except AttributeError : print ( \"IGNORING: type=%s; o=%s\" % ( str ( type ( o ) ) , str ( o ) ) ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the list of distinct values with preserving order . [CODESPLIT] def distinct ( xs ) : # don't use collections.OrderedDict because we do support Python 2.6 seen = set ( ) return [ x for x in xs if x not in seen and not seen . add ( x ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the standard error of a . [CODESPLIT] def stderr ( a ) : return np . nanstd ( a ) / np . sqrt ( sum ( np . isfinite ( a ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of the table names in the database . [CODESPLIT] def get_table_names ( connection ) : cursor = connection . cursor ( ) cursor . execute ( \"SELECT name FROM sqlite_master WHERE type == 'table'\" ) return [ name for ( name , ) in cursor ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call the supplied function with the supplied arguments and return the total execution time as a float in seconds . [CODESPLIT] def time ( func , * args , * * kwargs ) : start_time = time_module . time ( ) func ( * args , * * kwargs ) end_time = time_module . time ( ) return end_time - start_time", "target": 1, "target_options": ["no_match", "match"]}
{"input": "generate a CamelCase string from an underscore_string . [CODESPLIT] def camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = '' for component in components : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Makes a classname [CODESPLIT] def classnameify ( s ) : return '' . join ( w if w in ACRONYMS else w . title ( ) for w in s . split ( '_' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove duplicates from a list preserving the order . [CODESPLIT] def dedupe_list ( l ) : result = [ ] for el in l : if el not in result : result . append ( el ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "converts and unknown type to string for display purposes . [CODESPLIT] def force_to_string ( unknown ) : result = '' if type ( unknown ) is str : result = unknown if type ( unknown ) is int : result = str ( unknown ) if type ( unknown ) is float : result = str ( unknown ) if type ( unknown ) is dict : result = Dict2String ( unknown ) if type ( unknown ) is list : result = List2String ( unknown ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an array of the NaN pixels . [CODESPLIT] def nan_pixels ( self ) : nan_px = np . where ( np . isnan ( np . sum ( self . raw_data , axis = 2 ) ) ) nan_px = np . c_ [ nan_px [ 0 ] , nan_px [ 1 ] ] return nan_px", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take stderr bytes returned from MicroPython and attempt to create a non - verbose error message . [CODESPLIT] def clean_error ( err ) : if err : decoded = err . decode ( 'utf-8' ) try : return decoded . split ( '\\r\\n' ) [ - 2 ] except Exception : return decoded return 'There was an error.'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns data as : class : numpy . recarray . [CODESPLIT] def recarray ( self ) : return numpy . rec . fromrecords ( self . records , names = self . names )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper parse action to convert tokens to lower case . [CODESPLIT] def downcaseTokens ( s , l , t ) : return [ tt . lower ( ) for tt in map ( _ustr , t ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convenient shorthand for toarray ( * args ** kwargs ) . view ( np . recarray ) . [CODESPLIT] def torecarray ( * args , * * kwargs ) : import numpy as np return toarray ( * args , * * kwargs ) . view ( np . recarray )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reshape a multidimensional array to a vector . [CODESPLIT] def arr_to_vector ( arr ) : dim = array_dim ( arr ) tmp_arr = [ ] for n in range ( len ( dim ) - 1 ) : for inner in arr : for i in inner : tmp_arr . append ( i ) arr = tmp_arr tmp_arr = [ ] return arr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get all attribute members ( attribute property style method ) . [CODESPLIT] def get_all_attributes ( klass_or_instance ) : pairs = list ( ) for attr , value in inspect . getmembers ( klass_or_instance , lambda x : not inspect . isroutine ( x ) ) : if not ( attr . startswith ( \"__\" ) or attr . endswith ( \"__\" ) ) : pairs . append ( ( attr , value ) ) return pairs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "converts Synergy Timestamp for session to UTC zone seconds since epoch [CODESPLIT] def session_to_epoch ( timestamp ) : utc_timetuple = datetime . strptime ( timestamp , SYNERGY_SESSION_PATTERN ) . replace ( tzinfo = None ) . utctimetuple ( ) return calendar . timegm ( utc_timetuple )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an array of the zero pixels . [CODESPLIT] def zero_pixels ( self ) : zero_px = np . where ( np . sum ( self . raw_data , axis = 2 ) == 0 ) zero_px = np . c_ [ zero_px [ 0 ] , zero_px [ 1 ] ] return zero_px", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r End the table header which will appear on every page . [CODESPLIT] def end_table_header ( self ) : if self . header : msg = \"Table already has a header\" raise TableError ( msg ) self . header = True self . append ( Command ( r'endhead' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "main entry point for the jardiff CLI [CODESPLIT] def main ( args = sys . argv ) : parser = create_optparser ( args [ 0 ] ) return cli ( parser . parse_args ( args [ 1 : ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for raising the correct exception under Python 3 while still being able to raise the same common exception class in Python 2 . 7 . [CODESPLIT] def raise_os_error ( _errno , path = None ) : msg = \"%s: '%s'\" % ( strerror ( _errno ) , path ) if path else strerror ( _errno ) raise OSError ( _errno , msg )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Visible width of a potentially multiline content . [CODESPLIT] def _multiline_width ( multiline_s , line_width_fn = len ) : return max ( map ( line_width_fn , re . split ( \"[\\r\\n]\" , multiline_s ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute a python code object in the given environment . [CODESPLIT] def exec_function ( ast , globals_map ) : locals_map = globals_map exec ast in globals_map , locals_map return locals_map", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Changes a column name in a DataFrame Parameters : df - DataFrame DataFrame to operate on col_name - string Name of column to change new_col_name - string New name of column [CODESPLIT] def col_rename ( df , col_name , new_col_name ) : col_list = list ( df . columns ) for index , value in enumerate ( col_list ) : if value == col_name : col_list [ index ] = new_col_name break df . columns = col_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load another YAML file and embeds it using the !include tag . [CODESPLIT] def _include_yaml ( loader , node ) : return load_yaml ( os . path . join ( os . path . dirname ( loader . name ) , node . value ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert numbers to floats whether the decimal point is . or [CODESPLIT] def comma_converter ( float_string ) : trans_table = maketrans ( b',' , b'.' ) return float ( float_string . translate ( trans_table ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple function to convert naive : std : datetime . datetime object containing local time to a naive : std : datetime . datetime object with UTC time . [CODESPLIT] def datetime_local_to_utc ( local ) : timestamp = time . mktime ( local . timetuple ( ) ) return datetime . datetime . utcfromtimestamp ( timestamp )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert snake_case to camel_case . [CODESPLIT] def to_identifier ( s ) : if s . startswith ( 'GPS' ) : s = 'Gps' + s [ 3 : ] return '' . join ( [ i . capitalize ( ) for i in s . split ( '_' ) ] ) if '_' in s else s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Search tuple array by index and value : param t : tuple array : param i : index of the value in each tuple : param v : value : return : the first tuple in the array with the specific index / value [CODESPLIT] def tuple_search ( t , i , v ) : for e in t : if e [ i ] == v : return e return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "sets the aspect ratio of the current zoom level of the imshow image [CODESPLIT] def image_set_aspect ( aspect = 1.0 , axes = \"gca\" ) : if axes is \"gca\" : axes = _pylab . gca ( ) e = axes . get_images ( ) [ 0 ] . get_extent ( ) axes . set_aspect ( abs ( ( e [ 1 ] - e [ 0 ] ) / ( e [ 3 ] - e [ 2 ] ) ) / aspect )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Lock connection from being used else where [CODESPLIT] def lock ( self , block = True ) : self . _locked = True return self . _lock . acquire ( block )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates the returned positional object [CODESPLIT] def _validate_pos ( df ) : assert isinstance ( df , pd . DataFrame ) assert [ \"seqname\" , \"position\" , \"strand\" ] == df . columns . tolist ( ) assert df . position . dtype == np . dtype ( \"int64\" ) assert df . strand . dtype == np . dtype ( \"O\" ) assert df . seqname . dtype == np . dtype ( \"O\" ) return df", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns numpy array of natural logarithms of values . [CODESPLIT] def to_distribution_values ( self , values ) : with warnings . catch_warnings ( ) : warnings . simplefilter ( \"ignore\" ) # avoid RuntimeWarning: divide by zero encountered in log return numpy . log ( values )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Do all elements of x have a type from types? [CODESPLIT] def _valid_other_type ( x , types ) : return all ( any ( isinstance ( el , t ) for t in types ) for el in np . ravel ( x ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a stream handler if it exists . [CODESPLIT] def find_console_handler ( logger ) : for handler in logger . handlers : if ( isinstance ( handler , logging . StreamHandler ) and handler . stream == sys . stderr ) : return handler", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if unicode string only contains ASCII characters . [CODESPLIT] def unicode_is_ascii ( u_string ) : assert isinstance ( u_string , str ) try : u_string . encode ( 'ascii' ) return True except UnicodeEncodeError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Same to log but this one centralizes the message first . [CODESPLIT] def clog ( color ) : logger = log ( color ) return lambda msg : logger ( centralize ( msg ) . rstrip ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if object is defined in current namespace [CODESPLIT] def is_defined ( self , obj , force_import = False ) : from spyder_kernels . utils . dochelpers import isdefined ns = self . _get_current_namespace ( with_magics = True ) return isdefined ( obj , force_import = force_import , namespace = ns )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format a message in the log [CODESPLIT] def format ( self , record , * args , * * kwargs ) : return logging . Formatter . format ( self , record , * args , * * kwargs ) . replace ( '\\n' , '\\n' + ' ' * 8 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if a line consists only of a single punctuation character . [CODESPLIT] def is_delimiter ( line ) : return bool ( line ) and line [ 0 ] in punctuation and line [ 0 ] * len ( line ) == line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load logger config from file Keyword arguments : filename -- configuration filename ( Default : logging . ini ) * args -- options passed to fileConfig ** kwargs -- options passed to fileConfigg [CODESPLIT] def load_config ( filename = \"logging.ini\" , * args , * * kwargs ) : logging . config . fileConfig ( filename , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Whether this is a function parameter . [CODESPLIT] def is_parameter ( self ) : return ( isinstance ( self . scope , CodeFunction ) and self in self . scope . parameters )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if object is not a string but is iterable [CODESPLIT] def is_seq ( obj ) : if not hasattr ( obj , '__iter__' ) : return False if isinstance ( obj , basestring ) : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handle logging . [CODESPLIT] def logger ( message , level = 10 ) : logging . getLogger ( __name__ ) . log ( level , str ( message ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if something quacks like a list . [CODESPLIT] def is_listish ( obj ) : if isinstance ( obj , ( list , tuple , set ) ) : return True return is_sequence ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert Matrix attributes which are array - like or buffer to array . [CODESPLIT] def _convert_to_array ( array_like , dtype ) : if isinstance ( array_like , bytes ) : return np . frombuffer ( array_like , dtype = dtype ) return np . asarray ( array_like , dtype = dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validate if non empty string [CODESPLIT] def is_non_empty_string ( input_string ) : try : if not input_string . strip ( ) : raise ValueError ( ) except AttributeError as error : raise TypeError ( error ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets a naive datetime from a datetime . [CODESPLIT] def get_naive ( dt ) : if not dt . tzinfo : return dt if hasattr ( dt , \"asdatetime\" ) : return dt . asdatetime ( ) return dt . replace ( tzinfo = None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Match two names . [CODESPLIT] def _match_literal ( self , a , b = None ) : return a . lower ( ) == b if not self . case_sensitive else a == b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Makes the given dictionary symmetric . Values are assumed to be unique . [CODESPLIT] def make_symmetric ( dict ) : for key , value in list ( dict . items ( ) ) : dict [ value ] = key return dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if value is an integer long integer or float . [CODESPLIT] def isnumber ( * args ) : return all ( map ( lambda c : isinstance ( c , int ) or isinstance ( c , float ) , args ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Path helper gives you a path relative to this file [CODESPLIT] def relpath ( path ) : return os . path . normpath ( os . path . join ( os . path . abspath ( os . path . dirname ( __file__ ) ) , path ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get installed CUDA driver version . [CODESPLIT] def cudaDriverGetVersion ( ) : version = ctypes . c_int ( ) status = _libcudart . cudaDriverGetVersion ( ctypes . byref ( version ) ) cudaCheckStatus ( status ) return version . value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if the PTY should operate in raw mode . [CODESPLIT] def israw ( self , * * kwargs ) : if self . raw is None : info = self . _container_info ( ) self . raw = self . stdout . isatty ( ) and info [ 'Config' ] [ 'Tty' ] return self . raw", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The distance between two skip - connections . [CODESPLIT] def skip_connection_distance ( a , b ) : if a [ 2 ] != b [ 2 ] : return 1.0 len_a = abs ( a [ 1 ] - a [ 0 ] ) len_b = abs ( b [ 1 ] - b [ 0 ] ) return ( abs ( a [ 0 ] - b [ 0 ] ) + abs ( len_a - len_b ) ) / ( max ( a [ 0 ] , b [ 0 ] ) + max ( len_a , len_b ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a list of tuples describing a table into a HTML string [CODESPLIT] def html ( header_rows ) : name = 'table%d' % next ( tablecounter ) return HtmlTable ( [ map ( str , row ) for row in header_rows ] , name ) . render ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check that matrix is square . [CODESPLIT] def isSquare ( matrix ) : try : try : dim1 , dim2 = matrix . shape except AttributeError : dim1 , dim2 = _np . array ( matrix ) . shape except ValueError : return False if dim1 == dim2 : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert version like string to a tuple of integers . [CODESPLIT] def ver_to_tuple ( value ) : return tuple ( int ( _f ) for _f in re . split ( r'\\D+' , value ) if _f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if value is an instance or subclass of the class Type . [CODESPLIT] def is_type ( value ) : if isinstance ( value , type ) : return issubclass ( value , Type ) return isinstance ( value , Type )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Return variable as a string to print with given precision . [CODESPLIT] def _strvar ( a , prec = '{:G}' ) : return ' ' . join ( [ prec . format ( i ) for i in np . atleast_1d ( a ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a boolean stating if the filename is safe to use or not . Note that this does not test for legal names accepted but a more restricted set of : Letters numbers spaces hyphens underscores and periods . [CODESPLIT] def check_filename ( filename ) : if not isinstance ( filename , str ) : raise TypeError ( \"filename must be a string\" ) if regex . path . linux . filename . search ( filename ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a 20 char passphrase with easily typeable chars . [CODESPLIT] def GeneratePassphrase ( length = 20 ) : valid_chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" valid_chars += \"0123456789 ,-_&$#\" return \"\" . join ( random . choice ( valid_chars ) for i in range ( length ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "must be a float [CODESPLIT] def is_float ( value ) : return isinstance ( value , float ) or isinstance ( value , int ) or isinstance ( value , np . float64 ) , float ( value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply re . sub to bunch of ( pattern repl ) [CODESPLIT] def _sub_patterns ( patterns , text ) : for pattern , repl in patterns : text = re . sub ( pattern , repl , text ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Autoconnect slot activated when tbSourceDir is clicked . [CODESPLIT] def on_source_directory_chooser_clicked ( self ) : title = self . tr ( 'Set the source directory for script and scenario' ) self . choose_directory ( self . source_directory , title )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a list of JSON values to a list of models [CODESPLIT] def from_json_list ( cls , api_client , data ) : return [ cls . from_json ( api_client , item ) for item in data ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete all build components ; the package cache package builds bootstrap builds and distributions . [CODESPLIT] def clean_all ( self , args ) : self . clean_dists ( args ) self . clean_builds ( args ) self . clean_download_cache ( args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "merge two Mapping objects keeping the type of the first mapping [CODESPLIT] def _merge_maps ( m1 , m2 ) : return type ( m1 ) ( chain ( m1 . items ( ) , m2 . items ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove outputs from a notebook . [CODESPLIT] def strip ( notebook ) : for cell in notebook . cells : if cell . cell_type == 'code' : cell . outputs = [ ] cell . execution_count = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Scan through string looking for a location where this word produces a match and return a corresponding MatchObject instance . Return None if no position in the string matches the pattern ; note that this is different from finding a zero - length match at some point in the string . [CODESPLIT] def find_whole_word ( w ) : return re . compile ( r'\\b({0})\\b' . format ( w ) , flags = re . IGNORECASE ) . search", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Auto - scales the axes to fit all the data in plot index n . If n == None auto - scale everyone . [CODESPLIT] def autozoom ( self , n = None ) : if n == None : for p in self . plot_widgets : p . autoRange ( ) else : self . plot_widgets [ n ] . autoRange ( ) return self", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove decoded instruction from instruction cache [CODESPLIT] def invalidate_cache ( cpu , address , size ) : cache = cpu . instruction_cache for offset in range ( size ) : if address + offset in cache : del cache [ address + offset ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert matplotlib color code to hex color code [CODESPLIT] def color_to_hex ( color ) : if color is None or colorConverter . to_rgba ( color ) [ 3 ] == 0 : return 'none' else : rgb = colorConverter . to_rgb ( color ) return '#{0:02X}{1:02X}{2:02X}' . format ( * ( int ( 255 * c ) for c in rgb ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Erases n lines from the screen and moves the cursor up to follow [CODESPLIT] def erase_lines ( n = 1 ) : for _ in range ( n ) : print ( codes . cursor [ \"up\" ] , end = \"\" ) print ( codes . cursor [ \"eol\" ] , end = \"\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Draws the i - th horizontal line parallel to the lower axis . [CODESPLIT] def horizontal_line ( ax , scale , i , * * kwargs ) : p1 = ( 0 , i , scale - i ) p2 = ( scale - i , i , 0 ) line ( ax , p1 , p2 , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raises the supplied figure number or figure window . [CODESPLIT] def raise_figure_window ( f = 0 ) : if _fun . is_a_number ( f ) : f = _pylab . figure ( f ) f . canvas . manager . window . raise_ ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "linear regression calculation [CODESPLIT] def linregress ( x , y , return_stats = False ) : a1 , a0 , r_value , p_value , stderr = scipy . stats . linregress ( x , y ) retval = a1 , a0 if return_stats : retval += r_value , p_value , stderr return retval", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clears the default matplotlib ticks . [CODESPLIT] def clear_matplotlib_ticks ( self , axis = \"both\" ) : ax = self . get_axes ( ) plotting . clear_matplotlib_ticks ( ax = ax , axis = axis )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set y - axis limits of a subplot . [CODESPLIT] def set_ylimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_ylimits ( min , max )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the safe norm . [CODESPLIT] def _norm ( self , x ) : return tf . sqrt ( tf . reduce_sum ( tf . square ( x ) , keepdims = True , axis = - 1 ) + 1e-7 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dataframe that is a cross between dataframes df1 and df2 [CODESPLIT] def cross_join ( df1 , df2 ) : if len ( df1 ) == 0 : return df2 if len ( df2 ) == 0 : return df1 # Add as lists so that the new index keeps the items in # the order that they are added together all_columns = pd . Index ( list ( df1 . columns ) + list ( df2 . columns ) ) df1 [ 'key' ] = 1 df2 [ 'key' ] = 1 return pd . merge ( df1 , df2 , on = 'key' ) . loc [ : , all_columns ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Choose k random elements of array . [CODESPLIT] def downsample ( array , k ) : length = array . shape [ 0 ] indices = random . sample ( xrange ( length ) , k ) return array [ indices ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if contents of the files are the same [CODESPLIT] def cmp_contents ( filename1 , filename2 ) : with open_readable ( filename1 , 'rb' ) as fobj : contents1 = fobj . read ( ) with open_readable ( filename2 , 'rb' ) as fobj : contents2 = fobj . read ( ) return contents1 == contents2", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Digits needed to comforatbly display values in [ minval maxval ] [CODESPLIT] def _digits ( minval , maxval ) : if minval == maxval : return 3 else : return min ( 10 , max ( 2 , int ( 1 + abs ( np . log10 ( maxval - minval ) ) ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compare items in 2 arrays . Returns sum ( abs ( a ( i ) - b ( i ))) [CODESPLIT] def compare ( a , b ) : s = 0 for i in range ( len ( a ) ) : s = s + abs ( a [ i ] - b [ i ] ) return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "yields EVENT ENTRY pairs describing the differences between left and right which are filenames for a pair of zip files [CODESPLIT] def compare ( left , right ) : with open_zip ( left ) as l : with open_zip ( right ) as r : return compare_zips ( l , r )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run coverage tests . [CODESPLIT] def coverage ( ) : # Note: coverage options are controlled by .coveragerc file install ( ) test_setup ( ) sh ( \"%s -m coverage run %s\" % ( PYTHON , TEST_SCRIPT ) ) sh ( \"%s -m coverage report\" % PYTHON ) sh ( \"%s -m coverage html\" % PYTHON ) sh ( \"%s -m webbrowser -t htmlcov/index.html\" % PYTHON )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test two dictionary is equal on values . ( ignore order ) [CODESPLIT] def is_same_dict ( d1 , d2 ) : for k , v in d1 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d2 [ k ] ) else : assert d1 [ k ] == d2 [ k ] for k , v in d2 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d1 [ k ] ) else : assert d1 [ k ] == d2 [ k ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print out memory usage at this point in time [CODESPLIT] def m ( name = '' , * * kwargs ) : with Reflect . context ( * * kwargs ) as r : kwargs [ \"name\" ] = name instance = M_CLASS ( r , stream , * * kwargs ) instance ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Build a C ++ binary executable [CODESPLIT] def cpp_prog_builder ( build_context , target ) : yprint ( build_context . conf , 'Build CppProg' , target ) workspace_dir = build_context . get_workspace ( 'CppProg' , target . name ) build_cpp ( build_context , target , target . compiler_config , workspace_dir )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "merge two dictionaries [CODESPLIT] def dictmerge ( x , y ) : z = x . copy ( ) z . update ( y ) return z", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Advances to next line . [CODESPLIT] def advance_one_line ( self ) : current_line = self . _current_token . line_number while current_line == self . _current_token . line_number : self . _current_token = ConfigParser . Token ( * next ( self . _token_generator ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Merge another stats . [CODESPLIT] def merge ( self , other ) : Stats . merge ( self , other ) self . changes += other . changes", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the display length of a string . This can differ from the character length if the string contains wide characters . [CODESPLIT] def display_len ( text ) : text = unicodedata . normalize ( 'NFD' , text ) return sum ( char_width ( char ) for char in text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A helper to create a proxy method in a class . [CODESPLIT] def Proxy ( f ) : def Wrapped ( self , * args ) : return getattr ( self , f ) ( * args ) return Wrapped", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gives a string representation of a PB2 message . [CODESPLIT] def _message_to_string ( message , data = None ) : if data is None : data = _json_from_message ( message ) return \"Message {} from {} to {}: {}\" . format ( message . namespace , message . source_id , message . destination_id , data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reshape a multidimensional array to a vector . [CODESPLIT] def arr_to_vector ( arr ) : dim = array_dim ( arr ) tmp_arr = [ ] for n in range ( len ( dim ) - 1 ) : for inner in arr : for i in inner : tmp_arr . append ( i ) arr = tmp_arr tmp_arr = [ ] return arr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return possible range for min function . [CODESPLIT] def min_values ( args ) : return Interval ( min ( x . low for x in args ) , min ( x . high for x in args ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply last 2D transforms [CODESPLIT] def post_process ( self ) : self . image . putdata ( self . pixels ) self . image = self . image . transpose ( Image . ROTATE_90 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A wrapper of os . makedirs () . [CODESPLIT] def makedirs ( path , mode = 0o777 , exist_ok = False ) : os . makedirs ( path , mode , exist_ok )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Try to convert variables into datatypes . [CODESPLIT] def autoconvert ( string ) : for fn in ( boolify , int , float ) : try : return fn ( string ) except ValueError : pass return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialize a ListCollectionsResponse object from a json dictionary . [CODESPLIT] def _from_dict ( cls , _dict ) : args = { } if 'collections' in _dict : args [ 'collections' ] = [ Collection . _from_dict ( x ) for x in ( _dict . get ( 'collections' ) ) ] return cls ( * * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wanted functionality from Counters ( new in Python 2 . 7 ) . [CODESPLIT] def most_common ( items ) : counts = { } for i in items : counts . setdefault ( i , 0 ) counts [ i ] += 1 return max ( six . iteritems ( counts ) , key = operator . itemgetter ( 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run a find_one on this model s collection . The arguments to Model . find_one are the same as to pymongo . Collection . find_one . [CODESPLIT] def find_one ( cls , * args , * * kwargs ) : database , collection = cls . _collection_key . split ( '.' ) return current ( ) [ database ] [ collection ] . find_one ( * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the indent size in spaces at the start of a line of text . [CODESPLIT] def indentsize ( line ) : expline = string . expandtabs ( line ) return len ( expline ) - len ( string . lstrip ( expline ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Choose the most common item from the list or the first item if all items are unique . [CODESPLIT] def mostCommonItem ( lst ) : # This elegant solution from: http://stackoverflow.com/a/1518632/1760218 lst = [ l for l in lst if l ] if lst : return max ( set ( lst ) , key = lst . count ) else : return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates an environment key - equivalent for the given key [CODESPLIT] def make_env_key ( app_name , key ) : key = key . replace ( '-' , '_' ) . replace ( ' ' , '_' ) return str ( \"_\" . join ( ( x . upper ( ) for x in ( app_name , key ) ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get all the prime factor of given integer [CODESPLIT] def getPrimeFactors ( n ) : lo = [ 1 ] n2 = n // 2 k = 2 for k in range ( 2 , n2 + 1 ) : if ( n // k ) * k == n : lo . append ( k ) return lo + [ n , ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Align the position in the file to the next block of specified size [CODESPLIT] def align_file_position ( f , size ) : align = ( size - 1 ) - ( f . tell ( ) % size ) f . seek ( align , 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Formats given header column . This involves changing _Px_ to ( _xP_ to ) and all other _ to spaces . [CODESPLIT] def format_header_cell ( val ) : return re . sub ( '_' , ' ' , re . sub ( r'(_Px_)' , '(' , re . sub ( r'(_xP_)' , ')' , str ( val ) ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Moves the text cursor to given line . [CODESPLIT] def go_to_line ( self , line ) : cursor = self . textCursor ( ) cursor . setPosition ( self . document ( ) . findBlockByNumber ( line - 1 ) . position ( ) ) self . setTextCursor ( cursor ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a shallow copy of the sorted dictionary . [CODESPLIT] def copy ( self ) : return self . __class__ ( self . _key , self . _load , self . _iteritems ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Singleton definition . [CODESPLIT] def singleton ( class_ ) : instances = { } def get_instance ( * args , * * kwargs ) : if class_ not in instances : instances [ class_ ] = class_ ( * args , * * kwargs ) return instances [ class_ ] return get_instance", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Inputs [ a b c ] returns { a : 0 b : 1 c : 2 } . [CODESPLIT] def list_string_to_dict ( string ) : dictionary = { } for idx , c in enumerate ( string ) : dictionary . update ( { c : idx } ) return dictionary", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a re . match object if an empty comment was found on line . [CODESPLIT] def _match_space_at_line ( line ) : regex = re . compile ( r\"^{0}$\" . format ( _MDL_COMMENT ) ) return regex . match ( line )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates symbolic link for either operating system . http : // stackoverflow . com / questions / 6260149 / os - symlink - support - in - windows [CODESPLIT] def create_symlink ( source , link_name ) : os_symlink = getattr ( os , \"symlink\" , None ) if isinstance ( os_symlink , collections . Callable ) : os_symlink ( source , link_name ) else : import ctypes csl = ctypes . windll . kernel32 . CreateSymbolicLinkW csl . argtypes = ( ctypes . c_wchar_p , ctypes . c_wchar_p , ctypes . c_uint32 ) csl . restype = ctypes . c_ubyte flags = 1 if os . path . isdir ( source ) else 0 if csl ( link_name , source , flags ) == 0 : raise ctypes . WinError ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return string as a comment [CODESPLIT] def _comment ( string ) : lines = [ line . strip ( ) for line in string . splitlines ( ) ] return \"# \" + ( \"%s# \" % linesep ) . join ( lines )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Temporarily replace sys . argv with current arguments [CODESPLIT] def replace_sys_args ( new_args ) : # Replace sys.argv arguments # for module import old_args = sys . argv sys . argv = new_args try : yield finally : sys . argv = old_args", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return n size lists from a given list l [CODESPLIT] def chunk_list ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Export the specified context to be capable context transferring [CODESPLIT] def export_context ( cls , context ) : if context is None : return result = [ ( x . context_name ( ) , x . context_value ( ) ) for x in context ] result . reverse ( ) return tuple ( result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generates the matrices that positive and negative samples are multiplied with . The matrix for positive samples is randomly drawn from a uniform distribution with elements in [ - 1 1 ] . The matrix for negative examples is the sum of the positive matrix with a matrix drawn from a normal distribution with mean 0 variance 1 . [CODESPLIT] def generate_matrices ( dim = 40 ) : positive = numpy . random . uniform ( - 1 , 1 , ( dim , dim ) ) negative = positive + numpy . random . normal ( 0 , 1 , ( dim , dim ) ) return positive , negative", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print QR Code for the provided string [CODESPLIT] def qr ( self , text ) : qr_code = qrcode . QRCode ( version = 4 , box_size = 4 , border = 1 ) qr_code . add_data ( text ) qr_code . make ( fit = True ) qr_img = qr_code . make_image ( ) im = qr_img . _img . convert ( \"RGB\" ) # Convert the RGB image in printable image self . _convert_image ( im )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "helpful in situations where browser / app may recognize Unicode encoding in the \\ u0b8e type syntax but not actual unicode glyph / code - point [CODESPLIT] def to_unicode_repr ( _letter ) : # Python 2-3 compatible return u\"u'\" + u\"\" . join ( [ u\"\\\\u%04x\" % ord ( l ) for l in _letter ] ) + u\"'\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Callable function for the multiprocessing pool . [CODESPLIT] def compute ( args ) : x , y , params = args return x , y , mandelbrot ( x , y , params )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clear only any cached global data . [CODESPLIT] def clear_global ( self ) : vname = self . varname logger . debug ( f'global clearning {vname}' ) if vname in globals ( ) : logger . debug ( 'removing global instance var: {}' . format ( vname ) ) del globals ( ) [ vname ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "retrieve a result from the pool [CODESPLIT] def get ( self ) : if self . closed : raise PoolClosed ( ) while self . _getcount not in self . _cache : counter , result = self . outq . get ( ) self . _cache [ counter ] = result result , succeeded = self . _cache . pop ( self . _getcount ) self . _getcount += 1 if not succeeded : klass , exc , tb = result raise klass , exc , tb return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Destroy self since closures cannot be called again . [CODESPLIT] def _release ( self ) : del self . funcs del self . variables del self . variable_values del self . satisfied", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Callable function for the multiprocessing pool . [CODESPLIT] def compute_capture ( args ) : x , y , w , h , params = args return x , y , mandelbrot_capture ( x , y , w , h , params )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the highest priority Processing Block from the queue . [CODESPLIT] def get ( self ) : with self . _mutex : entry = self . _queue . pop ( ) del self . _block_map [ entry [ 2 ] ] return entry [ 2 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This method removes columns in data [CODESPLIT] def remove_columns ( self , data , columns ) : for column in columns : if column in data . columns : data = data . drop ( column , axis = 1 ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Underlying synchronized wrapper . [CODESPLIT] def _synced ( method , self , args , kwargs ) : with self . _lock : return method ( * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deletes the specified file from the local filesystem . [CODESPLIT] def _delete_local ( self , filename ) : if os . path . exists ( filename ) : os . remove ( filename )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of the table names in the database . [CODESPLIT] def get_table_names ( connection ) : cursor = connection . cursor ( ) cursor . execute ( \"SELECT name FROM sqlite_master WHERE type == 'table'\" ) return [ name for ( name , ) in cursor ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove multiple elements from a list and return result . This implementation is faster than the alternative below . Also note the creation of a new list to avoid altering the original . We don t have any current use for the original intact list but may in the future ... [CODESPLIT] def remove_elements ( target , indices ) : copied = list ( target ) for index in reversed ( indices ) : del copied [ index ] return copied", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove problem characters from string [CODESPLIT] def remove_bad ( string ) : remove = [ ':' , ',' , '(' , ')' , ' ' , '|' , ';' , '\\'' ] for c in remove : string = string . replace ( c , '_' ) return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Restoring scrollbar position after main window is visible [CODESPLIT] def restore_scrollbar_position ( self ) : scrollbar_pos = self . get_option ( 'scrollbar_position' , None ) if scrollbar_pos is not None : self . explorer . treewidget . set_scrollbar_position ( scrollbar_pos )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove unwanted list indices . First argument is the list of indices to remove . Other elements are the lists to trim . [CODESPLIT] def rm_empty_indices ( * args ) : rm_inds = args [ 0 ] if not rm_inds : return args [ 1 : ] keep_inds = [ i for i in range ( len ( args [ 1 ] ) ) if i not in rm_inds ] return [ [ a [ i ] for i in keep_inds ] for a in args [ 1 : ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "expects a _n . array returns the global minimum of ( value - array ) ^2 [CODESPLIT] def index_nearest ( value , array ) : a = ( array - value ) ** 2 return index ( a . min ( ) , a )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove a node from this network . [CODESPLIT] def remove_node ( self , node ) : if _debug : Network . _debug ( \"remove_node %r\" , node ) self . nodes . remove ( node ) node . lan = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A deprecation warning emmiter as a decorator . [CODESPLIT] def deprecate ( func ) : @ wraps ( func ) def wrapper ( * args , * * kwargs ) : warn ( \"Deprecated, this will be removed in the future\" , DeprecationWarning ) return func ( * args , * * kwargs ) wrapper . __doc__ = \"Deprecated.\\n\" + ( wrapper . __doc__ or \"\" ) return wrapper", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a list of words given text removing punctuation . [CODESPLIT] def wordify ( text ) : stopset = set ( nltk . corpus . stopwords . words ( 'english' ) ) tokens = nltk . WordPunctTokenizer ( ) . tokenize ( text ) return [ w for w in tokens if w not in stopset ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is the user a system administrator [CODESPLIT] def is_admin ( self ) : return self . role == self . roles . administrator . value and self . state == State . approved", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tries to connect to the Heron Server [CODESPLIT] def start_connect ( self ) : Log . debug ( \"In start_connect() of %s\" % self . _get_classname ( ) ) # TODO: specify buffer size, exception handling self . create_socket ( socket . AF_INET , socket . SOCK_STREAM ) # when ready, handle_connect is called self . _connecting = True self . connect ( self . endpoint )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of unique items ( similar to set functionality ) . [CODESPLIT] def unique ( input_list ) : output = [ ] for item in input_list : if item not in output : output . append ( item ) return output", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convenience method that works with all 2 . x versions of Python to determine whether or not something is stringlike . [CODESPLIT] def isString ( s ) : try : return isinstance ( s , unicode ) or isinstance ( s , basestring ) except NameError : return isinstance ( s , str )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Log - normal function from scipy [CODESPLIT] def lognorm ( x , mu , sigma = 1.0 ) : return stats . lognorm ( sigma , scale = mu ) . pdf ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the API type of the given value based on its python type . [CODESPLIT] def _api_type ( self , value ) : if isinstance ( value , six . string_types ) : return 'string' elif isinstance ( value , six . integer_types ) : return 'integer' elif type ( value ) is datetime . datetime : return 'date'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reverse the normalization done to a batch of images . [CODESPLIT] def denorm ( self , arr ) : if type ( arr ) is not np . ndarray : arr = to_np ( arr ) if len ( arr . shape ) == 3 : arr = arr [ None ] return self . transform . denorm ( np . rollaxis ( arr , 1 , 4 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if an object is a sequence . [CODESPLIT] def is_seq ( obj ) : return ( not is_str ( obj ) and not is_dict ( obj ) and ( hasattr ( obj , \"__getitem__\" ) or hasattr ( obj , \"__iter__\" ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "I check to see if a method on a TestCase has been disabled via nose s convention for disabling a TestCase . This makes it so that users can mix nose s parameterized tests with green as a runner . [CODESPLIT] def isTestCaseDisabled ( test_case_class , method_name ) : test_method = getattr ( test_case_class , method_name ) return getattr ( test_method , \"__test__\" , 'not nose' ) is False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Match and yield all the tokens of the input string . [CODESPLIT] def tokenize ( string ) : for match in TOKENS_REGEX . finditer ( string ) : yield Token ( match . lastgroup , match . group ( ) . strip ( ) , match . span ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Chunk one big list into few small lists . [CODESPLIT] def chunked ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if array is an array of real numbers . [CODESPLIT] def contains_all ( self , array ) : dtype = getattr ( array , 'dtype' , None ) if dtype is None : dtype = np . result_type ( * array ) return is_real_dtype ( dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit the program due to user s choices . [CODESPLIT] def quit ( self ) : self . script . LOG . warn ( \"Abort due to user choice!\" ) sys . exit ( self . QUIT_RC )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns data as : class : numpy . recarray . [CODESPLIT] def recarray ( self ) : return numpy . rec . fromrecords ( self . records , names = self . names )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This method allows printing several images in one shot . This is useful if the client code does not want the printer to make pause during printing [CODESPLIT] def print_images ( self , * printable_images ) : printable_image = reduce ( lambda x , y : x . append ( y ) , list ( printable_images ) ) self . print_image ( printable_image )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Represent data as a masked array . [CODESPLIT] def ma ( self ) : a = self . array return numpy . ma . MaskedArray ( a , mask = numpy . logical_not ( numpy . isfinite ( a ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raw pointwise multiplication of two elements . [CODESPLIT] def _divide ( self , x1 , x2 , out ) : self . tspace . _divide ( x1 . tensor , x2 . tensor , out . tensor )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets a dict of this object s properties so that it can be used to send a dump to the client [CODESPLIT] def _to_json ( self ) : return dict ( ( ( k , v ) for k , v in self . __dict__ . iteritems ( ) if k != 'server' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper asking if the user want to download the file [CODESPLIT] def _user_yes_no_query ( self , question ) : sys . stdout . write ( '%s [y/n]\\n' % question ) while True : try : return strtobool ( raw_input ( ) . lower ( ) ) except ValueError : sys . stdout . write ( 'Please respond with \\'y\\' or \\'n\\'.\\n' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "JSON serializer for objects not serializable by default json code [CODESPLIT] def json_datetime_serial ( obj ) : if isinstance ( obj , ( datetime , date ) ) : serial = obj . isoformat ( ) return serial if ObjectId is not None and isinstance ( obj , ObjectId ) : # TODO: try to use bson.json_util instead return str ( obj ) raise TypeError ( \"Type not serializable\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper parse action to convert tokens to lower case . [CODESPLIT] def downcaseTokens ( s , l , t ) : return [ tt . lower ( ) for tt in map ( _ustr , t ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert the vector of labels dataY into one - hot encoding . [CODESPLIT] def to_one_hot ( dataY ) : nc = 1 + np . max ( dataY ) onehot = [ np . zeros ( nc , dtype = np . int8 ) for _ in dataY ] for i , j in enumerate ( dataY ) : onehot [ i ] [ j ] = 1 return onehot", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check for Python 3 . 5 matrix multiplication . [CODESPLIT] def matrix_at_check ( self , original , loc , tokens ) : return self . check_py ( \"35\" , \"matrix multiplication\" , original , loc , tokens )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The function compares strings ignoring case [CODESPLIT] def is_equal_strings_ignore_case ( first , second ) : if first and second : return first . upper ( ) == second . upper ( ) else : return not ( first or second )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Internal helper called to tell the property its name . [CODESPLIT] def _fix_up ( self , cls , code_name ) : self . _code_name = code_name if self . _name is None : self . _name = code_name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the dotproduct of two vectors . [CODESPLIT] def dot_v3 ( v , w ) : return sum ( [ x * y for x , y in zip ( v , w ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like dict . update but does not overwrite items [CODESPLIT] def dict_update_newkeys ( dict_ , dict2 ) : for key , val in six . iteritems ( dict2 ) : if key not in dict_ : dict_ [ key ] = val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Download the given JSON file and pretty - print before we output it . [CODESPLIT] def download_json ( local_filename , url , clobber = False ) : with open ( local_filename , 'w' ) as json_file : json_file . write ( json . dumps ( requests . get ( url ) . json ( ) , sort_keys = True , indent = 2 , separators = ( ',' , ': ' ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads image specified by path into numpy . ndarray [CODESPLIT] def read_img ( path ) : img = cv2 . resize ( cv2 . imread ( path , 0 ) , ( 80 , 30 ) ) . astype ( np . float32 ) / 255 img = np . expand_dims ( img . transpose ( 1 , 0 ) , 0 ) return img", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Download the given JSON file and pretty - print before we output it . [CODESPLIT] def download_json ( local_filename , url , clobber = False ) : with open ( local_filename , 'w' ) as json_file : json_file . write ( json . dumps ( requests . get ( url ) . json ( ) , sort_keys = True , indent = 2 , separators = ( ',' , ': ' ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a file into a string PRE : fname is a small file ( to avoid hogging memory and its discontents ) [CODESPLIT] def file_to_str ( fname ) : data = None # rU = read with Universal line terminator with open ( fname , 'rU' ) as fd : data = fd . read ( ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Download a file from a link in Python 3 . [CODESPLIT] def _download_py3 ( link , path , __hdr__ ) : try : req = urllib . request . Request ( link , headers = __hdr__ ) u = urllib . request . urlopen ( req ) except Exception as e : raise Exception ( ' Download failed with the error:\\n{}' . format ( e ) ) with open ( path , 'wb' ) as outf : for l in u : outf . write ( l ) u . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Writes a DOT graphviz file of the domain structure and returns the filename [CODESPLIT] def to_dotfile ( self ) : domain = self . get_domain ( ) filename = \"%s.dot\" % ( self . __class__ . __name__ ) nx . write_dot ( domain , filename ) return filename", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Use openpyxl to read an Excel file . [CODESPLIT] def _openpyxl_read_xl ( xl_path : str ) : try : wb = load_workbook ( filename = xl_path , read_only = True ) except : raise else : return wb", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return evidence codes in order shown in code2name . [CODESPLIT] def get_order ( self , codes ) : return sorted ( codes , key = lambda e : [ self . ev2idx . get ( e ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper parse action to convert tokens to upper case . [CODESPLIT] def upcaseTokens ( s , l , t ) : return [ tt . upper ( ) for tt in map ( _ustr , t ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert an OrderedDict containing C values to a 1D array . [CODESPLIT] def C_dict2array ( C ) : return np . hstack ( [ np . asarray ( C [ k ] ) . ravel ( ) for k in C_keys ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Emulate what a Python set () does but keeping the element s order . [CODESPLIT] def remove_duplicates ( lst ) : dset = set ( ) return [ l for l in lst if l not in dset and not dset . add ( l ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a path to its canonical case - normalized absolute version . [CODESPLIT] def normalize_path ( path ) : return os . path . normcase ( os . path . realpath ( os . path . expanduser ( path ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the haversine of an angle [CODESPLIT] def haversine ( x ) : y = .5 * x y = np . sin ( y ) return y * y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return possible range for min function . [CODESPLIT] def min_values ( args ) : return Interval ( min ( x . low for x in args ) , min ( x . high for x in args ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Close port . [CODESPLIT] def close ( self ) : os . close ( self . in_d ) os . close ( self . out_d )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve contents of each page of PDF [CODESPLIT] def resources ( self ) : return [ self . pdf . getPage ( i ) for i in range ( self . pdf . getNumPages ( ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Method to extract keywords from the text provided . [CODESPLIT] def extract_keywords_from_text ( self , text ) : sentences = nltk . tokenize . sent_tokenize ( text ) self . extract_keywords_from_sentences ( sentences )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deserializes string to date . [CODESPLIT] def deserialize_date ( string ) : try : from dateutil . parser import parse return parse ( string ) . date ( ) except ImportError : return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a bs4 object of the page requested [CODESPLIT] def get_soup ( page = '' ) : content = requests . get ( '%s/%s' % ( BASE_URL , page ) ) . text return BeautifulSoup ( content )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse a date using dateutil . parser . parse if available falling back to datetime . datetime . strptime if not [CODESPLIT] def parse_date ( s ) : if isinstance ( s , ( datetime . datetime , datetime . date ) ) : return s try : from dateutil . parser import parse except ImportError : parse = lambda d : datetime . datetime . strptime ( d , \"%Y-%m-%d\" ) return parse ( s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fill NaNs with the previous value the next value or if all are NaN then 1 . 0 [CODESPLIT] def clean_dataframe ( df ) : df = df . fillna ( method = 'ffill' ) df = df . fillna ( 0.0 ) return df", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Underlying synchronized wrapper . [CODESPLIT] def _synced ( method , self , args , kwargs ) : with self . _lock : return method ( * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the slice after at sub in string astr [CODESPLIT] def fsliceafter ( astr , sub ) : findex = astr . find ( sub ) return astr [ findex + len ( sub ) : ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap standard function to easily pass into map processing . [CODESPLIT] def map_wrap ( f ) : @ functools . wraps ( f ) def wrapper ( * args , * * kwargs ) : return f ( * args , * * kwargs ) return wrapper", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flat nested list of lists into a single list . [CODESPLIT] def flatten ( l , types = ( list , float ) ) : l = [ item if isinstance ( item , types ) else [ item ] for item in l ] return [ item for sublist in l for item in sublist ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ajout d un message de log de type DEBUG [CODESPLIT] def debug ( self , text ) : self . logger . debug ( \"{}{}\" . format ( self . message_prefix , text ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Safely convert a single number to integer . [CODESPLIT] def safe_int_conv ( number ) : try : return int ( np . array ( number ) . astype ( int , casting = 'safe' ) ) except TypeError : raise ValueError ( 'cannot safely convert {} to integer' . format ( number ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a shell - escaped version of the string s . [CODESPLIT] def quote ( self , s ) : if six . PY2 : from pipes import quote else : from shlex import quote return quote ( s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Safely convert a single number to integer . [CODESPLIT] def safe_int_conv ( number ) : try : return int ( np . array ( number ) . astype ( int , casting = 'safe' ) ) except TypeError : raise ValueError ( 'cannot safely convert {} to integer' . format ( number ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a absolute path in the file system . [CODESPLIT] def create_path ( path ) : import os if not os . path . exists ( path ) : os . makedirs ( path )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Translate an image in fourier - space with plane waves [CODESPLIT] def translate_fourier ( image , dx ) : N = image . shape [ 0 ] f = 2 * np . pi * np . fft . fftfreq ( N ) kx , ky , kz = np . meshgrid ( * ( f , ) * 3 , indexing = 'ij' ) kv = np . array ( [ kx , ky , kz ] ) . T q = np . fft . fftn ( image ) * np . exp ( - 1.j * ( kv * dx ) . sum ( axis = - 1 ) ) . T return np . real ( np . fft . ifftn ( q ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Main funcion when executing this module as script [CODESPLIT] def main_func ( args = None ) : # we have to initialize a gui even if we dont need one right now. # as soon as you call maya.standalone.initialize(), a QApplication # with type Tty is created. This is the type for conosle apps. # Because i have not found a way to replace that, we just init the gui. guimain . init_gui ( ) main . init ( ) launcher = Launcher ( ) parsed , unknown = launcher . parse_args ( args ) parsed . func ( parsed , unknown )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Code due to Thomas Heller - published in Python Cookbook ( O Reilley ) [CODESPLIT] def debug_on_error ( type , value , tb ) : traceback . print_exc ( type , value , tb ) print ( ) pdb . pm ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a vector randomly within the given rectangle . [CODESPLIT] def from_rectangle ( box ) : x = box . left + box . width * random . uniform ( 0 , 1 ) y = box . bottom + box . height * random . uniform ( 0 , 1 ) return Vector ( x , y )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Start a Pdb instance at the calling frame with stdout routed to sys . __stdout__ . [CODESPLIT] def set_trace ( ) : # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py pdb . Pdb ( stdout = sys . __stdout__ ) . set_trace ( sys . _getframe ( ) . f_back )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes duplicate objects . [CODESPLIT] def _remove_duplicates ( objects ) : seen , uniq = set ( ) , [ ] for obj in objects : obj_id = id ( obj ) if obj_id in seen : continue seen . add ( obj_id ) uniq . append ( obj ) return uniq", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Start a Pdb instance at the calling frame with stdout routed to sys . __stdout__ . [CODESPLIT] def set_trace ( ) : # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py pdb . Pdb ( stdout = sys . __stdout__ ) . set_trace ( sys . _getframe ( ) . f_back )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string from snake case to camel case . For example some_var would become someVar . [CODESPLIT] def to_camel_case ( snake_case_string ) : parts = snake_case_string . lstrip ( '_' ) . split ( '_' ) return parts [ 0 ] + '' . join ( [ i . title ( ) for i in parts [ 1 : ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get width and height of a PDF [CODESPLIT] def dimensions ( self ) : size = self . pdf . getPage ( 0 ) . mediaBox return { 'w' : float ( size [ 2 ] ) , 'h' : float ( size [ 3 ] ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "history Display a list of commands that have been entered . [CODESPLIT] def do_history ( self , line ) : self . _split_args ( line , 0 , 0 ) for idx , item in enumerate ( self . _history ) : d1_cli . impl . util . print_info ( \"{0: 3d} {1}\" . format ( idx , item ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pass in a dictionary that has unsafe characters as the keys and the percent encoded value as the value . [CODESPLIT] def quote ( s , unsafe = '/' ) : res = s . replace ( '%' , '%25' ) for c in unsafe : res = res . replace ( c , '%' + ( hex ( ord ( c ) ) . upper ( ) ) [ 2 : ] ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the given command ( with shell = False ) and return a tuple of ( int returncode str output ) . Strip the output of enclosing whitespace . [CODESPLIT] def call_out ( command ) : # start external command process p = subprocess . Popen ( command , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) # get outputs out , _ = p . communicate ( ) return p . returncode , out . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return type may come from any boolop operand . [CODESPLIT] def visit_BoolOp ( self , node ) : return sum ( ( self . visit ( value ) for value in node . values ) , [ ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns factor and offset of linear regression function by least squares method . [CODESPLIT] def linearRegressionAnalysis ( series ) : n = safeLen ( series ) sumI = sum ( [ i for i , v in enumerate ( series ) if v is not None ] ) sumV = sum ( [ v for i , v in enumerate ( series ) if v is not None ] ) sumII = sum ( [ i * i for i , v in enumerate ( series ) if v is not None ] ) sumIV = sum ( [ i * v for i , v in enumerate ( series ) if v is not None ] ) denominator = float ( n * sumII - sumI * sumI ) if denominator == 0 : return None else : factor = ( n * sumIV - sumI * sumV ) / denominator / series . step offset = sumII * sumV - sumIV * sumI offset = offset / denominator - factor * series . start return factor , offset", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the last n results ( or possibly less if not found ) . Note that the last results are not necessarily the best ones! Depending on the search type . [CODESPLIT] def searchlast ( self , n = 10 ) : solutions = deque ( [ ] , n ) for solution in self : solutions . append ( solution ) return solutions", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Try to find the token for the provided request token key . [CODESPLIT] def _get_token ( self , oauth_request , token_type = 'access' ) : token_field = oauth_request . get_parameter ( 'oauth_token' ) token = self . data_store . lookup_token ( token_type , token_field ) if not token : raise OAuthError ( 'Invalid %s token: %s' % ( token_type , token_field ) ) return token", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pause the music [CODESPLIT] def pause ( self ) : mixer . music . pause ( ) self . pause_time = self . get_time ( ) self . paused = True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the minimum of an array ignoring any NaNs . [CODESPLIT] def fn_min ( self , a , axis = None ) : return numpy . nanmin ( self . _to_ndarray ( a ) , axis = axis )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Process a matplotlib image object and call renderer . draw_image [CODESPLIT] def draw_image ( self , ax , image ) : self . renderer . draw_image ( imdata = utils . image_to_base64 ( image ) , extent = image . get_extent ( ) , coordinates = \"data\" , style = { \"alpha\" : image . get_alpha ( ) , \"zorder\" : image . get_zorder ( ) } , mplobj = image )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterative mean . [CODESPLIT] def average ( iterator ) : count = 0 total = 0 for num in iterator : count += 1 total += num return float ( total ) / count", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cartesian to Polar coordinates conversion . [CODESPLIT] def cart2pol ( x , y ) : theta = np . arctan2 ( y , x ) rho = np . hypot ( x , y ) return theta , rho", "target": 1, "target_options": ["no_match", "match"]}
{"input": "itertools . starmap for deferred callables using cooperative multitasking [CODESPLIT] def asyncStarCmap ( asyncCallable , iterable ) : results = [ ] yield coopStar ( asyncCallable , results . append , iterable ) returnValue ( results )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns names of object columns in the DataFrame . [CODESPLIT] def get_obj_cols ( df ) : obj_cols = [ ] for idx , dt in enumerate ( df . dtypes ) : if dt == 'object' or is_category ( dt ) : obj_cols . append ( df . columns . values [ idx ] ) return obj_cols", "target": 1, "target_options": ["no_match", "match"]}
{"input": "http : // stackoverflow . com / questions / 1230669 / subprocess - deleting - child - processes - in - windows [CODESPLIT] def _psutil_kill_pid ( pid ) : try : parent = Process ( pid ) for child in parent . children ( recursive = True ) : child . kill ( ) parent . kill ( ) except NoSuchProcess : return", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Called when a new DropDownItem gets selected . [CODESPLIT] def onchange ( self , value ) : log . debug ( 'combo box. selected %s' % value ) self . select_by_value ( value ) return ( value , )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "postfix_expr : left_hand_side_expr | left_hand_side_expr PLUSPLUS | left_hand_side_expr MINUSMINUS [CODESPLIT] def p_postfix_expr ( self , p ) : if len ( p ) == 2 : p [ 0 ] = p [ 1 ] else : p [ 0 ] = ast . UnaryOp ( op = p [ 2 ] , value = p [ 1 ] , postfix = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve the given URL using PhantomJS . PhantomJS will evaluate all scripts and return the HTML after body . onload . url - The page URL to retrieve data - The form data . TODO : Currently ignored . [CODESPLIT] def phantomjs_retrieve ( url , data = None ) : range_limit ( ) print \"pGET\" , url process = subprocess . Popen ( [ 'phantomjs' , PHANTOM_SCRIPT , url ] , stdout = subprocess . PIPE ) out = process . communicate ( ) process . wait ( ) response = out [ 0 ] . decode ( 'utf-8' , 'ignore' ) status = response [ : 2 ] body = response [ 3 : ] # After the 'ok ' part. if status == 'ok' : return 200 , body else : return 404 , body", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a nested list and returns the size of each dimension followed by the element type in the list [CODESPLIT] def get_list_dimensions ( _list ) : if isinstance ( _list , list ) or isinstance ( _list , tuple ) : return [ len ( _list ) ] + get_list_dimensions ( _list [ 0 ] ) return [ ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Gets the string representation of the given type . [CODESPLIT] def getTypeStr ( _type ) : if isinstance ( _type , CustomType ) : return str ( _type ) if hasattr ( _type , '__name__' ) : return _type . __name__ return ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "iterator version of get_list_column [CODESPLIT] def iget_list_column_slice ( list_ , start = None , stop = None , stride = None ) : if isinstance ( start , slice ) : slice_ = start else : slice_ = slice ( start , stop , stride ) return ( row [ slice_ ] for row in list_ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format a Python o into a pretty - printed representation . [CODESPLIT] def pformat ( o , indent = 1 , width = 80 , depth = None ) : return PrettyPrinter ( indent = indent , width = width , depth = depth ) . pformat ( o )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return start and end date of this quarter . [CODESPLIT] def this_quarter ( ) : since = TODAY + delta ( day = 1 ) while since . month % 3 != 0 : since -= delta ( months = 1 ) until = since + delta ( months = 3 ) return Date ( since ) , Date ( until )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prints stack trace for current exceptions chain . [CODESPLIT] def print_trace ( self ) : traceback . print_exc ( ) for tb in self . tracebacks : print tb , print ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the help text ( signature + docstring ) for a command ( function ) . [CODESPLIT] def help_for_command ( command ) : help_text = pydoc . text . document ( command ) # remove backspaces return re . subn ( '.\\\\x08' , '' , help_text ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if git command is available . [CODESPLIT] def check_git ( ) : try : with open ( os . devnull , \"wb\" ) as devnull : subprocess . check_call ( [ \"git\" , \"--version\" ] , stdout = devnull , stderr = devnull ) except : raise RuntimeError ( \"Please make sure git is installed and on your path.\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Output data as a nicely - formatted python data structure [CODESPLIT] def py ( self , output ) : import pprint pprint . pprint ( output , stream = self . outfile )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty print the object s representation . [CODESPLIT] def pretty ( obj , verbose = False , max_width = 79 , newline = '\\n' ) : stream = StringIO ( ) printer = RepresentationPrinter ( stream , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) return stream . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the length in bytes of a given file object . Necessary because os . fstat only works on real files and not file - like objects . This works on more types of streams primarily StringIO . [CODESPLIT] def file_length ( file_obj ) : file_obj . seek ( 0 , 2 ) length = file_obj . tell ( ) file_obj . seek ( 0 ) return length", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prints DB data representation of the object . [CODESPLIT] def prnt ( self ) : print ( \"= = = =\\n\\n%s object key: \\033[32m%s\\033[0m\" % ( self . __class__ . __name__ , self . key ) ) pprnt ( self . _data or self . clean_value ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a timestamp string into a microseconds value : param timestamp : return time in microseconds [CODESPLIT] def timestamp_to_microseconds ( timestamp ) : timestamp_str = datetime . datetime . strptime ( timestamp , ISO_DATETIME_REGEX ) epoch_time_secs = calendar . timegm ( timestamp_str . timetuple ( ) ) epoch_time_mus = epoch_time_secs * 1e6 + timestamp_str . microsecond return epoch_time_mus", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print results straight to stdout [CODESPLIT] def stdout_display ( ) : if sys . version_info [ 0 ] == 2 : yield SmartBuffer ( sys . stdout ) else : yield SmartBuffer ( sys . stdout . buffer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Choose the most common item from the list or the first item if all items are unique . [CODESPLIT] def mostCommonItem ( lst ) : # This elegant solution from: http://stackoverflow.com/a/1518632/1760218 lst = [ l for l in lst if l ] if lst : return max ( set ( lst ) , key = lst . count ) else : return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Startup of the node . : param join : optionally wait for the process to end ( default : True ) : return : None [CODESPLIT] def start ( self , timeout = None ) : assert super ( PyrosBase , self ) . start ( timeout = timeout ) # Because we currently use this to setup connection return self . name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a tuple of strings that match the regular expression pattern . [CODESPLIT] def filter_regex ( names , regex ) : return tuple ( name for name in names if regex . search ( name ) is not None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Value of property . [CODESPLIT] def value ( self ) : if self . _prop . fget is None : raise AttributeError ( 'Unable to read attribute' ) return self . _prop . fget ( self . _obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Subclasses may override this method . [CODESPLIT] def _get_points ( self ) : return tuple ( [ self . _getitem__points ( i ) for i in range ( self . _len__points ( ) ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format a list of error_names into a pylint : disable = line . [CODESPLIT] def format_pylint_disables ( error_names , tag = True ) : tag_str = \"lint-amnesty, \" if tag else \"\" if error_names : return u\"  # {tag}pylint: disable={disabled}\" . format ( disabled = \", \" . join ( sorted ( error_names ) ) , tag = tag_str , ) else : return \"\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates an array of n true random numbers obtained from the quantum random number generator at qrng . anu . edu . au [CODESPLIT] def qrandom ( n ) : import quantumrandom return np . concatenate ( [ quantumrandom . get_data ( data_type = 'uint16' , array_length = 1024 ) for i in range ( int ( np . ceil ( n / 1024.0 ) ) ) ] ) [ : n ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete all rows from a table : param dbconn : data base connection : param table_name : name of the table : return : [CODESPLIT] def clear_table ( dbconn , table_name ) : cur = dbconn . cursor ( ) cur . execute ( \"DELETE FROM '{name}'\" . format ( name = table_name ) ) dbconn . commit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert to lowercase and strip spaces [CODESPLIT] def lowstrip ( term ) : term = re . sub ( '\\s+' , ' ' , term ) term = term . lower ( ) return term", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Change the mode ( permissions ) of this file . The permissions are unix - style and identical to those used by python s C { os . chmod } function . [CODESPLIT] def chmod ( self , mode ) : self . sftp . _log ( DEBUG , 'chmod(%s, %r)' % ( hexlify ( self . handle ) , mode ) ) attr = SFTPAttributes ( ) attr . st_mode = mode self . sftp . _request ( CMD_FSETSTAT , self . handle , attr )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the tests . [CODESPLIT] def test ( ctx , all = False , verbose = False ) : cmd = 'tox' if all else 'py.test' if verbose : cmd += ' -v' return ctx . run ( cmd , pty = True ) . return_code", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a column of the given matrix . [CODESPLIT] def get_column ( self , X , column ) : if isinstance ( X , pd . DataFrame ) : return X [ column ] . values return X [ : , column ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set value of the checkbox . [CODESPLIT] def set_value ( self , value ) : if value : self . setCheckState ( Qt . Checked ) else : self . setCheckState ( Qt . Unchecked )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show the x - axis tick labels for a subplot . [CODESPLIT] def show_xticklabels ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . show_xticklabels ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reimplement Qt method [CODESPLIT] def resizeEvent ( self , event ) : if not self . isMaximized ( ) and not self . fullscreen_flag : self . window_size = self . size ( ) QMainWindow . resizeEvent ( self , event ) # To be used by the tour to be able to resize\n self . sig_resized . emit ( event )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prints a summary table . [CODESPLIT] def PrintSummaryTable ( self ) : print ( \"\"\"\n\nAs of {0:s} the repository contains:\n\n| **File paths covered** | **{1:d}** |\n| :------------------ | ------: |\n| **Registry keys covered** | **{2:d}** |\n| **Total artifacts** | **{3:d}** |\n\"\"\" . format ( time . strftime ( '%Y-%m-%d' ) , self . path_count , self . reg_key_count , self . total_count ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the current LED state by querying the remote controller . [CODESPLIT] def state ( self ) : ev = self . _query_waiters . request ( self . __do_query_state ) ev . wait ( 1.0 ) return self . _state", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Manually refresh the swagger document . This can help resolve errors communicate with the API . [CODESPLIT] def refresh_swagger ( self ) : try : os . remove ( self . _get_swagger_filename ( self . swagger_url ) ) except EnvironmentError as e : logger . warn ( os . strerror ( e . errno ) ) else : self . __init__ ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if the queue is full [CODESPLIT] def full ( self ) : if not self . size : return False return len ( self . pq ) == ( self . size + self . removed_count )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Conveinience : [CODESPLIT] def get_tablenames ( cur ) : cur . execute ( \"SELECT name FROM sqlite_master WHERE type='table'\" ) tablename_list_ = cur . fetchall ( ) tablename_list = [ str ( tablename [ 0 ] ) for tablename in tablename_list_ ] return tablename_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Emulate what a Python set () does but keeping the element s order . [CODESPLIT] def remove_duplicates ( lst ) : dset = set ( ) return [ l for l in lst if l not in dset and not dset . add ( l ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function that gets relative path to the filename [CODESPLIT] def rel_path ( filename ) : return os . path . join ( os . getcwd ( ) , os . path . dirname ( __file__ ) , filename )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts bokehJS timestamp to datetime64 . [CODESPLIT] def convert_timestamp ( timestamp ) : datetime = dt . datetime . utcfromtimestamp ( timestamp / 1000. ) return np . datetime64 ( datetime . replace ( tzinfo = None ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns file name of file at given url . [CODESPLIT] def get_file_name ( url ) : return os . path . basename ( urllib . parse . urlparse ( url ) . path ) or 'unknown_name'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "quit crash [CODESPLIT] def _quit ( self , * args ) : self . logger . warn ( 'Bye!' ) sys . exit ( self . exit ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prepare the handler ensuring RabbitMQ is connected or start a new connection attempt . [CODESPLIT] def prepare ( self ) : super ( RabbitMQRequestHandler , self ) . prepare ( ) if self . _rabbitmq_is_closed : self . _connect_to_rabbitmq ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "For list values returns the index location of element x . If x does not exist will raise an error . [CODESPLIT] def sorted_index ( values , x ) : i = bisect_left ( values , x ) j = bisect_right ( values , x ) return values [ i : j ] . index ( x ) + i", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Random normal variates . [CODESPLIT] def rnormal ( mu , tau , size = None ) : return np . random . normal ( mu , 1. / np . sqrt ( tau ) , size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of active CPUs on a Darwin system . [CODESPLIT] def _num_cpus_darwin ( ) : p = subprocess . Popen ( [ 'sysctl' , '-n' , 'hw.ncpu' ] , stdout = subprocess . PIPE ) return p . stdout . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the name of the newest file given an iterable of file names . [CODESPLIT] def newest_file ( file_iterable ) : return max ( file_iterable , key = lambda fname : os . path . getmtime ( fname ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return module * modname * base path [CODESPLIT] def get_module_path ( modname ) : return osp . abspath ( osp . dirname ( sys . modules [ modname ] . __file__ ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If output is string then print the string and also time used [CODESPLIT] def timeit ( output ) : b = time . time ( ) yield print output , 'time used: %.3fs' % ( time . time ( ) - b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a string from a file - like object . [CODESPLIT] def read_string ( buff , byteorder = 'big' ) : length = read_numeric ( USHORT , buff , byteorder ) return buff . read ( length ) . decode ( 'utf-8' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add widget actions to toolbar [CODESPLIT] def add_to_toolbar ( self , toolbar , widget ) : actions = widget . toolbar_actions if actions is not None : add_actions ( toolbar , actions )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": rtype : numpy matrix [CODESPLIT] def load_data ( filename ) : data = pandas . read_csv ( filename , header = None , delimiter = '\\t' , skiprows = 9 ) return data . as_matrix ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a ( probably ) unique ID to identify a system . Used to differentiate votes . [CODESPLIT] def get_system_uid ( ) : try : if os . name == 'nt' : return get_nt_system_uid ( ) if sys . platform == 'darwin' : return get_osx_system_uid ( ) except Exception : return get_mac_uid ( ) else : return get_mac_uid ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove comments and empty lines [CODESPLIT] def lines ( input ) : for raw_line in input : line = raw_line . strip ( ) if line and not line . startswith ( '#' ) : yield strip_comments ( line )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get user name provide by operating system [CODESPLIT] def get_user_name ( ) : if sys . platform == 'win32' : #user = os.getenv('USERPROFILE') user = os . getenv ( 'USERNAME' ) else : user = os . getenv ( 'LOGNAME' ) return user", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the lines for a file from the cache . Update the cache if it doesn t contain an entry for this file already . [CODESPLIT] def getlines ( filename , module_globals = None ) : if filename in cache : return cache [ filename ] [ 2 ] try : return updatecache ( filename , module_globals ) except MemoryError : clearcache ( ) return [ ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return calculated y - values for the domain of x - values in [ 1 num_x ] . [CODESPLIT] def compute_y ( self , coefficients , num_x ) : y_vals = [ ] for x in range ( 1 , num_x + 1 ) : y = sum ( [ c * x ** i for i , c in enumerate ( coefficients [ : : - 1 ] ) ] ) y_vals . append ( y ) return y_vals", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to read bytes until a certain end byte is hit [CODESPLIT] def _readuntil ( f , end = _TYPE_END ) : buf = bytearray ( ) byte = f . read ( 1 ) while byte != end : if byte == b'' : raise ValueError ( 'File ended unexpectedly. Expected end byte {}.' . format ( end ) ) buf += byte byte = f . read ( 1 ) return buf", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds a pos1 element to a frog token . [CODESPLIT] def _add_pos1 ( token ) : result = token . copy ( ) result [ 'pos1' ] = _POSMAP [ token [ 'pos' ] . split ( \"(\" ) [ 0 ] ] return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read entire contents of file into a string . [CODESPLIT] def read_string_from_file ( path , encoding = \"utf8\" ) : with codecs . open ( path , \"rb\" , encoding = encoding ) as f : value = f . read ( ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the given path relative to this file . [CODESPLIT] def relative_path ( path ) : return os . path . join ( os . path . dirname ( __file__ ) , path )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show a basic reference about the GUI Console . [CODESPLIT] def page_guiref ( arg_s = None ) : from IPython . core import page page . page ( gui_reference , auto_html = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generator for reading from standard input in nonblocking mode . [CODESPLIT] def _read_stdin ( ) : line = sys . stdin . readline ( ) while line : yield line line = sys . stdin . readline ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Saves the case as an Excel spreadsheet . [CODESPLIT] def save_excel ( self , fd ) : from pylon . io . excel import ExcelWriter ExcelWriter ( self ) . write ( fd )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Python s input () is blocking which means the event loop we set above can t be running while we re blocking there . This method will let the loop run while we wait for input . [CODESPLIT] async def async_input ( prompt ) : print ( prompt , end = '' , flush = True ) return ( await loop . run_in_executor ( None , sys . stdin . readline ) ) . rstrip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convenience method for just changing font size . [CODESPLIT] def set_font_size ( self , size ) : if self . font . font_size == size : pass else : self . font . _set_size ( size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns json contents as string [CODESPLIT] def open_json ( file_name ) : with open ( file_name , \"r\" ) as json_data : data = json . load ( json_data ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get zero - indexed line from an open file - like . [CODESPLIT] def get_lines ( handle , line ) : for i , l in enumerate ( handle ) : if i == line : return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns if given object is read only ( built - in or extension ) . [CODESPLIT] def is_read_only ( object ) : try : attribute = \"_trace__read__\" setattr ( object , attribute , True ) delattr ( object , attribute ) return False except ( TypeError , AttributeError ) : return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return 2D arrays of x and y map coordinates for input GDAL Dataset [CODESPLIT] def get_xy_grids ( ds , stride = 1 , getval = False ) : gt = ds . GetGeoTransform ( ) #stride = stride_m/gt[1] pX = np . arange ( 0 , ds . RasterXSize , stride ) pY = np . arange ( 0 , ds . RasterYSize , stride ) psamp = np . meshgrid ( pX , pY ) mX , mY = pixelToMap ( psamp [ 0 ] , psamp [ 1 ] , gt ) return mX , mY", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse Config File from yaml file . [CODESPLIT] def _parse_config ( config_file_path ) : config_file = open ( config_file_path , 'r' ) config = yaml . load ( config_file ) config_file . close ( ) return config", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Invert mapping of dictionary ( i . e . map values to list of keys ) [CODESPLIT] def invertDictMapping ( d ) : inv_map = { } for k , v in d . items ( ) : inv_map [ v ] = inv_map . get ( v , [ ] ) inv_map [ v ] . append ( k ) return inv_map", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Forward mouse cursor position events to the example [CODESPLIT] def mouse_move_event ( self , event ) : self . example . mouse_position_event ( event . x ( ) , event . y ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return type string compatible with numpy . [CODESPLIT] def get_var_type ( self , name ) : name = create_string_buffer ( name ) type_ = create_string_buffer ( MAXSTRLEN ) self . library . get_var_type . argtypes = [ c_char_p , c_char_p ] self . library . get_var_type ( name , type_ ) return type_ . value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "acquire a single redis node [CODESPLIT] def acquire_node ( self , node ) : try : return node . set ( self . resource , self . lock_key , nx = True , px = self . ttl ) except ( redis . exceptions . ConnectionError , redis . exceptions . TimeoutError ) : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call java and return version information . [CODESPLIT] def java_version ( ) : result = subprocess . check_output ( [ c . JAVA , '-version' ] , stderr = subprocess . STDOUT ) first_line = result . splitlines ( ) [ 0 ] return first_line . decode ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Emulate expireat [CODESPLIT] def expireat ( self , key , when ) : expire_time = datetime . fromtimestamp ( when ) key = self . _encode ( key ) if key in self . redis : self . timeouts [ key ] = expire_time return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Register all globally visible functions . [CODESPLIT] def init_checks_registry ( ) : mod = inspect . getmodule ( register_check ) for ( name , function ) in inspect . getmembers ( mod , inspect . isfunction ) : register_check ( function )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Traverse parent refs to top . [CODESPLIT] def find_root ( self ) : cmd = self while cmd . parent : cmd = cmd . parent return cmd", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load a texture from a file into a PIL image . [CODESPLIT] def _load_texture ( file_name , resolver ) : file_data = resolver . get ( file_name ) image = PIL . Image . open ( util . wrap_as_stream ( file_data ) ) return image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a repr () for a list / tuple [CODESPLIT] def _tuple_repr ( data ) : if len ( data ) == 1 : return \"(%s,)\" % rpr ( data [ 0 ] ) else : return \"(%s)\" % \", \" . join ( [ rpr ( x ) for x in data ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Loads a model from specified file [CODESPLIT] def Load ( file ) : with open ( file , 'rb' ) as file : model = dill . load ( file ) return model", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate all matches found within a string for a regex and yield each match as a string [CODESPLIT] def iter_finds ( regex_obj , s ) : if isinstance ( regex_obj , str ) : for m in re . finditer ( regex_obj , s ) : yield m . group ( ) else : for m in regex_obj . finditer ( s ) : yield m . group ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a symmetrical binary tree with [CODESPLIT] def make_bintree ( levels ) : G = nx . DiGraph ( ) root = '0' G . add_node ( root ) add_children ( G , root , levels , 2 ) return G", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A decorator that returns a clone of the current object so that we can re - use the object for similar requests . [CODESPLIT] def _makes_clone ( _func , * args , * * kw ) : self = args [ 0 ] . _clone ( ) _func ( self , * args [ 1 : ] , * * kw ) return self", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a string composed of elements in inlist with each element separated by delimiter . Used by function writedelimited . Use \\ t for tab - delimiting . [CODESPLIT] def linedelimited ( inlist , delimiter ) : outstr = '' for item in inlist : if type ( item ) != StringType : item = str ( item ) outstr = outstr + item + delimiter outstr = outstr [ 0 : - 1 ] return outstr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "validate that we can store the multi - index ; reset and return the new object [CODESPLIT] def validate_multiindex ( self , obj ) : levels = [ l if l is not None else \"level_{0}\" . format ( i ) for i , l in enumerate ( obj . index . names ) ] try : return obj . reset_index ( ) , levels except ValueError : raise ValueError ( \"duplicate names/columns in the multi-index when \" \"storing as a table\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Displays a simple message box with text and a single OK button . Returns the text of the button clicked on . [CODESPLIT] def alert ( text = '' , title = '' , button = OK_TEXT , root = None , timeout = None ) : assert TKINTER_IMPORT_SUCCEEDED , 'Tkinter is required for pymsgbox' return _buttonbox ( msg = text , title = title , choices = [ str ( button ) ] , root = root , timeout = timeout )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses CREATE INDEX CONCURRENTLY to create a duplicate index then tries to swap the new index for the original . [CODESPLIT] def cmd_reindex ( ) : db = connect ( args . database ) for idx in args . indexes : pg_reindex ( db , idx )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def list_add_capitalize ( l ) : nl = [ ] for i in l : nl . append ( i ) if hasattr ( i , \"capitalize\" ) : nl . append ( i . capitalize ( ) ) return list ( set ( nl ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call it on your own endpoint s to update the back history navigation . If you bypass it the next submit or back will go over it . [CODESPLIT] def update_redirect ( self ) : page_history = Stack ( session . get ( \"page_history\" , [ ] ) ) page_history . push ( request . url ) session [ \"page_history\" ] = page_history . to_json ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a generator of tuples k c such that k is the name of the python attribute for the column and c is the name of the column in the sql table . [CODESPLIT] def get_column_keys_and_names ( table ) : ins = inspect ( table ) return ( ( k , c . name ) for k , c in ins . mapper . c . items ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Filter the dict * d * to remove keys not in * keys * . [CODESPLIT] def filter_dict_by_key ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "extract features in a sentence [CODESPLIT] def sent2features ( sentence , template ) : return [ word2features ( sentence , i , template ) for i in range ( len ( sentence ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Handles whitespace cleanup . [CODESPLIT] def handle_whitespace ( text ) : text = re_retab . sub ( sub_retab , text ) text = re_whitespace . sub ( '' , text ) . strip ( ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function returns a pretty table used to display the port results . [CODESPLIT] def get_table ( ports ) : table = PrettyTable ( [ \"Name\" , \"Port\" , \"Protocol\" , \"Description\" ] ) table . align [ \"Name\" ] = \"l\" table . align [ \"Description\" ] = \"l\" table . padding_width = 1 for port in ports : table . add_row ( port ) return table", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes trailing zeros in the list of integers and returns a new list of integers [CODESPLIT] def _remove_blank ( l ) : ret = [ ] for i , _ in enumerate ( l ) : if l [ i ] == 0 : break ret . append ( l [ i ] ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Erases n lines from the screen and moves the cursor up to follow [CODESPLIT] def erase_lines ( n = 1 ) : for _ in range ( n ) : print ( codes . cursor [ \"up\" ] , end = \"\" ) print ( codes . cursor [ \"eol\" ] , end = \"\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "set colouring on if STDOUT is a terminal device off otherwise [CODESPLIT] def auto ( ) : try : Style . enabled = False Style . enabled = sys . stdout . isatty ( ) except ( AttributeError , TypeError ) : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Scattering form - factor amplitude of a sphere normalized to F ( q = 0 ) = V [CODESPLIT] def Fsphere ( q , R ) : return 4 * np . pi / q ** 3 * ( np . sin ( q * R ) - q * R * np . cos ( q * R ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes dict keys which have have self as value . [CODESPLIT] def _remove_dict_keys_with_value ( dict_ , val ) : return { k : v for k , v in dict_ . items ( ) if v is not val }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert snake_case to camel_case . [CODESPLIT] def to_identifier ( s ) : if s . startswith ( 'GPS' ) : s = 'Gps' + s [ 3 : ] return '' . join ( [ i . capitalize ( ) for i in s . split ( '_' ) ] ) if '_' in s else s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Makes the list have unique items only and maintains the order [CODESPLIT] def unique ( _list ) : ret = [ ] for item in _list : if item not in ret : ret . append ( item ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a new IPAString containing only the vowels in the current string . [CODESPLIT] def vowels ( self ) : return IPAString ( ipa_chars = [ c for c in self . ipa_chars if c . is_vowel ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "prune all but the first ( = best ) n items [CODESPLIT] def prune ( self , n ) : if self . minimize : self . data = self . data [ : n ] else : self . data = self . data [ - 1 * n : ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Render an INPUT element of type SUBMIT which will post this form to the server . [CODESPLIT] def submitbutton ( self , request , tag ) : return tags . input ( type = 'submit' , name = '__submit__' , value = self . _getDescription ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Recursivly delete a directory [CODESPLIT] def rrmdir ( directory ) : for root , dirs , files in os . walk ( directory , topdown = False ) : for name in files : os . remove ( os . path . join ( root , name ) ) for name in dirs : os . rmdir ( os . path . join ( root , name ) ) os . rmdir ( directory )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Nested lists to single - level list does not split strings [CODESPLIT] def flatten_list ( l ) : return list ( chain . from_iterable ( repeat ( x , 1 ) if isinstance ( x , str ) else x for x in l ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a dictionary and a key list remove any data in the dictionary with the given keys . [CODESPLIT] def rm_keys_from_dict ( d , keys ) : # Loop for each key given for key in keys : # Is the key in the dictionary? if key in d : try : d . pop ( key , None ) except KeyError : # Not concerned with an error. Keep going. pass return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create parametric ellipse from 200 points . [CODESPLIT] def create_ellipse ( width , height , angle ) : angle = angle / 180.0 * np . pi thetas = np . linspace ( 0 , 2 * np . pi , 200 ) a = width / 2.0 b = height / 2.0 x = a * np . cos ( thetas ) * np . cos ( angle ) - b * np . sin ( thetas ) * np . sin ( angle ) y = a * np . cos ( thetas ) * np . sin ( angle ) + b * np . sin ( thetas ) * np . cos ( angle ) z = np . zeros ( thetas . shape ) return np . vstack ( ( x , y , z ) ) . T", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove null items from a dictionary [CODESPLIT] def purge_dict ( idict ) : odict = { } for key , val in idict . items ( ) : if is_null ( val ) : continue odict [ key ] = val return odict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set foreground - and background colors and intensity . [CODESPLIT] def set_color ( self , fg = None , bg = None , intensify = False , target = sys . stdout ) : raise NotImplementedError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove and return the item at index . [CODESPLIT] def pop ( self , index = - 1 ) : value = self . _list . pop ( index ) del self . _dict [ value ] return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Select rows where the given field evaluates True . [CODESPLIT] def selecttrue ( table , field , complement = False ) : return select ( table , field , lambda v : bool ( v ) , complement = complement )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace accentuated chars in string by their non accentuated equivalent . [CODESPLIT] def unaccentuate ( s ) : return \"\" . join ( c for c in unicodedata . normalize ( \"NFKD\" , s ) if not unicodedata . combining ( c ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A non - optimal implementation of a regex filter [CODESPLIT] def subn_filter ( s , find , replace , count = 0 ) : return re . gsub ( find , replace , count , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Center all lines of the text . It is assumed that all lines width is smaller then B { width } because the line width will not be checked . Args : text ( str ) : Text to wrap . width ( int ) : Maximum number of characters per line . Returns : str : Centered text . [CODESPLIT] def center_text ( text , width = 80 ) : centered = [ ] for line in text . splitlines ( ) : centered . append ( line . center ( width ) ) return \"\\n\" . join ( centered )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "stupid windows . converts the backslash to forwardslash for consistency [CODESPLIT] def __unixify ( self , s ) : return os . path . normpath ( s ) . replace ( os . sep , \"/\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Does a string replace with a list of search and replacements [CODESPLIT] def multi_replace ( instr , search_list = [ ] , repl_list = None ) : repl_list = [ '' ] * len ( search_list ) if repl_list is None else repl_list for ser , repl in zip ( search_list , repl_list ) : instr = instr . replace ( ser , repl ) return instr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Register relation endpoint ( s ) between two resources . [CODESPLIT] def configure_relation ( graph , ns , mappings ) : convention = RelationConvention ( graph ) convention . configure ( ns , mappings )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "replace nan in a by val and returns the replaced array and the nan position [CODESPLIT] def _replace_nan ( a , val ) : mask = isnull ( a ) return where_method ( val , mask , a ) , mask", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print a colored string to the target handle . [CODESPLIT] def cprint ( string , fg = None , bg = None , end = '\\n' , target = sys . stdout ) : _color_manager . set_color ( fg , bg ) target . write ( string + end ) target . flush ( ) # Needed for Python 3.x _color_manager . set_defaults ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def http_request_json ( * args , * * kwargs ) : ret , status = http_request ( * args , * * kwargs ) return json . loads ( ret ) , status", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def stdoutwriteline ( * args ) : s = \"\" for i in args : s += str ( i ) + \" \" s = s . strip ( ) sys . stdout . write ( str ( s ) + \"\\n\" ) sys . stdout . flush ( ) return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates requests session user - agent with the driver s user agent [CODESPLIT] def copy_user_agent_from_driver ( self ) : selenium_user_agent = self . driver . execute_script ( \"return navigator.userAgent;\" ) self . headers . update ( { \"user-agent\" : selenium_user_agent } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Message printer . [CODESPLIT] def _show ( self , message , indent = 0 , enable_verbose = True ) : # pragma: no cover if enable_verbose : print ( \"    \" * indent + message )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Not meant to be used directly use : meth : Instaloader . save_session_to_file . [CODESPLIT] def save_session_to_file ( self , sessionfile ) : pickle . dump ( requests . utils . dict_from_cookiejar ( self . _session . cookies ) , sessionfile )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if an http server runs on a given port . [CODESPLIT] def is_http_running_on ( port ) : try : conn = httplib . HTTPConnection ( '127.0.0.1:' + str ( port ) ) conn . connect ( ) conn . close ( ) return True except Exception : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the text fetched via http GET from URL read as encoding [CODESPLIT] def download ( url , encoding = 'utf-8' ) : import requests response = requests . get ( url ) response . encoding = encoding return response . text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "extract features in a sentence [CODESPLIT] def sent2features ( sentence , template ) : return [ word2features ( sentence , i , template ) for i in range ( len ( sentence ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "clear plot [CODESPLIT] def clear ( self ) : self . axes . cla ( ) self . conf . ntrace = 0 self . conf . xlabel = '' self . conf . ylabel = '' self . conf . title = ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "( x y ) position of the mouse on the screen . type : ( int int ) [CODESPLIT] def __init__ ( self , pos , cell , motion , cellmotion ) : self . pos = pos self . cell = cell \"\"\"(x, y) position of the mouse snapped to a cell on the root console.\n        type: (int, int)\"\"\" self . motion = motion \"\"\"(x, y) motion of the mouse on the screen.\n        type: (int, int)\"\"\" self . cellmotion = cellmotion \"\"\"(x, y) mostion of the mouse moving over cells on the root console.\n        type: (int, int)\"\"\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resize current array . If size is None then array became nonfixed - length array . If new size is less then current size and value then value will be truncated ( lesser significant bits will be truncated ) . [CODESPLIT] def resize ( self , size ) : if size is not None : self . __value = int ( WBinArray ( self . __value ) [ : size ] ) self . __size = size", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print list of strings to the predefined stdout . [CODESPLIT] def print_out ( self , * lst ) : self . print2file ( self . stdout , True , True , * lst )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Disable the hourglass cursor and listen for layer changes . [CODESPLIT] def disable_busy_cursor ( ) : while QgsApplication . instance ( ) . overrideCursor ( ) is not None and QgsApplication . instance ( ) . overrideCursor ( ) . shape ( ) == QtCore . Qt . WaitCursor : QgsApplication . instance ( ) . restoreOverrideCursor ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turns response into a properly formatted json or text object [CODESPLIT] async def json_or_text ( response ) : text = await response . text ( ) if response . headers [ 'Content-Type' ] == 'application/json; charset=utf-8' : return json . loads ( text ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get authentication . [CODESPLIT] def get_auth ( ) : import getpass user = input ( \"User Name: \" ) # noqa pswd = getpass . getpass ( 'Password: ' ) return Github ( user , pswd )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Starts the process of building a new HTTP route linked to this API instance [CODESPLIT] def http ( self , * args , * * kwargs ) : kwargs [ 'api' ] = self . api return http ( * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Unix shell - style wildcards . Case - insensitive [CODESPLIT] def ILIKE ( pattern ) : return P ( lambda x : fnmatch . fnmatch ( x . lower ( ) , pattern . lower ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the documentation that the server sends for the API . [CODESPLIT] def documentation ( self ) : newclient = self . __class__ ( self . session , self . root_url ) return newclient . get_raw ( '/' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add indent of indent spaces to string . split ( \\ n ) [ 1 : ] [CODESPLIT] def _add_indent ( string , indent ) : lines = string . split ( \"\\n\" ) first , lines = lines [ 0 ] , lines [ 1 : ] lines = [ \"{indent}{s}\" . format ( indent = \" \" * indent , s = s ) for s in lines ] lines = [ first ] + lines return \"\\n\" . join ( lines )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given GO IDs return key GO IDs . [CODESPLIT] def get_key_goids ( self , goids ) : go2obj = self . go2obj return set ( go2obj [ go ] . id for go in goids )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Requests - mock requests . post wrapper . [CODESPLIT] def requests_post ( url , data = None , json = None , * * kwargs ) : return requests_request ( 'post' , url , data = data , json = json , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract the boundaries from a list of indexes [CODESPLIT] def get_idx_rect ( index_list ) : rows , cols = list ( zip ( * [ ( i . row ( ) , i . column ( ) ) for i in index_list ] ) ) return ( min ( rows ) , max ( rows ) , min ( cols ) , max ( cols ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Move cursor to this line in the current buffer . [CODESPLIT] def _go_to_line ( editor , line ) : b = editor . application . current_buffer b . cursor_position = b . document . translate_row_col_to_index ( max ( 0 , int ( line ) - 1 ) , 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the first location in our array that is not empty [CODESPLIT] def find_start_point ( self ) : for i , row in enumerate ( self . data ) : for j , _ in enumerate ( row ) : if self . data [ i , j ] != 0 : # or not np.isfinite(self.data[i,j]): return i , j", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Same order unique list using only a list compression . [CODESPLIT] def uniquify_list ( L ) : return [ e for i , e in enumerate ( L ) if L . index ( e ) == i ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize the length of a vector to one [CODESPLIT] def norm_vec ( vector ) : assert len ( vector ) == 3 v = np . array ( vector ) return v / np . sqrt ( np . sum ( v ** 2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get string from file . [CODESPLIT] def get_file_string ( filepath ) : with open ( os . path . abspath ( filepath ) ) as f : return f . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a tuple of strings that match the regular expression pattern . [CODESPLIT] def filter_regex ( names , regex ) : return tuple ( name for name in names if regex . search ( name ) is not None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the contents of the sql file from the given filename . [CODESPLIT] def _get_sql ( filename ) : with open ( os . path . join ( SQL_DIR , filename ) , 'r' ) as f : return f . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses S3 URL . [CODESPLIT] def parse_s3_url ( url ) : bucket = '' path = '' if url : result = urlparse ( url ) bucket = result . netloc path = result . path . strip ( '/' ) return bucket , path", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a tuple of strings that match the regular expression pattern . [CODESPLIT] def filter_regex ( names , regex ) : return tuple ( name for name in names if regex . search ( name ) is not None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return the contents of a pickle file [CODESPLIT] def pickle_load ( fname ) : assert type ( fname ) is str and os . path . exists ( fname ) print ( \"loaded\" , fname ) return pickle . load ( open ( fname , \"rb\" ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "searchs a value in a dicionary and returns the key of the first occurrence [CODESPLIT] def get_key_by_value ( dictionary , search_value ) : for key , value in dictionary . iteritems ( ) : if value == search_value : return ugettext ( key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "plot distribution [CODESPLIT] def plot_dist_normal ( s , mu , sigma ) : import matplotlib . pyplot as plt count , bins , ignored = plt . hist ( s , 30 , normed = True ) plt . plot ( bins , 1 / ( sigma * np . sqrt ( 2 * np . pi ) ) * np . exp ( - ( bins - mu ) ** 2 / ( 2 * sigma ** 2 ) ) , linewidth = 2 , color = 'r' ) plt . show ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a python dictionary to the proto supplied [CODESPLIT] def _dict_to_proto ( py_dict , proto ) : dict_json_str = json . dumps ( py_dict ) return json_format . Parse ( dict_json_str , proto )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Round to sig figs [CODESPLIT] def round_to_n ( x , n ) : return round ( x , - int ( np . floor ( np . log10 ( x ) ) ) + ( n - 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calls the specified Trigger of another Area with the optionally given parameters . [CODESPLIT] def trigger ( self , target : str , trigger : str , parameters : Dict [ str , Any ] = { } ) : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return opened file with a specific encoding . [CODESPLIT] def open_with_encoding ( filename , encoding , mode = 'r' ) : return io . open ( filename , mode = mode , encoding = encoding , newline = '' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the * cmd * and exit with the proper exit code . [CODESPLIT] def call_and_exit ( self , cmd , shell = True ) : sys . exit ( subprocess . call ( cmd , shell = shell ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "An async result aggregator that combines all the results This gets executed in unsync . loop and unsync . thread [CODESPLIT] async def result_processor ( tasks ) : output = { } for task in tasks : num , res = await task output [ num ] = res return output", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds text to the axes at the specified position . [CODESPLIT] def add_text ( text , x = 0.01 , y = 0.01 , axes = \"gca\" , draw = True , * * kwargs ) : if axes == \"gca\" : axes = _pylab . gca ( ) axes . text ( x , y , text , transform = axes . transAxes , * * kwargs ) if draw : _pylab . draw ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "htmlify string [CODESPLIT] def safe_quotes ( text , escape_single_quotes = False ) : if isinstance ( text , str ) : safe_text = text . replace ( '\"' , \"&quot;\" ) if escape_single_quotes : safe_text = safe_text . replace ( \"'\" , \"&#92;'\" ) return safe_text . replace ( 'True' , 'true' ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function executes the request with the provided json payload and return the json response [CODESPLIT] def make_post_request ( self , url , auth , json_payload ) : response = requests . post ( url , auth = auth , json = json_payload ) return response . json ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns svg from matplotlib chart [CODESPLIT] def fig2x ( figure , format ) : # Save svg to file like object svg_io io = StringIO ( ) figure . savefig ( io , format = format ) # Rewind the file like object io . seek ( 0 ) data = io . getvalue ( ) io . close ( ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Display error message via stderr or GUI . [CODESPLIT] def error ( * args ) : if sys . stdin . isatty ( ) : print ( 'ERROR:' , * args , file = sys . stderr ) else : notify_error ( * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Close last created figure alias to plt . close () . [CODESPLIT] def close ( * args , * * kwargs ) : _ , plt , _ = _import_plt ( ) plt . close ( * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Not meant to be used directly use : meth : Instaloader . save_session_to_file . [CODESPLIT] def save_session_to_file ( self , sessionfile ) : pickle . dump ( requests . utils . dict_from_cookiejar ( self . _session . cookies ) , sessionfile )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get letters from string only . [CODESPLIT] def return_letters_from_string ( text ) : out = \"\" for letter in text : if letter . isalpha ( ) : out += letter return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Not meant to be used directly use : meth : Instaloader . save_session_to_file . [CODESPLIT] def save_session_to_file ( self , sessionfile ) : pickle . dump ( requests . utils . dict_from_cookiejar ( self . _session . cookies ) , sessionfile )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like print_exc () but return a string . Backport for Python 2 . 3 . [CODESPLIT] def format_exc ( limit = None ) : try : etype , value , tb = sys . exc_info ( ) return '' . join ( traceback . format_exception ( etype , value , tb , limit ) ) finally : etype = value = tb = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "1x1 convolution [CODESPLIT] def conv1x1 ( in_planes , out_planes , stride = 1 ) : return nn . Conv2d ( in_planes , out_planes , kernel_size = 1 , stride = stride , bias = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get display name for a key or mangle for display [CODESPLIT] def _get_name ( self , key ) : if key in self . display_names : return self . display_names [ key ] return key . capitalize ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print something on screen when self . verbose == True [CODESPLIT] def _screen ( self , s , newline = False ) : if self . verbose : if newline : print ( s ) else : print ( s , end = ' ' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Efficient conversion from scipy sparse matrix to cvxopt sparse matrix [CODESPLIT] def scipy_sparse_to_spmatrix ( A ) : coo = A . tocoo ( ) SP = spmatrix ( coo . data . tolist ( ) , coo . row . tolist ( ) , coo . col . tolist ( ) , size = A . shape ) return SP", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Writes the string to stdout [CODESPLIT] def _stdout_raw ( self , s ) : print ( s , end = '' , file = sys . stdout ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse string into Identity dictionary . [CODESPLIT] def string_to_identity ( identity_str ) : m = _identity_regexp . match ( identity_str ) result = m . groupdict ( ) log . debug ( 'parsed identity: %s' , result ) return { k : v for k , v in result . items ( ) if v }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a bs4 object of the page requested [CODESPLIT] def get_soup ( page = '' ) : content = requests . get ( '%s/%s' % ( BASE_URL , page ) ) . text return BeautifulSoup ( content )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Register all globally visible functions . [CODESPLIT] def init_checks_registry ( ) : mod = inspect . getmodule ( register_check ) for ( name , function ) in inspect . getmembers ( mod , inspect . isfunction ) : register_check ( function )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Performs a mouse out the element . [CODESPLIT] def mouse_out ( self ) : self . scroll_to ( ) ActionChains ( self . parent . driver ) . move_by_offset ( 0 , 0 ) . click ( ) . perform ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Push a new value into heap . [CODESPLIT] def push ( h , x ) : h . push ( x ) up ( h , h . size ( ) - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Scroll both categories Canvas and scrolling container [CODESPLIT] def _set_scroll_v ( self , * args ) : self . _canvas_categories . yview ( * args ) self . _canvas_scroll . yview ( * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs a bash script in the local directory [CODESPLIT] def bash ( filename ) : sys . stdout . flush ( ) subprocess . call ( \"bash {}\" . format ( filename ) , shell = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a leading hash # at the beginning of every line in the source . [CODESPLIT] def _add_hash ( source ) : source = '\\n' . join ( '# ' + line . rstrip ( ) for line in source . splitlines ( ) ) return source", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Select rows where the given field evaluates True . [CODESPLIT] def selecttrue ( table , field , complement = False ) : return select ( table , field , lambda v : bool ( v ) , complement = complement )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Executes a ( shell ) command in the background [CODESPLIT] def execute_in_background ( self ) : # http://stackoverflow.com/questions/1605520 args = shlex . split ( self . cmd ) p = Popen ( args ) return p . pid", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add an object to Javascript . [CODESPLIT] def add_to_js ( self , name , var ) : frame = self . page ( ) . mainFrame ( ) frame . addToJavaScriptWindowObject ( name , var )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Select rows where the given field evaluates True . [CODESPLIT] def selecttrue ( table , field , complement = False ) : return select ( table , field , lambda v : bool ( v ) , complement = complement )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the progress ratio and percentage . [CODESPLIT] def ratio_and_percentage ( current , total , time_remaining ) : return \"{} / {} ({}% completed)\" . format ( current , total , int ( current / total * 100 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "dialogue box for choosing directory [CODESPLIT] def ask_dir ( self ) : args [ 'directory' ] = askdirectory ( * * self . dir_opt ) self . dir_text . set ( args [ 'directory' ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Grabs image data and converts it to a numpy array [CODESPLIT] def numpy ( self ) : # load GDCM's image reading functionality image_reader = gdcm . ImageReader ( ) image_reader . SetFileName ( self . fname ) if not image_reader . Read ( ) : raise IOError ( \"Could not read DICOM image\" ) pixel_array = self . _gdcm_to_numpy ( image_reader . GetImage ( ) ) return pixel_array", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Select rows where the given field is greater than the given value . [CODESPLIT] def selectgt ( table , field , value , complement = False ) : value = Comparable ( value ) return selectop ( table , field , value , operator . gt , complement = complement )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read tag data from file and return as unicode string . [CODESPLIT] def read_utf8 ( fh , byteorder , dtype , count , offsetsize ) : return fh . read ( count ) . decode ( 'utf-8' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Select rows where the given field is not None . [CODESPLIT] def selectnotnone ( table , field , complement = False ) : return select ( table , field , lambda v : v is not None , complement = complement )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a Python object stored in a specified YAML file . [CODESPLIT] def ReadManyFromPath ( filepath ) : with io . open ( filepath , mode = \"r\" , encoding = \"utf-8\" ) as filedesc : return ReadManyFromFile ( filedesc )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Select rows where the given field is not None . [CODESPLIT] def selectnotnone ( table , field , complement = False ) : return select ( table , field , lambda v : v is not None , complement = complement )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns nr of first entry parseable to float in ll None otherwise [CODESPLIT] def find_first_number ( ll ) : for nr , entry in enumerate ( ll ) : try : float ( entry ) except ( ValueError , TypeError ) as e : pass else : return nr return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Filter a list of dicts by IDs using an id key on each dict . [CODESPLIT] def filter_by_ids ( original_list , ids_to_filter ) : if not ids_to_filter : return original_list return [ i for i in original_list if i [ 'id' ] in ids_to_filter ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initializes an attribute container identifier . [CODESPLIT] def __init__ ( self ) : super ( AttributeContainerIdentifier , self ) . __init__ ( ) self . _identifier = id ( self )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Main funcion when executing this module as script [CODESPLIT] def main_func ( args = None ) : # we have to initialize a gui even if we dont need one right now. # as soon as you call maya.standalone.initialize(), a QApplication # with type Tty is created. This is the type for conosle apps. # Because i have not found a way to replace that, we just init the gui. guimain . init_gui ( ) main . init ( ) launcher = Launcher ( ) parsed , unknown = launcher . parse_args ( args ) parsed . func ( parsed , unknown )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is an asyncio adapted version of pyserial read . It provides a non - blocking read and returns a line of data read . [CODESPLIT] async def readline ( self ) : future = asyncio . Future ( ) data_available = False while True : if not data_available : if not self . my_serial . inWaiting ( ) : await asyncio . sleep ( self . sleep_tune ) else : data_available = True data = self . my_serial . readline ( ) future . set_result ( data ) else : if not future . done ( ) : await asyncio . sleep ( self . sleep_tune ) else : return future . result ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Trim a PIL image and remove white space . [CODESPLIT] def _trim ( image ) : background = PIL . Image . new ( image . mode , image . size , image . getpixel ( ( 0 , 0 ) ) ) diff = PIL . ImageChops . difference ( image , background ) diff = PIL . ImageChops . add ( diff , diff , 2.0 , - 100 ) bbox = diff . getbbox ( ) if bbox : image = image . crop ( bbox ) return image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes a : py : class : . Series from the chart . [CODESPLIT] def remove_series ( self , series ) : if len ( self . all_series ( ) ) == 1 : raise ValueError ( \"Cannot remove last series from %s\" % str ( self ) ) self . _all_series . remove ( series ) series . _chart = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deletes all the unnamed columns [CODESPLIT] def del_Unnamed ( df ) : cols_del = [ c for c in df . columns if 'Unnamed' in c ] return df . drop ( cols_del , axis = 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return request s X_POLYAXON_ ... : header as a bytestring . [CODESPLIT] def get_header ( request , header_service ) : service = request . META . get ( 'HTTP_{}' . format ( header_service ) , b'' ) if isinstance ( service , str ) : # Work around django test client oddness service = service . encode ( HTTP_HEADER_ENCODING ) return service", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes tags from objects [CODESPLIT] def _removeTags ( tags , objects ) : for t in tags : for o in objects : o . tags . remove ( t ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Not meant to be used directly use : meth : Instaloader . save_session_to_file . [CODESPLIT] def save_session_to_file ( self , sessionfile ) : pickle . dump ( requests . utils . dict_from_cookiejar ( self . _session . cookies ) , sessionfile )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "See if a message is ( probably ) a datagrepper message and attempt to mutate it to pass signature validation . [CODESPLIT] def fix_datagrepper_message ( message ) : if not ( 'source_name' in message and 'source_version' in message ) : return message # Don't mutate the original message message = message . copy ( ) del message [ 'source_name' ] del message [ 'source_version' ] # datanommer adds the headers field to the message in all cases. # This is a huge problem because if the signature was generated with a 'headers' # key set and we delete it here, messages will fail validation, but if we don't # messages will fail validation if they didn't have a 'headers' key set. # # There's no way to know whether or not the headers field was part of the signed # message or not. Generally, the problem is datanommer is mutating messages. if 'headers' in message and not message [ 'headers' ] : del message [ 'headers' ] if 'timestamp' in message : message [ 'timestamp' ] = int ( message [ 'timestamp' ] ) return message", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the modified time of a file [CODESPLIT] def set_time ( filename , mod_time ) : log . debug ( 'Setting modified time to %s' , mod_time ) mtime = calendar . timegm ( mod_time . utctimetuple ( ) ) # utctimetuple discards microseconds, so restore it (for consistency)\n mtime += mod_time . microsecond / 1000000 atime = os . stat ( filename ) . st_atime os . utime ( filename , ( atime , mtime ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a list of words given text removing punctuation . [CODESPLIT] def wordify ( text ) : stopset = set ( nltk . corpus . stopwords . words ( 'english' ) ) tokens = nltk . WordPunctTokenizer ( ) . tokenize ( text ) return [ w for w in tokens if w not in stopset ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets a global variable given its name . [CODESPLIT] def get_var ( name , factory = None ) : if name not in _VARS and factory is not None : _VARS [ name ] = factory ( ) return _VARS . get ( name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove all non - MagIC columns from all tables . [CODESPLIT] def remove_non_magic_cols ( self ) : for table_name in self . tables : table = self . tables [ table_name ] table . remove_non_magic_cols_from_table ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn the ring for a single position . For example [ a b c d ] becomes [ b c d a ] . [CODESPLIT] def turn ( self ) : first = self . _data . pop ( 0 ) self . _data . append ( first )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove ticks tick labels and frame from axis [CODESPLIT] def clean_axis ( axis ) : axis . get_xaxis ( ) . set_ticks ( [ ] ) axis . get_yaxis ( ) . set_ticks ( [ ] ) for spine in list ( axis . spines . values ( ) ) : spine . set_visible ( False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the log level of the specified logger . [CODESPLIT] def set_log_level ( logger_name : str , log_level : str , propagate : bool = False ) : log = logging . getLogger ( logger_name ) log . propagate = propagate log . setLevel ( log_level )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a comma separated option into a list . [CODESPLIT] def split_comma_argument ( comma_sep_str ) : terms = [ ] for term in comma_sep_str . split ( ',' ) : if term : terms . append ( term ) return terms", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator which adds correct MIME type for python source to the decorated bottle API function . [CODESPLIT] def python_mime ( fn ) : @ wraps ( fn ) def python_mime_decorator ( * args , * * kwargs ) : response . content_type = \"text/x-python\" return fn ( * args , * * kwargs ) return python_mime_decorator", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the key names for the pivot model instance [CODESPLIT] def set_pivot_keys ( self , foreign_key , other_key ) : self . __foreign_key = foreign_key self . __other_key = other_key return self", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a spec to a mock . spec can either be an object or a list of strings . Only attributes on the spec can be fetched as attributes from the mock . [CODESPLIT] def mock_add_spec ( self , spec , spec_set = False ) : self . _mock_add_spec ( spec , spec_set ) self . _mock_set_magics ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace regex with string . [CODESPLIT] def fmt_subst ( regex , subst ) : return lambda text : re . sub ( regex , subst , text ) if text else text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove element from the RangeSet if it is a member . [CODESPLIT] def discard ( self , element ) : try : i = int ( element ) set . discard ( self , i ) except ValueError : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Computes the median of a log - normal distribution built with the stats data . [CODESPLIT] def median ( self ) : mu = self . mean ( ) ret_val = math . exp ( mu ) if math . isnan ( ret_val ) : ret_val = float ( \"inf\" ) return ret_val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strips trailing whitespace from string lowercases it and replaces spaces with underscores [CODESPLIT] def normalise_string ( string ) : string = ( string . strip ( ) ) . lower ( ) return re . sub ( r'\\W+' , '_' , string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert any timestamp to UTC ( with tzinfo ) . [CODESPLIT] def to_utc ( self , dt ) : if dt . tzinfo is None : return dt . replace ( tzinfo = self . utc ) return dt . astimezone ( self . utc )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace any non - word characters with a dash . [CODESPLIT] def dashrepl ( value ) : patt = re . compile ( r'\\W' , re . UNICODE ) return re . sub ( patt , '-' , value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts and image to matrix ( one pixel per line ) [CODESPLIT] def im2mat ( I ) : return I . reshape ( ( I . shape [ 0 ] * I . shape [ 1 ] , I . shape [ 2 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns OK then waits approximately 1 second and restarts container [CODESPLIT] async def restart ( request ) : def wait_and_restart ( ) : log . info ( 'Restarting server' ) sleep ( 1 ) os . system ( 'kill 1' ) Thread ( target = wait_and_restart ) . start ( ) return web . json_response ( { \"message\" : \"restarting\" } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Report whether this RangeSet contains another set . [CODESPLIT] def issuperset ( self , other ) : self . _binary_sanity_check ( other ) return set . issuperset ( self , other )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Send a potentially ragged EOF . [CODESPLIT] def feed_eof ( self ) : self . _incoming . write_eof ( ) ssldata , appdata = self . feed_ssldata ( b'' ) assert appdata == [ ] or appdata == [ b'' ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the depth of the longest branch of the tree [CODESPLIT] def maxDepth ( self , currentDepth = 0 ) : if not any ( ( self . left , self . right ) ) : return currentDepth result = 0 for child in ( self . left , self . right ) : if child : result = max ( result , child . maxDepth ( currentDepth + 1 ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Constructs a shapely Polygon from the provided bounds tuple . [CODESPLIT] def bounds_to_poly ( bounds ) : x0 , y0 , x1 , y1 = bounds return Polygon ( [ ( x0 , y0 ) , ( x1 , y0 ) , ( x1 , y1 ) , ( x0 , y1 ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resets the iterator to the start . [CODESPLIT] def reset ( self ) : self . __iterator , self . __saved = itertools . tee ( self . __saved )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rounds a float value off to the desired precision [CODESPLIT] def _saferound ( value , decimal_places ) : try : f = float ( value ) except ValueError : return '' format = '%%.%df' % decimal_places return format % f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shuffle the data . [CODESPLIT] def _shuffle ( data , idx ) : shuffle_data = [ ] for idx_k , idx_v in data : shuffle_data . append ( ( idx_k , mx . ndarray . array ( idx_v . asnumpy ( ) [ idx ] , idx_v . context ) ) ) return shuffle_data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Round to sig figs [CODESPLIT] def round_to_n ( x , n ) : return round ( x , - int ( np . floor ( np . log10 ( x ) ) ) + ( n - 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shuffle the data . [CODESPLIT] def _shuffle ( data , idx ) : shuffle_data = [ ] for idx_k , idx_v in data : shuffle_data . append ( ( idx_k , mx . ndarray . array ( idx_v . asnumpy ( ) [ idx ] , idx_v . context ) ) ) return shuffle_data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Round to sig figs [CODESPLIT] def round_to_n ( x , n ) : return round ( x , - int ( np . floor ( np . log10 ( x ) ) ) + ( n - 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a copy of the signal with the low pass applied args specifed are passed through to _butter . : return : [CODESPLIT] def lowPass ( self , * args ) : return Signal ( self . _butter ( self . samples , 'low' , * args ) , fs = self . fs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Start and maintain the streaming connection ... [CODESPLIT] def begin_stream_loop ( stream , poll_interval ) : while should_continue ( ) : try : stream . start_polling ( poll_interval ) except Exception as e : # Infinite restart logger . error ( \"Exception while polling. Restarting in 1 second.\" , exc_info = True ) time . sleep ( 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a tuple of numbers . e . g . vertices normals or teture coords . [CODESPLIT] def readTuple ( self , line , n = 3 ) : numbers = [ num for num in line . split ( ' ' ) if num ] return [ float ( num ) for num in numbers [ 1 : n + 1 ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return byte - size of a memoryview or buffer . [CODESPLIT] def _nbytes ( buf ) : if isinstance ( buf , memoryview ) : if PY3 : # py3 introduces nbytes attribute return buf . nbytes else : # compute nbytes on py2 size = buf . itemsize for dim in buf . shape : size *= dim return size else : # not a memoryview, raw bytes/ py2 buffer return len ( buf )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Skip the next time frame [CODESPLIT] def _skip_frame ( self ) : for line in self . _f : if line == 'ITEM: ATOMS\\n' : break for i in range ( self . num_atoms ) : next ( self . _f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Skip the specified number of elements in the list . [CODESPLIT] def skip ( self , n ) : try : self . _iter_object . skip ( n ) except AttributeError : for i in range ( 0 , n ) : self . next ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Direct access to byte data . [CODESPLIT] def getbyteslice ( self , start , end ) : c = self . _rawarray [ start : end ] return c", "target": 1, "target_options": ["no_match", "match"]}
{"input": "We have a full length slice . [CODESPLIT] def is_full_slice ( obj , l ) : return ( isinstance ( obj , slice ) and obj . start == 0 and obj . stop == l and obj . step is None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resizes the given image to fit inside a box of the given size . [CODESPLIT] def resize_image ( self , data , size ) : from machina . core . compat import PILImage as Image image = Image . open ( BytesIO ( data ) ) # Resize! image . thumbnail ( size , Image . ANTIALIAS ) string = BytesIO ( ) image . save ( string , format = 'PNG' ) return string . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shutdown process ( this method is also a signal handler ) [CODESPLIT] def stop ( self , dummy_signum = None , dummy_frame = None ) : logging . info ( 'Shutting down ...' ) self . socket . close ( ) sys . exit ( 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Stops the background synchronization thread [CODESPLIT] def stop ( self ) : with self . synclock : if self . syncthread is not None : self . syncthread . cancel ( ) self . syncthread = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a list of the data types for each column in * data * . [CODESPLIT] def _get_column_types ( self , data ) : columns = list ( zip_longest ( * data ) ) return [ self . _get_column_type ( column ) for column in columns ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "sort a list of files by filename only ignoring the directory names [CODESPLIT] def sort_filenames ( filenames ) : basenames = [ os . path . basename ( x ) for x in filenames ] indexes = [ i [ 0 ] for i in sorted ( enumerate ( basenames ) , key = lambda x : x [ 1 ] ) ] return [ filenames [ x ] for x in indexes ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Key function used to sort transcripts . Taking the negative of protein sequence length and nucleotide sequence length so that the transcripts with longest sequences come first in the list . This couldn t be accomplished with reverse = True since we re also sorting by transcript name ( which places TP53 - 001 before TP53 - 002 ) . [CODESPLIT] def transcript_sort_key ( transcript ) : return ( - len ( transcript . protein_sequence ) , - len ( transcript . sequence ) , transcript . name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return IPython s guess for the default encoding for bytes as text . [CODESPLIT] def getdefaultencoding ( ) : enc = get_stream_enc ( sys . stdin ) if not enc or enc == 'ascii' : try : # There are reports of getpreferredencoding raising errors # in some cases, which may well be fixed, but let's be conservative here. enc = locale . getpreferredencoding ( ) except Exception : pass return enc or sys . getdefaultencoding ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Key function used to sort transcripts . Taking the negative of protein sequence length and nucleotide sequence length so that the transcripts with longest sequences come first in the list . This couldn t be accomplished with reverse = True since we re also sorting by transcript name ( which places TP53 - 001 before TP53 - 002 ) . [CODESPLIT] def transcript_sort_key ( transcript ) : return ( - len ( transcript . protein_sequence ) , - len ( transcript . sequence ) , transcript . name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an appropriate positive infinity for this dtype . [CODESPLIT] def get_neg_infinity ( dtype ) : if issubclass ( dtype . type , ( np . floating , np . integer ) ) : return - np . inf if issubclass ( dtype . type , np . complexfloating ) : return - np . inf - 1j * np . inf return NINF", "target": 1, "target_options": ["no_match", "match"]}
{"input": "consider the distance between two mapPoints ignoring all terrain pathing issues [CODESPLIT] def direct2dDistance ( self , point ) : if not isinstance ( point , MapPoint ) : return 0.0 return ( ( self . x - point . x ) ** 2 + ( self . y - point . y ) ** 2 ) ** ( 0.5 ) # simple distance formula", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds execute permission to file . : param filename : : return : [CODESPLIT] def chmod_add_excute ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieves the Python library directory path . [CODESPLIT] def GetPythonLibraryDirectoryPath ( ) : path = sysconfig . get_python_lib ( True ) _ , _ , path = path . rpartition ( sysconfig . PREFIX ) if path . startswith ( os . sep ) : path = path [ 1 : ] return path", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates a Spearman rank - order correlation coefficient . Taken from Heiman s Basic Statistics for the Behav . Sci ( 1st ) p . 192 . [CODESPLIT] def lspearmanr ( x , y ) : TINY = 1e-30 if len ( x ) != len ( y ) : raise ValueError ( 'Input values not paired in spearmanr.  Aborting.' ) n = len ( x ) rankx = rankdata ( x ) ranky = rankdata ( y ) dsq = sumdiffsquared ( rankx , ranky ) rs = 1 - 6 * dsq / float ( n * ( n ** 2 - 1 ) ) t = rs * math . sqrt ( ( n - 2 ) / ( ( rs + 1.0 ) * ( 1.0 - rs ) ) ) df = n - 2 probrs = betai ( 0.5 * df , 0.5 , df / ( df + t * t ) ) # t already a float # probability values for rs are from part 2 of the spearman function in # Numerical Recipies, p.510.  They are close to tables, but not exact. (?) return rs , probrs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the opposite of input condition . [CODESPLIT] def _not ( condition = None , * * kwargs ) : result = True if condition is not None : result = not run ( condition , * * kwargs ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Override method to set a value to show it as 0 to 100 . [CODESPLIT] def setValue ( self , p_float ) : p_float = p_float * 100 super ( PercentageSpinBox , self ) . setValue ( p_float )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "split command args to args list returns a list of args [CODESPLIT] def expand_args ( cmd_args ) : if isinstance ( cmd_args , ( tuple , list ) ) : args_list = list ( cmd_args ) else : args_list = shlex . split ( cmd_args ) return args_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to add timezone information to datetime so that datetime is comparable to other datetime objects in recent versions that now also have timezone information . [CODESPLIT] def datetime_from_timestamp ( timestamp , content ) : return set_date_tzinfo ( datetime . fromtimestamp ( timestamp ) , tz_name = content . settings . get ( 'TIMEZONE' , None ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split s by sep unless it s inside a quote . [CODESPLIT] def split_on ( s , sep = \" \" ) : pattern = '''((?:[^%s\"']|\"[^\"]*\"|'[^']*')+)''' % sep return [ _strip_speechmarks ( t ) for t in re . split ( pattern , s ) [ 1 : : 2 ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "take sys . argv that is used to call a command - line script and return a correctly split list of arguments for example this input : [ eqarea . py - f infile - F outfile - A ] will return this output : [[ f infile ] [ F outfile ] [ A ]] [CODESPLIT] def extract_args ( argv ) : string = \" \" . join ( argv ) string = string . split ( ' -' ) program = string [ 0 ] arguments = [ s . split ( ) for s in string [ 1 : ] ] return arguments", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Moves the brush to a particular position . [CODESPLIT] def move_to ( x , y ) : _make_cnc_request ( \"coord/{0}/{1}\" . format ( x , y ) ) state [ 'turtle' ] . goto ( x , y )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "split string into list of strings by specified number . [CODESPLIT] def _split_str ( s , n ) : length = len ( s ) return [ s [ i : i + n ] for i in range ( 0 , length , n ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a timevalue for interval comparisons [CODESPLIT] def stopwatch_now ( ) : if six . PY2 : now = time . time ( ) else : now = time . monotonic ( ) return now", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a file exists [CODESPLIT] def file_found ( filename , force ) : if os . path . exists ( filename ) and not force : logger . info ( \"Found %s; skipping...\" % filename ) return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Matrix solve op . [CODESPLIT] def MatrixSolve ( a , rhs , adj ) : return np . linalg . solve ( a if not adj else _adjoint ( a ) , rhs ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a binding from the sparql query result create a dict of plain text [CODESPLIT] def _bindingsToDict ( self , bindings ) : myDict = { } for key , val in bindings . iteritems ( ) : myDict [ key . toPython ( ) . replace ( '?' , '' ) ] = val . toPython ( ) return myDict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Matrix solve op . [CODESPLIT] def MatrixSolve ( a , rhs , adj ) : return np . linalg . solve ( a if not adj else _adjoint ( a ) , rhs ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create database tables from sqlalchemy models [CODESPLIT] def createdb ( ) : manager . db . engine . echo = True manager . db . create_all ( ) set_alembic_revision ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "mono - exponential curve . [CODESPLIT] def algo_exp ( x , m , t , b ) : return m * np . exp ( - t * x ) + b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create database tables from sqlalchemy models [CODESPLIT] def createdb ( ) : manager . db . engine . echo = True manager . db . create_all ( ) set_alembic_revision ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the indices of the lexicographical sorting order of the supplied arrays . [CODESPLIT] def arglexsort ( arrays ) : dtypes = ',' . join ( array . dtype . str for array in arrays ) recarray = np . empty ( len ( arrays [ 0 ] ) , dtype = dtypes ) for i , array in enumerate ( arrays ) : recarray [ 'f%s' % i ] = array return recarray . argsort ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Conveinience : [CODESPLIT] def get_tablenames ( cur ) : cur . execute ( \"SELECT name FROM sqlite_master WHERE type='table'\" ) tablename_list_ = cur . fetchall ( ) tablename_list = [ str ( tablename [ 0 ] ) for tablename in tablename_list_ ] return tablename_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sorts a dict by value . [CODESPLIT] def sort_dict ( d , key = None , reverse = False ) : kv_items = [ kv for kv in d . items ( ) ] # Sort kv_items according to key. if key is None : kv_items . sort ( key = lambda t : t [ 1 ] , reverse = reverse ) else : kv_items . sort ( key = key , reverse = reverse ) # Build ordered dict. return collections . OrderedDict ( kv_items )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initializes the database file object . [CODESPLIT] def __init__ ( self ) : super ( Sqlite3DatabaseFile , self ) . __init__ ( ) self . _connection = None self . _cursor = None self . filename = None self . read_only = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the indices of the lexicographical sorting order of the supplied arrays . [CODESPLIT] def arglexsort ( arrays ) : dtypes = ',' . join ( array . dtype . str for array in arrays ) recarray = np . empty ( len ( arrays [ 0 ] ) , dtype = dtypes ) for i , array in enumerate ( arrays ) : recarray [ 'f%s' % i ] = array return recarray . argsort ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Unwrap a Python 2 . 6 SSL socket so we can call shutdown () [CODESPLIT] def _shutdown_transport ( self ) : if self . sock is not None : try : unwrap = self . sock . unwrap except AttributeError : return try : self . sock = unwrap ( ) except ValueError : # Failure within SSL might mean unwrap exists but socket is not # deemed wrapped pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sort the given list in the way that humans expect . [CODESPLIT] def sort_nicely ( l ) : convert = lambda text : int ( text ) if text . isdigit ( ) else text alphanum_key = lambda key : [ convert ( c ) for c in re . split ( '([0-9]+)' , key ) ] l . sort ( key = alphanum_key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate standard deviation weighted by errors [CODESPLIT] def weighted_std ( values , weights ) : average = np . average ( values , weights = weights ) variance = np . average ( ( values - average ) ** 2 , weights = weights ) return np . sqrt ( variance )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute standard deviation with ddof degrees of freedom [CODESPLIT] def _std ( self , x ) : return np . nanstd ( x . values , ddof = self . _ddof )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call a remote api method but don t raise if an error occurred . [CODESPLIT] def safe_call ( cls , method , * args ) : return cls . call ( method , * args , safe = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine with width in pixels of string . [CODESPLIT] def text_width ( string , font_name , font_size ) : return stringWidth ( string , fontName = font_name , fontSize = font_size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A static value ( does not change at runtime ) which is known at compile time [CODESPLIT] def is_static ( * p ) : return all ( is_CONST ( x ) or is_number ( x ) or is_const ( x ) for x in p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "given an Nxm matrix containing boundary info between simplices compute indidence info matrix not very reusable ; should probably not be in this lib [CODESPLIT] def incidence ( boundary ) : return GroupBy ( boundary ) . split ( np . arange ( boundary . size ) // boundary . shape [ 1 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update a staticmethod update . [CODESPLIT] def _update_staticmethod ( self , oldsm , newsm ) : # While we can't modify the staticmethod object itself (it has no # mutable attributes), we *can* extract the underlying function # (by calling __get__(), which returns it) and update it in-place. # We don't have the class available to pass to __get__() but any # object except None will do. self . _update ( None , None , oldsm . __get__ ( 0 ) , newsm . __get__ ( 0 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform column - stacking on a list of 2d data blocks . [CODESPLIT] def column_stack_2d ( data ) : return list ( list ( itt . chain . from_iterable ( _ ) ) for _ in zip ( * data ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gracefully close connection to stomp server . [CODESPLIT] def disconnect ( self ) : if self . _connected : self . _connected = False self . _conn . disconnect ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Stops the status update thread . [CODESPLIT] def _StopStatusUpdateThread ( self ) : self . _status_update_active = False if self . _status_update_thread . isAlive ( ) : self . _status_update_thread . join ( ) self . _status_update_thread = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Portable cast function . [CODESPLIT] def to_binary ( s , encoding = 'utf8' ) : if PY3 : # pragma: no cover return s if isinstance ( s , binary_type ) else binary_type ( s , encoding = encoding ) return binary_type ( s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Method to handle what to do when the stop button is pressed [CODESPLIT] def stop_button_click_handler ( self ) : self . stop_button . setDisabled ( True ) # Interrupt computations or stop debugging\n if not self . shellwidget . _reading : self . interrupt_kernel ( ) else : self . shellwidget . write_to_stdin ( 'exit' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shortcut to create md5 hash : param s : : return : [CODESPLIT] def md5_string ( s ) : m = hashlib . md5 ( ) m . update ( s ) return str ( m . hexdigest ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call a system command in the background disown it and hide it s output . [CODESPLIT] def disown ( cmd ) : subprocess . Popen ( cmd , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Magnitude of a complex matrix . [CODESPLIT] def magnitude ( X ) : r = np . real ( X ) i = np . imag ( X ) return np . sqrt ( r * r + i * i )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deserialize s ( a str ) to a Python object . [CODESPLIT] def loads ( s , model = None , parser = None ) : with StringIO ( s ) as f : return load ( f , model = model , parser = parser )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the dotproduct between self and another vector . [CODESPLIT] def dot ( self , w ) : return sum ( [ x * y for x , y in zip ( self , w ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create : class : PNG from raw bytes . : arg bytes b : The raw bytes of the PNG file . : rtype : : class : PNG [CODESPLIT] def from_bytes ( cls , b ) : im = cls ( ) im . chunks = list ( parse_chunks ( b ) ) im . init ( ) return im", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Serialize obj as a JSON formatted stream to fp [CODESPLIT] def _serialize_json ( obj , fp ) : json . dump ( obj , fp , indent = 4 , default = serialize )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if a given string is an url [CODESPLIT] def is_valid_url ( url ) : pieces = urlparse ( url ) return all ( [ pieces . scheme , pieces . netloc ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format a duration in seconds . [CODESPLIT] def fmt_duration ( secs ) : return ' ' . join ( fmt . human_duration ( secs , 0 , precision = 2 , short = True ) . strip ( ) . split ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the memory byte size of a Numpy array as an integer . [CODESPLIT] def bytesize ( arr ) : byte_size = np . prod ( arr . shape ) * np . dtype ( arr . dtype ) . itemsize return byte_size", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert string to int or float . [CODESPLIT] def covstr ( s ) : try : ret = int ( s ) except ValueError : ret = float ( s ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns system keyword arguments removing Nones . [CODESPLIT] def _system_parameters ( * * kwargs ) : return { key : value for key , value in kwargs . items ( ) if ( value is not None or value == { } ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is the same functionality as int . from_bytes in python 3 [CODESPLIT] def _from_bytes ( bytes , byteorder = \"big\" , signed = False ) : return int . from_bytes ( bytes , byteorder = byteorder , signed = signed )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determines whether the passed value is a string safe for 2 / 3 . [CODESPLIT] def is_string ( val ) : try : basestring except NameError : return isinstance ( val , str ) return isinstance ( val , basestring )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Match two names . [CODESPLIT] def _match_literal ( self , a , b = None ) : return a . lower ( ) == b if not self . case_sensitive else a == b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list consisting of the cumulative sum of the items in the passed list . [CODESPLIT] def lcumsum ( inlist ) : newlist = copy . deepcopy ( inlist ) for i in range ( 1 , len ( newlist ) ) : newlist [ i ] = newlist [ i ] + newlist [ i - 1 ] return newlist", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the string is only composed of hex characters . [CODESPLIT] def is_hex_string ( string ) : pattern = re . compile ( r'[A-Fa-f0-9]+' ) if isinstance ( string , six . binary_type ) : string = str ( string ) return pattern . match ( string ) is not None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The how well do the features plus a constant base rate sum up to the model output . [CODESPLIT] def local_accuracy ( X_train , y_train , X_test , y_test , attr_test , model_generator , metric , trained_model ) : X_train , X_test = to_array ( X_train , X_test ) # how many features to mask assert X_train . shape [ 1 ] == X_test . shape [ 1 ] # keep nkeep top features and re-train the model for each test explanation yp_test = trained_model . predict ( X_test ) return metric ( yp_test , strip_list ( attr_test ) . sum ( 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the string is only composed of hex characters . [CODESPLIT] def is_hex_string ( string ) : pattern = re . compile ( r'[A-Fa-f0-9]+' ) if isinstance ( string , six . binary_type ) : string = str ( string ) return pattern . match ( string ) is not None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert documentation to HTML [CODESPLIT] def doc_to_html ( doc , doc_format = \"ROBOT\" ) : from robot . libdocpkg . htmlwriter import DocToHtml return DocToHtml ( doc_format ) ( doc )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a python string to C string . [CODESPLIT] def c_str ( string ) : if not isinstance ( string , str ) : string = string . decode ( 'ascii' ) return ctypes . c_char_p ( string . encode ( 'utf-8' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Packs a list of triple indexes into a 2D numpy array . [CODESPLIT] def pack_triples_numpy ( triples ) : if len ( triples ) == 0 : return np . array ( [ ] , dtype = np . int64 ) return np . stack ( list ( map ( _transform_triple_numpy , triples ) ) , axis = 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A small helper function to convert a string to a numeric value if appropriate [CODESPLIT] def _convert_to_float_if_possible ( s ) : try : ret = float ( s ) except ( ValueError , TypeError ) : ret = s return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert input argument to bytes [CODESPLIT] def str2bytes ( x ) : if type ( x ) is bytes : return x elif type ( x ) is str : return bytes ( [ ord ( i ) for i in x ] ) else : return str2bytes ( str ( x ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "String hash ( djb2 ) with consistency between py2 / py3 and persistency between runs ( unlike hash ) . [CODESPLIT] def _string_hash ( s ) : h = 5381 for c in s : h = h * 33 + ord ( c ) return h", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert from whatever is given to a list of scalars for the lookup_field . [CODESPLIT] def coerce ( self , value ) : if isinstance ( value , dict ) : value = [ value ] if not isiterable_notstring ( value ) : value = [ value ] return [ coerce_single_instance ( self . lookup_field , v ) for v in value ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a text and drops all non - printable and non - ascii characters and also any whitespace characters that aren t space . [CODESPLIT] def drop_bad_characters ( text ) : # Strip all non-ascii and non-printable characters text = '' . join ( [ c for c in text if c in ALLOWED_CHARS ] ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes an object / rabalist from registery . This is useful if you want to allow the garbage collector to free the memory taken by the objects you ve already loaded . Be careful might cause some discrepenties in your scripts . For objects cascades to free the registeries of related rabalists also [CODESPLIT] def removeFromRegistery ( obj ) : if isRabaObject ( obj ) : _unregisterRabaObjectInstance ( obj ) elif isRabaList ( obj ) : _unregisterRabaListInstance ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param list_of_points : : return : list_of_points with None s removed [CODESPLIT] def filter_none ( list_of_points ) : remove_elementnone = filter ( lambda p : p is not None , list_of_points ) remove_sublistnone = filter ( lambda p : not contains_none ( p ) , remove_elementnone ) return list ( remove_sublistnone )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transparently unzip the file handle [CODESPLIT] def _unzip_handle ( handle ) : if isinstance ( handle , basestring ) : handle = _gzip_open_filename ( handle ) else : handle = _gzip_open_handle ( handle ) return handle", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the slice after at sub in string astr [CODESPLIT] def fsliceafter ( astr , sub ) : findex = astr . find ( sub ) return astr [ findex + len ( sub ) : ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update the text tuple at x and y with the given s and d [CODESPLIT] def _update_texttuple ( self , x , y , s , cs , d ) : pos = ( x , y , cs ) for i , ( old_x , old_y , old_s , old_cs , old_d ) in enumerate ( self . value ) : if ( old_x , old_y , old_cs ) == pos : self . value [ i ] = ( old_x , old_y , s , old_cs , d ) return raise ValueError ( \"No text tuple found at {0}!\" . format ( pos ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Authenticates account using soap method . [CODESPLIT] def authenticate ( self , transport , account_name , password = None ) : Authenticator . authenticate ( self , transport , account_name , password ) if password == None : return self . pre_auth ( transport , account_name ) else : return self . auth ( transport , account_name , password )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper parse action to convert tokens to upper case . [CODESPLIT] def upcaseTokens ( s , l , t ) : return [ tt . upper ( ) for tt in map ( _ustr , t ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns an updated copy of the dictionary without modifying the original [CODESPLIT] def copy_and_update ( dictionary , update ) : newdict = dictionary . copy ( ) newdict . update ( update ) return newdict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Drops and re - creates the SQL schema [CODESPLIT] def init_db ( ) : db . drop_all ( ) db . configure_mappers ( ) db . create_all ( ) db . session . commit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Performs an automatic prediction for the specified machine and returns the predicted values . [CODESPLIT] def _do_auto_predict ( machine , X , * args ) : if auto_predict and hasattr ( machine , \"predict\" ) : return machine . predict ( X )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a table row to a dictionary . [CODESPLIT] def row_to_dict ( row ) : o = { } for colname in row . colnames : if isinstance ( row [ colname ] , np . string_ ) and row [ colname ] . dtype . kind in [ 'S' , 'U' ] : o [ colname ] = str ( row [ colname ] ) else : o [ colname ] = row [ colname ] return o", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Colorizes a given string if coloring is available . [CODESPLIT] def color_string ( color , string ) : if not color_available : return string return color + string + colorama . Fore . RESET", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Starts a new task . [CODESPLIT] def execute ( self , env , args ) : # start the task if env . task . start ( args . task_name ) : env . io . success ( u'Task Loaded.' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns an built - in stop - list for the language as a set of words . [CODESPLIT] def get_stoplist ( language ) : file_path = os . path . join ( \"stoplists\" , \"%s.txt\" % language ) try : stopwords = pkgutil . get_data ( \"justext\" , file_path ) except IOError : raise ValueError ( \"Stoplist for language '%s' is missing. \" \"Please use function 'get_stoplists' for complete list of stoplists \" \"and feel free to contribute by your own stoplist.\" % language ) return frozenset ( w . decode ( \"utf8\" ) . lower ( ) for w in stopwords . splitlines ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility method to create temp files . These are cleaned at the end of the test [CODESPLIT] def create_tmpfile ( self , content ) : # Not using a context manager to avoid unneccessary identation in test code tmpfile , tmpfilepath = tempfile . mkstemp ( ) self . tmpfiles . append ( tmpfilepath ) with os . fdopen ( tmpfile , \"w\" ) as f : f . write ( content ) return tmpfilepath", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a matrix of logic comparison of A or B [CODESPLIT] def aandb ( a , b ) : return matrix ( np . logical_and ( a , b ) . astype ( 'float' ) , a . size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Old style use JSONTemplateResponse instead of this . [CODESPLIT] def json_template ( data , template_name , template_context ) : html = render_to_string ( template_name , template_context ) data = data or { } data [ 'html' ] = html return HttpResponse ( json_encode ( data ) , content_type = 'application/json' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Same as : meth : pymongo . collection . Collection . find except it returns the right document class . [CODESPLIT] def find ( self , * args , * * kwargs ) : return Cursor ( self , * args , wrap = self . document_class , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the i - th unfolding of a tensor . [CODESPLIT] def unfolding ( tens , i ) : return reshape ( tens . full ( ) , ( np . prod ( tens . n [ 0 : ( i + 1 ) ] ) , - 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "members () issues an ldap query for all users and returns a dict for each matching entry . This can be quite slow and takes roughly 3s to complete . You may optionally restrict the scope by specifying a uid which is roughly equivalent to a search ( uid = foo ) [CODESPLIT] def members ( self , uid = \"*\" , objects = False ) : entries = self . search ( uid = '*' ) if objects : return self . memberObjects ( entries ) result = [ ] for entry in entries : result . append ( entry [ 1 ] ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flatten all dimensions of a except the last . [CODESPLIT] def flatten_all_but_last ( a ) : ret = tf . reshape ( a , [ - 1 , tf . shape ( a ) [ - 1 ] ] ) if not tf . executing_eagerly ( ) : ret . set_shape ( [ None ] + a . get_shape ( ) . as_list ( ) [ - 1 : ] ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "if the value is in the list move it to the front and return it . [CODESPLIT] def list_move_to_front ( l , value = 'other' ) : l = list ( l ) if value in l : l . remove ( value ) l . insert ( 0 , value ) return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is this attribute present? [CODESPLIT] def has_attribute ( module_name , attribute_name ) : init_file = '%s/__init__.py' % module_name return any ( [ attribute_name in init_line for init_line in open ( init_file ) . readlines ( ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "sort multiple ranges [CODESPLIT] def sort_genomic_ranges ( rngs ) : return sorted ( rngs , key = lambda x : ( x . chr , x . start , x . end ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if an array is a square matrix . [CODESPLIT] def is_square_matrix ( mat ) : mat = np . array ( mat ) if mat . ndim != 2 : return False shape = mat . shape return shape [ 0 ] == shape [ 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Store the user session for a client . [CODESPLIT] def save_session ( self , sid , session , namespace = None ) : return self . server . save_session ( sid , session , namespace = namespace or self . namespace )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if the socket managed by this connection is connected [CODESPLIT] def is_connected ( self ) : try : return self . socket is not None and self . socket . getsockname ( ) [ 1 ] != 0 and BaseTransport . is_connected ( self ) except socket . error : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterate through lines of file . [CODESPLIT] def txt_line_iterator ( path ) : with tf . gfile . Open ( path ) as f : for line in f : yield line . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is not a list or a dict [CODESPLIT] def _validate_type_scalar ( self , value ) : if isinstance ( value , _int_types + ( _str_type , float , date , datetime , bool ) ) : return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "generate a method to write the configuration in yaml to the method desired [CODESPLIT] def generate_write_yaml_to_file ( file_name ) : def write_yaml ( config ) : with open ( file_name , 'w+' ) as fh : fh . write ( yaml . dump ( config ) ) return write_yaml", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Stops the process status RPC server . [CODESPLIT] def Stop ( self ) : self . _Close ( ) if self . _rpc_thread . isAlive ( ) : self . _rpc_thread . join ( ) self . _rpc_thread = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check the validity of an IPv6 address [CODESPLIT] def is_valid_ipv6 ( ip_str ) : try : socket . inet_pton ( socket . AF_INET6 , ip_str ) except socket . error : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Try to flush all stdio buffers both from python and from C . [CODESPLIT] def flush ( ) : try : sys . stdout . flush ( ) sys . stderr . flush ( ) except ( AttributeError , ValueError , IOError ) : pass # unsupported try : libc . fflush ( None ) except ( AttributeError , ValueError , IOError ) : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns this subset s representation as a list of indices . [CODESPLIT] def get_list_representation ( self ) : if self . is_list : return self . list_or_slice else : return self [ list ( range ( self . num_examples ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Terminate all workers and threads . [CODESPLIT] def terminate ( self ) : for t in self . _threads : t . quit ( ) self . _thread = [ ] self . _workers = [ ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply last 2D transforms [CODESPLIT] def post_process ( self ) : self . image . putdata ( self . pixels ) self . image = self . image . transpose ( Image . ROTATE_90 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Note that the Executor must be close () d elsewhere or join () will never return . [CODESPLIT] def join ( self ) : self . inputfeeder_thread . join ( ) self . pool . join ( ) self . resulttracker_thread . join ( ) self . failuretracker_thread . join ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility method to convert list to tsv line with carriage return [CODESPLIT] def write_tsv_line_from_list ( linelist , outfp ) : line = '\\t' . join ( linelist ) outfp . write ( line ) outfp . write ( '\\n' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a sentence from a piece of text . [CODESPLIT] def _make_sentence ( txt ) : #Make sure first letter is capitalized txt = txt . strip ( ' ' ) txt = txt [ 0 ] . upper ( ) + txt [ 1 : ] + '.' return txt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "itertools . starmap for deferred callables using cooperative multitasking [CODESPLIT] def asyncStarCmap ( asyncCallable , iterable ) : results = [ ] yield coopStar ( asyncCallable , results . append , iterable ) returnValue ( results )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write to given samples to a wav file . The samples are expected to be floating point numbers in the range of - 1 . 0 to 1 . 0 . [CODESPLIT] def write_wav ( path , samples , sr = 16000 ) : max_value = np . abs ( np . iinfo ( np . int16 ) . min ) data = ( samples * max_value ) . astype ( np . int16 ) scipy . io . wavfile . write ( path , sr , data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a directory and any intermediate directories that don t already exist . This function handles the case where two threads try to create a directory at once . [CODESPLIT] def make_directory ( path ) : if not os . path . exists ( path ) : # concurrent writes that try to create the same dir can fail try : os . makedirs ( path ) except OSError as e : if e . errno == errno . EEXIST : pass else : raise e", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the rotation matrix representated by the quaternion [CODESPLIT] def quaternion_to_rotation_matrix ( quaternion ) : c , x , y , z = quaternion return np . array ( [ [ c * c + x * x - y * y - z * z , 2 * x * y - 2 * c * z , 2 * x * z + 2 * c * y ] , [ 2 * x * y + 2 * c * z , c * c - x * x + y * y - z * z , 2 * y * z - 2 * c * x ] , [ 2 * x * z - 2 * c * y , 2 * y * z + 2 * c * x , c * c - x * x - y * y + z * z ] ] , float )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create the file with the given content [CODESPLIT] def write_file ( filename , content ) : print 'Generating {0}' . format ( filename ) with open ( filename , 'wb' ) as out_f : out_f . write ( content )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a millisecond accuracy timestamp to a datetime [CODESPLIT] def ms_to_datetime ( ms ) : dt = datetime . datetime . utcfromtimestamp ( ms / 1000 ) return dt . replace ( microsecond = ( ms % 1000 ) * 1000 ) . replace ( tzinfo = pytz . utc )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retries the passed function 3 times before failing [CODESPLIT] def retry_test ( func ) : success = False ex = Exception ( \"Unknown\" ) for i in six . moves . range ( 3 ) : try : result = func ( ) except Exception as e : time . sleep ( 1 ) ex = e else : success = True break if not success : raise ex assert success return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "converts Synergy Timestamp for session to UTC zone seconds since epoch [CODESPLIT] def session_to_epoch ( timestamp ) : utc_timetuple = datetime . strptime ( timestamp , SYNERGY_SESSION_PATTERN ) . replace ( tzinfo = None ) . utctimetuple ( ) return calendar . timegm ( utc_timetuple )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the host s ip number . [CODESPLIT] def get_own_ip ( ) : sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) try : sock . connect ( ( \"8.8.8.8\" , 80 ) ) except socket . gaierror : ip_ = \"127.0.0.1\" else : ip_ = sock . getsockname ( ) [ 0 ] finally : sock . close ( ) return ip_", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Appends tzinfo and assumes UTC if datetime object has no tzinfo already . [CODESPLIT] def make_aware ( dt ) : return dt if dt . tzinfo else dt . replace ( tzinfo = timezone . utc )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Populates an object s attributes using the provided dict [CODESPLIT] def populate_obj ( obj , attrs ) : for k , v in attrs . iteritems ( ) : setattr ( obj , k , v )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert an ARF timestamp to a datetime . datetime object ( naive local time ) [CODESPLIT] def timestamp_to_datetime ( timestamp ) : from datetime import datetime , timedelta obj = datetime . fromtimestamp ( timestamp [ 0 ] ) return obj + timedelta ( microseconds = int ( timestamp [ 1 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert input argument to bytes [CODESPLIT] def str2bytes ( x ) : if type ( x ) is bytes : return x elif type ( x ) is str : return bytes ( [ ord ( i ) for i in x ] ) else : return str2bytes ( str ( x ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Appends tzinfo and assumes UTC if datetime object has no tzinfo already . [CODESPLIT] def make_aware ( dt ) : return dt if dt . tzinfo else dt . replace ( tzinfo = timezone . utc )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a list of tuples describing a table into a HTML string [CODESPLIT] def html ( header_rows ) : name = 'table%d' % next ( tablecounter ) return HtmlTable ( [ map ( str , row ) for row in header_rows ] , name ) . render ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update inplace widgets position when doing vertical scroll [CODESPLIT] def yview ( self , * args ) : self . after_idle ( self . __updateWnds ) ttk . Treeview . yview ( self , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine whether indicated file appears to be a gzipped FASTQ . [CODESPLIT] def is_gzipped_fastq ( file_name ) : _ , ext = os . path . splitext ( file_name ) return file_name . endswith ( \".fastq.gz\" ) or file_name . endswith ( \".fq.gz\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Restoring scrollbar position after main window is visible [CODESPLIT] def restore_scrollbar_position ( self ) : scrollbar_pos = self . get_option ( 'scrollbar_position' , None ) if scrollbar_pos is not None : self . explorer . treewidget . set_scrollbar_position ( scrollbar_pos )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if something quacks like a list . [CODESPLIT] def is_listish ( obj ) : if isinstance ( obj , ( list , tuple , set ) ) : return True return is_sequence ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Translate an image in fourier - space with plane waves [CODESPLIT] def translate_fourier ( image , dx ) : N = image . shape [ 0 ] f = 2 * np . pi * np . fft . fftfreq ( N ) kx , ky , kz = np . meshgrid ( * ( f , ) * 3 , indexing = 'ij' ) kv = np . array ( [ kx , ky , kz ] ) . T q = np . fft . fftn ( image ) * np . exp ( - 1.j * ( kv * dx ) . sum ( axis = - 1 ) ) . T return np . real ( np . fft . ifftn ( q ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if the queue is full [CODESPLIT] def full ( self ) : if not self . size : return False return len ( self . pq ) == ( self . size + self . removed_count )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "PostgreSQL connection [CODESPLIT] def get_pg_connection ( host , user , port , password , database , ssl = { } ) : return psycopg2 . connect ( host = host , user = user , port = port , password = password , dbname = database , sslmode = ssl . get ( 'sslmode' , None ) , sslcert = ssl . get ( 'sslcert' , None ) , sslkey = ssl . get ( 'sslkey' , None ) , sslrootcert = ssl . get ( 'sslrootcert' , None ) , )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns js [ key ] if set otherwise default . Note js [ key ] can be None . : param js : : param key : : param default : : param take_none : : return : [CODESPLIT] def defvalkey ( js , key , default = None , take_none = True ) : if js is None : return default if key not in js : return default if js [ key ] is None and not take_none : return default return js [ key ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dict from entries in a scala . collection . immutable . Map [CODESPLIT] def get_python_dict ( scala_map ) : python_dict = { } keys = get_python_list ( scala_map . keys ( ) . toList ( ) ) for key in keys : python_dict [ key ] = scala_map . apply ( key ) return python_dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resize and image to fit the passed in width keeping the aspect ratio the same [CODESPLIT] def resize_image_to_fit_width ( image , dest_w ) : scale_factor = dest_w / image . size [ 0 ] dest_h = image . size [ 1 ] * scale_factor scaled_image = image . resize ( ( int ( dest_w ) , int ( dest_h ) ) , PIL . Image . ANTIALIAS ) return scaled_image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "position in 3d space [CODESPLIT] def list ( self ) : return [ self . _pos3d . x , self . _pos3d . y , self . _pos3d . z ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prompts the user for yes or no . [CODESPLIT] def yn_prompt ( msg , default = True ) : ret = custom_prompt ( msg , [ \"y\" , \"n\" ] , \"y\" if default else \"n\" ) if ret == \"y\" : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Provides the value of the specified attribute [CODESPLIT] def GetAttributeNs ( self , localName , namespaceURI ) : ret = libxml2mod . xmlTextReaderGetAttributeNs ( self . _o , localName , namespaceURI ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return whether the handler is using sys . stdout . [CODESPLIT] def _using_stdout ( self ) : if WINDOWS and colorama : # Then self.stream is an AnsiToWin32 object. return self . stream . wrapped is sys . stdout return self . stream is sys . stdout", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Performs a join using the union join function . [CODESPLIT] def merge ( left , right , how = 'inner' , key = None , left_key = None , right_key = None , left_as = 'left' , right_as = 'right' ) : return join ( left , right , how , key , left_key , right_key , join_fn = make_union_join ( left_as , right_as ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Linear oldstyle interpolation of the transform matrix . [CODESPLIT] def _linearInterpolationTransformMatrix ( matrix1 , matrix2 , value ) : return tuple ( _interpolateValue ( matrix1 [ i ] , matrix2 [ i ] , value ) for i in range ( len ( matrix1 ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if we should use Unix style . [CODESPLIT] def is_unix_style ( flags ) : return ( util . platform ( ) != \"windows\" or ( not bool ( flags & REALPATH ) and get_case ( flags ) ) ) and not flags & _FORCEWIN", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Invert mapping of dictionary ( i . e . map values to list of keys ) [CODESPLIT] def invertDictMapping ( d ) : inv_map = { } for k , v in d . items ( ) : inv_map [ v ] = inv_map . get ( v , [ ] ) inv_map [ v ] . append ( k ) return inv_map", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run server with provided command line arguments . [CODESPLIT] def start ( args ) : application = tornado . web . Application ( [ ( r\"/run\" , run . get_handler ( args ) ) , ( r\"/status\" , run . StatusHandler ) ] ) application . runmonitor = RunMonitor ( ) application . listen ( args . port ) tornado . ioloop . IOLoop . instance ( ) . start ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the arithematic mean of the values in the passed list . Assumes a 1D list but will function on the 1st dim of an array ( ! ) . [CODESPLIT] def mean ( inlist ) : sum = 0 for item in inlist : sum = sum + item return sum / float ( len ( inlist ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create NumPy array from a pointer to some memory . [CODESPLIT] def _frombuffer ( ptr , frames , channels , dtype ) : framesize = channels * dtype . itemsize data = np . frombuffer ( ffi . buffer ( ptr , frames * framesize ) , dtype = dtype ) data . shape = - 1 , channels return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Construct a single page PDF from the provided page in memory [CODESPLIT] def _single_page_pdf ( page ) : pdf = Pdf . new ( ) pdf . pages . append ( page ) bio = BytesIO ( ) pdf . save ( bio ) bio . seek ( 0 ) return bio . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a list of JSON values to a list of models [CODESPLIT] def from_json_list ( cls , api_client , data ) : return [ cls . from_json ( api_client , item ) for item in data ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Executes a db query gets the first value and closes the connection . [CODESPLIT] def query_fetch_one ( self , query , values ) : self . cursor . execute ( query , values ) retval = self . cursor . fetchone ( ) self . __close_db ( ) return retval", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pre - order depth - first [CODESPLIT] def walk_tree ( root ) : yield root for child in root . children : for el in walk_tree ( child ) : yield el", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function that does what isoformat does but it actually does the same every time instead of randomly doing different things on some systems and also it represents that time as the equivalent UTC time . [CODESPLIT] def __consistent_isoformat_utc ( datetime_val ) : isotime = datetime_val . astimezone ( pytz . utc ) . strftime ( \"%Y-%m-%dT%H:%M:%S%z\" ) if isotime [ - 2 ] != \":\" : isotime = isotime [ : - 2 ] + \":\" + isotime [ - 2 : ] return isotime", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retries function until it doesn t raise an EINTR error [CODESPLIT] def retry_on_signal ( function ) : while True : try : return function ( ) except EnvironmentError , e : if e . errno != errno . EINTR : raise", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterate through all elements . [CODESPLIT] def __iter__ ( self ) : for value , count in self . counts ( ) : for _ in range ( count ) : yield value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calls a function . If an error of the given exception type with interrupted system call ( EINTR ) occurs calls the function again . [CODESPLIT] def eintr_retry ( exc_type , f , * args , * * kwargs ) : while True : try : return f ( * args , * * kwargs ) except exc_type as exc : if exc . errno != EINTR : raise else : break", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterate through lines of file . [CODESPLIT] def txt_line_iterator ( path ) : with tf . gfile . Open ( path ) as f : for line in f : yield line . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If value is a datetime convert to timestamp [CODESPLIT] def dt_to_ts ( value ) : if not isinstance ( value , datetime ) : return value return calendar . timegm ( value . utctimetuple ( ) ) + value . microsecond / 1000000.0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an iterator over the values of a dictionary . [CODESPLIT] def itervalues ( d , * * kw ) : if not PY2 : return iter ( d . values ( * * kw ) ) return d . itervalues ( * * kw )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize path slashes . [CODESPLIT] def norm_slash ( name ) : if isinstance ( name , str ) : return name . replace ( '/' , \"\\\\\" ) if not is_case_sensitive ( ) else name else : return name . replace ( b'/' , b\"\\\\\" ) if not is_case_sensitive ( ) else name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap itertools . groupby to make life easier . [CODESPLIT] def group_by ( iterable , key_func ) : groups = ( list ( sub ) for key , sub in groupby ( iterable , key_func ) ) return zip ( groups , groups )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A helper to create a proxy method in a class . [CODESPLIT] def Proxy ( f ) : def Wrapped ( self , * args ) : return getattr ( self , f ) ( * args ) return Wrapped", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Integer to two bytes [CODESPLIT] def intToBin ( i ) : # divide in two parts (bytes) i1 = i % 256 i2 = int ( i / 256 ) # make string (little endian) return i . to_bytes ( 2 , byteorder = 'little' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the path of java executable [CODESPLIT] def get_java_path ( ) : java_home = os . environ . get ( \"JAVA_HOME\" ) return os . path . join ( java_home , BIN_DIR , \"java\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "create a key for index by converting index into a base - 26 number using A - Z as the characters . [CODESPLIT] def excel_key ( index ) : X = lambda n : ~ n and X ( ( n // 26 ) - 1 ) + chr ( 65 + ( n % 26 ) ) or '' return X ( int ( index ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run Python test cases against Java runtime classes . [CODESPLIT] def test_python_java_rt ( ) : sub_env = { 'PYTHONPATH' : _build_dir ( ) } log . info ( 'Executing Python unit tests (against Java runtime classes)...' ) return jpyutil . _execute_python_scripts ( python_java_rt_tests , env = sub_env )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split text into list of sentences . [CODESPLIT] def split_into_sentences ( s ) : s = re . sub ( r\"\\s+\" , \" \" , s ) s = re . sub ( r\"[\\\\.\\\\?\\\\!]\" , \"\\n\" , s ) return s . split ( \"\\n\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a varaible return the list of attributes that are available inside of a template [CODESPLIT] def get_attributes ( var ) : is_valid = partial ( is_valid_in_template , var ) return list ( filter ( is_valid , dir ( var ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "calculate the fill similarity over the image [CODESPLIT] def _sim_fill ( r1 , r2 , imsize ) : bbsize = ( ( max ( r1 [ \"max_x\" ] , r2 [ \"max_x\" ] ) - min ( r1 [ \"min_x\" ] , r2 [ \"min_x\" ] ) ) * ( max ( r1 [ \"max_y\" ] , r2 [ \"max_y\" ] ) - min ( r1 [ \"min_y\" ] , r2 [ \"min_y\" ] ) ) ) return 1.0 - ( bbsize - r1 [ \"size\" ] - r2 [ \"size\" ] ) / imsize", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a character delimited version of the provided list as a Python string [CODESPLIT] def delimited ( items , character = '|' ) : return '|' . join ( items ) if type ( items ) in ( list , tuple , set ) else items", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if the given type is a builtin one . [CODESPLIT] def is_builtin_type ( tp ) : return hasattr ( __builtins__ , tp . __name__ ) and tp is getattr ( __builtins__ , tp . __name__ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coerce value to an JSON - compatible representation . [CODESPLIT] def _timestamp_to_json_row ( value ) : if isinstance ( value , datetime . datetime ) : value = _microseconds_from_datetime ( value ) * 1e-6 return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like isinstance ( obj check ) but strict . [CODESPLIT] def istype ( obj , check ) : if isinstance ( check , tuple ) : for cls in check : if type ( obj ) is cls : return True return False else : return type ( obj ) is check", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses an ISO8601 formatted datetime from a string value [CODESPLIT] def parse_json_date ( value ) : if not value : return None return datetime . datetime . strptime ( value , JSON_DATETIME_FORMAT ) . replace ( tzinfo = pytz . UTC )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function for conversion of various data types into numeric representation . [CODESPLIT] def _to_numeric ( val ) : if isinstance ( val , ( int , float , datetime . datetime , datetime . timedelta ) ) : return val return float ( val )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Open and load JSON from file . [CODESPLIT] def read_json ( location ) : location = ensure_path ( location ) with location . open ( 'r' , encoding = 'utf8' ) as f : return ujson . load ( f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple generic JSON serializer for common objects . [CODESPLIT] def json_serialize ( obj ) : if isinstance ( obj , datetime ) : return obj . isoformat ( ) if hasattr ( obj , 'id' ) : return jsonify ( obj . id ) if hasattr ( obj , 'name' ) : return jsonify ( obj . name ) raise TypeError ( '{0} is not JSON serializable' . format ( obj ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform underscore separated string to pascal case [CODESPLIT] def to_pascal_case ( s ) : return re . sub ( r'(?!^)_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , s . capitalize ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "TODO doc string [CODESPLIT] def __init__ ( self , testnet = False , dryrun = False ) : self . testnet = testnet self . dryrun = dryrun", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list copy in which each item occurs only once ( in - order ) . [CODESPLIT] def unique ( iterable ) : seen = set ( ) return [ x for x in iterable if x not in seen and not seen . add ( x ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run all Tests [ nose ] [CODESPLIT] def test ( ) : command = 'nosetests --with-coverage --cover-package=pwnurl' status = subprocess . call ( shlex . split ( command ) ) sys . exit ( status )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raises an AssertionError if expected is actual . [CODESPLIT] def assert_is_not ( expected , actual , message = None , extra = None ) : assert expected is not actual , _assert_fail_message ( message , expected , actual , \"is\" , extra )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "These actions will be done after SIGTERM . [CODESPLIT] def sigterm ( self , signum , frame ) : self . logger . warning ( \"Caught signal %s. Stopping daemon.\" % signum ) sys . exit ( 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Guess if URL is a http or ftp URL . [CODESPLIT] def guess_url ( url ) : if url . lower ( ) . startswith ( \"www.\" ) : # syntactic sugar return \"http://%s\" % url elif url . lower ( ) . startswith ( \"ftp.\" ) : # syntactic sugar return \"ftp://%s\" % url return url", "target": 1, "target_options": ["no_match", "match"]}
{"input": "L2 Normalize along specified axes . [CODESPLIT] def normalize ( v , axis = None , eps = 1e-10 ) : return v / max ( anorm ( v , axis = axis , keepdims = True ) , eps )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transparently unzip the file handle [CODESPLIT] def _unzip_handle ( handle ) : if isinstance ( handle , basestring ) : handle = _gzip_open_filename ( handle ) else : handle = _gzip_open_handle ( handle ) return handle", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for plotting . [CODESPLIT] def finish_plot ( ) : plt . legend ( ) plt . grid ( color = '0.7' ) plt . xlabel ( 'x' ) plt . ylabel ( 'y' ) plt . show ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper parse action to convert tokens to upper case . [CODESPLIT] def upcaseTokens ( s , l , t ) : return [ tt . upper ( ) for tt in map ( _ustr , t ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return type may come from any boolop operand . [CODESPLIT] def visit_BoolOp ( self , node ) : return sum ( ( self . visit ( value ) for value in node . values ) , [ ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the text fetched via http GET from URL read as encoding [CODESPLIT] def download ( url , encoding = 'utf-8' ) : import requests response = requests . get ( url ) response . encoding = encoding return response . text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Use the S3 SWAG backend . [CODESPLIT] def s3 ( ctx , bucket_name , data_file , region ) : if not ctx . data_file : ctx . data_file = data_file if not ctx . bucket_name : ctx . bucket_name = bucket_name if not ctx . region : ctx . region = region ctx . type = 's3'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Small transformer model with small batch size for fast step times . [CODESPLIT] def afx_small ( ) : hparams = transformer . transformer_tpu ( ) hparams . filter_size = 1024 hparams . num_heads = 4 hparams . num_hidden_layers = 3 hparams . batch_size = 512 return hparams", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if the url is a safe redirection . [CODESPLIT] def is_safe_url ( url , host = None ) : if not url : return False netloc = urlparse . urlparse ( url ) [ 1 ] return not netloc or netloc == host", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last n rows in the table [CODESPLIT] def get_last_row ( dbconn , tablename , n = 1 , uuid = None ) : return fetch ( dbconn , tablename , n , uuid , end = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The url of this window [CODESPLIT] def url ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . url", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a dictionary from a URL params [CODESPLIT] def get_url_args ( url ) : url_data = urllib . parse . urlparse ( url ) arg_dict = urllib . parse . parse_qs ( url_data . query ) return arg_dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A function to generate the latex representation of sympy expressions . [CODESPLIT] def print_latex ( o ) : if can_print_latex ( o ) : s = latex ( o , mode = 'plain' ) s = s . replace ( '\\\\dag' , '\\\\dagger' ) s = s . strip ( '$' ) return '$$%s$$' % s # Fallback to the string printer return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the channels of a colorbar . [CODESPLIT] def colorbar ( height , length , colormap ) : cbar = np . tile ( np . arange ( length ) * 1.0 / ( length - 1 ) , ( height , 1 ) ) cbar = ( cbar * ( colormap . values . max ( ) - colormap . values . min ( ) ) + colormap . values . min ( ) ) return colormap . colorize ( cbar )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Builds instance from dictionary of properties . [CODESPLIT] def fromDict ( cls , _dict ) : obj = cls ( ) obj . __dict__ . update ( _dict ) return obj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determines the number of bytes required to store a NumPy array with the specified shape and datatype . [CODESPLIT] def _requiredSize ( shape , dtype ) : return math . floor ( np . prod ( np . asarray ( shape , dtype = np . uint64 ) ) * np . dtype ( dtype ) . itemsize )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a shell - escaped version of the string s . [CODESPLIT] def quote ( self , s ) : if six . PY2 : from pipes import quote else : from shlex import quote return quote ( s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get unit vector for a given one . [CODESPLIT] def normalized ( vector ) : length = numpy . sum ( vector * vector , axis = - 1 ) length = numpy . sqrt ( length . reshape ( length . shape + ( 1 , ) ) ) return vector / length", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator which dynamically binds static methods to the model for later use . [CODESPLIT] def static_method ( cls , f ) : setattr ( cls , f . __name__ , staticmethod ( f ) ) return f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Align the given integer number to the closest page offset which usually is 4096 bytes . [CODESPLIT] def align_to_mmap ( num , round_up ) : res = ( num // ALLOCATIONGRANULARITY ) * ALLOCATIONGRANULARITY if round_up and ( res != num ) : res += ALLOCATIONGRANULARITY # END handle size return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call a function after a delay unless another function is set in the meantime . [CODESPLIT] def set ( self , f ) : self . stop ( ) self . _create_timer ( f ) self . start ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Interactive test run . [CODESPLIT] def test ( ) : try : while 1 : x , digs = input ( 'Enter (x, digs): ' ) print x , fix ( x , digs ) , sci ( x , digs ) except ( EOFError , KeyboardInterrupt ) : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a object into dictionary with all of its readable attributes . [CODESPLIT] def dict_from_object ( obj : object ) : # If object is a dict instance, no need to convert. return ( obj if isinstance ( obj , dict ) else { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( '_' ) } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flushes the prompt before requesting the input [CODESPLIT] def _normal_prompt ( self ) : sys . stdout . write ( self . __get_ps1 ( ) ) sys . stdout . flush ( ) return safe_input ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the total length of all of the flattened variables . [CODESPLIT] def get_flat_size ( self ) : return sum ( np . prod ( v . get_shape ( ) . as_list ( ) ) for v in self . variables . values ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "read a simple text file from a private location to get username and password [CODESPLIT] def read_credentials ( fname ) : with open ( fname , 'r' ) as f : username = f . readline ( ) . strip ( '\\n' ) password = f . readline ( ) . strip ( '\\n' ) return username , password", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the names of all callable attributes of an object [CODESPLIT] def get_methods ( * objs ) : return set ( attr for obj in objs for attr in dir ( obj ) if not attr . startswith ( '_' ) and callable ( getattr ( obj , attr ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "bytes to unicode [CODESPLIT] def b2u ( string ) : if ( isinstance ( string , bytes ) or ( PY2 and isinstance ( string , str ) ) ) : return string . decode ( 'utf-8' ) return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns data as : class : numpy . recarray . [CODESPLIT] def recarray ( self ) : return numpy . rec . fromrecords ( self . records , names = self . names )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Integer validator [CODESPLIT] def validate_int ( value ) : if value and not isinstance ( value , int ) : try : int ( str ( value ) ) except ( TypeError , ValueError ) : raise ValidationError ( 'not a valid number' ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transforms a list of 2 element tuples to a dictionary [CODESPLIT] def list2dict ( list_of_options ) : d = { } for key , value in list_of_options : d [ key ] = value return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check the validity of an IPv6 address [CODESPLIT] def is_valid_ipv6 ( ip_str ) : try : socket . inet_pton ( socket . AF_INET6 , ip_str ) except socket . error : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Getter for series values ( flattened ) [CODESPLIT] def _values ( self ) : return [ val for serie in self . series for val in serie . values if val is not None ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "tool to ensure input and output data have the same number of samples [CODESPLIT] def check_X_y ( X , y ) : if len ( X ) != len ( y ) : raise ValueError ( 'Inconsistent input and output data shapes. ' 'found X: {} and y: {}' . format ( X . shape , y . shape ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns json contents as string [CODESPLIT] def open_json ( file_name ) : with open ( file_name , \"r\" ) as json_data : data = json . load ( json_data ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an old style protocol buffer object . [CODESPLIT] def AsPrimitiveProto ( self ) : if self . protobuf : result = self . protobuf ( ) result . ParseFromString ( self . SerializeToString ( ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "SPSS . sav files to Pandas DataFrame through Rpy2 [CODESPLIT] def sav_to_pandas_rpy2 ( input_file ) : import pandas . rpy . common as com w = com . robj . r ( 'foreign::read.spss(\"%s\", to.data.frame=TRUE)' % input_file ) return com . convert_robj ( w )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates data is a timestamp [CODESPLIT] def is_timestamp ( instance ) : if not isinstance ( instance , ( int , str ) ) : return True return datetime . fromtimestamp ( int ( instance ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate each a : tc element in non - first rows of range . [CODESPLIT] def iter_except_top_row_tcs ( self ) : for tr in self . _tbl . tr_lst [ self . _top + 1 : self . _bottom ] : for tc in tr . tc_lst [ self . _left : self . _right ] : yield tc", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Natural log of scipy norm function truncated at zero [CODESPLIT] def ln_norm ( x , mu , sigma = 1.0 ) : return np . log ( stats . norm ( loc = mu , scale = sigma ) . pdf ( x ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Start web application [CODESPLIT] def web ( host , port ) : from . webserver . web import get_app get_app ( ) . run ( host = host , port = port )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Match and yield all the tokens of the input string . [CODESPLIT] def tokenize ( string ) : for match in TOKENS_REGEX . finditer ( string ) : yield Token ( match . lastgroup , match . group ( ) . strip ( ) , match . span ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the type of the item . [CODESPLIT] def get_type ( self ) : item_type = self . xmlnode . prop ( \"type\" ) if not item_type : item_type = \"?\" return item_type . decode ( \"utf-8\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": return : A bool if the current machine is running OS X 10 . 7 [CODESPLIT] def _is_osx_107 ( ) : if sys . platform != 'darwin' : return False version = platform . mac_ver ( ) [ 0 ] return tuple ( map ( int , version . split ( '.' ) ) ) [ 0 : 2 ] == ( 10 , 7 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Closes all not current windows . Useful for tests - after each test you can automatically close all windows . [CODESPLIT] def close_other_windows ( self ) : main_window_handle = self . current_window_handle for window_handle in self . window_handles : if window_handle == main_window_handle : continue self . switch_to_window ( window_handle ) self . close ( ) self . switch_to_window ( main_window_handle )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Magnitude of a complex matrix . [CODESPLIT] def magnitude ( X ) : r = np . real ( X ) i = np . imag ( X ) return np . sqrt ( r * r + i * i )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Swap system memory as a ( total used free sin sout ) tuple . [CODESPLIT] def swap_memory ( ) : mem = _psutil_mswindows . get_virtual_mem ( ) total = mem [ 2 ] free = mem [ 3 ] used = total - free percent = usage_percent ( used , total , _round = 1 ) return nt_swapmeminfo ( total , used , free , percent , 0 , 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make script_path executable . [CODESPLIT] def make_executable ( script_path ) : status = os . stat ( script_path ) os . chmod ( script_path , status . st_mode | stat . S_IEXEC )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write a dict to a JSON file . [CODESPLIT] def _write_json ( file , contents ) : with open ( file , 'w' ) as f : return json . dump ( contents , f , indent = 2 , sort_keys = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove duplicates from a sequence ( of hashable items ) while maintaining order . NOTE : This only works if items in the list are hashable types . [CODESPLIT] def dedupe ( items ) : seen = set ( ) for item in items : if item not in seen : yield item seen . add ( item )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update only one property in the dict [CODESPLIT] def set_property ( self , key , value ) : self . properties [ key ] = value self . sync_properties ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "View the quaternion array as an array of floats [CODESPLIT] def as_float_array ( a ) : return np . asarray ( a , dtype = np . quaternion ) . view ( ( np . double , 4 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Saves dictionary as CSV file . [CODESPLIT] def save_dict_to_file ( filename , dictionary ) : with open ( filename , 'w' ) as f : writer = csv . writer ( f ) for k , v in iteritems ( dictionary ) : writer . writerow ( [ str ( k ) , str ( v ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds noise to Y [CODESPLIT] def add_noise ( Y , sigma ) : return Y + np . random . normal ( 0 , sigma , Y . shape )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute average gradient norm of an image [CODESPLIT] def average_gradient ( data , * kwargs ) : return np . average ( np . array ( np . gradient ( data ) ) ** 2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a timevalue for interval comparisons [CODESPLIT] def stopwatch_now ( ) : if six . PY2 : now = time . time ( ) else : now = time . monotonic ( ) return now", "target": 1, "target_options": ["no_match", "match"]}
{"input": "implementation of safe dumper using Ordered Dict Yaml Dumper [CODESPLIT] def safe_dump ( data , stream = None , * * kwds ) : return yaml . dump ( data , stream = stream , Dumper = ODYD , * * kwds )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load a YAML file from path [CODESPLIT] def load_yaml_file ( file_path : str ) : with codecs . open ( file_path , 'r' ) as f : return yaml . safe_load ( f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If Python 2 replace non - ascii characters and return encoded string . [CODESPLIT] def safe_unicode ( string ) : if not PY3 : uni = string . replace ( u'\\u2019' , \"'\" ) return uni . encode ( 'utf-8' ) return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the top - level element of a document sub - tree containing the YAML serialization of a Python object . [CODESPLIT] def yaml_to_param ( obj , name ) : return from_pyvalue ( u\"yaml:%s\" % name , unicode ( yaml . dump ( obj ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fix common typos in given URL like forgotten colon . [CODESPLIT] def url_fix_common_typos ( url ) : if url . startswith ( \"http//\" ) : url = \"http://\" + url [ 6 : ] elif url . startswith ( \"https//\" ) : url = \"https://\" + url [ 7 : ] return url", "target": 1, "target_options": ["no_match", "match"]}
{"input": "reads the zip file determines compression and unzips recursively until source files are extracted [CODESPLIT] def extract_all ( zipfile , dest_folder ) : z = ZipFile ( zipfile ) print ( z ) z . extract ( dest_folder )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handle many to many relationships [CODESPLIT] def handle_m2m ( self , sender , instance , * * kwargs ) : self . handle_save ( instance . __class__ , instance )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract the archive . [CODESPLIT] def extract ( self , destination ) : with zipfile . ZipFile ( self . archive , 'r' ) as zip_ref : zip_ref . extractall ( destination )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dict from entries in a scala . collection . immutable . Map [CODESPLIT] def get_python_dict ( scala_map ) : python_dict = { } keys = get_python_list ( scala_map . keys ( ) . toList ( ) ) for key in keys : python_dict [ key ] = scala_map . apply ( key ) return python_dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def compress ( data , * * kwargs ) : \"\"\"zlib.compress(data, **kwargs)\n    \n    \"\"\" + zopfli . __COMPRESSOR_DOCSTRING__ + \"\"\"\n    Returns:\n      String containing a zlib container\n    \"\"\" kwargs [ 'gzip_mode' ] = 0 return zopfli . zopfli . compress ( data , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the arithematic mean of the values in the passed list . Assumes a 1D list but will function on the 1st dim of an array ( ! ) . [CODESPLIT] def mean ( inlist ) : sum = 0 for item in inlist : sum = sum + item return sum / float ( len ( inlist ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Init connection and consumer with openstack mq . [CODESPLIT] def init_mq ( self ) : mq = self . init_connection ( ) self . init_consumer ( mq ) return mq . connection", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the dot product of the given vectors . [CODESPLIT] def dot_product ( self , other ) : return self . x * other . x + self . y * other . y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the maximum value of the domain . [CODESPLIT] def max ( self ) : return int ( self . _max ) if not np . isinf ( self . _max ) else self . _max", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs a bash script in the local directory [CODESPLIT] def bash ( filename ) : sys . stdout . flush ( ) subprocess . call ( \"bash {}\" . format ( filename ) , shell = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert list of key value lists to dict [CODESPLIT] def list_of_lists_to_dict ( l ) : d = { } for key , val in l : d . setdefault ( key , [ ] ) . append ( val ) return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the length of the longest consecutive run of identical values . [CODESPLIT] def longest_run_1d ( arr ) : v , rl = rle_1d ( arr ) [ : 2 ] return np . where ( v , rl , 0 ) . max ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transforms a list of 2 element tuples to a dictionary [CODESPLIT] def list2dict ( list_of_options ) : d = { } for key , value in list_of_options : d [ key ] = value return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generates a random integer in the available range . [CODESPLIT] def simulate ( self ) : min_ = ( - sys . maxsize - 1 ) if self . _min is None else self . _min max_ = sys . maxsize if self . _max is None else self . _max return random . randint ( min_ , max_ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Context manager ( with statement ) that changes the current directory during the context . [CODESPLIT] def in_directory ( path ) : curdir = os . path . abspath ( os . curdir ) os . chdir ( path ) yield os . chdir ( curdir )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the median of a list . [CODESPLIT] def median ( data ) : data . sort ( ) num_values = len ( data ) half = num_values // 2 if num_values % 2 : return data [ half ] return 0.5 * ( data [ half - 1 ] + data [ half ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Alternate name for filter so as to not collide with the built - in python filter operator . [CODESPLIT] def filter_ ( stream_spec , filter_name , * args , * * kwargs ) : return filter ( stream_spec , filter_name , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Appends a PDF to a pyPDF writer . Legacy interface . [CODESPLIT] def append_pdf ( input_pdf : bytes , output_writer : PdfFileWriter ) : append_memory_pdf_to_writer ( input_pdf = input_pdf , writer = output_writer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "date to unix timestamp in milliseconds [CODESPLIT] def date_to_timestamp ( date ) : date_tuple = date . timetuple ( ) timestamp = calendar . timegm ( date_tuple ) * 1000 return timestamp", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator which adds correct MIME type for python source to the decorated bottle API function . [CODESPLIT] def python_mime ( fn ) : @ wraps ( fn ) def python_mime_decorator ( * args , * * kwargs ) : response . content_type = \"text/x-python\" return fn ( * args , * * kwargs ) return python_mime_decorator", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Searches for the specified method and returns its descriptor . [CODESPLIT] def FindMethodByName ( self , name ) : for method in self . methods : if name == method . name : return method return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Nested lists to single - level list does not split strings [CODESPLIT] def flatten_list ( l ) : return list ( chain . from_iterable ( repeat ( x , 1 ) if isinstance ( x , str ) else x for x in l ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a matplotlib colormap . [CODESPLIT] def add_matplotlib_cmap ( cm , name = None ) : global cmaps cmap = matplotlib_to_ginga_cmap ( cm , name = name ) cmaps [ cmap . name ] = cmap", "target": 1, "target_options": ["no_match", "match"]}
{"input": "str to bytes ( py3k ) [CODESPLIT] def to_bytes ( value ) : vtype = type ( value ) if vtype == bytes or vtype == type ( None ) : return value try : return vtype . encode ( value ) except UnicodeEncodeError : pass return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find one wrapper with conversion to dictionary [CODESPLIT] def find_one ( self , query ) : mongo_response = yield self . collection . find_one ( query ) raise Return ( self . _obj_cursor_to_dictionary ( mongo_response ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deserialize b ( instance of bytes ) to a Python object . [CODESPLIT] def loadb ( b ) : assert isinstance ( b , ( bytes , bytearray ) ) return std_json . loads ( b . decode ( 'utf-8' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initializes a rotating logger [CODESPLIT] def init_rotating_logger ( level , logfile , max_files , max_bytes ) : logging . basicConfig ( ) root_logger = logging . getLogger ( ) log_format = \"[%(asctime)s] [%(levelname)s] %(filename)s: %(message)s\" root_logger . setLevel ( level ) handler = RotatingFileHandler ( logfile , maxBytes = max_bytes , backupCount = max_files ) handler . setFormatter ( logging . Formatter ( fmt = log_format , datefmt = date_format ) ) root_logger . addHandler ( handler ) for handler in root_logger . handlers : root_logger . debug ( \"Associated handlers - \" + str ( handler ) ) if isinstance ( handler , logging . StreamHandler ) : root_logger . debug ( \"Removing StreamHandler: \" + str ( handler ) ) root_logger . handlers . remove ( handler )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Command line interface for PyBEL . [CODESPLIT] def main ( ctx , connection ) : ctx . obj = Manager ( connection = connection ) ctx . obj . bind ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the first line of a file . [CODESPLIT] def getfirstline ( file , default ) : with open ( file , 'rb' ) as fh : content = fh . readlines ( ) if len ( content ) == 1 : return content [ 0 ] . decode ( 'utf-8' ) . strip ( '\\n' ) return default", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap an item in optional parentheses only applying them if necessary . [CODESPLIT] def maybeparens ( lparen , item , rparen ) : return item | lparen . suppress ( ) + item + rparen . suppress ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a naive datetime object for the given timezone . A timezone is any pytz - like or datetime . tzinfo - like timezone object . If no timezone is given then UTC is assumed . [CODESPLIT] def now ( timezone = None ) : d = datetime . datetime . utcnow ( ) if not timezone : return d return to_timezone ( d , timezone ) . replace ( tzinfo = None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Redirect the stdout [CODESPLIT] def redirect_stdout ( new_stdout ) : old_stdout , sys . stdout = sys . stdout , new_stdout try : yield None finally : sys . stdout = old_stdout", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace boolean variables by the characters F / T [CODESPLIT] def _check_and_convert_bools ( self ) : replacements = { True : 'T' , False : 'F' , } for key in self . bools : if isinstance ( self [ key ] , bool ) : self [ key ] = replacements [ self [ key ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit the runtime context . This will end the transaction . [CODESPLIT] def __exit__ ( self , * exc ) : if exc [ 0 ] is None and exc [ 1 ] is None and exc [ 2 ] is None : self . commit ( ) else : self . rollback ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn dict keys and values into native strings . [CODESPLIT] def stringify_dict_contents ( dct ) : return { str_if_nested_or_str ( k ) : str_if_nested_or_str ( v ) for k , v in dct . items ( ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Moves the layer up in the stacking order . [CODESPLIT] def up ( self ) : i = self . index ( ) if i != None : del self . canvas . layers [ i ] i = min ( len ( self . canvas . layers ) , i + 1 ) self . canvas . layers . insert ( i , self )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty output of nested dictionaries . [CODESPLIT] def pretty_dict_string ( d , indent = 0 ) : s = '' for key , value in sorted ( d . items ( ) ) : s += '    ' * indent + str ( key ) if isinstance ( value , dict ) : s += '\\n' + pretty_dict_string ( value , indent + 1 ) else : s += '=' + str ( value ) + '\\n' return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return locale from GET lang param or automatically . [CODESPLIT] def set_locale ( request ) : return request . query . get ( 'lang' , app . ps . babel . select_locale_by_request ( request ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return whether num is a power of two [CODESPLIT] def is_power_of_2 ( num ) : log = math . log2 ( num ) return int ( log ) == float ( log )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Save a qrcode object into out_filepath . Parameters ---------- qrcode : qrcode object [CODESPLIT] def _qrcode_to_file ( qrcode , out_filepath ) : try : qrcode . save ( out_filepath ) except Exception as exc : raise IOError ( 'Error trying to save QR code file {}.' . format ( out_filepath ) ) from exc else : return qrcode", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets the caption_found and plot_found variables to False . [CODESPLIT] def prepare ( doc ) : doc . caption_found = False doc . plot_found = False doc . listings_counter = 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def copy ( obj ) : def copy ( self ) : \"\"\"\n        Copy self to a new object.\n        \"\"\" from copy import deepcopy return deepcopy ( self ) obj . copy = copy return obj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shot noise corruption to images . [CODESPLIT] def shot_noise ( x , severity = 1 ) : c = [ 60 , 25 , 12 , 5 , 3 ] [ severity - 1 ] x = np . array ( x ) / 255. x_clip = np . clip ( np . random . poisson ( x * c ) / float ( c ) , 0 , 1 ) * 255 return around_and_astype ( x_clip )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a random positive integer ( for a Django PositiveIntegerField ) [CODESPLIT] def positive_integer ( anon , obj , field , val ) : return anon . faker . positive_integer ( field = field )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize the image to zero mean and unit variance . [CODESPLIT] def _normalize ( image ) : offset = tf . constant ( MEAN_RGB , shape = [ 1 , 1 , 3 ] ) image -= offset scale = tf . constant ( STDDEV_RGB , shape = [ 1 , 1 , 3 ] ) image /= scale return image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Has a 50 / 50 chance of calling a function [CODESPLIT] def sometimesish ( fn ) : def wrapped ( * args , * * kwargs ) : if random . randint ( 1 , 2 ) == 1 : return fn ( * args , * * kwargs ) return wrapped", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Random uniform variates . [CODESPLIT] def runiform ( lower , upper , size = None ) : return np . random . uniform ( lower , upper , size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract a numpy array from a base64 buffer [CODESPLIT] def decode_arr ( data ) : data = data . encode ( 'utf-8' ) return frombuffer ( base64 . b64decode ( data ) , float64 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract the boundaries from a list of indexes [CODESPLIT] def get_idx_rect ( index_list ) : rows , cols = list ( zip ( * [ ( i . row ( ) , i . column ( ) ) for i in index_list ] ) ) return ( min ( rows ) , max ( rows ) , min ( cols ) , max ( cols ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "From a given natural integer returns the prime factors and their multiplicity : param n : Natural integer : return : [CODESPLIT] def _factor_generator ( n ) : p = prime_factors ( n ) factors = { } for p1 in p : try : factors [ p1 ] += 1 except KeyError : factors [ p1 ] = 1 return factors", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read the specified pin and return HIGH / true if the pin is pulled high or LOW / false if pulled low . [CODESPLIT] def input ( self , pin ) : return self . mraa_gpio . Gpio . read ( self . mraa_gpio . Gpio ( pin ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the number of rows of the main dataframe [CODESPLIT] def count_ ( self ) : try : num = len ( self . df . index ) except Exception as e : self . err ( e , \"Can not count data\" ) return return num", "target": 1, "target_options": ["no_match", "match"]}
{"input": "! Iterate over subkeys of a key [CODESPLIT] def _iter_keys ( key ) : for i in range ( winreg . QueryInfoKey ( key ) [ 0 ] ) : yield winreg . OpenKey ( key , winreg . EnumKey ( key , i ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the shape of the dataset as ( rows cols ) . [CODESPLIT] def shape ( self ) : if not self . data : return ( 0 , 0 ) return ( len ( self . data ) , len ( self . dimensions ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse Config File from yaml file . [CODESPLIT] def _parse_config ( config_file_path ) : config_file = open ( config_file_path , 'r' ) config = yaml . load ( config_file ) config_file . close ( ) return config", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": rtype : numpy matrix [CODESPLIT] def load_data ( filename ) : data = pandas . read_csv ( filename , header = None , delimiter = '\\t' , skiprows = 9 ) return data . as_matrix ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a one - hot encoded array back to string [CODESPLIT] def one_hot2string ( arr , vocab ) : tokens = one_hot2token ( arr ) indexToLetter = _get_index_dict ( vocab ) return [ '' . join ( [ indexToLetter [ x ] for x in row ] ) for row in tokens ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a python file and returns a awslambda . Code object : param python_file : : return : [CODESPLIT] def lambda_from_file ( python_file ) : lambda_function = [ ] with open ( python_file , 'r' ) as f : lambda_function . extend ( f . read ( ) . splitlines ( ) ) return awslambda . Code ( ZipFile = ( Join ( '\\n' , lambda_function ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a map from a code ( usually a string ) to the shorter numeric value [CODESPLIT] def reverse_code_map ( self ) : return { c . value : ( c . ikey if c . ikey else c . key ) for c in self . codes }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts html content to plain text [CODESPLIT] def html_to_text ( content ) : text = None h2t = html2text . HTML2Text ( ) h2t . ignore_links = False text = h2t . handle ( content ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This loads a geojson file into a geojson python dictionary using the json module . Note : to load with a different text encoding use the encoding argument . [CODESPLIT] def _loadfilepath ( self , filepath , * * kwargs ) : with open ( filepath , \"r\" ) as f : data = json . load ( f , * * kwargs ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Recieving the JSON file from uulm [CODESPLIT] def get ( url ) : response = urllib . request . urlopen ( url ) data = response . read ( ) data = data . decode ( \"utf-8\" ) data = json . loads ( data ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate CSV / TSV file from biolink model [CODESPLIT] def cli ( yamlfile , root , format ) : print ( CsvGenerator ( yamlfile , format ) . serialize ( classes = root ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "read a simple text file from a private location to get username and password [CODESPLIT] def read_credentials ( fname ) : with open ( fname , 'r' ) as f : username = f . readline ( ) . strip ( '\\n' ) password = f . readline ( ) . strip ( '\\n' ) return username , password", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is builtin in python2 but we have to roll our own on py3 . [CODESPLIT] def execfile ( fname , variables ) : with open ( fname ) as f : code = compile ( f . read ( ) , fname , 'exec' ) exec ( code , variables )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Does openat read - only then does fdopen to get a file object [CODESPLIT] def fopenat ( base_fd , path ) : return os . fdopen ( openat ( base_fd , path , os . O_RDONLY ) , 'rb' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This a private ( You shouldn t have to call it ) recursive function that inserts a child tree into a parent tree . [CODESPLIT] def aux_insertTree ( childTree , parentTree ) : if childTree . x1 != None and childTree . x2 != None : parentTree . insert ( childTree . x1 , childTree . x2 , childTree . name , childTree . referedObject ) for c in childTree . children : aux_insertTree ( c , parentTree )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the serial port e . g . : / dev / tty . usbserial - A4001ib8 [CODESPLIT] def do_serial ( self , p ) : try : self . serial . port = p self . serial . open ( ) print 'Opening serial port: %s' % p except Exception , e : print 'Unable to open serial port: %s' % p", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function flatten given nested list . Argument : nested list Returns : flat list [CODESPLIT] def flat_list ( lst ) : if isinstance ( lst , list ) : for item in lst : for i in flat_list ( item ) : yield i else : yield lst", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list with the order that features requested appear in dataset [CODESPLIT] def get_feature_order ( dataset , features ) : all_features = dataset . get_feature_names ( ) i = [ all_features . index ( f ) for f in features ] return i", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the circular permutation for a given list of items . [CODESPLIT] def circ_permutation ( items ) : permutations = [ ] for i in range ( len ( items ) ) : permutations . append ( items [ i : ] + items [ : i ] ) return permutations", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format list responses into a table . [CODESPLIT] def _format_list ( result ) : if not result : return result if isinstance ( result [ 0 ] , dict ) : return _format_list_objects ( result ) table = Table ( [ 'value' ] ) for item in result : table . add_row ( [ iter_to_table ( item ) ] ) return table", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Redirects to the specified view or url [CODESPLIT] def redirect ( view = None , url = None , * * kwargs ) : if view : if url : kwargs [ \"url\" ] = url url = flask . url_for ( view , * * kwargs ) current_context . exit ( flask . redirect ( url ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pad a matrix with zeros on all sides . [CODESPLIT] def zero_pad ( m , n = 1 ) : return np . pad ( m , ( n , n ) , mode = 'constant' , constant_values = [ 0 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get a set of keys from redis [CODESPLIT] def get ( self , key ) : res = self . connection . get ( key ) print ( res ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format a string for screen printing . [CODESPLIT] def format_screen ( strng ) : # Paragraph continue par_re = re . compile ( r'\\\\$' , re . MULTILINE ) strng = par_re . sub ( '' , strng ) return strng", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the project path ( aka project root ) [CODESPLIT] def path ( self ) : return pathlib . Path ( self . package . __file__ ) . resolve ( ) . parent . parent", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get max for queryset . [CODESPLIT] def get_max ( qs , field ) : max_field = '%s__max' % field num = qs . aggregate ( Max ( field ) ) [ max_field ] return num if num else 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "underscore to mixed case notation [CODESPLIT] def case_us2mc ( x ) : return re . sub ( r'_([a-z])' , lambda m : ( m . group ( 1 ) . upper ( ) ) , x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove remote file Return : bool : true or false [CODESPLIT] def remove ( self , path ) : p = self . cmd ( 'shell' , 'rm' , path ) stdout , stderr = p . communicate ( ) if stdout or stderr : return False else : return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check for semicolons at the end of lines . [CODESPLIT] def endline_semicolon_check ( self , original , loc , tokens ) : return self . check_strict ( \"semicolon at end of line\" , original , loc , tokens )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse file specified by constructor . [CODESPLIT] def parse ( self ) : f = open ( self . parse_log_path , \"r\" ) self . parse2 ( f ) f . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform relative pathnames into absolute pathnames . [CODESPLIT] def get_absolute_path ( * args ) : directory = os . path . dirname ( os . path . abspath ( __file__ ) ) return os . path . join ( directory , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses a given dictionary with the key being the OBD PID and the value its returned value by the OBD interface : param dict o : : return : [CODESPLIT] def parse_obj ( o ) : r = { } for k , v in o . items ( ) : if is_unable_to_connect ( v ) : r [ k ] = None try : r [ k ] = parse_value ( k , v ) except ( ObdPidParserUnknownError , AttributeError , TypeError ) : r [ k ] = None return r", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove duplicated elements in a list . Args : lista : List with elements to clean duplicates . [CODESPLIT] def remove_list_duplicates ( lista , unique = False ) : result = [ ] allready = [ ] for elem in lista : if elem not in result : result . append ( elem ) else : allready . append ( elem ) if unique : for elem in allready : result = list ( filter ( ( elem ) . __ne__ , result ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return default argument value as given by argparse s add_argument () . [CODESPLIT] def arg_default ( * args , * * kwargs ) : parser = argparse . ArgumentParser ( ) parser . add_argument ( * args , * * kwargs ) args = vars ( parser . parse_args ( [ ] ) ) _ , default = args . popitem ( ) return default", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace accentuated chars in string by their non accentuated equivalent . [CODESPLIT] def unaccentuate ( s ) : return \"\" . join ( c for c in unicodedata . normalize ( \"NFKD\" , s ) if not unicodedata . combining ( c ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flags that a function is linear wrt all args [CODESPLIT] def def_linear ( fun ) : defjvp_argnum ( fun , lambda argnum , g , ans , args , kwargs : fun ( * subval ( args , argnum , g ) , * * kwargs ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds the argument to an argparse . ArgumentParser instance [CODESPLIT] def add_to_parser ( self , parser ) : kwargs = self . _get_kwargs ( ) args = self . _get_args ( ) parser . add_argument ( * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Same as : meth : random . choice but also supports : class : set type to be passed as sequence . [CODESPLIT] def random_choice ( sequence ) : return random . choice ( tuple ( sequence ) if isinstance ( sequence , set ) else sequence )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Undoes the effects of the escape () function . [CODESPLIT] def unescape ( str ) : out = '' prev_backslash = False for char in str : if not prev_backslash and char == '\\\\' : prev_backslash = True continue out += char prev_backslash = False return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Horizontally flip the given PIL Image . [CODESPLIT] def hflip ( img ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) return img . transpose ( Image . FLIP_LEFT_RIGHT )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip whitespace from string columns . [CODESPLIT] def strip_columns ( tab ) : for colname in tab . colnames : if tab [ colname ] . dtype . kind in [ 'S' , 'U' ] : tab [ colname ] = np . core . defchararray . strip ( tab [ colname ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def export_all ( self ) : query = \"\"\"\n\t\t\tSELECT quote, library, logid\n\t\t\tfrom quotes\n\t\t\tleft outer join quote_log on quotes.quoteid = quote_log.quoteid\n\t\t\t\"\"\" fields = 'text' , 'library' , 'log_id' return ( dict ( zip ( fields , res ) ) for res in self . db . execute ( query ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a sequence convert it to a comma separated string . If however the argument is a single object return its string representation . [CODESPLIT] def seq_to_str ( obj , sep = \",\" ) : if isinstance ( obj , string_classes ) : return obj elif isinstance ( obj , ( list , tuple ) ) : return sep . join ( [ str ( x ) for x in obj ] ) else : return str ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Plot precision - recall curve . [CODESPLIT] def _precision_recall ( y_true , y_score , ax = None ) : precision , recall , _ = precision_recall_curve ( y_true , y_score ) average_precision = average_precision_score ( y_true , y_score ) if ax is None : ax = plt . gca ( ) ax . plot ( recall , precision , label = ( 'Precision-Recall curve: AUC={0:0.2f}' . format ( average_precision ) ) ) _set_ax_settings ( ax ) return ax", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a list ( l ) will removing duplicates from the list preserving the original order of the list . Assumes that the list entrie are hashable . [CODESPLIT] def dedup_list ( l ) : dedup = set ( ) return [ x for x in l if not ( x in dedup or dedup . add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get longitudes from cartesian coordinates . [CODESPLIT] def get_lons_from_cartesian ( x__ , y__ ) : return rad2deg ( arccos ( x__ / sqrt ( x__ ** 2 + y__ ** 2 ) ) ) * sign ( y__ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove duplicates from a sequence preserving order [CODESPLIT] def remove_dups ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes illegal characters for XML . [CODESPLIT] def _RemoveIllegalXMLCharacters ( self , xml_string ) : if not isinstance ( xml_string , py2to3 . STRING_TYPES ) : return xml_string return self . _ILLEGAL_XML_RE . sub ( '\\ufffd' , xml_string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return time in milliseconds from start_time [CODESPLIT] def timespan ( start_time ) : timespan = datetime . datetime . now ( ) - start_time timespan_ms = timespan . total_seconds ( ) * 1000 return timespan_ms", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes dict keys which have have self as value . [CODESPLIT] def _remove_dict_keys_with_value ( dict_ , val ) : return { k : v for k , v in dict_ . items ( ) if v is not val }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Display all available logging information . [CODESPLIT] def pylog ( self , * args , * * kwargs ) : printerr ( self . name , args , kwargs , traceback . format_exc ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip accents to prepare for slugification . [CODESPLIT] def strip_accents ( s ) : nfkd = unicodedata . normalize ( 'NFKD' , unicode ( s ) ) return u'' . join ( ch for ch in nfkd if not unicodedata . combining ( ch ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print a formatted indented text . [CODESPLIT] def indented_show ( text , howmany = 1 ) : print ( StrTemplate . pad_indent ( text = text , howmany = howmany ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace all non - letter characters with underscores [CODESPLIT] def key_to_metric ( self , key ) : return '' . join ( l if l in string . letters else '_' for l in key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return a string representations of the ram [CODESPLIT] def get_ram ( self , format_ = \"nl\" ) : ram = [ self . ram . read ( i ) for i in range ( self . ram . size ) ] return self . _format_mem ( ram , format_ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove the querystring from the end of a URL . [CODESPLIT] def strip_querystring ( url ) : p = six . moves . urllib . parse . urlparse ( url ) return p . scheme + \"://\" + p . netloc + p . path", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Gets the string representation of the given type . [CODESPLIT] def getTypeStr ( _type ) : if isinstance ( _type , CustomType ) : return str ( _type ) if hasattr ( _type , '__name__' ) : return _type . __name__ return ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility function to remove duplicates from a list : param seq : The sequence ( list ) to deduplicate : return : A list with original duplicates removed [CODESPLIT] def dedupe_list ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print out system information ( version MAC addrs ) . [CODESPLIT] async def sysinfo ( dev : Device ) : click . echo ( await dev . get_system_info ( ) ) click . echo ( await dev . get_interface_information ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes a : py : class : . Series from the chart . [CODESPLIT] def remove_series ( self , series ) : if len ( self . all_series ( ) ) == 1 : raise ValueError ( \"Cannot remove last series from %s\" % str ( self ) ) self . _all_series . remove ( series ) series . _chart = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print something on screen when self . verbose == True [CODESPLIT] def _screen ( self , s , newline = False ) : if self . verbose : if newline : print ( s ) else : print ( s , end = ' ' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert to lowercase and strip spaces [CODESPLIT] def lowstrip ( term ) : term = re . sub ( '\\s+' , ' ' , term ) term = term . lower ( ) return term", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print something on screen when self . verbose == True [CODESPLIT] def _screen ( self , s , newline = False ) : if self . verbose : if newline : print ( s ) else : print ( s , end = ' ' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert bytes and non - string into Python 3 str [CODESPLIT] def to_str ( s ) : if isinstance ( s , bytes ) : s = s . decode ( 'utf-8' ) elif not isinstance ( s , str ) : s = str ( s ) return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function prints the given String immediately and flushes the output . [CODESPLIT] def printOut ( value , end = '\\n' ) : sys . stdout . write ( value ) sys . stdout . write ( end ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This removes newlines and multiple spaces from a string . [CODESPLIT] def normalize_value ( text ) : result = text . replace ( '\\n' , ' ' ) result = re . subn ( '[ ]{2,}' , ' ' , result ) [ 0 ] return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets the index of Nth occurance of a given character in a string [CODESPLIT] def IndexOfNth ( s , value , n ) : remaining = n for i in xrange ( 0 , len ( s ) ) : if s [ i ] == value : remaining -= 1 if remaining == 0 : return i return - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove a file from an AWS S3 bucket . [CODESPLIT] def remove_file_from_s3 ( awsclient , bucket , key ) : client_s3 = awsclient . get_client ( 's3' ) response = client_s3 . delete_object ( Bucket = bucket , Key = key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get trace_id from flask request headers . [CODESPLIT] def get_trace_id_from_flask ( ) : if flask is None or not flask . request : return None header = flask . request . headers . get ( _FLASK_TRACE_HEADER ) if header is None : return None trace_id = header . split ( \"/\" , 1 ) [ 0 ] return trace_id", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a list ( l ) will removing duplicates from the list preserving the original order of the list . Assumes that the list entrie are hashable . [CODESPLIT] def dedup_list ( l ) : dedup = set ( ) return [ x for x in l if not ( x in dedup or dedup . add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns this programs current memory usage in bytes [CODESPLIT] def current_memory_usage ( ) : import psutil proc = psutil . Process ( os . getpid ( ) ) #meminfo = proc.get_memory_info() meminfo = proc . memory_info ( ) rss = meminfo [ 0 ] # Resident Set Size / Mem Usage vms = meminfo [ 1 ] # Virtual Memory Size / VM Size  # NOQA return rss", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate indexes to change from col - major to row - major ordering [CODESPLIT] def _idx_col2rowm ( d ) : if 0 == len ( d ) : return 1 if 1 == len ( d ) : return np . arange ( d [ 0 ] ) # order='F' indicates column-major ordering idx = np . array ( np . arange ( np . prod ( d ) ) ) . reshape ( d , order = 'F' ) . T return idx . flatten ( order = 'F' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets RAM memory usage [CODESPLIT] def get_memory_usage ( ) : process = psutil . Process ( os . getpid ( ) ) mem = process . memory_info ( ) . rss return mem / ( 1024 * 1024 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print list of strings to the predefined stdout . [CODESPLIT] def print_out ( self , * lst ) : self . print2file ( self . stdout , True , True , * lst )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "replace nan in a by val and returns the replaced array and the nan position [CODESPLIT] def _replace_nan ( a , val ) : mask = isnull ( a ) return where_method ( val , mask , a ) , mask", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses data in table [CODESPLIT] def parse ( self ) : data = [ ] # add name of section for row in self . soup . find_all ( \"tr\" ) : # cycle through all rows parsed = self . _parse_row ( row ) if parsed : data . append ( parsed ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a dataframe and string - i - fy a column of values . Turn nan / None into and all other values into strings . [CODESPLIT] def stringify_col ( df , col_name ) : df = df . copy ( ) df [ col_name ] = df [ col_name ] . fillna ( \"\" ) df [ col_name ] = df [ col_name ] . astype ( str ) return df", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add 0x to string at start . [CODESPLIT] def add_0x ( string ) : if isinstance ( string , bytes ) : string = string . decode ( 'utf-8' ) return '0x' + str ( string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Warn deprecated . [CODESPLIT] def warn_deprecated ( message , stacklevel = 2 ) : # pragma: no cover warnings . warn ( message , category = DeprecationWarning , stacklevel = stacklevel )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "image resize function used by quite a few image problems . [CODESPLIT] def resize_by_area ( img , size ) : return tf . to_int64 ( tf . image . resize_images ( img , [ size , size ] , tf . image . ResizeMethod . AREA ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Subclasses may override this method . [CODESPLIT] def _get_points ( self ) : return tuple ( [ self . _getitem__points ( i ) for i in range ( self . _len__points ( ) ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "validate that we can store the multi - index ; reset and return the new object [CODESPLIT] def validate_multiindex ( self , obj ) : levels = [ l if l is not None else \"level_{0}\" . format ( i ) for i , l in enumerate ( obj . index . names ) ] try : return obj . reset_index ( ) , levels except ValueError : raise ValueError ( \"duplicate names/columns in the multi-index when \" \"storing as a table\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raw print to sys . __stdout__ otherwise identical interface to print () . [CODESPLIT] def raw_print ( * args , * * kw ) : print ( * args , sep = kw . get ( 'sep' , ' ' ) , end = kw . get ( 'end' , '\\n' ) , file = sys . __stdout__ ) sys . __stdout__ . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "validate that we can store the multi - index ; reset and return the new object [CODESPLIT] def validate_multiindex ( self , obj ) : levels = [ l if l is not None else \"level_{0}\" . format ( i ) for i , l in enumerate ( obj . index . names ) ] try : return obj . reset_index ( ) , levels except ValueError : raise ValueError ( \"duplicate names/columns in the multi-index when \" \"storing as a table\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Let user select a directory . [CODESPLIT] def popup ( self , title , callfn , initialdir = None ) : super ( DirectorySelection , self ) . popup ( title , callfn , initialdir )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts and image to matrix ( one pixel per line ) [CODESPLIT] def im2mat ( I ) : return I . reshape ( ( I . shape [ 0 ] * I . shape [ 1 ] , I . shape [ 2 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply 2to3 tool ( Python2 to Python3 conversion tool ) to Python sources . [CODESPLIT] def command_py2to3 ( args ) : from lib2to3 . main import main sys . exit ( main ( \"lib2to3.fixes\" , args = args . sources ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Represent string / bytes s as base64 omitting newlines [CODESPLIT] def toBase64 ( s ) : if isinstance ( s , str ) : s = s . encode ( \"utf-8\" ) return binascii . b2a_base64 ( s ) [ : - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a bs4 object of the page requested [CODESPLIT] def get_soup ( page = '' ) : content = requests . get ( '%s/%s' % ( BASE_URL , page ) ) . text return BeautifulSoup ( content )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes the write permissions for the given file for owner groups and others . [CODESPLIT] def make_file_read_only ( file_path ) : old_permissions = os . stat ( file_path ) . st_mode os . chmod ( file_path , old_permissions & ~ WRITE_PERMISSIONS )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if the method is a bound method ( attached to an class instance . [CODESPLIT] def __is_bound_method ( method ) : if not ( hasattr ( method , \"__func__\" ) and hasattr ( method , \"__self__\" ) ) : return False # Bound methods have a __self__ attribute pointing to the owner instance return six . get_method_self ( method ) is not None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a generator of tuples k c such that k is the name of the python attribute for the column and c is the name of the column in the sql table . [CODESPLIT] def get_column_keys_and_names ( table ) : ins = inspect ( table ) return ( ( k , c . name ) for k , c in ins . mapper . c . items ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "URL Validation function [CODESPLIT] def clean_url ( url ) : if not url . startswith ( ( 'http://' , 'https://' ) ) : url = f'http://{url}' if not URL_RE . match ( url ) : raise BadURLException ( f'{url} is not valid' ) return url", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get max for queryset . [CODESPLIT] def get_max ( qs , field ) : max_field = '%s__max' % field num = qs . aggregate ( Max ( field ) ) [ max_field ] return num if num else 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the short - time Fourier transform magnitude . [CODESPLIT] def stft_magnitude ( signal , fft_length , hop_length = None , window_length = None ) : frames = frame ( signal , window_length , hop_length ) # Apply frame window to each frame. We use a periodic Hann (cosine of period # window_length) instead of the symmetric Hann of np.hanning (period # window_length-1). window = periodic_hann ( window_length ) windowed_frames = frames * window return np . abs ( np . fft . rfft ( windowed_frames , int ( fft_length ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a set of unique n - grams from a string . [CODESPLIT] def make_unique_ngrams ( s , n ) : return set ( s [ i : i + n ] for i in range ( len ( s ) - n + 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format a duration in seconds . [CODESPLIT] def fmt_duration ( secs ) : return ' ' . join ( fmt . human_duration ( secs , 0 , precision = 2 , short = True ) . strip ( ) . split ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a new IPAString containing only the vowels in the current string . [CODESPLIT] def vowels ( self ) : return IPAString ( ipa_chars = [ c for c in self . ipa_chars if c . is_vowel ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The module where this route s view function was defined . [CODESPLIT] def module_name ( self ) : if not self . view_func : return None elif self . _controller_cls : rv = inspect . getmodule ( self . _controller_cls ) . __name__ return rv return inspect . getmodule ( self . view_func ) . __name__", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if a year is leap year . [CODESPLIT] def _is_leap_year ( year ) : isleap = ( ( np . mod ( year , 4 ) == 0 ) & ( ( np . mod ( year , 100 ) != 0 ) | ( np . mod ( year , 400 ) == 0 ) ) ) return isleap", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the integer index of * series * in this sequence . [CODESPLIT] def series_index ( self , series ) : for idx , s in enumerate ( self ) : if series is s : return idx raise ValueError ( 'series not in chart data object' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "copy the dict filter_keywords [CODESPLIT] def _remove_keywords ( d ) : return { k : v for k , v in iteritems ( d ) if k not in RESERVED }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Performs Right Outer Join : return right_outer : dict [CODESPLIT] def right_outer ( self ) : self . get_collections_data ( ) right_outer_join = self . merge_join_docs ( set ( self . collections_data [ 'right' ] . keys ( ) ) ) return right_outer_join", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A function that works for both Python 2 . x and Python 3 . x . It asks the user for input and returns it as a string . [CODESPLIT] def input_int_default ( question = \"\" , default = 0 ) : answer = input_string ( question ) if answer == \"\" or answer == \"yes\" : return default else : return int ( answer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "An async result aggregator that combines all the results This gets executed in unsync . loop and unsync . thread [CODESPLIT] async def result_processor ( tasks ) : output = { } for task in tasks : num , res = await task output [ num ] = res return output", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given something that closely resembles a dictionary we attempt to coerce it into a propery dictionary . [CODESPLIT] def to_dict ( dictish ) : if hasattr ( dictish , 'iterkeys' ) : m = dictish . iterkeys elif hasattr ( dictish , 'keys' ) : m = dictish . keys else : raise ValueError ( dictish ) return dict ( ( k , dictish [ k ] ) for k in m ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Gets the string representation of the given type . [CODESPLIT] def getTypeStr ( _type ) : if isinstance ( _type , CustomType ) : return str ( _type ) if hasattr ( _type , '__name__' ) : return _type . __name__ return ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Allow \\ n . join ( ... ) statements to work in Py2 and Py3 . : param sep : : param joinable : : return : [CODESPLIT] def _py2_and_3_joiner ( sep , joinable ) : if ISPY3 : sep = bytes ( sep , DEFAULT_ENCODING ) joined = sep . join ( joinable ) return joined . decode ( DEFAULT_ENCODING ) if ISPY3 else joined", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a shallow copy of a directional graph and reverse the edges . This is a workaround to solve the issue that one cannot easily make a shallow reversed copy of a graph in NetworkX 2 since networkx . reverse ( copy = False ) now returns a GraphView and GraphViews are always read - only . [CODESPLIT] def shallow_reverse ( g ) : new_g = networkx . DiGraph ( ) new_g . add_nodes_from ( g . nodes ( ) ) for src , dst , data in g . edges ( data = True ) : new_g . add_edge ( dst , src , * * data ) return new_g", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the n - grams that match between two sequences [CODESPLIT] def __matches ( s1 , s2 , ngrams_fn , n = 3 ) : ngrams1 , ngrams2 = set ( ngrams_fn ( s1 , n = n ) ) , set ( ngrams_fn ( s2 , n = n ) ) return ngrams1 . intersection ( ngrams2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "swap and then flatten axes 0 and 1 [CODESPLIT] def sf01 ( arr ) : s = arr . shape return arr . swapaxes ( 0 , 1 ) . reshape ( s [ 0 ] * s [ 1 ] , * s [ 2 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse ISO8601 timestamps given by github API . [CODESPLIT] def parse_timestamp ( timestamp ) : dt = dateutil . parser . parse ( timestamp ) return dt . astimezone ( dateutil . tz . tzutc ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rotate and flip a quadrant appropriately [CODESPLIT] def _rotate ( n , x , y , rx , ry ) : if ry == 0 : if rx == 1 : x = n - 1 - x y = n - 1 - y return y , x return x , y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Redirect standard out to file . [CODESPLIT] def redirect_output ( fileobj ) : old = sys . stdout sys . stdout = fileobj try : yield fileobj finally : sys . stdout = old", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a float returns a rounded int . Should give the same result on both Py2 / 3 [CODESPLIT] def intround ( value ) : return int ( decimal . Decimal . from_float ( value ) . to_integral_value ( decimal . ROUND_HALF_EVEN ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns system clipboard contents . [CODESPLIT] def paste ( xsel = False ) : selection = \"primary\" if xsel else \"clipboard\" try : return subprocess . Popen ( [ \"xclip\" , \"-selection\" , selection , \"-o\" ] , stdout = subprocess . PIPE ) . communicate ( ) [ 0 ] . decode ( \"utf-8\" ) except OSError as why : raise XclipNotFound", "target": 1, "target_options": ["no_match", "match"]}
{"input": "arr_out = round_array ( array_in ) [CODESPLIT] def round_array ( array_in ) : if isinstance ( array_in , ndarray ) : return np . round ( array_in ) . astype ( int ) else : return int ( np . round ( array_in ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize the string according to normalization list [CODESPLIT] def normalize ( self , string ) : return '' . join ( [ self . _normalize . get ( x , x ) for x in nfd ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert file extension to lowercase . [CODESPLIT] def lower_ext ( abspath ) : fname , ext = os . path . splitext ( abspath ) return fname + ext . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given two data points [ X Y ] linearly interpolate those at x . [CODESPLIT] def _linear_interpolation ( x , X , Y ) : return ( Y [ 1 ] * ( x - X [ 0 ] ) + Y [ 0 ] * ( X [ 1 ] - x ) ) / ( X [ 1 ] - X [ 0 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shorcut for self . run . [CODESPLIT] def __call__ ( self , func , * args , * * kwargs ) : return self . run ( func , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "please override [CODESPLIT] def storeByteArray ( self , context , page , len , data , returnError ) : returnError . contents . value = self . IllegalStateError raise NotImplementedError ( \"You must override this method.\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the tests . [CODESPLIT] def test ( ctx , all = False , verbose = False ) : cmd = 'tox' if all else 'py.test' if verbose : cmd += ' -v' return ctx . run ( cmd , pty = True ) . return_code", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return the underlying numpy array [CODESPLIT] def array ( self ) : return np . arange ( self . start , self . stop , self . step )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run application tests [CODESPLIT] def test ( nose_argsuments ) : from nose import run params = [ '__main__' , '-c' , 'nose.ini' ] params . extend ( nose_argsuments ) run ( argv = params )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Value of property . [CODESPLIT] def value ( self ) : if self . _prop . fget is None : raise AttributeError ( 'Unable to read attribute' ) return self . _prop . fget ( self . _obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "write the html file contents to disk [CODESPLIT] def _save_file ( self , filename , contents ) : with open ( filename , 'w' ) as f : f . write ( contents )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resets the scale on this image . Correctly aligns time scale undoes manual scaling [CODESPLIT] def resetScale ( self ) : self . img . scale ( 1. / self . imgScale [ 0 ] , 1. / self . imgScale [ 1 ] ) self . imgScale = ( 1. , 1. )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rewrite a file adding a line to its beginning . [CODESPLIT] def prepend_line ( filepath , line ) : with open ( filepath ) as f : lines = f . readlines ( ) lines . insert ( 0 , line ) with open ( filepath , 'w' ) as f : f . writelines ( lines )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Asks Tcpdump to parse the filter then build the matching BPF bytecode using get_bpf_pointer . [CODESPLIT] def compile_filter ( bpf_filter , iface = None ) : if not TCPDUMP : raise Scapy_Exception ( \"tcpdump is not available. Cannot use filter !\" ) try : process = subprocess . Popen ( [ conf . prog . tcpdump , \"-p\" , \"-i\" , ( conf . iface if iface is None else iface ) , \"-ddd\" , \"-s\" , str ( MTU ) , bpf_filter ] , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) except OSError as ex : raise Scapy_Exception ( \"Failed to attach filter: %s\" % ex ) lines , err = process . communicate ( ) ret = process . returncode if ret : raise Scapy_Exception ( \"Failed to attach filter: tcpdump returned: %s\" % err ) lines = lines . strip ( ) . split ( b\"\\n\" ) return get_bpf_pointer ( lines )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ajoute la target au plot [CODESPLIT] def plot_target ( target , ax ) : ax . scatter ( target [ 0 ] , target [ 1 ] , target [ 2 ] , c = \"red\" , s = 80 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "append item and print it to stdout [CODESPLIT] def append ( self , item ) : print ( item ) super ( MyList , self ) . append ( item )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "function to fetch links equal to limit [CODESPLIT] def get_duckduckgo_links ( limit , params , headers ) : resp = s . get ( 'https://duckduckgo.com/html' , params = params , headers = headers ) links = scrape_links ( resp . content , engine = 'd' ) return links [ : limit ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds noise to Y [CODESPLIT] def add_noise ( Y , sigma ) : return Y + np . random . normal ( 0 , sigma , Y . shape )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update only one property in the dict [CODESPLIT] def set_property ( self , key , value ) : self . properties [ key ] = value self . sync_properties ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine whether two strings are equivalent . [CODESPLIT] def eqstr ( a , b ) : return bool ( libspice . eqstr_c ( stypes . stringToCharP ( a ) , stypes . stringToCharP ( b ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "u Returns a list of children and available helper methods . [CODESPLIT] def __dir__ ( self ) : return sorted ( self . keys ( ) | { m for m in dir ( self . __class__ ) if m . startswith ( 'to_' ) } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Just the last entry . [CODESPLIT] def get_last ( self , table = None ) : if table is None : table = self . main_table query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table return self . own_cursor . execute ( query ) . fetchone ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Min reduction op . [CODESPLIT] def Min ( a , axis , keep_dims ) : return np . amin ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a column of the given matrix . [CODESPLIT] def get_column ( self , X , column ) : if isinstance ( X , pd . DataFrame ) : return X [ column ] . values return X [ : , column ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Build argument parsers . [CODESPLIT] def build_parser ( ) : parser = argparse . ArgumentParser ( \"Release packages to pypi\" ) parser . add_argument ( '--check' , '-c' , action = \"store_true\" , help = \"Do a dry run without uploading\" ) parser . add_argument ( 'component' , help = \"The component to release as component-version\" ) return parser", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Send email message via Flask - Sendmail . [CODESPLIT] def send_email_message ( self , recipient , subject , html_message , text_message , sender_email , sender_name ) : if not current_app . testing : # pragma: no cover # Prepare email message from flask_sendmail import Message message = Message ( subject , recipients = [ recipient ] , html = html_message , body = text_message ) # Send email message self . mail . send ( message )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Represent data as a masked array . [CODESPLIT] def ma ( self ) : a = self . array return numpy . ma . MaskedArray ( a , mask = numpy . logical_not ( numpy . isfinite ( a ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sends plain text using _send_text () . [CODESPLIT] async def _send_plain_text ( self , request : Request , stack : Stack ) : await self . _send_text ( request , stack , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Direct access to byte data . [CODESPLIT] def getbyteslice ( self , start , end ) : c = self . _rawarray [ start : end ] return c", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove the querystring from the end of a URL . [CODESPLIT] def strip_querystring ( url ) : p = six . moves . urllib . parse . urlparse ( url ) return p . scheme + \"://\" + p . netloc + p . path", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Splits a list into chunks [CODESPLIT] def chunks ( arr , size ) : for i in _range ( 0 , len ( arr ) , size ) : yield arr [ i : i + size ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run a server on the specified socket . [CODESPLIT] def yield_connections ( sock ) : while True : log . debug ( 'waiting for connection on %s' , sock . getsockname ( ) ) try : conn , _ = sock . accept ( ) except KeyboardInterrupt : return conn . settimeout ( None ) log . debug ( 'accepted connection on %s' , sock . getsockname ( ) ) yield conn", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the parameter to the default if it doesn t exist [CODESPLIT] def set_if_empty ( self , param , default ) : if not self . has ( param ) : self . set ( param , default )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Populate axis limits GUI with current plot values . [CODESPLIT] def set_xlimits_widgets ( self , set_min = True , set_max = True ) : xmin , xmax = self . tab_plot . ax . get_xlim ( ) if set_min : self . w . x_lo . set_text ( '{0}' . format ( xmin ) ) if set_max : self . w . x_hi . set_text ( '{0}' . format ( xmax ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Array of bytes [CODESPLIT] def barray ( iterlines ) : lst = [ line . encode ( 'utf-8' ) for line in iterlines ] arr = numpy . array ( lst ) return arr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a matplotlib colormap . [CODESPLIT] def add_matplotlib_cmap ( cm , name = None ) : global cmaps cmap = matplotlib_to_ginga_cmap ( cm , name = name ) cmaps [ cmap . name ] = cmap", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns true if all of the elements in the list are equal . [CODESPLIT] def _check_elements_equal ( lst ) : assert isinstance ( lst , list ) , \"Input value must be a list.\" return not lst or lst . count ( lst [ 0 ] ) == len ( lst )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the pixel at ( x y ) to the integers in sequence color . [CODESPLIT] def setPixel ( self , x , y , color ) : return _fitz . Pixmap_setPixel ( self , x , y , color )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Assert that a value must be a given type . [CODESPLIT] def _assert_is_type ( name , value , value_type ) : if not isinstance ( value , value_type ) : if type ( value_type ) is tuple : types = ', ' . join ( t . __name__ for t in value_type ) raise ValueError ( '{0} must be one of ({1})' . format ( name , types ) ) else : raise ValueError ( '{0} must be {1}' . format ( name , value_type . __name__ ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a target dct and a dict of { key : default value } pairs calls setdefault for all of those pairs . [CODESPLIT] def setdefaults ( dct , defaults ) : for key in defaults : dct . setdefault ( key , defaults [ key ] ) return dct", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coroutine called by MapAsync . It s wrapping the call of run_in_executor to run the synchronous function as thread [CODESPLIT] async def _thread_coro ( self , * args ) : return await self . _loop . run_in_executor ( self . _executor , self . _function , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "gets a horiztonal line [CODESPLIT] def get_hline ( ) : return Window ( width = LayoutDimension . exact ( 1 ) , height = LayoutDimension . exact ( 1 ) , content = FillControl ( '-' , token = Token . Line ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "StringIO constructor shim for the async wrapper . [CODESPLIT] def StringIO ( * args , * * kwargs ) : raw = sync_io . StringIO ( * args , * * kwargs ) return AsyncStringIOWrapper ( raw )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the attribute name identifier [CODESPLIT] def get_attribute_name_id ( attr ) : return attr . value . id if isinstance ( attr . value , ast . Name ) else None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Intersect this flag with other in - place . [CODESPLIT] def __iand__ ( self , other ) : self . known &= other . known self . active &= other . active return self", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns given method name . [CODESPLIT] def get_method_name ( method ) : name = get_object_name ( method ) if name . startswith ( \"__\" ) and not name . endswith ( \"__\" ) : name = \"_{0}{1}\" . format ( get_object_name ( method . im_class ) , name ) return name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Just connects the docstring pre_processor and should_skip functions to be applied on all docstrings . [CODESPLIT] def setup ( app ) : app . connect ( 'autodoc-process-docstring' , lambda * args : pre_processor ( * args , namer = audiolazy_namer ) ) app . connect ( 'autodoc-skip-member' , should_skip )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert CamelCase to snake_case . [CODESPLIT] def convert_camel_case_to_snake_case ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the size of x along axis dimensions only . [CODESPLIT] def array_size ( x , axis ) : axis_shape = x . shape if axis is None else tuple ( x . shape [ a ] for a in axis ) return max ( numpy . prod ( axis_shape ) , 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the mean value across a list of dictionaries [CODESPLIT] def _mean_dict ( dict_list ) : return { k : np . array ( [ d [ k ] for d in dict_list ] ) . mean ( ) for k in dict_list [ 0 ] . keys ( ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the slice after at sub in string astr [CODESPLIT] def fsliceafter ( astr , sub ) : findex = astr . find ( sub ) return astr [ findex + len ( sub ) : ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "average of the values must have more than 0 entries . [CODESPLIT] def average ( arr ) : if len ( arr ) == 0 : sys . stderr . write ( \"ERROR: no content in array to take average\\n\" ) sys . exit ( ) if len ( arr ) == 1 : return arr [ 0 ] return float ( sum ( arr ) ) / float ( len ( arr ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns mean of non - None elements of the list [CODESPLIT] def _aggr_mean ( inList ) : aggrSum = 0 nonNone = 0 for elem in inList : if elem != SENTINEL_VALUE_FOR_MISSING_DATA : aggrSum += elem nonNone += 1 if nonNone != 0 : return aggrSum / nonNone else : return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prints discovered resources and their associated methods . Nice when noodling in the terminal to wrap your head around Magento s insanity . [CODESPLIT] def help ( self ) : print ( 'Resources:' ) print ( '' ) for name in sorted ( self . _resources . keys ( ) ) : methods = sorted ( self . _resources [ name ] . _methods . keys ( ) ) print ( '{}: {}' . format ( bold ( name ) , ', ' . join ( methods ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialize Log Analytics data client for use with CLI . [CODESPLIT] def loganalytics_data_plane_client ( cli_ctx , _ ) : from . vendored_sdks . loganalytics import LogAnalyticsDataClient from azure . cli . core . _profile import Profile profile = Profile ( cli_ctx = cli_ctx ) cred , _ , _ = profile . get_login_credentials ( resource = \"https://api.loganalytics.io\" ) return LogAnalyticsDataClient ( cred )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show the received object as precise as possible . [CODESPLIT] def _repr ( obj ) : vals = \", \" . join ( \"{}={!r}\" . format ( name , getattr ( obj , name ) ) for name in obj . _attribs ) if vals : t = \"{}(name={}, {})\" . format ( obj . __class__ . __name__ , obj . name , vals ) else : t = \"{}(name={})\" . format ( obj . __class__ . __name__ , obj . name ) return t", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a background thread for httpd and serve forever [CODESPLIT] def start ( self ) : self . _process = threading . Thread ( target = self . _background_runner ) self . _process . start ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Outputs a string to the console ( stdout ) . [CODESPLIT] def out ( self , output , newline = True ) : click . echo ( output , nl = newline )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract a numpy array from a base64 buffer [CODESPLIT] def decode_arr ( data ) : data = data . encode ( 'utf-8' ) return frombuffer ( base64 . b64decode ( data ) , float64 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty print a CSV file . [CODESPLIT] def csvpretty ( csvfile : csvfile = sys . stdin ) : shellish . tabulate ( csv . reader ( csvfile ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Encodes a whole batch of input arrays without learning . [CODESPLIT] def encode_batch ( self , inputBatch ) : X = inputBatch encode = self . encode Y = np . array ( [ encode ( x ) for x in X ] ) return Y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse a BeautifulSoup element as the given type . [CODESPLIT] def parse ( el , typ ) : if not el : return typ ( ) txt = text ( el ) if not txt : return typ ( ) return typ ( txt )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return info about an object s members as JSON [CODESPLIT] def as_tree ( context ) : tree = _build_tree ( context , 2 , 1 ) if type ( tree ) == dict : tree = [ tree ] return Response ( content_type = 'application/json' , body = json . dumps ( tree ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Singleton definition . [CODESPLIT] def singleton ( class_ ) : instances = { } def get_instance ( * args , * * kwargs ) : if class_ not in instances : instances [ class_ ] = class_ ( * args , * * kwargs ) return instances [ class_ ] return get_instance", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield code with useless pass lines removed . [CODESPLIT] def filter_useless_pass ( source ) : try : marked_lines = frozenset ( useless_pass_line_numbers ( source ) ) except ( SyntaxError , tokenize . TokenError ) : marked_lines = frozenset ( ) sio = io . StringIO ( source ) for line_number , line in enumerate ( sio . readlines ( ) , start = 1 ) : if line_number not in marked_lines : yield line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Manually refresh the swagger document . This can help resolve errors communicate with the API . [CODESPLIT] def refresh_swagger ( self ) : try : os . remove ( self . _get_swagger_filename ( self . swagger_url ) ) except EnvironmentError as e : logger . warn ( os . strerror ( e . errno ) ) else : self . __init__ ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "iterator version of get_list_column [CODESPLIT] def iget_list_column_slice ( list_ , start = None , stop = None , stride = None ) : if isinstance ( start , slice ) : slice_ = start else : slice_ = slice ( start , stop , stride ) return ( row [ slice_ ] for row in list_ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the indices of the lexicographical sorting order of the supplied arrays . [CODESPLIT] def arglexsort ( arrays ) : dtypes = ',' . join ( array . dtype . str for array in arrays ) recarray = np . empty ( len ( arrays [ 0 ] ) , dtype = dtypes ) for i , array in enumerate ( arrays ) : recarray [ 'f%s' % i ] = array return recarray . argsort ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Register callbacks for button press events and selection changed [CODESPLIT] def register_view ( self , view ) : super ( ListViewController , self ) . register_view ( view ) self . tree_view . connect ( 'button_press_event' , self . mouse_click )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print a formatted indented text . [CODESPLIT] def indented_show ( text , howmany = 1 ) : print ( StrTemplate . pad_indent ( text = text , howmany = howmany ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Abbreviates each part of string that is delimited by a - . [CODESPLIT] def abbreviate_dashed ( s ) : r = [ ] for part in s . split ( '-' ) : r . append ( abbreviate ( part ) ) return '-' . join ( r )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a boolean index with True if the value is masked . [CODESPLIT] def maskIndex ( self ) : if isinstance ( self . mask , bool ) : return np . full ( self . data . shape , self . mask , dtype = np . bool ) else : return self . mask", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Splits a string into parts at multiple characters [CODESPLIT] def _split ( string , splitters ) : part = '' for character in string : if character in splitters : yield part part = '' else : part += character yield part", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a key from S3 [CODESPLIT] def read_key ( self , key , bucket_name = None ) : obj = self . get_key ( key , bucket_name ) return obj . get ( ) [ 'Body' ] . read ( ) . decode ( 'utf-8' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a sentence into list of words . [CODESPLIT] def split_into_words ( s ) : s = re . sub ( r\"\\W+\" , \" \" , s ) s = re . sub ( r\"[_0-9]+\" , \" \" , s ) return s . split ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the contents of an object stored in S3 as bytes [CODESPLIT] def get_as_bytes ( self , s3_path ) : ( bucket , key ) = self . _path_to_bucket_and_key ( s3_path ) obj = self . s3 . Object ( bucket , key ) contents = obj . get ( ) [ 'Body' ] . read ( ) return contents", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check for Python 3 . 5 matrix multiplication . [CODESPLIT] def matrix_at_check ( self , original , loc , tokens ) : return self . check_py ( \"35\" , \"matrix multiplication\" , original , loc , tokens )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Render a template string using sandboxed environment . [CODESPLIT] def render_template ( self , source , * * kwargs_context ) : return self . jinja_env . from_string ( source ) . render ( kwargs_context )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set database sequence objects to match the source db [CODESPLIT] def emit_db_sequence_updates ( engine ) : if engine and engine . name == 'postgresql' : # not implemented for other RDBMS; necessity unknown conn = engine . connect ( ) qry = \"\"\"SELECT 'SELECT last_value FROM ' || n.nspname ||\n                         '.' || c.relname || ';' AS qry,\n                        n.nspname || '.' || c.relname AS qual_name\n                 FROM   pg_namespace n\n                 JOIN   pg_class c ON (n.oid = c.relnamespace)\n                 WHERE  c.relkind = 'S'\"\"\" for ( qry , qual_name ) in list ( conn . execute ( qry ) ) : ( lastval , ) = conn . execute ( qry ) . first ( ) nextval = int ( lastval ) + 1 yield \"ALTER SEQUENCE %s RESTART WITH %s;\" % ( qual_name , nextval )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the method double for the provided method name creating one if necessary . [CODESPLIT] def method_double_for ( self , method_name ) : if method_name not in self . _method_doubles : self . _method_doubles [ method_name ] = MethodDouble ( method_name , self . _target ) return self . _method_doubles [ method_name ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Provides the color corresponding to value x in the form of a tuple ( R G B A ) with int values between 0 and 255 . [CODESPLIT] def rgba_bytes_tuple ( self , x ) : return tuple ( int ( u * 255.9999 ) for u in self . rgba_floats_tuple ( x ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Bulk insert or update . [CODESPLIT] def bulk_query ( self , query , * multiparams ) : with self . get_connection ( ) as conn : conn . bulk_query ( query , * multiparams )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Drops and re - creates the SQL schema [CODESPLIT] def init_db ( ) : db . drop_all ( ) db . configure_mappers ( ) db . create_all ( ) db . session . commit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute standard deviation with ddof degrees of freedom [CODESPLIT] def _std ( self , x ) : return np . nanstd ( x . values , ddof = self . _ddof )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts an ARRAY string stored in the database back into a Numpy array . [CODESPLIT] def convert_array ( array ) : out = io . BytesIO ( array ) out . seek ( 0 ) return np . load ( out )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If given environment key is defined print it out . [CODESPLIT] def print_env_info ( key , out = sys . stderr ) : value = os . getenv ( key ) if value is not None : print ( key , \"=\" , repr ( value ) , file = out )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets the maxsize attribute of the named cache [CODESPLIT] def set_cache_max ( self , cache_name , maxsize , * * kwargs ) : cache = self . _get_cache ( cache_name ) cache . set_maxsize ( maxsize , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Stop dragging . [CODESPLIT] def _on_release ( self , event ) : if self . _drag_cols or self . _drag_rows : self . _visual_drag . place_forget ( ) self . _dragged_col = None self . _dragged_row = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update a cached value . [CODESPLIT] def update_cache ( self , data ) : UTILS . update ( self . _cache , data ) self . _save_cache ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Method to handle what to do when the stop button is pressed [CODESPLIT] def stop_button_click_handler ( self ) : self . stop_button . setDisabled ( True ) # Interrupt computations or stop debugging\n if not self . shellwidget . _reading : self . interrupt_kernel ( ) else : self . shellwidget . write_to_stdin ( 'exit' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the angle between vectors a and b in degrees . [CODESPLIT] def angle ( x , y ) : return arccos ( dot ( x , y ) / ( norm ( x ) * norm ( y ) ) ) * 180. / pi", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a given file is available in the cache or not [CODESPLIT] def is_cached ( file_name ) : gml_file_path = join ( join ( expanduser ( '~' ) , OCTOGRID_DIRECTORY ) , file_name ) return isfile ( gml_file_path )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterative mean . [CODESPLIT] def average ( iterator ) : count = 0 total = 0 for num in iterator : count += 1 total += num return float ( total ) / count", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add object to db session . Only for session - centric object - database mappers . [CODESPLIT] def add_object ( self , object ) : if object . id is None : object . get_id ( ) self . db . engine . save ( object )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the SSE to the cluster center [CODESPLIT] def _cal_dist2center ( X , center ) : dmemb2cen = scipy . spatial . distance . cdist ( X , center . reshape ( 1 , X . shape [ 1 ] ) , metric = 'seuclidean' ) return ( np . sum ( dmemb2cen ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Save data as a HDF5 file . [CODESPLIT] def save_hdf5 ( X , y , path ) : with h5py . File ( path , 'w' ) as f : is_sparse = 1 if sparse . issparse ( X ) else 0 f [ 'issparse' ] = is_sparse f [ 'target' ] = y if is_sparse : if not sparse . isspmatrix_csr ( X ) : X = X . tocsr ( ) f [ 'shape' ] = np . array ( X . shape ) f [ 'data' ] = X . data f [ 'indices' ] = X . indices f [ 'indptr' ] = X . indptr else : f [ 'data' ] = X", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the eigvals of mat and then find the center eigval difference . [CODESPLIT] def center_eigenvalue_diff ( mat ) : N = len ( mat ) evals = np . sort ( la . eigvals ( mat ) ) diff = np . abs ( evals [ N / 2 ] - evals [ N / 2 - 1 ] ) return diff", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a gzipped version of a previously opened file s buffer . [CODESPLIT] def get_gzipped_contents ( input_file ) : zbuf = StringIO ( ) zfile = GzipFile ( mode = \"wb\" , compresslevel = 6 , fileobj = zbuf ) zfile . write ( input_file . read ( ) ) zfile . close ( ) return ContentFile ( zbuf . getvalue ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate angle between two vectors [CODESPLIT] def vec_angle ( a , b ) : cosang = np . dot ( a , b ) sinang = fast_norm ( np . cross ( a , b ) ) return np . arctan2 ( sinang , cosang )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert CamelCase to lower_and_underscore . [CODESPLIT] def decamelise ( text ) : s = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call color function base on name [CODESPLIT] def color_func ( func_name ) : if str ( func_name ) . isdigit ( ) : return term_color ( int ( func_name ) ) return globals ( ) [ func_name ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Concatenate all the text parts again . [CODESPLIT] def token_list_to_text ( tokenlist ) : ZeroWidthEscape = Token . ZeroWidthEscape return '' . join ( item [ 1 ] for item in tokenlist if item [ 0 ] != ZeroWidthEscape )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Has a 50 / 50 chance of calling a function [CODESPLIT] def sometimesish ( fn ) : def wrapped ( * args , * * kwargs ) : if random . randint ( 1 , 2 ) == 1 : return fn ( * args , * * kwargs ) return wrapped", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return the usage string for available options [CODESPLIT] def help ( self , level = 0 ) : self . cmdline_parser . formatter . output_level = level with _patch_optparse ( ) : return self . cmdline_parser . format_help ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets token - based auth headers . [CODESPLIT] def get_request ( self , request ) : request . transport_user = self . username request . transport_password = self . api_key return request", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns min ( val1 val2 ) returning None only if both values are None [CODESPLIT] def min_or_none ( val1 , val2 ) : return min ( val1 , val2 , key = lambda x : sys . maxint if x is None else x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return evidence codes in order shown in code2name . [CODESPLIT] def get_order ( self , codes ) : return sorted ( codes , key = lambda e : [ self . ev2idx . get ( e ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the * cmd * and exit with the proper exit code . [CODESPLIT] def call_and_exit ( self , cmd , shell = True ) : sys . exit ( subprocess . call ( cmd , shell = shell ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "average of the values must have more than 0 entries . [CODESPLIT] def average ( arr ) : if len ( arr ) == 0 : sys . stderr . write ( \"ERROR: no content in array to take average\\n\" ) sys . exit ( ) if len ( arr ) == 1 : return arr [ 0 ] return float ( sum ( arr ) ) / float ( len ( arr ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Scroll both categories Canvas and scrolling container [CODESPLIT] def _set_scroll_v ( self , * args ) : self . _canvas_categories . yview ( * args ) self . _canvas_scroll . yview ( * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Provide the root module of a TF - 2 . 0 API for use within TensorBoard . [CODESPLIT] def tf2 ( ) : # Import the `tf` compat API from this file and check if it's already TF 2.0. if tf . __version__ . startswith ( '2.' ) : return tf elif hasattr ( tf , 'compat' ) and hasattr ( tf . compat , 'v2' ) : # As a fallback, try `tensorflow.compat.v2` if it's defined. return tf . compat . v2 raise ImportError ( 'cannot import tensorflow 2.0 API' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs a shell command returns console output . [CODESPLIT] def _run_cmd_get_output ( cmd ) : process = subprocess . Popen ( cmd . split ( ) , stdout = subprocess . PIPE ) out , err = process . communicate ( ) return out or err", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Efficient cartesian product of a list of 1D arrays returning the expanded array views for each dimensions . By default arrays are flattened which may be controlled with the flat flag . The array views can be turned into regular arrays with the copy flag . [CODESPLIT] def cartesian_product ( arrays , flat = True , copy = False ) : arrays = np . broadcast_arrays ( * np . ix_ ( * arrays ) ) if flat : return tuple ( arr . flatten ( ) if copy else arr . flat for arr in arrays ) return tuple ( arr . copy ( ) if copy else arr for arr in arrays )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is this attribute present? [CODESPLIT] def has_attribute ( module_name , attribute_name ) : init_file = '%s/__init__.py' % module_name return any ( [ attribute_name in init_line for init_line in open ( init_file ) . readlines ( ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a string return true if it matches the supplied list of patterns . [CODESPLIT] def match ( string , patterns ) : if patterns is None : return True else : return any ( re . match ( pattern , string ) for pattern in patterns )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a text into separate words . [CODESPLIT] def tokenize_list ( self , text ) : return [ self . get_record_token ( record ) for record in self . analyze ( text ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deserializes string to date . [CODESPLIT] def deserialize_date ( string ) : try : from dateutil . parser import parse return parse ( string ) . date ( ) except ImportError : return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "compose a list of functions [CODESPLIT] def compose ( * funcs ) : return lambda x : reduce ( lambda v , f : f ( v ) , reversed ( funcs ) , x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flatten all dimensions of a except the last . [CODESPLIT] def flatten_all_but_last ( a ) : ret = tf . reshape ( a , [ - 1 , tf . shape ( a ) [ - 1 ] ] ) if not tf . executing_eagerly ( ) : ret . set_shape ( [ None ] + a . get_shape ( ) . as_list ( ) [ - 1 : ] ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Similar to #itertools . chain . from_iterable () . [CODESPLIT] def concat ( cls , iterables ) : def generator ( ) : for it in iterables : for element in it : yield element return cls ( generator ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the maximum value of the domain . [CODESPLIT] def max ( self ) : return int ( self . _max ) if not np . isinf ( self . _max ) else self . _max", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cell background color event handler [CODESPLIT] def OnCellBackgroundColor ( self , event ) : with undo . group ( _ ( \"Background color\" ) ) : self . grid . actions . set_attr ( \"bgcolor\" , event . color ) self . grid . ForceRefresh ( ) self . grid . update_attribute_toolbar ( ) event . Skip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the length of the longest consecutive run of True values . [CODESPLIT] def longest_run ( da , dim = 'time' ) : d = rle ( da , dim = dim ) rl_long = d . max ( dim = dim ) return rl_long", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Builds sphinx docs from a given directory . [CODESPLIT] def build_docs ( directory ) : os . chdir ( directory ) process = subprocess . Popen ( [ \"make\" , \"html\" ] , cwd = directory ) process . communicate ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute a normal python statement in user namespace . [CODESPLIT] def ex ( self , cmd ) : with self . builtin_trap : exec cmd in self . user_global_ns , self . user_ns", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Appends a PDF to a pyPDF writer . Legacy interface . [CODESPLIT] def append_pdf ( input_pdf : bytes , output_writer : PdfFileWriter ) : append_memory_pdf_to_writer ( input_pdf = input_pdf , writer = output_writer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the modified time of a file [CODESPLIT] def set_time ( filename , mod_time ) : log . debug ( 'Setting modified time to %s' , mod_time ) mtime = calendar . timegm ( mod_time . utctimetuple ( ) ) # utctimetuple discards microseconds, so restore it (for consistency)\n mtime += mod_time . microsecond / 1000000 atime = os . stat ( filename ) . st_atime os . utime ( filename , ( atime , mtime ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Changes a column name in a DataFrame Parameters : df - DataFrame DataFrame to operate on col_name - string Name of column to change new_col_name - string New name of column [CODESPLIT] def col_rename ( df , col_name , new_col_name ) : col_list = list ( df . columns ) for index , value in enumerate ( col_list ) : if value == col_name : col_list [ index ] = new_col_name break df . columns = col_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper to uncheck a checkbox [CODESPLIT] def checkbox_uncheck ( self , force_check = False ) : if self . get_attribute ( 'checked' ) : self . click ( force_click = force_check )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "http : // stackoverflow . com / a / 31312102 / 190597 ( SoulNibbler ) [CODESPLIT] def adapt_array ( arr ) : out = io . BytesIO ( ) np . save ( out , arr ) out . seek ( 0 ) return sqlite3 . Binary ( out . read ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Internal helper for oauth code [CODESPLIT] def __set_token_expired ( self , value ) : self . _token_expired = datetime . datetime . now ( ) + datetime . timedelta ( seconds = value ) return", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Additional check for the dimension model to ensure that attributes given as the key and label attribute on the dimension exist . [CODESPLIT] def check_attribute_exists ( instance ) : attributes = instance . get ( 'attributes' , { } ) . keys ( ) if instance . get ( 'key_attribute' ) not in attributes : return False label_attr = instance . get ( 'label_attribute' ) if label_attr and label_attr not in attributes : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Redirect standard out to file . [CODESPLIT] def redirect_output ( fileobj ) : old = sys . stdout sys . stdout = fileobj try : yield fileobj finally : sys . stdout = old", "target": 1, "target_options": ["no_match", "match"]}
{"input": "with dir_path ( path ) to change into a directory . [CODESPLIT] def dir_path ( dir ) : old_dir = os . getcwd ( ) os . chdir ( dir ) yield os . chdir ( old_dir )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the leftmost index of an element in a list using binary search . [CODESPLIT] def bisect_index ( a , x ) : i = bisect . bisect_left ( a , x ) if i != len ( a ) and a [ i ] == x : return i raise ValueError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Super class ordering is important here - user must get saved first . [CODESPLIT] def save_form ( self , request , form , change ) : OwnableAdmin . save_form ( self , request , form , change ) return DisplayableAdmin . save_form ( self , request , form , change )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a string for various input types [CODESPLIT] def check_str ( obj ) : if isinstance ( obj , str ) : return obj if isinstance ( obj , float ) : return str ( int ( obj ) ) else : return str ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gaussian model m is [ psill range nugget ] [CODESPLIT] def gaussian_variogram_model ( m , d ) : psill = float ( m [ 0 ] ) range_ = float ( m [ 1 ] ) nugget = float ( m [ 2 ] ) return psill * ( 1. - np . exp ( - d ** 2. / ( range_ * 4. / 7. ) ** 2. ) ) + nugget", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute average gradient norm of an image [CODESPLIT] def average_gradient ( data , * kwargs ) : return np . average ( np . array ( np . gradient ( data ) ) ** 2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty Prints seconds as Hours : Minutes : Seconds . MilliSeconds [CODESPLIT] def pprint ( self , seconds ) : return ( \"%d:%02d:%02d.%03d\" , reduce ( lambda ll , b : divmod ( ll [ 0 ] , b ) + ll [ 1 : ] , [ ( seconds * 1000 , ) , 1000 , 60 , 60 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Match and yield all the tokens of the input string . [CODESPLIT] def tokenize ( string ) : for match in TOKENS_REGEX . finditer ( string ) : yield Token ( match . lastgroup , match . group ( ) . strip ( ) , match . span ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper method that escapes parameters to a SQL query . [CODESPLIT] def _escape ( s ) : e = s e = e . replace ( '\\\\' , '\\\\\\\\' ) e = e . replace ( '\\n' , '\\\\n' ) e = e . replace ( '\\r' , '\\\\r' ) e = e . replace ( \"'\" , \"\\\\'\" ) e = e . replace ( '\"' , '\\\\\"' ) return e", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function to normalize data to have mean 0 and unity standard deviation ( also called z - transform ) Parameters ---------- data : numpy . ndarray Returns ------- numpy . ndarray z - transform of input array [CODESPLIT] def normalize ( data ) : data = data . astype ( float ) data -= data . mean ( ) return data / data . std ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a string return true if it matches the supplied list of patterns . [CODESPLIT] def match ( string , patterns ) : if patterns is None : return True else : return any ( re . match ( pattern , string ) for pattern in patterns )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform a named tuple into a dictionary [CODESPLIT] def dictify ( a_named_tuple ) : return dict ( ( s , getattr ( a_named_tuple , s ) ) for s in a_named_tuple . _fields )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "print_tree : prints out structure of tree Args : indent ( int ) : What level of indentation at which to start printing Returns : None [CODESPLIT] def print_tree ( self , indent = 2 ) : config . LOGGER . info ( \"{indent}{data}\" . format ( indent = \"   \" * indent , data = str ( self ) ) ) for child in self . children : child . print_tree ( indent + 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the file - like object is readable . [CODESPLIT] def is_readable ( fp , size = 1 ) : read_size = len ( fp . read ( size ) ) fp . seek ( - read_size , 1 ) return read_size == size", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strips elements of values from the beginning of sequence . [CODESPLIT] def strip_head ( sequence , values ) : values = set ( values ) return list ( itertools . dropwhile ( lambda x : x in values , sequence ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the folder exisits . If not create the folder [CODESPLIT] def check_create_folder ( filename ) : os . makedirs ( os . path . dirname ( filename ) , exist_ok = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts the table to a dict . [CODESPLIT] def to_dict ( self ) : return { \"name\" : self . table_name , \"kind\" : self . table_kind , \"data\" : [ r . to_dict ( ) for r in self ] }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is this attribute present? [CODESPLIT] def has_attribute ( module_name , attribute_name ) : init_file = '%s/__init__.py' % module_name return any ( [ attribute_name in init_line for init_line in open ( init_file ) . readlines ( ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a list a certain size [CODESPLIT] def _crop_list_to_size ( l , size ) : for x in range ( size - len ( l ) ) : l . append ( False ) for x in range ( len ( l ) - size ) : l . pop ( ) return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if an element from a list is the only element of a string . [CODESPLIT] def isin_alone ( elems , line ) : found = False for e in elems : if line . strip ( ) . lower ( ) == e . lower ( ) : found = True break return found", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a legal python name for the given name for use as a unit key . [CODESPLIT] def unit_key_from_name ( name ) : result = name for old , new in six . iteritems ( UNIT_KEY_REPLACEMENTS ) : result = result . replace ( old , new ) # Collapse redundant underscores and convert to uppercase. result = re . sub ( r'_+' , '_' , result . upper ( ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "test if object is a list or tuple [CODESPLIT] def is_iter_non_string ( obj ) : if isinstance ( obj , list ) or isinstance ( obj , tuple ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string of bytes into an integer as per X9 . 62 . [CODESPLIT] def string_to_int ( s ) : result = 0 for c in s : if not isinstance ( c , int ) : c = ord ( c ) result = 256 * result + c return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the products from a query response as a Pandas DataFrame with the values in their appropriate Python types . [CODESPLIT] def to_dataframe ( products ) : try : import pandas as pd except ImportError : raise ImportError ( \"to_dataframe requires the optional dependency Pandas.\" ) return pd . DataFrame . from_dict ( products , orient = 'index' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts binary address to Ipv4 format . [CODESPLIT] def _get_ipv4_from_binary ( self , bin_addr ) : return socket . inet_ntop ( socket . AF_INET , struct . pack ( \"!L\" , bin_addr ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Whether this path is a symbolic link . [CODESPLIT] def is_symlink ( self ) : try : return S_ISLNK ( self . lstat ( ) . st_mode ) except OSError as e : if e . errno != ENOENT : raise # Path doesn't exist return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If value is a datetime convert to timestamp [CODESPLIT] def dt_to_ts ( value ) : if not isinstance ( value , datetime ) : return value return calendar . timegm ( value . utctimetuple ( ) ) + value . microsecond / 1000000.0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if arg is a valid file that already exists on the file system . [CODESPLIT] def is_valid_folder ( parser , arg ) : arg = os . path . abspath ( arg ) if not os . path . isdir ( arg ) : parser . error ( \"The folder %s does not exist!\" % arg ) else : return arg", "target": 1, "target_options": ["no_match", "match"]}
{"input": "ensure the master exit from Barrier [CODESPLIT] def abort ( self ) : self . mutex . release ( ) self . turnstile . release ( ) self . mutex . release ( ) self . turnstile2 . release ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determines if a system process identifer exists in process table . [CODESPLIT] def pid_exists ( pid ) : try : os . kill ( pid , 0 ) except OSError as exc : return exc . errno == errno . EPERM else : return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param sequence : Any sequence whose elements can be evaluated as booleans . : returns : true if all elements of the sequence satisfy True and x . [CODESPLIT] def All ( sequence ) : return bool ( reduce ( lambda x , y : x and y , sequence , True ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns angle between vec_a and vec_b in range [ 0 PI ] . This does not distinguish if a is left of or right of b . [CODESPLIT] def angle_v2_rad ( vec_a , vec_b ) : # cos(x) = A * B / |A| * |B| return math . acos ( vec_a . dot ( vec_b ) / ( vec_a . length ( ) * vec_b . length ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks to see if a 2D list is a valid 2D matrix [CODESPLIT] def _rectangular ( n ) : for i in n : if len ( i ) != len ( n [ 0 ] ) : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterate through lines of file . [CODESPLIT] def txt_line_iterator ( path ) : with tf . gfile . Open ( path ) as f : for line in f : yield line . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test two dictionary is equal on values . ( ignore order ) [CODESPLIT] def is_same_dict ( d1 , d2 ) : for k , v in d1 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d2 [ k ] ) else : assert d1 [ k ] == d2 [ k ] for k , v in d2 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d1 [ k ] ) else : assert d1 [ k ] == d2 [ k ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Checks if l is iterable and contains only integral types [CODESPLIT] def is_iterable_of_int ( l ) : if not is_iterable ( l ) : return False return all ( is_int ( value ) for value in l )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function for conversion of various data types into numeric representation . [CODESPLIT] def _to_numeric ( val ) : if isinstance ( val , ( int , float , datetime . datetime , datetime . timedelta ) ) : return val return float ( val )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "is_valid_image_extension . [CODESPLIT] def is_valid_image_extension ( file_path ) : valid_extensions = [ '.jpeg' , '.jpg' , '.gif' , '.png' ] _ , extension = os . path . splitext ( file_path ) return extension . lower ( ) in valid_extensions", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rollback MySQL Transaction to database . MySQLDB : If the database and tables support transactions this rolls back ( cancels ) the current transaction ; otherwise a NotSupportedError is raised . [CODESPLIT] def rollback ( self ) : try : if self . connection is not None : self . connection . rollback ( ) self . _updateCheckTime ( ) self . release ( ) except Exception , e : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts text that may be camelcased into an underscored format [CODESPLIT] def underscore ( text ) : return UNDERSCORE [ 1 ] . sub ( r'\\1_\\2' , UNDERSCORE [ 0 ] . sub ( r'\\1_\\2' , text ) ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a boolean indicating if the code is executed inside softimage . [CODESPLIT] def inside_softimage ( ) : try : import maya return False except ImportError : pass try : from win32com . client import Dispatch as disp disp ( 'XSI.Application' ) return True except : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "generate a CamelCase string from an underscore_string . [CODESPLIT] def camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = '' for component in components : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Checks if l is a numpy array of integers [CODESPLIT] def is_int_vector ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 1 and ( l . dtype . kind == 'i' or l . dtype . kind == 'u' ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "kwarg values always have defaults [CODESPLIT] def test_kwargs_are_optional ( self ) : with patch ( \"sys.exit\" ) as mock_exit : cli = MicroCLITestCase . T ( \"script_name f3\" . split ( ) ) . run ( ) # kwargs are optional mock_exit . assert_called_with ( 4 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Indicates whether or not the given row contains valid data . [CODESPLIT] def is_valid_row ( cls , row ) : for k in row . keys ( ) : if row [ k ] is None : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a unixtime timestamp to a datetime object . The function converts a timestamp in Unix format to a datetime object . UTC timezone will also be set . : param ut : Unix timestamp to convert : returns : a datetime object : raises InvalidDateError : when the given timestamp cannot be converted into a valid date [CODESPLIT] def unixtime_to_datetime ( ut ) : dt = datetime . datetime . utcfromtimestamp ( ut ) dt = dt . replace ( tzinfo = tz . tzutc ( ) ) return dt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a Django project is being managed with manage . py or django - admin scripts [CODESPLIT] def is_managed ( ) : for item in sys . argv : if re . search ( r'manage.py|django-admin|django' , item ) is not None : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string from snake case to camel case with the first letter capitalized . For example some_var would become SomeVar . [CODESPLIT] def to_capitalized_camel_case ( snake_case_string ) : parts = snake_case_string . split ( '_' ) return '' . join ( [ i . title ( ) for i in parts ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether one of the items in the list has multiple lines . [CODESPLIT] def has_multiline_items ( maybe_list : Optional [ Sequence [ str ] ] ) : return maybe_list and any ( is_multiline ( item ) for item in maybe_list )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns whether the given table exists . [CODESPLIT] def table_exists ( self , table ) : if not self . dataset_exists ( table . dataset ) : return False try : self . client . tables ( ) . get ( projectId = table . project_id , datasetId = table . dataset_id , tableId = table . table_id ) . execute ( ) except http . HttpError as ex : if ex . resp . status == 404 : return False raise return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return whether two objects are equal via recursion using : func : numpy . array_equal for comparing numpy arays . [CODESPLIT] def numpy_aware_eq ( a , b ) : if isinstance ( a , np . ndarray ) or isinstance ( b , np . ndarray ) : return np . array_equal ( a , b ) if ( ( isinstance ( a , Iterable ) and isinstance ( b , Iterable ) ) and not isinstance ( a , str ) and not isinstance ( b , str ) ) : if len ( a ) != len ( b ) : return False return all ( numpy_aware_eq ( x , y ) for x , y in zip ( a , b ) ) return a == b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return first row and also iterable with same items as original [CODESPLIT] def peekiter ( iterable ) : it = iter ( iterable ) one = next ( it ) def gen ( ) : \"\"\"Generator that returns first and proxy other items from source\"\"\" yield one while True : yield next ( it ) return ( one , gen ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test two dictionary is equal on values . ( ignore order ) [CODESPLIT] def is_same_dict ( d1 , d2 ) : for k , v in d1 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d2 [ k ] ) else : assert d1 [ k ] == d2 [ k ] for k , v in d2 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d1 [ k ] ) else : assert d1 [ k ] == d2 [ k ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Got this code from here : http : // stackoverflow . com / questions / 6116978 / python - replace - multiple - strings [CODESPLIT] def str_ripper ( self , text ) : return self . pattern . sub ( lambda m : self . rep [ re . escape ( m . group ( 0 ) ) ] , text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if value is a valid UUID . [CODESPLIT] def valid_uuid ( value ) : try : uuid . UUID ( value , version = 4 ) return True except ( TypeError , ValueError , AttributeError ) : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get single system variable from CCU / Homegear [CODESPLIT] def getSystemVariable ( self , remote , name ) : if self . _server is not None : return self . _server . getSystemVariable ( remote , name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns is seq is sequence and not string . [CODESPLIT] def _is_proper_sequence ( seq ) : return ( isinstance ( seq , collections . abc . Sequence ) and not isinstance ( seq , str ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns system clipboard contents . [CODESPLIT] def paste ( xsel = False ) : selection = \"primary\" if xsel else \"clipboard\" try : return subprocess . Popen ( [ \"xclip\" , \"-selection\" , selection , \"-o\" ] , stdout = subprocess . PIPE ) . communicate ( ) [ 0 ] . decode ( \"utf-8\" ) except OSError as why : raise XclipNotFound", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if given filename is an image . [CODESPLIT] def is_image ( filename ) : # note: isfile() also accepts symlinks return os . path . isfile ( filename ) and filename . lower ( ) . endswith ( ImageExts )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Checks if l is iterable and contains only integral types [CODESPLIT] def is_iterable_of_int ( l ) : if not is_iterable ( l ) : return False return all ( is_int ( value ) for value in l )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format list . [CODESPLIT] def list_formatter ( handler , item , value ) : return u', ' . join ( str ( v ) for v in value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Heuristic check if an object is a namedtuple . [CODESPLIT] def isnamedtuple ( obj ) : return isinstance ( obj , tuple ) and hasattr ( obj , \"_fields\" ) and hasattr ( obj , \"_asdict\" ) and callable ( obj . _asdict )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run Python test cases against Java runtime classes . [CODESPLIT] def test_python_java_rt ( ) : sub_env = { 'PYTHONPATH' : _build_dir ( ) } log . info ( 'Executing Python unit tests (against Java runtime classes)...' ) return jpyutil . _execute_python_scripts ( python_java_rt_tests , env = sub_env )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Last modified timestamp as a UTC datetime [CODESPLIT] def last_modified_date ( filename ) : mtime = os . path . getmtime ( filename ) dt = datetime . datetime . utcfromtimestamp ( mtime ) return dt . replace ( tzinfo = pytz . utc )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a UTC timestamp to a datetime . datetime . [CODESPLIT] def timestamp_to_datetime ( cls , time_stamp , localized = True ) : ret = datetime . datetime . utcfromtimestamp ( time_stamp ) if localized : ret = localize ( ret , pytz . utc ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine whether or not obj is iterable but not a string ( eg a list set tuple etc ) . [CODESPLIT] def is_iterable_but_not_string ( obj ) : return hasattr ( obj , '__iter__' ) and not isinstance ( obj , str ) and not isinstance ( obj , bytes )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if a python datum is an instance of a schema . [CODESPLIT] def validate ( datum , schema , field = None , raise_errors = True ) : record_type = extract_record_type ( schema ) result = None validator = VALIDATORS . get ( record_type ) if validator : result = validator ( datum , schema = schema , parent_ns = field , raise_errors = raise_errors ) elif record_type in SCHEMA_DEFS : result = validate ( datum , schema = SCHEMA_DEFS [ record_type ] , field = field , raise_errors = raise_errors ) else : raise UnknownType ( record_type ) if raise_errors and result is False : raise ValidationError ( ValidationErrorData ( datum , schema , field ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "To know the allocated memory at function termination . [CODESPLIT] def memory_used ( self ) : if self . _end_memory : memory_used = self . _end_memory - self . _start_memory return memory_used else : return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if a string looks like an email address [CODESPLIT] def __validate_email ( self , email ) : e = re . match ( self . EMAIL_ADDRESS_REGEX , email , re . UNICODE ) if e : return email else : error = \"Invalid email address: \" + str ( email ) msg = self . GRIMOIRELAB_INVALID_FORMAT % { 'error' : error } raise InvalidFormatError ( cause = msg )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns whether a path names an existing directory we can list and read files from . [CODESPLIT] def is_readable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . R_OK ) and os . access ( path , os . X_OK )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "An argparse type representing an email address . [CODESPLIT] def email_type ( arg ) : if not is_valid_email_address ( arg ) : raise argparse . ArgumentTypeError ( \"{0} is not a valid email address\" . format ( repr ( arg ) ) ) return arg", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determines if a system process identifer exists in process table . [CODESPLIT] def pid_exists ( pid ) : try : os . kill ( pid , 0 ) except OSError as exc : return exc . errno == errno . EPERM else : return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Use W3C XSD schema to validate the document as it is processed . Activation is only possible before the first Read () . If [CODESPLIT] def SchemaValidate ( self , xsd ) : ret = libxml2mod . xmlTextReaderSchemaValidate ( self . _o , xsd ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fetch a query argument as a boolean . [CODESPLIT] def arg_bool ( name , default = False ) : v = request . args . get ( name , '' ) if not len ( v ) : return default return v in BOOL_TRUISH", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function is called to check if a username / password combination is valid . [CODESPLIT] def check_auth ( username , pwd ) : cfg = get_current_config ( ) return username == cfg [ \"dashboard_httpauth\" ] . split ( \":\" ) [ 0 ] and pwd == cfg [ \"dashboard_httpauth\" ] . split ( \":\" ) [ 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "checks if a particular rpm package is installed [CODESPLIT] def is_rpm_package_installed ( pkg ) : with settings ( hide ( 'warnings' , 'running' , 'stdout' , 'stderr' ) , warn_only = True , capture = True ) : result = sudo ( \"rpm -q %s\" % pkg ) if result . return_code == 0 : return True elif result . return_code == 1 : return False else : # print error to user print ( result ) raise SystemExit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Report whether this RangeSet contains another set . [CODESPLIT] def issuperset ( self , other ) : self . _binary_sanity_check ( other ) return set . issuperset ( self , other )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Put curly brackets round an indented text [CODESPLIT] def dumped ( text , level , indent = 2 ) : return indented ( \"{\\n%s\\n}\" % indented ( text , level + 1 , indent ) or \"None\" , level , indent ) + \"\\n\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Put curly brackets round an indented text [CODESPLIT] def dumped ( text , level , indent = 2 ) : return indented ( \"{\\n%s\\n}\" % indented ( text , level + 1 , indent ) or \"None\" , level , indent ) + \"\\n\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns whether the provided name is a valid variable name in Python [CODESPLIT] def is_valid_variable_name ( string_to_check ) : try : parse ( '{} = None' . format ( string_to_check ) ) return True except ( SyntaxError , ValueError , TypeError ) : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a lowercase string with punctuation and bad chars removed : param s : string to clean [CODESPLIT] def _clean_str ( self , s ) : return s . translate ( str . maketrans ( '' , '' , punctuation ) ) . replace ( '\\u200b' , \" \" ) . strip ( ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This method asserts that only one value of the provided list is True . [CODESPLIT] def assert_exactly_one_true ( bool_list ) : assert isinstance ( bool_list , list ) counter = 0 for item in bool_list : if item : counter += 1 return counter == 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "n may be the inside of block or object [CODESPLIT] def is_empty_object ( n , last ) : if n . strip ( ) : return False # seems to be but can be empty code last = last . strip ( ) markers = { ')' , ';' , } if not last or last [ - 1 ] in markers : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get object from string reference . [CODESPLIT] def get_obj ( ref ) : oid = int ( ref ) return server . id2ref . get ( oid ) or server . id2obj [ oid ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes input from user . Works for Python 2 and 3 . [CODESPLIT] def _stdin_ ( p ) : _v = sys . version [ 0 ] return input ( p ) if _v is '3' else raw_input ( p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cartesian to Polar coordinates conversion . [CODESPLIT] def cart2pol ( x , y ) : theta = np . arctan2 ( y , x ) rho = np . hypot ( x , y ) return theta , rho", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Install the hook . [CODESPLIT] def install_handle_input ( self ) : self . pointer = self . get_fptr ( ) self . hooked = ctypes . windll . user32 . SetWindowsHookExA ( 13 , self . pointer , ctypes . windll . kernel32 . GetModuleHandleW ( None ) , 0 ) if not self . hooked : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if two objects are equal . [CODESPLIT] def __eq__ ( self , other ) : return isinstance ( other , self . __class__ ) and self . _freeze ( ) == other . _freeze ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether one of the items in the list has multiple lines . [CODESPLIT] def has_multiline_items ( maybe_list : Optional [ Sequence [ str ] ] ) : return maybe_list and any ( is_multiline ( item ) for item in maybe_list )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap a function as a method . [CODESPLIT] def method ( func ) : attr = abc . abstractmethod ( func ) attr . __imethod__ = True return attr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "change mod to writeable [CODESPLIT] def chmod ( f ) : try : os . chmod ( f , S_IWRITE ) # windows (cover all) except Exception as e : pass try : os . chmod ( f , 0o777 ) # *nix except Exception as e : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call a C function that takes a pointer as its last argument and return the C object that it contains after the function has finished . [CODESPLIT] def get_ctype ( rtype , cfunc , * args ) : val_p = backend . ffi . new ( rtype ) args = args + ( val_p , ) cfunc ( * args ) return val_p [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove params query and fragment parts from URL so that os . path . basename and os . path . splitext can work correctly . [CODESPLIT] def clean_url ( url ) : parsed = urlparse ( url . strip ( ) ) reconstructed = ParseResult ( parsed . scheme , parsed . netloc , parsed . path , params = '' , query = '' , fragment = '' ) return reconstructed . geturl ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap a string at a line length [CODESPLIT] def wrap ( string , length , indent ) : newline = \"\\n\" + \" \" * indent return newline . join ( ( string [ i : i + length ] for i in range ( 0 , len ( string ) , length ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Close all open / active plotters [CODESPLIT] def close_all ( ) : for key , p in _ALL_PLOTTERS . items ( ) : p . close ( ) _ALL_PLOTTERS . clear ( ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the angle between vector x and y [CODESPLIT] def angle_between_vectors ( x , y ) : dp = dot_product ( x , y ) if dp == 0 : return 0 xm = magnitude ( x ) ym = magnitude ( y ) return math . acos ( dp / ( xm * ym ) ) * ( 180. / math . pi )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Close our socket . [CODESPLIT] def socket_close ( self ) : if self . sock != NC . INVALID_SOCKET : self . sock . close ( ) self . sock = NC . INVALID_SOCKET", "target": 1, "target_options": ["no_match", "match"]}
{"input": "prints the top n lines of a file [CODESPLIT] def head ( filename , n = 10 ) : with freader ( filename ) as fr : for _ in range ( n ) : print ( fr . readline ( ) . strip ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Closes the websocket connection . [CODESPLIT] def _close_websocket ( self ) : close_method = getattr ( self . _websocket , \"close\" , None ) if callable ( close_method ) : asyncio . ensure_future ( close_method ( ) , loop = self . _event_loop ) self . _websocket = None self . _dispatch_event ( event = \"close\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Selects the best fit of the estimators already implemented by choosing the model with the smallest mean square error metric for the trained values . [CODESPLIT] def fit_select_best ( X , y ) : models = [ fit ( X , y ) for fit in [ fit_linear , fit_quadratic ] ] errors = map ( lambda model : mse ( y , model . predict ( X ) ) , models ) return min ( zip ( models , errors ) , key = itemgetter ( 1 ) ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Softmax function . [CODESPLIT] def softmax ( attrs , inputs , proto_obj ) : if 'axis' not in attrs : attrs = translation_utils . _add_extra_attributes ( attrs , { 'axis' : 1 } ) return 'softmax' , attrs , inputs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Disable event loop integration with wxPython . [CODESPLIT] def disable_wx ( self ) : if self . _apps . has_key ( GUI_WX ) : self . _apps [ GUI_WX ] . _in_event_loop = False self . clear_inputhook ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Underline the input [CODESPLIT] def underline ( self , msg ) : return click . style ( msg , underline = True ) if self . colorize else msg", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pop - up menu and wx . EVT_CLOSE closing event [CODESPLIT] def on_close ( self , evt ) : self . stop ( ) # DoseWatcher if evt . EventObject is not self : # Avoid deadlocks self . Close ( ) # wx.Frame evt . Skip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Small transformer model with small batch size for fast step times . [CODESPLIT] def afx_small ( ) : hparams = transformer . transformer_tpu ( ) hparams . filter_size = 1024 hparams . num_heads = 4 hparams . num_hidden_layers = 3 hparams . batch_size = 512 return hparams", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Restoring scrollbar position after main window is visible [CODESPLIT] def restore_scrollbar_position ( self ) : scrollbar_pos = self . get_option ( 'scrollbar_position' , None ) if scrollbar_pos is not None : self . explorer . treewidget . set_scrollbar_position ( scrollbar_pos )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decide if the Ipython command line is running code . [CODESPLIT] def IPYTHON_MAIN ( ) : import pkg_resources runner_frame = inspect . getouterframes ( inspect . currentframe ( ) ) [ - 2 ] return ( getattr ( runner_frame , \"function\" , None ) == pkg_resources . load_entry_point ( \"ipython\" , \"console_scripts\" , \"ipython\" ) . __name__ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of rows preceding the data table for * series * in the Excel worksheet . [CODESPLIT] def series_table_row_offset ( self , series ) : title_and_spacer_rows = series . index * 2 data_point_rows = series . data_point_offset return title_and_spacer_rows + data_point_rows", "target": 1, "target_options": ["no_match", "match"]}
{"input": "is_valid_image_extension . [CODESPLIT] def is_valid_image_extension ( file_path ) : valid_extensions = [ '.jpeg' , '.jpg' , '.gif' , '.png' ] _ , extension = os . path . splitext ( file_path ) return extension . lower ( ) in valid_extensions", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return child elements of type tagName if found else [] [CODESPLIT] def getChildElementsByTagName ( self , tagName ) : result = [ ] for child in self . childNodes : if isinstance ( child , Element ) : if child . tagName == tagName : result . append ( child ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Matthews correlation coefficient [CODESPLIT] def mcc ( y_true , y_pred , round = True ) : y_true , y_pred = _mask_value_nan ( y_true , y_pred ) if round : y_true = np . round ( y_true ) y_pred = np . round ( y_pred ) return skm . matthews_corrcoef ( y_true , y_pred )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tell whether a kernel driver is active on given interface number . [CODESPLIT] def kernelDriverActive ( self , interface ) : result = libusb1 . libusb_kernel_driver_active ( self . __handle , interface ) if result == 0 : return False elif result == 1 : return True raiseUSBError ( result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Do a schemas validation of the given resource it will use the SAX streamable validation internally . [CODESPLIT] def schemaValidateFile ( self , filename , options ) : ret = libxml2mod . xmlSchemaValidateFile ( self . _o , filename , options ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Proximal operator to project onto zero [CODESPLIT] def prox_zero ( X , step ) : return np . zeros ( X . shape , dtype = X . dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of entries in a table by counting them . [CODESPLIT] def count_rows ( self , table_name ) : self . table_must_exist ( table_name ) query = \"SELECT COUNT (*) FROM `%s`\" % table_name . lower ( ) self . own_cursor . execute ( query ) return int ( self . own_cursor . fetchone ( ) [ 0 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "in string astr replace all occurences of thefind with thereplace [CODESPLIT] def myreplace ( astr , thefind , thereplace ) : alist = astr . split ( thefind ) new_s = alist . split ( thereplace ) return new_s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coerce value to an JSON - compatible representation . [CODESPLIT] def _time_to_json ( value ) : if isinstance ( value , datetime . time ) : value = value . isoformat ( ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "unload the previously loaded shared library [CODESPLIT] def cleanup_lib ( self ) : if not self . using_openmp : #this if statement is necessary because shared libraries that use #OpenMP will core dump when unloaded, this is a well-known issue with OpenMP logging . debug ( 'unloading shared library' ) _ctypes . dlclose ( self . lib . _handle )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reverse the range [CODESPLIT] def negate ( self ) : self . from_value , self . to_value = self . to_value , self . from_value self . include_lower , self . include_upper = self . include_upper , self . include_lower", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a ctypes float pointer array to a numpy array . [CODESPLIT] def cfloat32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_float ) ) : return np . fromiter ( cptr , dtype = np . float32 , count = length ) else : raise RuntimeError ( 'Expected float pointer' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if string could be a valid python identifier [CODESPLIT] def is_identifier ( string ) : matched = PYTHON_IDENTIFIER_RE . match ( string ) return bool ( matched ) and not keyword . iskeyword ( string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a ctypes int pointer array to a numpy array . [CODESPLIT] def cint8_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int8 ) ) : return np . fromiter ( cptr , dtype = np . int8 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets the resource attribute if available [CODESPLIT] def get_resource_attribute ( self , attr ) : if attr not in self . resource_attributes : raise KeyError ( \"%s is not in resource attributes\" % attr ) return self . resource_attributes [ attr ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create ctypes pointer to object . [CODESPLIT] def POINTER ( obj ) : p = ctypes . POINTER ( obj ) if not isinstance ( p . from_param , classmethod ) : def from_param ( cls , x ) : if x is None : return cls ( ) else : return x p . from_param = classmethod ( from_param ) return p", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deserialize b ( instance of bytes ) to a Python object . [CODESPLIT] def loadb ( b ) : assert isinstance ( b , ( bytes , bytearray ) ) return std_json . loads ( b . decode ( 'utf-8' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function that does what isoformat does but it actually does the same every time instead of randomly doing different things on some systems and also it represents that time as the equivalent UTC time . [CODESPLIT] def __consistent_isoformat_utc ( datetime_val ) : isotime = datetime_val . astimezone ( pytz . utc ) . strftime ( \"%Y-%m-%dT%H:%M:%S%z\" ) if isotime [ - 2 ] != \":\" : isotime = isotime [ : - 2 ] + \":\" + isotime [ - 2 : ] return isotime", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Swap single and double curly brackets [CODESPLIT] def _swap_curly ( string ) : return ( string . replace ( '{{ ' , '{{' ) . replace ( '{{' , '\\x00' ) . replace ( '{' , '{{' ) . replace ( '\\x00' , '{' ) . replace ( ' }}' , '}}' ) . replace ( '}}' , '\\x00' ) . replace ( '}' , '}}' ) . replace ( '\\x00' , '}' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the current time . [CODESPLIT] def now_time ( str = False ) : if str : return datetime . datetime . now ( ) . strftime ( \"%Y-%m-%d %H:%M:%S\" ) return datetime . datetime . now ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Performs an automatic prediction for the specified machine and returns the predicted values . [CODESPLIT] def _do_auto_predict ( machine , X , * args ) : if auto_predict and hasattr ( machine , \"predict\" ) : return machine . predict ( X )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set cursor to initial position and reset any shifting . [CODESPLIT] def home ( self ) : self . command ( c . LCD_RETURNHOME ) self . _cursor_pos = ( 0 , 0 ) c . msleep ( 2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the SQL typename required to store the given FieldDefinition [CODESPLIT] def _getTypename ( self , defn ) : return 'REAL' if defn . type . float or 'TIME' in defn . type . name or defn . dntoeu else 'INTEGER'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list of literal values . [CODESPLIT] def INIT_LIST_EXPR ( self , cursor ) : values = [ self . parse_cursor ( child ) for child in list ( cursor . get_children ( ) ) ] return values", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convenient shorthand for toarray ( * args ** kwargs ) . view ( np . recarray ) . [CODESPLIT] def torecarray ( * args , * * kwargs ) : import numpy as np return toarray ( * args , * * kwargs ) . view ( np . recarray )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "JSON serializer for objects not serializable by default json code [CODESPLIT] def json_serial ( obj ) : if isinstance ( obj , LegipyModel ) : return obj . to_json ( ) elif isinstance ( obj , ( datetime . date , datetime . datetime ) ) : return obj . isoformat ( ) raise TypeError ( \"Type {0} not serializable\" . format ( repr ( type ( obj ) ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "View the quaternion array as an array of floats [CODESPLIT] def as_float_array ( a ) : return np . asarray ( a , dtype = np . quaternion ) . view ( ( np . double , 4 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wraps openjpeg library function cio_close . [CODESPLIT] def cio_close ( cio ) : OPENJPEG . opj_cio_close . argtypes = [ ctypes . POINTER ( CioType ) ] OPENJPEG . opj_cio_close ( cio )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip trailing component trailing from content if it exists . Used when generating names from view classes . [CODESPLIT] def remove_trailing_string ( content , trailing ) : if content . endswith ( trailing ) and content != trailing : return content [ : - len ( trailing ) ] return content", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rotates an image by deg degrees [CODESPLIT] def rotate_img ( im , deg , mode = cv2 . BORDER_CONSTANT , interpolation = cv2 . INTER_AREA ) : r , c ,  * _ = im . shape M = cv2 . getRotationMatrix2D ( ( c // 2 , r // 2 ) , deg , 1 ) return cv2 . warpAffine ( im , M , ( c , r ) , borderMode = mode , flags = cv2 . WARP_FILL_OUTLIERS + interpolation )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format the given vars in the form : flag = value [CODESPLIT] def format_vars ( args ) : variables = [ ] for key , value in args . items ( ) : if value : variables += [ '{0}={1}' . format ( key , value ) ] return variables", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Kill the dashboard . [CODESPLIT] def kill_dashboard ( self , check_alive = True ) : self . _kill_process_type ( ray_constants . PROCESS_TYPE_DASHBOARD , check_alive = check_alive )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Categorical accuracy [CODESPLIT] def cat_acc ( y_true , y_pred ) : return np . mean ( y_true . argmax ( axis = 1 ) == y_pred . argmax ( axis = 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a Python date that corresponds to the specified string representation . [CODESPLIT] def string_to_date ( value ) : if isinstance ( value , datetime . date ) : return value return dateutil . parser . parse ( value ) . date ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Applies the sofplus activation function element - wise to the input . [CODESPLIT] def softplus ( attrs , inputs , proto_obj ) : new_attrs = translation_utils . _add_extra_attributes ( attrs , { 'act_type' : 'softrelu' } ) return 'Activation' , new_attrs , inputs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Use one of the functions below for printing not this one . [CODESPLIT] def print_with_header ( header , message , color , indent = 0 ) : print ( ) padding = ' ' * indent print ( padding + color + BOLD + header + ENDC + color + message + ENDC )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the margin in pixels above the plot area setting border_top . [CODESPLIT] def calculate_top_margin ( self ) : self . border_top = 5 if self . show_graph_title : self . border_top += self . title_font_size self . border_top += 5 if self . show_graph_subtitle : self . border_top += self . subtitle_font_size", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the margin in pixels above the plot area setting border_top . [CODESPLIT] def calculate_top_margin ( self ) : self . border_top = 5 if self . show_graph_title : self . border_top += self . title_font_size self . border_top += 5 if self . show_graph_subtitle : self . border_top += self . subtitle_font_size", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts python datetime to epoch microseconds . [CODESPLIT] def _DateToEpoch ( date ) : tz_zero = datetime . datetime . utcfromtimestamp ( 0 ) diff_sec = int ( ( date - tz_zero ) . total_seconds ( ) ) return diff_sec * 1000000", "target": 1, "target_options": ["no_match", "match"]}
{"input": "quit crash [CODESPLIT] def _quit ( self , * args ) : self . logger . warn ( 'Bye!' ) sys . exit ( self . exit ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update dict with fields from obj . attributes . [CODESPLIT] def update_dict ( obj , dict , attributes ) : for attribute in attributes : if hasattr ( obj , attribute ) and getattr ( obj , attribute ) is not None : dict [ attribute ] = getattr ( obj , attribute )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return a serialized version of obj or raise a TypeError [CODESPLIT] def _default ( self , obj ) : return obj . __dict__ if isinstance ( obj , JsonObj ) else json . JSONDecoder ( ) . decode ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "* Get the root path for this python package - used in unit testing code * [CODESPLIT] def getpackagepath ( ) : moduleDirectory = os . path . dirname ( __file__ ) packagePath = os . path . dirname ( __file__ ) + \"/../\" return packagePath", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorate a function so that print arguments before calling it . [CODESPLIT] def print_args ( output = sys . stdout ) : def decorator ( func ) : \"\"\"The decorator function.\n        \"\"\" @ wraps ( func ) def _ ( * args , * * kwargs ) : \"\"\"The decorated function.\n            \"\"\" output . write ( \"Args: {0}, KwArgs: {1}\\n\" . format ( str ( args ) , str ( kwargs ) ) ) return func ( * args , * * kwargs ) return _ return decorator", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If the number of columns matches we can concatenate two LabeldMatrices with the + operator . [CODESPLIT] def __add__ ( self , other ) : assert self . matrix . shape [ 1 ] == other . matrix . shape [ 1 ] return LabeledMatrix ( np . concatenate ( [ self . matrix , other . matrix ] , axis = 0 ) , self . labels )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty output of nested dictionaries . [CODESPLIT] def pretty_dict_string ( d , indent = 0 ) : s = '' for key , value in sorted ( d . items ( ) ) : s += '    ' * indent + str ( key ) if isinstance ( value , dict ) : s += '\\n' + pretty_dict_string ( value , indent + 1 ) else : s += '=' + str ( value ) + '\\n' return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if value is an integer . [CODESPLIT] def is_int ( value ) : if isinstance ( value , bool ) : return False try : int ( value ) return True except ( ValueError , TypeError ) : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This decorator is for flat_list function . It converts returned generator to list . [CODESPLIT] def generator_to_list ( fn ) : def wrapper ( * args , * * kw ) : return list ( fn ( * args , * * kw ) ) return wrapper", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strips a figure into multiple figures with a trace on each of them [CODESPLIT] def strip_figures ( figure ) : fig = [ ] for trace in figure [ 'data' ] : fig . append ( dict ( data = [ trace ] , layout = figure [ 'layout' ] ) ) return fig", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Second order polynomial [CODESPLIT] def Square ( x , a , b , c ) : return a * x ** 2 + b * x + c", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate angle between two vectors [CODESPLIT] def vec_angle ( a , b ) : cosang = np . dot ( a , b ) sinang = fast_norm ( np . cross ( a , b ) ) return np . arctan2 ( sinang , cosang )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "An array of all parameters ( including frozen parameters ) [CODESPLIT] def parameter_vector ( self ) : return np . array ( [ getattr ( self , k ) for k in self . parameter_names ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rewrite a file adding a line to its beginning . [CODESPLIT] def prepend_line ( filepath , line ) : with open ( filepath ) as f : lines = f . readlines ( ) lines . insert ( 0 , line ) with open ( filepath , 'w' ) as f : f . writelines ( lines )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like dict but does not hold any null values . [CODESPLIT] def nonull_dict ( self ) : return { k : v for k , v in six . iteritems ( self . dict ) if v and k != '_codes' }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transforms a DataFrame in place . Computes all outputs of the DataFrame . [CODESPLIT] def transform ( self , df ) : for name , function in self . outputs : df [ name ] = function ( df )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete object on remote [CODESPLIT] def delete ( self , name ) : obj = self . _get_object ( name ) if obj : return self . driver . delete_object ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper parse action to convert tokens to upper case . [CODESPLIT] def upcaseTokens ( s , l , t ) : return [ tt . upper ( ) for tt in map ( _ustr , t ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a short description of the device . [CODESPLIT] def desc ( self ) : return '{0} (ID: {1}) - {2} - {3}' . format ( self . name , self . device_id , self . type , self . status )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Filter the given object through the filter chain . [CODESPLIT] def filter ( self , obj , * args , * * kwargs ) : for _ , _ , func in self . _filter_order : obj = func ( obj , * args , * * kwargs ) if obj is None : return None return obj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "FFT of y assuming complex or real - valued inputs . This goes through the numpy fourier transform process assembling and returning ( frequencies complex fft ) given time and signal data y . [CODESPLIT] def fft ( t , y , pow2 = False , window = None , rescale = False ) : # make sure they're numpy arrays, and make copies to avoid the referencing error y = _n . array ( y ) t = _n . array ( t ) # if we're doing the power of 2, do it if pow2 : keep = 2 ** int ( _n . log2 ( len ( y ) ) ) # now resize the data y . resize ( keep ) t . resize ( keep ) # Window the data if not window in [ None , False , 0 ] : try : # Get the windowing array w = eval ( \"_n.\" + window , dict ( _n = _n ) ) ( len ( y ) ) # Store the original variance v0 = _n . average ( abs ( y ) ** 2 ) # window the time domain data  y = y * w # Rescale by the variance ratio if rescale : y = y * _n . sqrt ( v0 / _n . average ( abs ( y ) ** 2 ) ) except : print ( \"ERROR: Bad window!\" ) return # do the actual fft, and normalize Y = _n . fft . fftshift ( _n . fft . fft ( y ) / len ( t ) ) f = _n . fft . fftshift ( _n . fft . fftfreq ( len ( t ) , t [ 1 ] - t [ 0 ] ) ) return f , Y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to restore index information after collection . Doesn t use self so we can serialize this . [CODESPLIT] def _update_index_on_df ( df , index_names ) : if index_names : df = df . set_index ( index_names ) # Remove names from unnamed indexes index_names = _denormalize_index_names ( index_names ) df . index . names = index_names return df", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return True if callback is a vanilla plain jane function [CODESPLIT] def is_function ( self ) : if self . is_instance ( ) or self . is_class ( ) : return False return isinstance ( self . callback , ( Callable , classmethod ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Guess string encoding . [CODESPLIT] def guess_encoding ( text , default = DEFAULT_ENCODING ) : result = chardet . detect ( text ) return normalize_result ( result , default = default )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function will create and then start a new Async task with the default callbacks argument defined in the decorator . [CODESPLIT] def build_and_start ( query , directory ) : Async ( target = grep , args = [ query , directory ] ) . start ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get width of a string in the current font [CODESPLIT] def _string_width ( self , s ) : s = str ( s ) w = 0 for char in s : char = ord ( char ) w += self . character_widths [ char ] return w * self . font_size / 1000.0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a list of the data types for each column in * data * . [CODESPLIT] def _get_column_types ( self , data ) : columns = list ( zip_longest ( * data ) ) return [ self . _get_column_type ( column ) for column in columns ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a python file and returns a awslambda . Code object : param python_file : : return : [CODESPLIT] def lambda_from_file ( python_file ) : lambda_function = [ ] with open ( python_file , 'r' ) as f : lambda_function . extend ( f . read ( ) . splitlines ( ) ) return awslambda . Code ( ZipFile = ( Join ( '\\n' , lambda_function ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Invoked when determining whether a specific key is in the dictionary using key in d . [CODESPLIT] def __contains__ ( self , key ) : k = self . _real_key ( key ) return k in self . _data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show the x - axis tick labels for a subplot . [CODESPLIT] def show_xticklabels ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . show_xticklabels ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a Seaborn bar chart [CODESPLIT] def seaborn_bar_ ( self , label = None , style = None , opts = None ) : try : fig = sns . barplot ( self . x , self . y , palette = \"BuGn_d\" ) return fig except Exception as e : self . err ( e , self . seaborn_bar_ , \"Can not get Seaborn bar chart object\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create nicely - formatted string based on arguments msg and title : param msg : the msg to be displayed : param title : the window title : return : None [CODESPLIT] def getFileDialogTitle ( msg , title ) : if msg and title : return \"%s - %s\" % ( title , msg ) if msg and not title : return str ( msg ) if title and not msg : return str ( title ) return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check for existence of key in dict return value or raise error [CODESPLIT] def _check_conversion ( key , valid_dict ) : if key not in valid_dict and key not in valid_dict . values ( ) : # Only show users the nice string values keys = [ v for v in valid_dict . keys ( ) if isinstance ( v , string_types ) ] raise ValueError ( 'value must be one of %s, not %s' % ( keys , key ) ) return valid_dict [ key ] if key in valid_dict else key", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get an item from a dict which contains just one item . [CODESPLIT] def get_single_item ( d ) : assert len ( d ) == 1 , 'Single-item dict must have just one item, not %d.' % len ( d ) return next ( six . iteritems ( d ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "merge two dictionaries [CODESPLIT] def dictmerge ( x , y ) : z = x . copy ( ) z . update ( y ) return z", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates bounding box for a line segment [CODESPLIT] def bounding_box_from ( points , i , i1 , thr ) : pi = points [ i ] pi1 = points [ i1 ] min_lat = min ( pi . lat , pi1 . lat ) min_lon = min ( pi . lon , pi1 . lon ) max_lat = max ( pi . lat , pi1 . lat ) max_lon = max ( pi . lon , pi1 . lon ) return min_lat - thr , min_lon - thr , max_lat + thr , max_lon + thr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "update () extends rather than replaces existing key lists . [CODESPLIT] def update ( self , other_dict ) : for key , value in iter_multi_items ( other_dict ) : MultiDict . add ( self , key , value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the box ( for horizontal graphs ) [CODESPLIT] def swap ( self ) : self . xmin , self . ymin = self . ymin , self . xmin self . xmax , self . ymax = self . ymax , self . xmax", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an iterator over the values of a dictionary . [CODESPLIT] def itervalues ( d , * * kw ) : if not PY2 : return iter ( d . values ( * * kw ) ) return d . itervalues ( * * kw )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert anything to bytes [CODESPLIT] def tob ( data , enc = 'utf8' ) : return data . encode ( enc ) if isinstance ( data , six . text_type ) else bytes ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove null items from a dictionary [CODESPLIT] def purge_dict ( idict ) : odict = { } for key , val in idict . items ( ) : if is_null ( val ) : continue odict [ key ] = val return odict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes // - comments and single - line C - style / * * / comments . [CODESPLIT] def CleanseComments ( line ) : commentpos = line . find ( '//' ) if commentpos != - 1 and not IsCppString ( line [ : commentpos ] ) : line = line [ : commentpos ] . rstrip ( ) # get rid of /* ... */ return _RE_PATTERN_CLEANSE_LINE_C_COMMENTS . sub ( '' , line )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set path to history file . produces no file . [CODESPLIT] def set_history_file ( self , path ) : if path : self . history = prompt_toolkit . history . FileHistory ( fixpath ( path ) ) else : self . history = prompt_toolkit . history . InMemoryHistory ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dict from entries in a scala . collection . immutable . Map [CODESPLIT] def get_python_dict ( scala_map ) : python_dict = { } keys = get_python_list ( scala_map . keys ( ) . toList ( ) ) for key in keys : python_dict [ key ] = scala_map . apply ( key ) return python_dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Because standard distinct used on the all fields are very slow and works only with PostgreSQL database this method provides alternative to the standard distinct method . : return : qs with unique objects [CODESPLIT] def fast_distinct ( self ) : return self . model . objects . filter ( pk__in = self . values_list ( 'pk' , flat = True ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Estimates the memory of the supplied array in bytes [CODESPLIT] def array_bytes ( array ) : return np . product ( array . shape ) * np . dtype ( array . dtype ) . itemsize", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set value of the checkbox . [CODESPLIT] def set_value ( self , value ) : if value : self . setCheckState ( Qt . Checked ) else : self . setCheckState ( Qt . Unchecked )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return locale from GET lang param or automatically . [CODESPLIT] def set_locale ( request ) : return request . query . get ( 'lang' , app . ps . babel . select_locale_by_request ( request ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def getMaxAffiliationInstanceID ( ) : dbconnectionhanlder = DBConnection ( ) dbconnectionhanlder . cursor . execute ( \"SELECT max(id) from `django-tethne_affiliation_instance`\" ) rows = dbconnectionhanlder . cursor . fetchall ( ) dbconnectionhanlder . conn . close ( ) if rows [ 0 ] [ 0 ] is None : return 0 else : return rows [ 0 ] [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the variance of values in a series . [CODESPLIT] def var ( series ) : if np . issubdtype ( series . dtype , np . number ) : return series . var ( ) else : return np . nan", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handle many to many relationships for user field [CODESPLIT] def handle_m2m_user ( self , sender , instance , * * kwargs ) : self . handle_save ( instance . user . __class__ , instance . user )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "int : current max id of objects [CODESPLIT] def maxId ( self ) : if len ( self . model . db ) == 0 : return 0 return max ( map ( lambda obj : obj [ \"id\" ] , self . model . db ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a JsonResponse . Make sure you have django installed first . [CODESPLIT] def json_response ( data , status = 200 ) : from django . http import JsonResponse return JsonResponse ( data = data , status = status , safe = isinstance ( data , dict ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Imports from javascript source file . globals is your globals () [CODESPLIT] def import_js ( path , lib_name , globals ) : with codecs . open ( path_as_local ( path ) , \"r\" , \"utf-8\" ) as f : js = f . read ( ) e = EvalJs ( ) e . execute ( js ) var = e . context [ 'var' ] globals [ lib_name ] = var . to_python ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse the code parameter from the a URL [CODESPLIT] def parse_code ( url ) : result = urlparse ( url ) query = parse_qs ( result . query ) return query [ 'code' ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Appends tzinfo and assumes UTC if datetime object has no tzinfo already . [CODESPLIT] def make_aware ( dt ) : return dt if dt . tzinfo else dt . replace ( tzinfo = timezone . utc )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute the user function . [CODESPLIT] def __call__ ( self , args ) : window , ij = args return self . user_func ( srcs , window , ij , global_args ) , window", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Releases this resource back to the pool it came from . [CODESPLIT] def release ( self ) : if self . errored : self . pool . delete_resource ( self ) else : self . pool . release ( self )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "determine whether two sequence names from a repeatmasker alignment match . [CODESPLIT] def _rm_name_match ( s1 , s2 ) : m_len = min ( len ( s1 ) , len ( s2 ) ) return s1 [ : m_len ] == s2 [ : m_len ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return generator of pull status objects [CODESPLIT] def pull_stream ( image ) : return ( json . loads ( s ) for s in _get_docker ( ) . pull ( image , stream = True ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes tags from objects [CODESPLIT] def _removeTags ( tags , objects ) : for t in tags : for o in objects : o . tags . remove ( t ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a date into a datetime [CODESPLIT] def date_to_datetime ( x ) : if not isinstance ( x , datetime ) and isinstance ( x , date ) : return datetime . combine ( x , time ( ) ) return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Slicing op . [CODESPLIT] def Slice ( a , begin , size ) : return np . copy ( a ) [ [ slice ( * tpl ) for tpl in zip ( begin , begin + size ) ] ] ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to unpickle data from picklefile . [CODESPLIT] def unpickle_file ( picklefile , * * kwargs ) : with open ( picklefile , 'rb' ) as f : return pickle . load ( f , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the dotproduct between self and another vector . [CODESPLIT] def dot ( self , w ) : return sum ( [ x * y for x , y in zip ( self , w ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Undo the effects of patch ( func obj name ) [CODESPLIT] def unpatch ( obj , name ) : setattr ( obj , name , getattr ( obj , name ) . original )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Draw a graph and save it into a file [CODESPLIT] def draw ( graph , fname ) : ag = networkx . nx_agraph . to_agraph ( graph ) ag . draw ( fname , prog = 'dot' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterates over the items of a sequence . If the sequence supports the dictionary protocol ( iteritems / items ) then we use that . Otherwise we use the enumerate built - in function . [CODESPLIT] def items ( iterable ) : if hasattr ( iterable , 'iteritems' ) : return ( p for p in iterable . iteritems ( ) ) elif hasattr ( iterable , 'items' ) : return ( p for p in iterable . items ( ) ) else : return ( p for p in enumerate ( iterable ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert snake_case to camel_case . [CODESPLIT] def to_identifier ( s ) : if s . startswith ( 'GPS' ) : s = 'Gps' + s [ 3 : ] return '' . join ( [ i . capitalize ( ) for i in s . split ( '_' ) ] ) if '_' in s else s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a json string representing the python object obj . [CODESPLIT] def to_json ( obj ) : i = StringIO . StringIO ( ) w = Writer ( i , encoding = 'UTF-8' ) w . write_value ( obj ) return i . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert CamelCase to lower_and_underscore . [CODESPLIT] def decamelise ( text ) : s = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "shows JSON indented representation of d [CODESPLIT] def pretty_dict_str ( d , indent = 2 ) : b = StringIO ( ) write_pretty_dict_str ( b , d , indent = indent ) return b . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "generate a CamelCase string from an underscore_string . [CODESPLIT] def camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = '' for component in components : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialize a KeyValuePair object from a json dictionary . [CODESPLIT] def _from_dict ( cls , _dict ) : args = { } if 'key' in _dict : args [ 'key' ] = Key . _from_dict ( _dict . get ( 'key' ) ) if 'value' in _dict : args [ 'value' ] = Value . _from_dict ( _dict . get ( 'value' ) ) return cls ( * * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "execute jobs in processes using N threads [CODESPLIT] def parallel ( processes , threads ) : pool = multithread ( threads ) pool . map ( run_process , processes ) pool . close ( ) pool . join ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn list of keywords into dictionary . [CODESPLIT] def _kw ( keywords ) : r = { } for k , v in keywords : r [ k ] = v return r", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert to snake case . [CODESPLIT] def to_snake_case ( text ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Re - index every document in a named index . [CODESPLIT] def update_index ( index ) : logger . info ( \"Updating search index: '%s'\" , index ) client = get_client ( ) responses = [ ] for model in get_index_models ( index ) : logger . info ( \"Updating search index model: '%s'\" , model . search_doc_type ) objects = model . objects . get_search_queryset ( index ) . iterator ( ) actions = bulk_actions ( objects , index = index , action = \"index\" ) response = helpers . bulk ( client , actions , chunk_size = get_setting ( \"chunk_size\" ) ) responses . append ( response ) return responses", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a string representing a numpy array of 0 s and 1 s [CODESPLIT] def bitsToString ( arr ) : s = array ( 'c' , '.' * len ( arr ) ) for i in xrange ( len ( arr ) ) : if arr [ i ] == 1 : s [ i ] = '*' return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add index alias to index_name [CODESPLIT] def add_index_alias ( es , index_name , alias_name ) : es . indices . put_alias ( index = index_name , name = terms_alias )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace boolean variables by the characters F / T [CODESPLIT] def _check_and_convert_bools ( self ) : replacements = { True : 'T' , False : 'F' , } for key in self . bools : if isinstance ( self [ key ] , bool ) : self [ key ] = replacements [ self [ key ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Index the given document . [CODESPLIT] def index ( obj , index = INDEX_NAME , doc_type = DOC_TYPE ) : doc = to_dict ( obj ) if doc is None : return id = doc . pop ( 'id' ) return es_conn . index ( index , doc_type , doc , id = id )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility function which converts lists to tuples . [CODESPLIT] def as_tuple ( self , value ) : if isinstance ( value , list ) : value = tuple ( value ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Formats given header column . This involves changing _Px_ to ( _xP_ to ) and all other _ to spaces . [CODESPLIT] def format_header_cell ( val ) : return re . sub ( '_' , ' ' , re . sub ( r'(_Px_)' , '(' , re . sub ( r'(_xP_)' , ')' , str ( val ) ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "iterparse variant that supports tag parameter ( like lxml ) yields elements and clears nodes after parsing . [CODESPLIT] def iterparse ( source , tag , clear = False , events = None ) : for event , elem in ElementTree . iterparse ( source , events = events ) : if elem . tag == tag : yield elem if clear : elem . clear ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply 2to3 tool ( Python2 to Python3 conversion tool ) to Python sources . [CODESPLIT] def command_py2to3 ( args ) : from lib2to3 . main import main sys . exit ( main ( \"lib2to3.fixes\" , args = args . sources ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates RFC2822 format [CODESPLIT] def is_rfc2822 ( instance : str ) : if not isinstance ( instance , str ) : return True return email . utils . parsedate ( instance ) is not None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Encodes Unicode strings to byte strings if necessary . [CODESPLIT] def b ( s ) : return s if isinstance ( s , bytes ) else s . encode ( locale . getpreferredencoding ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ensure val is Nx ( n_col ) usually Nx3 [CODESPLIT] def _check_color_dim ( val ) : val = np . atleast_2d ( val ) if val . shape [ 1 ] not in ( 3 , 4 ) : raise RuntimeError ( 'Value must have second dimension of size 3 or 4' ) return val , val . shape [ 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "DEBUG FUNC modify argv to look like you ran a command [CODESPLIT] def aug_sysargv ( cmdstr ) : import shlex argv = shlex . split ( cmdstr ) sys . argv . extend ( argv )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Provide a password prompt . [CODESPLIT] def getpass ( self , prompt , default = None ) : return click . prompt ( prompt , hide_input = True , default = default )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convenience function which returns the unit vector aligned with the miller index . [CODESPLIT] def get_mi_vec ( slab ) : mvec = np . cross ( slab . lattice . matrix [ 0 ] , slab . lattice . matrix [ 1 ] ) return mvec / np . linalg . norm ( mvec )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert strings to complex number instance with specified numpy type . [CODESPLIT] def c2f ( r , i , ctype_name ) : ftype = c2f_dict [ ctype_name ] return np . typeDict [ ctype_name ] ( ftype ( r ) + 1j * ftype ( i ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if a file is located within the given directory . [CODESPLIT] def contained_in ( filename , directory ) : filename = os . path . normcase ( os . path . abspath ( filename ) ) directory = os . path . normcase ( os . path . abspath ( directory ) ) return os . path . commonprefix ( [ filename , directory ] ) == directory", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute a python code object in the given environment . [CODESPLIT] def exec_function ( ast , globals_map ) : locals_map = globals_map exec ast in globals_map , locals_map return locals_map", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tests if an object is a collection . [CODESPLIT] def is_collection ( obj ) : col = getattr ( obj , '__getitem__' , False ) val = False if ( not col ) else True if isinstance ( obj , basestring ) : val = False return val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks whether the re module can compile the given regular expression . [CODESPLIT] def is_valid_regex ( string ) : try : re . compile ( string ) is_valid = True except re . error : is_valid = False return is_valid", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialize the ExcelWorkbook instance . [CODESPLIT] def __init__ ( self , filename , formatting_info = False , handle_ambiguous_date = None ) : super ( ) . __init__ ( filename ) self . workbook = xlrd . open_workbook ( self . filename , formatting_info = formatting_info ) self . handle_ambiguous_date = handle_ambiguous_date", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return whether two objects are equal via recursion using : func : numpy . array_equal for comparing numpy arays . [CODESPLIT] def numpy_aware_eq ( a , b ) : if isinstance ( a , np . ndarray ) or isinstance ( b , np . ndarray ) : return np . array_equal ( a , b ) if ( ( isinstance ( a , Iterable ) and isinstance ( b , Iterable ) ) and not isinstance ( a , str ) and not isinstance ( b , str ) ) : if len ( a ) != len ( b ) : return False return all ( numpy_aware_eq ( x , y ) for x , y in zip ( a , b ) ) return a == b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple method for handling exceptions raised by PyBankID . [CODESPLIT] def handle_exception ( error ) : response = jsonify ( error . to_dict ( ) ) response . status_code = error . status_code return response", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if a file is located within the given directory . [CODESPLIT] def contained_in ( filename , directory ) : filename = os . path . normcase ( os . path . abspath ( filename ) ) directory = os . path . normcase ( os . path . abspath ( directory ) ) return os . path . commonprefix ( [ filename , directory ] ) == directory", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether one of the items in the list has multiple lines . [CODESPLIT] def has_multiline_items ( maybe_list : Optional [ Sequence [ str ] ] ) : return maybe_list and any ( is_multiline ( item ) for item in maybe_list )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute a python code object in the given environment . [CODESPLIT] def exec_function ( ast , globals_map ) : locals_map = globals_map exec ast in globals_map , locals_map return locals_map", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if the socket managed by this connection is connected [CODESPLIT] def is_connected ( self ) : try : return self . socket is not None and self . socket . getsockname ( ) [ 1 ] != 0 and BaseTransport . is_connected ( self ) except socket . error : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the * cmd * and exit with the proper exit code . [CODESPLIT] def call_and_exit ( self , cmd , shell = True ) : sys . exit ( subprocess . call ( cmd , shell = shell ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns whether the specified element selector is present on the page . [CODESPLIT] def is_element_present ( driver , selector , by = By . CSS_SELECTOR ) : try : driver . find_element ( by = by , value = selector ) return True except Exception : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Conveinience : [CODESPLIT] def get_tablenames ( cur ) : cur . execute ( \"SELECT name FROM sqlite_master WHERE type='table'\" ) tablename_list_ = cur . fetchall ( ) tablename_list = [ str ( tablename [ 0 ] ) for tablename in tablename_list_ ] return tablename_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check whether the item is list ( tuple ) and consist of list ( tuple ) elements [CODESPLIT] def is_list_of_list ( item ) : if ( type ( item ) in ( list , tuple ) and len ( item ) and isinstance ( item [ 0 ] , ( list , tuple ) ) ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r A function to support exiting from exit hooks . [CODESPLIT] def exit ( exit_code = 0 ) : core . processExitHooks ( ) if state . isExitHooked and not hasattr ( sys , 'exitfunc' ) : # The function is called from the exit hook sys . stderr . flush ( ) sys . stdout . flush ( ) os . _exit ( exit_code ) #pylint: disable=W0212 sys . exit ( exit_code )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if list contains either values of type vtype or None . [CODESPLIT] def is_nullable_list ( val , vtype ) : return ( isinstance ( val , list ) and any ( isinstance ( v , vtype ) for v in val ) and all ( ( isinstance ( v , vtype ) or v is None ) for v in val ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Expand $vars in a string . [CODESPLIT] def _expand ( self , str , local_vars = { } ) : return ninja_syntax . expand ( str , self . vars , local_vars )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if the json_element passed is present for the task specified . [CODESPLIT] def task_property_present_predicate ( service , task , prop ) : try : response = get_service_task ( service , task ) except Exception as e : pass return ( response is not None ) and ( prop in response )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Merge args with kwargs . [CODESPLIT] def _merge_args_with_kwargs ( args_dict , kwargs_dict ) : ret = args_dict . copy ( ) ret . update ( kwargs_dict ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a boolean indicating if the code is executed inside softimage . [CODESPLIT] def inside_softimage ( ) : try : import maya return False except ImportError : pass try : from win32com . client import Dispatch as disp disp ( 'XSI.Application' ) return True except : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Solution found here : http : // stackoverflow . com / questions / 480214 / how - do - you - remove - duplicates - from - a - list - in - python - whilst - preserving - order [CODESPLIT] def unique_everseen ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get letters from string only . [CODESPLIT] def return_letters_from_string ( text ) : out = \"\" for letter in text : if letter . isalpha ( ) : out += letter return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Whether path is a directory to which the user has write access . [CODESPLIT] def _writable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . W_OK )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a dictionary from a URL params [CODESPLIT] def get_url_args ( url ) : url_data = urllib . parse . urlparse ( url ) arg_dict = urllib . parse . parse_qs ( url_data . query ) return arg_dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tests if image img in category cat exists [CODESPLIT] def test_for_image ( self , cat , img ) : return self . test_for_category ( cat ) and img in self . items [ cat ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "reads the zip file determines compression and unzips recursively until source files are extracted [CODESPLIT] def extract_all ( zipfile , dest_folder ) : z = ZipFile ( zipfile ) print ( z ) z . extract ( dest_folder )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is this a string . [CODESPLIT] def is_string ( obj ) : if PYTHON3 : str_type = ( bytes , str ) else : str_type = ( bytes , str , unicode ) return isinstance ( obj , str_type )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse a float value node in the AST . [CODESPLIT] def parse_float_literal ( ast , _variables = None ) : if isinstance ( ast , ( FloatValueNode , IntValueNode ) ) : return float ( ast . value ) return INVALID", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if a string is an integer . If the string value is an integer return True otherwise return False . Args : string : a string to test . [CODESPLIT] def is_int ( string ) : try : a = float ( string ) b = int ( a ) except ValueError : return False else : return a == b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Short Time Fourier Transform for real data keeping the full FFT block . [CODESPLIT] def stft ( func = None , * * kwparams ) : from numpy . fft import fft , ifft ifft_r = lambda * args : ifft ( * args ) . real return stft . base ( transform = fft , inverse_transform = ifft_r ) ( func , * * kwparams )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return whether two objects are equal via recursion using : func : numpy . array_equal for comparing numpy arays . [CODESPLIT] def numpy_aware_eq ( a , b ) : if isinstance ( a , np . ndarray ) or isinstance ( b , np . ndarray ) : return np . array_equal ( a , b ) if ( ( isinstance ( a , Iterable ) and isinstance ( b , Iterable ) ) and not isinstance ( a , str ) and not isinstance ( b , str ) ) : if len ( a ) != len ( b ) : return False return all ( numpy_aware_eq ( x , y ) for x , y in zip ( a , b ) ) return a == b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Short Time Fourier Transform for real data keeping the full FFT block . [CODESPLIT] def stft ( func = None , * * kwparams ) : from numpy . fft import fft , ifft ifft_r = lambda * args : ifft ( * args ) . real return stft . base ( transform = fft , inverse_transform = ifft_r ) ( func , * * kwparams )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if value is a valid UUID . [CODESPLIT] def valid_uuid ( value ) : try : uuid . UUID ( value , version = 4 ) return True except ( TypeError , ValueError , AttributeError ) : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the short - time Fourier transform magnitude . [CODESPLIT] def stft_magnitude ( signal , fft_length , hop_length = None , window_length = None ) : frames = frame ( signal , window_length , hop_length ) # Apply frame window to each frame. We use a periodic Hann (cosine of period # window_length) instead of the symmetric Hann of np.hanning (period # window_length-1). window = periodic_hann ( window_length ) windowed_frames = frames * window return np . abs ( np . fft . rfft ( windowed_frames , int ( fft_length ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the value of a local variable somewhere in the call stack . [CODESPLIT] def getvariable ( name ) : import inspect fr = inspect . currentframe ( ) try : while fr : fr = fr . f_back vars = fr . f_locals if name in vars : return vars [ name ] except : pass return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the modified time for a file as a datetime instance [CODESPLIT] def get_time ( filename ) : ts = os . stat ( filename ) . st_mtime return datetime . datetime . utcfromtimestamp ( ts )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if the GET querstring contains on values but it can contain empty keys . This is better than doing not bool ( request . GET ) as an empty key will return True [CODESPLIT] def check_empty_dict ( GET_dict ) : empty = True for k , v in GET_dict . items ( ) : # Don't disable on p(age) or 'all' GET param if v and k != 'p' and k != 'all' : empty = False return empty", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Open a file . [CODESPLIT] def open_file ( file , mode ) : if hasattr ( file , \"read\" ) : return file if hasattr ( file , \"open\" ) : return file . open ( mode ) return open ( file , mode )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks to see if a 2D list is a valid 2D matrix [CODESPLIT] def _rectangular ( n ) : for i in n : if len ( i ) != len ( n [ 0 ] ) : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rewind the file to the start of the body ( if seekable ) . [CODESPLIT] def rewindbody ( self ) : if not self . seekable : raise IOError , \"unseekable file\" self . fp . seek ( self . startofbody )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check shape of array or sparse matrix . [CODESPLIT] def _check_2d_shape ( X ) : if X . dtype . names is None and len ( X . shape ) != 2 : raise ValueError ( 'X needs to be 2-dimensional, not ' '{}-dimensional.' . format ( len ( X . shape ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the length in bytes of a given file object . Necessary because os . fstat only works on real files and not file - like objects . This works on more types of streams primarily StringIO . [CODESPLIT] def file_length ( file_obj ) : file_obj . seek ( 0 , 2 ) length = file_obj . tell ( ) file_obj . seek ( 0 ) return length", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if pip exists inside the virtual environment . Can be used as a naive way to verify that the environment is installed . [CODESPLIT] def _pip_exists ( self ) : return os . path . isfile ( os . path . join ( self . path , 'bin' , 'pip' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the skewness of data . [CODESPLIT] def skewness ( data ) : if len ( data ) == 0 : return None num = moment ( data , 3 ) denom = moment ( data , 2 ) ** 1.5 return num / denom if denom != 0 else 0.", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace masked - out elements in an array using an iterative image inpainting algorithm . [CODESPLIT] def inpaint ( self ) : import inpaint filled = inpaint . replace_nans ( np . ma . filled ( self . raster_data , np . NAN ) . astype ( np . float32 ) , 3 , 0.01 , 2 ) self . raster_data = np . ma . masked_invalid ( filled )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ensure val is Nx ( n_col ) usually Nx3 [CODESPLIT] def _check_color_dim ( val ) : val = np . atleast_2d ( val ) if val . shape [ 1 ] not in ( 3 , 4 ) : raise RuntimeError ( 'Value must have second dimension of size 3 or 4' ) return val , val . shape [ 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param list_of_points : : return : list_of_points with None s removed [CODESPLIT] def filter_none ( list_of_points ) : remove_elementnone = filter ( lambda p : p is not None , list_of_points ) remove_sublistnone = filter ( lambda p : not contains_none ( p ) , remove_elementnone ) return list ( remove_sublistnone )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param source : some iterable source ( list file etc ) : param lineSep : string of separators ( chars ) that must be removed : return : list of non empty lines with removed separators [CODESPLIT] def cleanLines ( source , lineSep = os . linesep ) : stripped = ( line . strip ( lineSep ) for line in source ) return ( line for line in stripped if len ( line ) != 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test that a and b are close and match in shape . [CODESPLIT] def allclose ( a , b ) : from numpy import allclose return ( a . shape == b . shape ) and allclose ( a , b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a camelCased string and converts to snake_case . [CODESPLIT] def camel_to_snake_case ( name ) : pattern = r'[A-Z][a-z]+|[A-Z]+(?![a-z])' return '_' . join ( map ( str . lower , re . findall ( pattern , name ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "For list values returns the index location of element x . If x does not exist will raise an error . [CODESPLIT] def sorted_index ( values , x ) : i = bisect_left ( values , x ) j = bisect_right ( values , x ) return values [ i : j ] . index ( x ) + i", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clears the console . [CODESPLIT] def clear ( ) : if sys . platform . startswith ( \"win\" ) : call ( \"cls\" , shell = True ) else : call ( \"clear\" , shell = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find rightmost value less than x . [CODESPLIT] def find_lt ( a , x ) : i = bs . bisect_left ( a , x ) if i : return i - 1 raise ValueError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieves a non - image asset associated with an entry [CODESPLIT] def retrieve_asset ( filename ) : record = model . Image . get ( asset_name = filename ) if not record : raise http_error . NotFound ( \"File not found\" ) if not record . is_asset : raise http_error . Forbidden ( ) return flask . send_file ( record . file_path , conditional = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flush all items from cache . [CODESPLIT] def Flush ( self ) : while self . _age : node = self . _age . PopLeft ( ) self . KillObject ( node . data ) self . _hash = dict ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Old style use JSONTemplateResponse instead of this . [CODESPLIT] def json_template ( data , template_name , template_context ) : html = render_to_string ( template_name , template_context ) data = data or { } data [ 'html' ] = html return HttpResponse ( json_encode ( data ) , content_type = 'application/json' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Closes the root Dataset . [CODESPLIT] def _closeResources ( self ) : logger . info ( \"Closing: {}\" . format ( self . _fileName ) ) self . _h5Group . close ( ) self . _h5Group = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fetch a query argument as a boolean . [CODESPLIT] def arg_bool ( name , default = False ) : v = request . args . get ( name , '' ) if not len ( v ) : return default return v in BOOL_TRUISH", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform actions before parent main window is closed [CODESPLIT] def closing_plugin ( self , cancelable = False ) : self . dialog_manager . close_all ( ) self . shell . exit_interpreter ( ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "it returns a 500 http response [CODESPLIT] def view_500 ( request , url = None ) : res = render_to_response ( \"500.html\" , context_instance = RequestContext ( request ) ) res . status_code = 500 return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shutdown process ( this method is also a signal handler ) [CODESPLIT] def stop ( self , dummy_signum = None , dummy_frame = None ) : logging . info ( 'Shutting down ...' ) self . socket . close ( ) sys . exit ( 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Logs out the current session by removing it from the cache . This is expected to only occur when a session has [CODESPLIT] def logout ( cache ) : cache . set ( flask . session [ 'auth0_key' ] , None ) flask . session . clear ( ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Erases n lines from the screen and moves the cursor up to follow [CODESPLIT] def erase_lines ( n = 1 ) : for _ in range ( n ) : print ( codes . cursor [ \"up\" ] , end = \"\" ) print ( codes . cursor [ \"eol\" ] , end = \"\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the location of the static data directory . [CODESPLIT] def staticdir ( ) : root = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( root , \"static\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a filter to the query [CODESPLIT] def filter ( self , f , operator = \"and\" ) : if self . _filtered : self . _filter_dsl . filter ( f ) else : self . _build_filtered_query ( f , operator ) return self", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a flatten version of the nested argument [CODESPLIT] def flatten ( nested ) : flat_return = list ( ) def __inner_flat ( nested , flat ) : for i in nested : __inner_flat ( i , flat ) if isinstance ( i , list ) else flat . append ( i ) return flat __inner_flat ( nested , flat_return ) return flat_return", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Merge all the PDF files in pdf_filepaths in a new PDF file out_filepath . [CODESPLIT] def merge_pdfs ( pdf_filepaths , out_filepath ) : merger = PdfFileMerger ( ) for pdf in pdf_filepaths : merger . append ( PdfFileReader ( open ( pdf , 'rb' ) ) ) merger . write ( out_filepath ) return out_filepath", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flat nested list of lists into a single list . [CODESPLIT] def flatten ( l , types = ( list , float ) ) : l = [ item if isinstance ( item , types ) else [ item ] for item in l ] return [ item for sublist in l for item in sublist ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Merge any number of dictionaries [CODESPLIT] def merge_dict ( data , * args ) : results = { } for current in ( data , ) + args : results . update ( current ) return results", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flatten a nested list by yielding its scalar items . [CODESPLIT] def flatten ( nested , containers = ( list , tuple ) ) : for item in nested : if hasattr ( item , \"next\" ) or isinstance ( item , containers ) : for subitem in flatten ( item ) : yield subitem else : yield item", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty Prints seconds as Hours : Minutes : Seconds . MilliSeconds [CODESPLIT] def pprint ( self , seconds ) : return ( \"%d:%02d:%02d.%03d\" , reduce ( lambda ll , b : divmod ( ll [ 0 ] , b ) + ll [ 1 : ] , [ ( seconds * 1000 , ) , 1000 , 60 , 60 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a multi - dimensional array and returns a 1 dimensional array with the same contents . [CODESPLIT] def flatten_array ( grid ) : grid = [ grid [ i ] [ j ] for i in range ( len ( grid ) ) for j in range ( len ( grid [ i ] ) ) ] while type ( grid [ 0 ] ) is list : grid = flatten_array ( grid ) return grid", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Special case of version () when the executable is a JAR file . [CODESPLIT] def version_jar ( self ) : cmd = config . get_command ( 'java' ) cmd . append ( '-jar' ) cmd += self . cmd self . version ( cmd = cmd , path = self . cmd [ 0 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a list possibly nested to any level return it flattened . [CODESPLIT] def flatten ( lis ) : new_lis = [ ] for item in lis : if isinstance ( item , collections . Sequence ) and not isinstance ( item , basestring ) : new_lis . extend ( flatten ( item ) ) else : new_lis . append ( item ) return new_lis", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clears the console . [CODESPLIT] def clear ( ) : if sys . platform . startswith ( \"win\" ) : call ( \"cls\" , shell = True ) else : call ( \"clear\" , shell = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Nested lists to single - level list does not split strings [CODESPLIT] def flatten_list ( l ) : return list ( chain . from_iterable ( repeat ( x , 1 ) if isinstance ( x , str ) else x for x in l ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of all parsed comments in a file . Mostly for testing & interactive use . [CODESPLIT] def parse_comments_for_file ( filename ) : return [ parse_comment ( strip_stars ( comment ) , next_line ) for comment , next_line in get_doc_comments ( read_file ( filename ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a float returns a rounded int . Should give the same result on both Py2 / 3 [CODESPLIT] def intround ( value ) : return int ( decimal . Decimal . from_float ( value ) . to_integral_value ( decimal . ROUND_HALF_EVEN ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Try to flush all stdio buffers both from python and from C . [CODESPLIT] def flush ( ) : try : sys . stdout . flush ( ) sys . stderr . flush ( ) except ( AttributeError , ValueError , IOError ) : pass # unsupported try : libc . fflush ( None ) except ( AttributeError , ValueError , IOError ) : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize and compare XML documents for equality . The document may or may not be a DataONE type . [CODESPLIT] def are_equal_xml ( a_xml , b_xml ) : a_dom = xml . dom . minidom . parseString ( a_xml ) b_dom = xml . dom . minidom . parseString ( b_xml ) return are_equal_elements ( a_dom . documentElement , b_dom . documentElement )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Safely convert a single number to integer . [CODESPLIT] def safe_int_conv ( number ) : try : return int ( np . array ( number ) . astype ( int , casting = 'safe' ) ) except TypeError : raise ValueError ( 'cannot safely convert {} to integer' . format ( number ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove duplicates from a sequence ( of hashable items ) while maintaining order . NOTE : This only works if items in the list are hashable types . [CODESPLIT] def dedupe ( items ) : seen = set ( ) for item in items : if item not in seen : yield item seen . add ( item )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Daemonize the running process . [CODESPLIT] def go_to_background ( ) : try : if os . fork ( ) : sys . exit ( ) except OSError as errmsg : LOGGER . error ( 'Fork failed: {0}' . format ( errmsg ) ) sys . exit ( 'Fork failed' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add Builders and construction variables for SGI MIPS C ++ to an Environment . [CODESPLIT] def generate ( env ) : cplusplus . generate ( env ) env [ 'CXX' ] = 'CC' env [ 'CXXFLAGS' ] = SCons . Util . CLVar ( '-LANG:std' ) env [ 'SHCXX' ] = '$CXX' env [ 'SHOBJSUFFIX' ] = '.o' env [ 'STATIC_AND_SHARED_OBJECTS_ARE_THE_SAME' ] = 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts each multiline string in a table to single line . [CODESPLIT] def multis_2_mono ( table ) : for row in range ( len ( table ) ) : for column in range ( len ( table [ row ] ) ) : table [ row ] [ column ] = table [ row ] [ column ] . replace ( '\\n' , ' ' ) return table", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": type s str [CODESPLIT] def safe_format ( s , * * kwargs ) : return string . Formatter ( ) . vformat ( s , ( ) , defaultdict ( str , * * kwargs ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine the number of leaves in a tree [CODESPLIT] def num_leaves ( tree ) : if tree . is_leaf : return 1 else : return num_leaves ( tree . left_child ) + num_leaves ( tree . right_child )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A function to generate the latex representation of sympy expressions . [CODESPLIT] def print_latex ( o ) : if can_print_latex ( o ) : s = latex ( o , mode = 'plain' ) s = s . replace ( '\\\\dag' , '\\\\dagger' ) s = s . strip ( '$' ) return '$$%s$$' % s # Fallback to the string printer return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compiles to native Python bytecode and runs program returning the topmost value on the stack . [CODESPLIT] def xeval ( source , optimize = True ) : native = xcompile ( source , optimize = optimize ) return native ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a repr () for a list / tuple [CODESPLIT] def _tuple_repr ( data ) : if len ( data ) == 1 : return \"(%s,)\" % rpr ( data [ 0 ] ) else : return \"(%s)\" % \", \" . join ( [ rpr ( x ) for x in data ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert an ARF timestamp to a datetime . datetime object ( naive local time ) [CODESPLIT] def timestamp_to_datetime ( timestamp ) : from datetime import datetime , timedelta obj = datetime . fromtimestamp ( timestamp [ 0 ] ) return obj + timedelta ( microseconds = int ( timestamp [ 1 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a virtual concatenate of several NumPy arrays . [CODESPLIT] def _concatenate_virtual_arrays ( arrs , cols = None , scaling = None ) : return None if not len ( arrs ) else ConcatenatedArrays ( arrs , cols , scaling = scaling )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given an object with a docstring return the first line of the docstring [CODESPLIT] def short_description ( func ) : doc = inspect . getdoc ( func ) if doc is not None : doc = inspect . cleandoc ( doc ) lines = doc . splitlines ( ) return lines [ 0 ] return \"\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a virtual concatenate of several NumPy arrays . [CODESPLIT] def _concatenate_virtual_arrays ( arrs , cols = None , scaling = None ) : return None if not len ( arrs ) else ConcatenatedArrays ( arrs , cols , scaling = scaling )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the billing cycle prior to this one . May return None [CODESPLIT] def get_previous ( self ) : return BillingCycle . objects . filter ( date_range__lt = self . date_range ) . order_by ( 'date_range' ) . last ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a virtual concatenate of several NumPy arrays . [CODESPLIT] def _concatenate_virtual_arrays ( arrs , cols = None , scaling = None ) : return None if not len ( arrs ) else ConcatenatedArrays ( arrs , cols , scaling = scaling )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds passed value to node s globals [CODESPLIT] def set_global ( node : Node , key : str , value : Any ) : node . node_globals [ key ] = value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if given value is a list tries to convert if it is not . [CODESPLIT] def to_list ( var ) : if var is None : return [ ] if isinstance ( var , str ) : var = var . split ( '\\n' ) elif not isinstance ( var , list ) : try : var = list ( var ) except TypeError : raise ValueError ( \"{} cannot be converted to the list.\" . format ( var ) ) return var", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove punctuation from string s . [CODESPLIT] def unpunctuate ( s , * , char_blacklist = string . punctuation ) : # remove punctuation s = \"\" . join ( c for c in s if c not in char_blacklist ) # remove consecutive spaces return \" \" . join ( filter ( None , s . split ( \" \" ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a conda environment inside the current sandbox for the given list of dependencies and options . [CODESPLIT] def create_conda_env ( sandbox_dir , env_name , dependencies , options = ( ) ) : env_dir = os . path . join ( sandbox_dir , env_name ) cmdline = [ \"conda\" , \"create\" , \"--yes\" , \"--copy\" , \"--quiet\" , \"-p\" , env_dir ] + list ( options ) + dependencies log . info ( \"Creating conda environment: \" ) log . info ( \"  command line: %s\" , cmdline ) subprocess . check_call ( cmdline , stderr = subprocess . PIPE , stdout = subprocess . PIPE ) log . debug ( \"Environment created\" ) return env_dir , env_name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return minimal quantum of a number as defined by precision . [CODESPLIT] def get_decimal_quantum ( precision ) : assert isinstance ( precision , ( int , decimal . Decimal ) ) return decimal . Decimal ( 10 ) ** ( - precision )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Expand the request URL for a request . [CODESPLIT] def get_url ( self , cmd , * * args ) : return self . http . base_url + self . _mkurl ( cmd , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generator for reading from standard input in nonblocking mode . [CODESPLIT] def _read_stdin ( ) : line = sys . stdin . readline ( ) while line : yield line line = sys . stdin . readline ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a list of ( key value ) pairs and turns it into a dict . [CODESPLIT] def list2dict ( lst ) : dic = { } for k , v in lst : dic [ k ] = v return dic", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A standard compound hash . [CODESPLIT] def double_sha256 ( data ) : return bytes_as_revhex ( hashlib . sha256 ( hashlib . sha256 ( data ) . digest ( ) ) . digest ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply 2to3 tool ( Python2 to Python3 conversion tool ) to Python sources . [CODESPLIT] def command_py2to3 ( args ) : from lib2to3 . main import main sys . exit ( main ( \"lib2to3.fixes\" , args = args . sources ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield one date per day from starting date to ending date . [CODESPLIT] def daterange ( start_date , end_date ) : for n in range ( int ( ( end_date - start_date ) . days ) ) : yield start_date + timedelta ( n )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string of a calculation energy e . g . - 1 . 2345 eV to a float . [CODESPLIT] def energy_string_to_float ( string ) : energy_re = re . compile ( \"(-?\\d+\\.\\d+)\" ) return float ( energy_re . match ( string ) . group ( 0 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate report from a campaign [CODESPLIT] def render ( template = None , ostr = None , * * kwargs ) : jinja_environment . filters [ 'texscape' ] = tex_escape template = template or DEFAULT_TEMPLATE ostr = ostr or sys . stdout jinja_template = jinja_environment . get_template ( template ) jinja_template . stream ( * * kwargs ) . dump ( ostr )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads the date from a string in the format YYYY / MM / DD and returns : class : datetime . date [CODESPLIT] def _read_date_from_string ( str1 ) : full_date = [ int ( x ) for x in str1 . split ( '/' ) ] return datetime . date ( full_date [ 0 ] , full_date [ 1 ] , full_date [ 2 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convolve 2d gaussian . [CODESPLIT] def convolve_gaussian_2d ( image , gaussian_kernel_1d ) : result = scipy . ndimage . filters . correlate1d ( image , gaussian_kernel_1d , axis = 0 ) result = scipy . ndimage . filters . correlate1d ( result , gaussian_kernel_1d , axis = 1 ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A handy wrapper to get a remote file content [CODESPLIT] def get_remote_content ( filepath ) : with hide ( 'running' ) : temp = BytesIO ( ) get ( filepath , temp ) content = temp . getvalue ( ) . decode ( 'utf-8' ) return content . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get element by name [CODESPLIT] def get_by ( self , name ) : return next ( ( item for item in self if item . name == name ) , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the angle between vectors a and b in degrees . [CODESPLIT] def angle ( x , y ) : return arccos ( dot ( x , y ) / ( norm ( x ) * norm ( y ) ) ) * 180. / pi", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn an SQLAlchemy model into a dict of field names and values . [CODESPLIT] def object_as_dict ( obj ) : return { c . key : getattr ( obj , c . key ) for c in inspect ( obj ) . mapper . column_attrs }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates the cosine similarity between this vector and another vector . [CODESPLIT] def similarity ( self , other ) : if self . magnitude == 0 or other . magnitude == 0 : return 0 return self . dot ( other ) / self . magnitude", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return relevant twitter timeline [CODESPLIT] def twitter_timeline ( screen_name , since_id = None ) : consumer_key = twitter_credential ( 'consumer_key' ) consumer_secret = twitter_credential ( 'consumer_secret' ) access_token = twitter_credential ( 'access_token' ) access_token_secret = twitter_credential ( 'access_secret' ) auth = tweepy . OAuthHandler ( consumer_key , consumer_secret ) auth . set_access_token ( access_token , access_token_secret ) api = tweepy . API ( auth ) return get_all_tweets ( screen_name , api , since_id )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a copy of seq without duplicates . [CODESPLIT] def uniq ( seq ) : seen = set ( ) return [ x for x in seq if str ( x ) not in seen and not seen . add ( str ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Python version independent function to obtain the parameters of a typing . Callable object . Returns as tuple : args result . Tested with CPython 2 . 7 3 . 5 3 . 6 and Jython 2 . 7 . 1 . [CODESPLIT] def get_Callable_args_res ( clb ) : try : return clb . __args__ , clb . __result__ except AttributeError : # Python 3.6 return clb . __args__ [ : - 1 ] , clb . __args__ [ - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generates a count of the number of times each unique item appears in a list [CODESPLIT] def count_list ( the_list ) : count = the_list . count result = [ ( item , count ( item ) ) for item in set ( the_list ) ] result . sort ( ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Count the number of rows in 2D arrays that contain any nan values . [CODESPLIT] def count_rows_with_nans ( X ) : if X . ndim == 2 : return np . where ( np . isnan ( X ) . sum ( axis = 1 ) != 0 , 1 , 0 ) . sum ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates the cosine similarity between this vector and another vector . [CODESPLIT] def similarity ( self , other ) : if self . magnitude == 0 or other . magnitude == 0 : return 0 return self . dot ( other ) / self . magnitude", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": type root : TreeNode : rtype : int [CODESPLIT] def min_depth ( self , root ) : if root is None : return 0 if root . left is not None or root . right is not None : return max ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1 return min ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute entropy on the string [CODESPLIT] def entropy ( string ) : p , lns = Counter ( string ) , float ( len ( string ) ) return - sum ( count / lns * math . log ( count / lns , 2 ) for count in p . values ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list of names of columns that are string type . [CODESPLIT] def _get_str_columns ( sf ) : return [ name for name in sf . column_names ( ) if sf [ name ] . dtype == str ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the number of characters at the beginning of text that are whitespace . [CODESPLIT] def _count_leading_whitespace ( text ) : idx = 0 for idx , char in enumerate ( text ) : if not char . isspace ( ) : return idx return idx + 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Collect digits from a string [CODESPLIT] def str2int ( string_with_int ) : return int ( \"\" . join ( [ char for char in string_with_int if char in string . digits ] ) or 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert input argument to bytes [CODESPLIT] def str2bytes ( x ) : if type ( x ) is bytes : return x elif type ( x ) is str : return bytes ( [ ord ( i ) for i in x ] ) else : return str2bytes ( str ( x ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a tuple that contains ( width height ) Pass in a url to an image and find out its size without loading the whole file If the image wxh could not be found the tuple will contain None values [CODESPLIT] def get_image_dimension ( self , url ) : w_h = ( None , None ) try : if url . startswith ( '//' ) : url = 'http:' + url data = requests . get ( url ) . content im = Image . open ( BytesIO ( data ) ) w_h = im . size except Exception : logger . warning ( \"Error getting image size {}\" . format ( url ) , exc_info = True ) return w_h", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This routine returns the 3x3 identity matrix . [CODESPLIT] def ident ( ) : matrix = stypes . emptyDoubleMatrix ( ) libspice . ident_c ( matrix ) return stypes . cMatrixToNumpy ( matrix )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Display the first and last n elements of a DataFrame . [CODESPLIT] def head_and_tail_print ( self , n = 5 ) : from IPython import display display . display ( display . HTML ( self . _head_and_tail_table ( n ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute entropy on the string [CODESPLIT] def entropy ( string ) : p , lns = Counter ( string ) , float ( len ( string ) ) return - sum ( count / lns * math . log ( count / lns , 2 ) for count in p . values ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Performs a join using the union join function . [CODESPLIT] def merge ( left , right , how = 'inner' , key = None , left_key = None , right_key = None , left_as = 'left' , right_as = 'right' ) : return join ( left , right , how , key , left_key , right_key , join_fn = make_union_join ( left_as , right_as ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return first occurrence matching f otherwise None [CODESPLIT] def findfirst ( f , coll ) : result = list ( dropwhile ( f , coll ) ) return result [ 0 ] if result else None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a list of points to a Path composed of lines connecting those points ( i . e . a linear spline or polyline ) . See also polygon () . [CODESPLIT] def polyline ( * points ) : return Path ( * [ Line ( points [ i ] , points [ i + 1 ] ) for i in range ( len ( points ) - 1 ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a generator that spits an iteratable into n - sized chunks . The last chunk may have less than n elements . [CODESPLIT] def split_every ( n , iterable ) : items = iter ( iterable ) return itertools . takewhile ( bool , ( list ( itertools . islice ( items , n ) ) for _ in itertools . count ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transforms a list of 2 element tuples to a dictionary [CODESPLIT] def list2dict ( list_of_options ) : d = { } for key , value in list_of_options : d [ key ] = value return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return frequencies for DFT [CODESPLIT] def fft_freqs ( n_fft , fs ) : return np . arange ( 0 , ( n_fft // 2 + 1 ) ) / float ( n_fft ) * float ( fs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a name which includes the module name and function name . [CODESPLIT] def get_func_name ( func ) : func_name = getattr ( func , '__name__' , func . __class__ . __name__ ) module_name = func . __module__ if module_name is not None : module_name = func . __module__ return '{}.{}' . format ( module_name , func_name ) return func_name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a sympy . Symbol with positive and integer assumptions . [CODESPLIT] def symbol_pos_int ( * args , * * kwargs ) : kwargs . update ( { 'positive' : True , 'integer' : True } ) return sympy . Symbol ( * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "As a convenience turn Python lists and tuples into NumPy arrays . [CODESPLIT] def _to_array ( value ) : if isinstance ( value , ( tuple , list ) ) : return array ( value ) elif isinstance ( value , ( float , int ) ) : return np . float64 ( value ) else : return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the value of a local variable somewhere in the call stack . [CODESPLIT] def getvariable ( name ) : import inspect fr = inspect . currentframe ( ) try : while fr : fr = fr . f_back vars = fr . f_locals if name in vars : return vars [ name ] except : pass return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a n + 1 dim one - hot array from n dim int - categorical array . [CODESPLIT] def one_hot ( x , size , dtype = np . float32 ) : return np . array ( x [ ... , np . newaxis ] == np . arange ( size ) , dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fetch an image from url and convert it into a Pillow Image object [CODESPLIT] def url_to_image ( url ) : r = requests . get ( url ) image = StringIO ( r . content ) return image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Temporary helper function to link to the API routes [CODESPLIT] def home ( ) : return dict ( links = dict ( api = '{}{}' . format ( request . url , PREFIX [ 1 : ] ) ) ) , HTTPStatus . OK", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return the key from the request [CODESPLIT] def get ( key , default = None ) : data = get_form ( ) or get_query_string ( ) return data . get ( key , default )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Debug a single doctest docstring in argument src [CODESPLIT] def debug_src ( src , pm = False , globs = None ) : testsrc = script_from_examples ( src ) debug_script ( testsrc , pm , globs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def difference ( ydata1 , ydata2 ) : y1 = _n . array ( ydata1 ) y2 = _n . array ( ydata2 ) return ( sum ( y2 - y1 ) / len ( ydata1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert numpy arrays of features and labels into an RDD of pairs . [CODESPLIT] def to_simple_rdd ( sc , features , labels ) : pairs = [ ( x , y ) for x , y in zip ( features , labels ) ] return sc . parallelize ( pairs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list of string names of all available GPUs [CODESPLIT] def get_available_gpus ( ) : local_device_protos = device_lib . list_local_devices ( ) return [ x . name for x in local_device_protos if x . device_type == 'GPU' ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A block of standard 2d convolutions . [CODESPLIT] def conv_block ( inputs , filters , dilation_rates_and_kernel_sizes , * * kwargs ) : return conv_block_internal ( conv , inputs , filters , dilation_rates_and_kernel_sizes , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns ( module locals ) of the funciton depth frames away from the caller [CODESPLIT] def extract_module_locals ( depth = 0 ) : f = sys . _getframe ( depth + 1 ) global_ns = f . f_globals module = sys . modules [ global_ns [ '__name__' ] ] return ( module , f . f_locals )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the MD5 hash for a file . [CODESPLIT] def get_file_md5sum ( path ) : with open ( path , 'rb' ) as fh : h = str ( hashlib . md5 ( fh . read ( ) ) . hexdigest ( ) ) return h", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Draw the voronoi tesselation of the points [CODESPLIT] def voronoi ( data , line_color = None , line_width = 2 , f_tooltip = None , cmap = None , max_area = 1e4 , alpha = 220 ) : from geoplotlib . layers import VoronoiLayer _global_config . layers . append ( VoronoiLayer ( data , line_color , line_width , f_tooltip , cmap , max_area , alpha ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the memory byte size of a Numpy array as an integer . [CODESPLIT] def bytesize ( arr ) : byte_size = np . prod ( arr . shape ) * np . dtype ( arr . dtype ) . itemsize return byte_size", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Assuming format YYYY - MM - DD hh : mm : ss [CODESPLIT] def _elapsed_time ( begin_time , end_time ) : bt = _str2datetime ( begin_time ) et = _str2datetime ( end_time ) return float ( ( et - bt ) . seconds )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a list of JSON values to a list of models [CODESPLIT] def from_json_list ( cls , api_client , data ) : return [ cls . from_json ( api_client , item ) for item in data ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the variable set with the given name . [CODESPLIT] def get_var ( self , name ) : for var in self . vars : if var . name == name : return var else : raise ValueError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a python string to c array . [CODESPLIT] def c_array ( ctype , values ) : if isinstance ( values , np . ndarray ) and values . dtype . itemsize == ctypes . sizeof ( ctype ) : return ( ctype * len ( values ) ) . from_buffer_copy ( values ) return ( ctype * len ( values ) ) ( * values )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the name of this node or its class name . [CODESPLIT] def node__name__ ( self ) : return self . node . __name__ if self . node . __name__ is not None else self . node . __class__ . __name__", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a ctypes void pointer to the memory mapped region . [CODESPLIT] def pointer ( self ) : return ctypes . cast ( ctypes . pointer ( ctypes . c_uint8 . from_buffer ( self . mapping , 0 ) ) , ctypes . c_void_p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load an object from a module by name [CODESPLIT] def load_object_by_name ( object_name ) : mod_name , attr = object_name . rsplit ( '.' , 1 ) mod = import_module ( mod_name ) return getattr ( mod , attr )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function used to fit the exponential decay . [CODESPLIT] def exp_fit_fun ( x , a , tau , c ) : # pylint: disable=invalid-name return a * np . exp ( - x / tau ) + c", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the length in bytes of a given file object . Necessary because os . fstat only works on real files and not file - like objects . This works on more types of streams primarily StringIO . [CODESPLIT] def file_length ( file_obj ) : file_obj . seek ( 0 , 2 ) length = file_obj . tell ( ) file_obj . seek ( 0 ) return length", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a grayscale image to BGR image . [CODESPLIT] def gray2bgr ( img ) : img = img [ ... , None ] if img . ndim == 2 else img out_img = cv2 . cvtColor ( img , cv2 . COLOR_GRAY2BGR ) return out_img", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs command and returns the output as string . [CODESPLIT] def check_output ( args ) : log . debug ( 'run: %s' , args ) out = subprocess . check_output ( args = args ) . decode ( 'utf-8' ) log . debug ( 'out: %r' , out ) return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Downloads and returns the full text of a particular page in the document . [CODESPLIT] def get_page_text ( self , page ) : url = self . get_page_text_url ( page ) return self . _get_url ( url )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert to datetime to UTC offset . [CODESPLIT] def convert_2_utc ( self , datetime_ , timezone ) : datetime_ = self . tz_mapper [ timezone ] . localize ( datetime_ ) return datetime_ . astimezone ( pytz . UTC )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Finds parent folder of file [CODESPLIT] def get_parent_folder_name ( file_path ) : return os . path . split ( os . path . split ( os . path . abspath ( file_path ) ) [ 0 ] ) [ - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts python datetime to epoch microseconds . [CODESPLIT] def _DateToEpoch ( date ) : tz_zero = datetime . datetime . utcfromtimestamp ( 0 ) diff_sec = int ( ( date - tz_zero ) . total_seconds ( ) ) return diff_sec * 1000000", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the path of font project directory . [CODESPLIT] def family_directory ( fonts ) : if fonts : dirname = os . path . dirname ( fonts [ 0 ] ) if dirname == '' : dirname = '.' return dirname", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print security object information for a pdf document [CODESPLIT] def security ( self ) : return { k : v for i in self . pdf . resolvedObjects . items ( ) for k , v in i [ 1 ] . items ( ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Integer to two bytes [CODESPLIT] def intToBin ( i ) : # devide in two parts (bytes) i1 = i % 256 i2 = int ( i / 256 ) # make string (little endian) return chr ( i1 ) + chr ( i2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper property containing the percentage this slider is filled . This property is read - only . [CODESPLIT] def p ( self ) : return ( self . n - self . nmin ) / max ( ( self . nmax - self . nmin ) , 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if value can be part of binary / bitwise operations . [CODESPLIT] def isbinary ( * args ) : return all ( map ( lambda c : isnumber ( c ) or isbool ( c ) , args ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator which adds extra functions to be downloaded to the pyboard . [CODESPLIT] def extra_funcs ( * funcs ) : def extra_funcs_decorator ( real_func ) : def wrapper ( * args , * * kwargs ) : return real_func ( * args , * * kwargs ) wrapper . extra_funcs = list ( funcs ) wrapper . source = inspect . getsource ( real_func ) wrapper . name = real_func . __name__ return wrapper return extra_funcs_decorator", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a csv and returns a List of Dicts with keys given by header row . [CODESPLIT] def csv_to_dicts ( file , header = None ) : with open ( file ) as csvfile : return [ row for row in csv . DictReader ( csvfile , fieldnames = header ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns this programs current memory usage in bytes [CODESPLIT] def current_memory_usage ( ) : import psutil proc = psutil . Process ( os . getpid ( ) ) #meminfo = proc.get_memory_info() meminfo = proc . memory_info ( ) rss = meminfo [ 0 ] # Resident Set Size / Mem Usage vms = meminfo [ 1 ] # Virtual Memory Size / VM Size  # NOQA return rss", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple measure of similarity : Number of letters in common / max length [CODESPLIT] def basic_word_sim ( word1 , word2 ) : return sum ( [ 1 for c in word1 if c in word2 ] ) / max ( len ( word1 ) , len ( word2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove a value from a dict . [CODESPLIT] def remove ( parent , idx ) : if isinstance ( parent , dict ) : del parent [ idx ] elif isinstance ( parent , list ) : del parent [ int ( idx ) ] else : raise JSONPathError ( \"Invalid path for operation\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a copy of the list without duplicates . [CODESPLIT] def unique ( list ) : unique = [ ] [ unique . append ( x ) for x in list if x not in unique ] return unique", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove null items from a dictionary [CODESPLIT] def purge_dict ( idict ) : odict = { } for key , val in idict . items ( ) : if is_null ( val ) : continue odict [ key ] = val return odict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove decoded instruction from instruction cache [CODESPLIT] def invalidate_cache ( cpu , address , size ) : cache = cpu . instruction_cache for offset in range ( size ) : if address + offset in cache : del cache [ address + offset ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a tuple of option taking possible presence of level into account [CODESPLIT] def option2tuple ( opt ) : if isinstance ( opt [ 0 ] , int ) : tup = opt [ 1 ] , opt [ 2 : ] else : tup = opt [ 0 ] , opt [ 1 : ] return tup", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs a shell command returns console output . [CODESPLIT] def _run_cmd_get_output ( cmd ) : process = subprocess . Popen ( cmd . split ( ) , stdout = subprocess . PIPE ) out , err = process . communicate ( ) return out or err", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete all the files and subdirectories in a directory . [CODESPLIT] def clean_out_dir ( directory ) : if not isinstance ( directory , path ) : directory = path ( directory ) for file_path in directory . files ( ) : file_path . remove ( ) for dir_path in directory . dirs ( ) : dir_path . rmtree ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get terminal width [CODESPLIT] def get_width ( ) : # Get terminal size ws = struct . pack ( \"HHHH\" , 0 , 0 , 0 , 0 ) ws = fcntl . ioctl ( sys . stdout . fileno ( ) , termios . TIOCGWINSZ , ws ) lines , columns , x , y = struct . unpack ( \"HHHH\" , ws ) width = min ( columns * 39 // 40 , columns - 2 ) return width", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return a normalized version of abmn [CODESPLIT] def _normalize_abmn ( abmn ) : abmn_2d = np . atleast_2d ( abmn ) abmn_normalized = np . hstack ( ( np . sort ( abmn_2d [ : , 0 : 2 ] , axis = 1 ) , np . sort ( abmn_2d [ : , 2 : 4 ] , axis = 1 ) , ) ) return abmn_normalized", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a symmetrical binary tree with [CODESPLIT] def make_bintree ( levels ) : G = nx . DiGraph ( ) root = '0' G . add_node ( root ) add_children ( G , root , levels , 2 ) return G", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the smallest index of the row ( s ) with this column equal to value . [CODESPLIT] def index ( self , value ) : for i in xrange ( len ( self . parentNode ) ) : if getattr ( self . parentNode [ i ] , self . Name ) == value : return i raise ValueError ( value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the item at the given index . [CODESPLIT] def __getitem__ ( self , index ) : row , col = index return self . rows [ row ] [ col ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Refresh the screen . You don t need to override this except to update only small portins of the screen . [CODESPLIT] def update_screen ( self ) : self . clock . tick ( self . FPS ) pygame . display . update ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the RMS of the audio [CODESPLIT] def calc_volume ( self , sample : np . ndarray ) : return sqrt ( np . mean ( np . square ( sample ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Try to determine the local IP address of the machine . [CODESPLIT] def _get_local_ip ( self ) : try : sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) # Use Google Public DNS server to determine own IP sock . connect ( ( '8.8.8.8' , 80 ) ) return sock . getsockname ( ) [ 0 ] except socket . error : try : return socket . gethostbyname ( socket . gethostname ( ) ) except socket . gaierror : return '127.0.0.1' finally : sock . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to get the location of a Python file . [CODESPLIT] def getScriptLocation ( ) : location = os . path . abspath ( \"./\" ) if __file__ . rfind ( \"/\" ) != - 1 : location = __file__ [ : __file__ . rfind ( \"/\" ) ] return location", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of rows preceding the data table for * series * in the Excel worksheet . [CODESPLIT] def series_table_row_offset ( self , series ) : title_and_spacer_rows = series . index * 2 data_point_rows = series . data_point_offset return title_and_spacer_rows + data_point_rows", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialize an API . [CODESPLIT] def initialize_api ( flask_app ) : if not flask_restplus : return api = flask_restplus . Api ( version = \"1.0\" , title = \"My Example API\" ) api . add_resource ( HelloWorld , \"/hello\" ) blueprint = flask . Blueprint ( \"api\" , __name__ , url_prefix = \"/api\" ) api . init_app ( blueprint ) flask_app . register_blueprint ( blueprint )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the name of an object including the module name if available . [CODESPLIT] def class_name ( obj ) : name = obj . __name__ module = getattr ( obj , '__module__' ) if module : name = f'{module}.{name}' return name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Instantiate the given extension class and register as a public attribute of the given base . [CODESPLIT] def register_extension_class ( ext , base , * args , * * kwargs ) : ext_instance = ext . plugin ( base , * args , * * kwargs ) setattr ( base , ext . name . lstrip ( '_' ) , ext_instance )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the size of a multidimansional array . [CODESPLIT] def array_dim ( arr ) : dim = [ ] while True : try : dim . append ( len ( arr ) ) arr = arr [ 0 ] except TypeError : return dim", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a get_content generator for top submissions . [CODESPLIT] def get_top ( self , * args , * * kwargs ) : return self . get_content ( self . config [ 'top' ] , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The url of this window [CODESPLIT] def url ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . url", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The size of this parameter equivalent to self . value . size [CODESPLIT] def size ( self ) : return np . multiply . reduce ( self . shape , dtype = np . int32 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "read a simple text file from a private location to get username and password [CODESPLIT] def read_credentials ( fname ) : with open ( fname , 'r' ) as f : username = f . readline ( ) . strip ( '\\n' ) password = f . readline ( ) . strip ( '\\n' ) return username , password", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Array of vector lengths [CODESPLIT] def length ( self ) : return np . sqrt ( np . sum ( self ** 2 , axis = 1 ) ) . view ( np . ndarray )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve a User object by ID . [CODESPLIT] def get_user_by_id ( self , id ) : return self . db_adapter . get_object ( self . UserClass , id = id )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Joins a voice channel [CODESPLIT] async def join ( self , ctx , * , channel : discord . VoiceChannel ) : if ctx . voice_client is not None : return await ctx . voice_client . move_to ( channel ) await channel . connect ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load an object from a module by name [CODESPLIT] def load_object_by_name ( object_name ) : mod_name , attr = object_name . rsplit ( '.' , 1 ) mod = import_module ( mod_name ) return getattr ( mod , attr )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Joins a voice channel [CODESPLIT] async def join ( self , ctx , * , channel : discord . VoiceChannel ) : if ctx . voice_client is not None : return await ctx . voice_client . move_to ( channel ) await channel . connect ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Main window move event [CODESPLIT] def OnMove ( self , event ) : # Store window position in config position = self . main_window . GetScreenPositionTuple ( ) config [ \"window_position\" ] = repr ( position )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handle user name changes [CODESPLIT] def _handle_chat_name ( self , data ) : self . room . user . nick = data self . conn . enqueue_data ( \"user\" , self . room . user )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determines the height and width of the console window [CODESPLIT] def size ( ) : try : assert os != 'nt' and sys . stdout . isatty ( ) rows , columns = os . popen ( 'stty size' , 'r' ) . read ( ) . split ( ) except ( AssertionError , AttributeError , ValueError ) : # in case of failure, use dimensions of a full screen 13\" laptop rows , columns = DEFAULT_HEIGHT , DEFAULT_WIDTH return int ( rows ) , int ( columns )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the absolute position of table top [CODESPLIT] def table_top_abs ( self ) : table_height = np . array ( [ 0 , 0 , self . table_full_size [ 2 ] ] ) return string_to_array ( self . floor . get ( \"pos\" ) ) + table_height", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Used for generating thumbnails . Does not include overlaid graphics . [CODESPLIT] def get_plain_image_as_widget ( self ) : arr = self . getwin_array ( order = self . rgb_order ) image = self . _get_qimage ( arr , self . qimg_fmt ) return image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return list of Logger classes . [CODESPLIT] def _get_loggers ( ) : from . . import loader modules = loader . get_package_modules ( 'logger' ) return list ( loader . get_plugins ( modules , [ _Logger ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get width and height of a PDF [CODESPLIT] def dimensions ( self ) : size = self . pdf . getPage ( 0 ) . mediaBox return { 'w' : float ( size [ 2 ] ) , 'h' : float ( size [ 3 ] ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This parallel fetcher uses gevent one uses gevent [CODESPLIT] def fetch_event ( urls ) : rs = ( grequests . get ( u ) for u in urls ) return [ content . json ( ) for content in grequests . map ( rs ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This parallel fetcher uses gevent one uses gevent [CODESPLIT] def fetch_event ( urls ) : rs = ( grequests . get ( u ) for u in urls ) return [ content . json ( ) for content in grequests . map ( rs ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Because standard distinct used on the all fields are very slow and works only with PostgreSQL database this method provides alternative to the standard distinct method . : return : qs with unique objects [CODESPLIT] def fast_distinct ( self ) : return self . model . objects . filter ( pk__in = self . values_list ( 'pk' , flat = True ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tries to encode images with ffmpeg to check if it works . [CODESPLIT] def ffmpeg_works ( ) : images = np . zeros ( ( 2 , 32 , 32 , 3 ) , dtype = np . uint8 ) try : _encode_gif ( images , 2 ) return True except ( IOError , OSError ) : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run manage . py using this component s specific Django settings [CODESPLIT] def managepy ( cmd , extra = None ) : extra = extra . split ( ) if extra else [ ] run_django_cli ( [ 'invoke' , cmd ] + extra )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "All branches in a list [CODESPLIT] def branches ( self ) : result = self . git ( self . default + [ 'branch' , '-a' , '--no-color' ] ) return [ l . strip ( ' *\\n' ) for l in result . split ( '\\n' ) if l . strip ( ' *\\n' ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the Fully Qualified Name from an instance or class . [CODESPLIT] def get_qualified_name ( _object ) : module = _object . __module__ if hasattr ( _object , '__name__' ) : _class = _object . __name__ else : _class = _object . __class__ . __name__ return module + '.' + _class", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates the distance between two points on earth . [CODESPLIT] def _calculate_distance ( latlon1 , latlon2 ) : lat1 , lon1 = latlon1 lat2 , lon2 = latlon2 dlon = lon2 - lon1 dlat = lat2 - lat1 R = 6371 # radius of the earth in kilometers a = np . sin ( dlat / 2 ) ** 2 + np . cos ( lat1 ) * np . cos ( lat2 ) * ( np . sin ( dlon / 2 ) ) ** 2 c = 2 * np . pi * R * np . arctan2 ( np . sqrt ( a ) , np . sqrt ( 1 - a ) ) / 180 return c", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Overriding init so we can set the post vars like a normal form and generate the form the same way Django does . [CODESPLIT] def __init__ ( self , form_post_data = None , * args , * * kwargs ) : kwargs . update ( { 'form_post_data' : form_post_data } ) super ( MongoModelForm , self ) . __init__ ( * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print security object information for a pdf document [CODESPLIT] def security ( self ) : return { k : v for i in self . pdf . resolvedObjects . items ( ) for k , v in i [ 1 ] . items ( ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "transform object to json [CODESPLIT] def object_to_json ( obj , indent = 2 ) : instance_json = json . dumps ( obj , indent = indent , ensure_ascii = False , cls = DjangoJSONEncoder ) return instance_json", "target": 1, "target_options": ["no_match", "match"]}
{"input": "create a graphviz graph from text [CODESPLIT] def _text_to_graphiz ( self , text ) : dot = Source ( text , format = 'svg' ) return dot . pipe ( ) . decode ( 'utf-8' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a shared memory array with the same shape and type as a given array filled with value . [CODESPLIT] def full_like ( array , value , dtype = None ) : shared = empty_like ( array , dtype ) shared [ : ] = value return shared", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate standard deviation weighted by errors [CODESPLIT] def weighted_std ( values , weights ) : average = np . average ( values , weights = weights ) variance = np . average ( ( values - average ) ** 2 , weights = weights ) return np . sqrt ( variance )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check for existence of key in dict return value or raise error [CODESPLIT] def _check_conversion ( key , valid_dict ) : if key not in valid_dict and key not in valid_dict . values ( ) : # Only show users the nice string values keys = [ v for v in valid_dict . keys ( ) if isinstance ( v , string_types ) ] raise ValueError ( 'value must be one of %s, not %s' % ( keys , key ) ) return valid_dict [ key ] if key in valid_dict else key", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a section a subsection and some text to the document . [CODESPLIT] def fill_document ( doc ) : with doc . create ( Section ( 'A section' ) ) : doc . append ( 'Some regular text and some ' ) doc . append ( italic ( 'italic text. ' ) ) with doc . create ( Subsection ( 'A subsection' ) ) : doc . append ( 'Also some crazy characters: $&#{}' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts from hex to hsv [CODESPLIT] def hex_to_hsv ( color ) : color = normalize ( color ) color = color [ 1 : ] # color=tuple(ord(c)/255.0 for c in color.decode('hex')) color = ( int ( color [ 0 : 2 ] , base = 16 ) / 255.0 , int ( color [ 2 : 4 ] , base = 16 ) / 255.0 , int ( color [ 4 : 6 ] , base = 16 ) / 255.0 ) return colorsys . rgb_to_hsv ( * color )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a proper string that should work in both Py3 / Py2 [CODESPLIT] def polite_string ( a_string ) : if is_py3 ( ) and hasattr ( a_string , 'decode' ) : try : return a_string . decode ( 'utf-8' ) except UnicodeDecodeError : return a_string return a_string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if the given value is a function or method object . [CODESPLIT] def isfunc ( x ) : return any ( [ inspect . isfunction ( x ) and not asyncio . iscoroutinefunction ( x ) , inspect . ismethod ( x ) and not asyncio . iscoroutinefunction ( x ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a prettier version of obj [CODESPLIT] def _get_pretty_string ( obj ) : sio = StringIO ( ) pprint . pprint ( obj , stream = sio ) return sio . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This class overrides this method [CODESPLIT] def action ( self ) : self . return_value = self . function ( * self . args , * * self . kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Open a HTTP connection to the URL and return a file - like object . [CODESPLIT] def _open_url ( url ) : response = requests . get ( url , stream = True ) if response . status_code != 200 : raise IOError ( \"Unable to download {}, HTTP {}\" . format ( url , response . status_code ) ) return response", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the parent path and the path from the new parent path . [CODESPLIT] def set_parent_path ( self , value ) : self . _parent_path = value self . path = value + r'/' + self . name self . _update_childrens_parent_path ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Draw a horizontal line up to a given length . [CODESPLIT] def hline ( self , x , y , width , color ) : self . rect ( x , y , width , 1 , color , fill = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize time in arbitrary timezone to UTC naive object . [CODESPLIT] def normalize_time ( timestamp ) : offset = timestamp . utcoffset ( ) if offset is None : return timestamp return timestamp . replace ( tzinfo = None ) - offset", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Undo the scaling of X according to feature_range . [CODESPLIT] def inverse_transform ( self , X ) : X = check_array ( X , copy = self . copy ) X -= self . min_ X /= self . scale_ return X", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Qt slot when the window is closed . [CODESPLIT] def closeEvent ( self , e ) : self . emit ( 'close_widget' ) super ( DockWidget , self ) . closeEvent ( e )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wipe the store [CODESPLIT] def wipe ( self ) : keys = list ( self . keys ( ) ) . copy ( ) for key in keys : self . delete ( key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert naive datetime to timezone - aware datetime [CODESPLIT] def datetime_to_timezone ( date , tz = \"UTC\" ) : if not date . tzinfo : date = date . replace ( tzinfo = timezone ( get_timezone ( ) ) ) return date . astimezone ( timezone ( tz ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a legal python name for the given name for use as a unit key . [CODESPLIT] def unit_key_from_name ( name ) : result = name for old , new in six . iteritems ( UNIT_KEY_REPLACEMENTS ) : result = result . replace ( old , new ) # Collapse redundant underscores and convert to uppercase. result = re . sub ( r'_+' , '_' , result . upper ( ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert WGS84 geodetic coordinates into ECEF Parameters ---------- latitude : float or array_like Geodetic latitude ( degrees ) longitude : float or array_like Geodetic longitude ( degrees ) altitude : float or array_like Geodetic Height ( km ) above WGS84 reference ellipsoid . Returns ------- x y z numpy arrays of x y z locations in km [CODESPLIT] def geodetic_to_ecef ( latitude , longitude , altitude ) : ellip = np . sqrt ( 1. - earth_b ** 2 / earth_a ** 2 ) r_n = earth_a / np . sqrt ( 1. - ellip ** 2 * np . sin ( np . deg2rad ( latitude ) ) ** 2 ) # colatitude = 90. - latitude x = ( r_n + altitude ) * np . cos ( np . deg2rad ( latitude ) ) * np . cos ( np . deg2rad ( longitude ) ) y = ( r_n + altitude ) * np . cos ( np . deg2rad ( latitude ) ) * np . sin ( np . deg2rad ( longitude ) ) z = ( r_n * ( 1. - ellip ** 2 ) + altitude ) * np . sin ( np . deg2rad ( latitude ) ) return x , y , z", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a function that checks whether a scalar or array is of a given kind ( e . g . float int datetime timedelta ) . [CODESPLIT] def make_kind_check ( python_types , numpy_kind ) : def check ( value ) : if hasattr ( value , 'dtype' ) : return value . dtype . kind == numpy_kind return isinstance ( value , python_types ) return check", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple abstraction on top of the : meth : ~elasticsearch . Elasticsearch . scroll api - a simple iterator that yields all hits as returned by underlining scroll requests . By default scan does not return results in any pre - determined order . To have a standard order in the returned documents ( either by score or explicit sort definition ) when scrolling use preserve_order = True . This may be an expensive operation and will negate the performance benefits of using scan . : arg client : instance of : class : ~elasticsearch . Elasticsearch to use : arg query : body for the : meth : ~elasticsearch . Elasticsearch . search api : arg scroll : Specify how long a consistent view of the index should be maintained for scrolled search : arg raise_on_error : raises an exception ( ScanError ) if an error is encountered ( some shards fail to execute ) . By default we raise . : arg preserve_order : don t set the search_type to scan - this will cause the scroll to paginate with preserving the order . Note that this can be an extremely expensive operation and can easily lead to unpredictable results use with caution . : arg size : size ( per shard ) of the batch send at each iteration . Any additional keyword arguments will be passed to the initial : meth : ~elasticsearch . Elasticsearch . search call :: scan ( es query = { query : { match : { title : python }}} index = orders - * doc_type = books ) [CODESPLIT] def scan ( client , query = None , scroll = '5m' , raise_on_error = True , preserve_order = False , size = 1000 , * * kwargs ) : if not preserve_order : kwargs [ 'search_type' ] = 'scan' # initial search resp = client . search ( body = query , scroll = scroll , size = size , * * kwargs ) scroll_id = resp . get ( '_scroll_id' ) if scroll_id is None : return first_run = True while True : # if we didn't set search_type to scan initial search contains data if preserve_order and first_run : first_run = False else : resp = client . scroll ( scroll_id , scroll = scroll ) for hit in resp [ 'hits' ] [ 'hits' ] : yield hit # check if we have any errrors if resp [ \"_shards\" ] [ \"failed\" ] : logger . warning ( 'Scroll request has failed on %d shards out of %d.' , resp [ '_shards' ] [ 'failed' ] , resp [ '_shards' ] [ 'total' ] ) if raise_on_error : raise ScanError ( 'Scroll request has failed on %d shards out of %d.' % ( resp [ '_shards' ] [ 'failed' ] , resp [ '_shards' ] [ 'total' ] ) ) scroll_id = resp . get ( '_scroll_id' ) # end of scroll if scroll_id is None or not resp [ 'hits' ] [ 'hits' ] : break", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a lowercased string with non alphabetic chars removed . [CODESPLIT] def _to_lower_alpha_only ( s ) : s = re . sub ( r'\\n' , ' ' , s . lower ( ) ) return re . sub ( r'[^a-z\\s]' , '' , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test two dictionary is equal on values . ( ignore order ) [CODESPLIT] def is_same_dict ( d1 , d2 ) : for k , v in d1 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d2 [ k ] ) else : assert d1 [ k ] == d2 [ k ] for k , v in d2 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d1 [ k ] ) else : assert d1 [ k ] == d2 [ k ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Random normal variates . [CODESPLIT] def rnormal ( mu , tau , size = None ) : return np . random . normal ( mu , 1. / np . sqrt ( tau ) , size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Requests - mock requests . post wrapper . [CODESPLIT] def requests_post ( url , data = None , json = None , * * kwargs ) : return requests_request ( 'post' , url , data = data , json = json , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks length of value [CODESPLIT] def check_length ( value , length ) : _length = len ( value ) if _length != length : raise ValueError ( \"length must be %d, not %d\" % ( length , _length ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "converts Synergy Timestamp for session to UTC zone seconds since epoch [CODESPLIT] def session_to_epoch ( timestamp ) : utc_timetuple = datetime . strptime ( timestamp , SYNERGY_SESSION_PATTERN ) . replace ( tzinfo = None ) . utctimetuple ( ) return calendar . timegm ( utc_timetuple )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if value is an instance or subclass of the class Type . [CODESPLIT] def is_type ( value ) : if isinstance ( value , type ) : return issubclass ( value , Type ) return isinstance ( value , Type )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "converts Synergy Timestamp for session to UTC zone seconds since epoch [CODESPLIT] def session_to_epoch ( timestamp ) : utc_timetuple = datetime . strptime ( timestamp , SYNERGY_SESSION_PATTERN ) . replace ( tzinfo = None ) . utctimetuple ( ) return calendar . timegm ( utc_timetuple )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove unwanted list indices . First argument is the list of indices to remove . Other elements are the lists to trim . [CODESPLIT] def rm_empty_indices ( * args ) : rm_inds = args [ 0 ] if not rm_inds : return args [ 1 : ] keep_inds = [ i for i in range ( len ( args [ 1 ] ) ) if i not in rm_inds ] return [ [ a [ i ] for i in keep_inds ] for a in args [ 1 : ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if two line segments meet . [CODESPLIT] def line_line_collide ( line1 , line2 ) : s , t , success = segment_intersection ( line1 [ : , 0 ] , line1 [ : , 1 ] , line2 [ : , 0 ] , line2 [ : , 1 ] ) if success : return _helpers . in_interval ( s , 0.0 , 1.0 ) and _helpers . in_interval ( t , 0.0 , 1.0 ) else : disjoint , _ = parallel_lines_parameters ( line1 [ : , 0 ] , line1 [ : , 1 ] , line2 [ : , 0 ] , line2 [ : , 1 ] ) return not disjoint", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if value is an instance or subclass of the class Type . [CODESPLIT] def is_type ( value ) : if isinstance ( value , type ) : return issubclass ( value , Type ) return isinstance ( value , Type )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return n size lists from a given list l [CODESPLIT] def chunk_list ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Escape bad characters for regular expressions . [CODESPLIT] def _escape ( self , s ) : for ch , r_ch in self . ESCAPE_SETS : s = s . replace ( ch , r_ch ) return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Copy given string into system clipboard . [CODESPLIT] def copy ( string , * * kwargs ) : window = Tk ( ) window . withdraw ( ) window . clipboard_clear ( ) window . clipboard_append ( string ) window . destroy ( ) return", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Project x and y [CODESPLIT] def __call__ ( self , xy ) : x , y = xy return ( self . x ( x ) , self . y ( y ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit without garbage collection this speeds up exit by about 10ms for things like bash completion . [CODESPLIT] def fast_exit ( code ) : sys . stdout . flush ( ) sys . stderr . flush ( ) os . _exit ( code )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Constructor . [CODESPLIT] def __init__ ( self , ba = None ) : self . bytearray = ba or ( bytearray ( b'\\0' ) * self . SIZEOF )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the given path relative to this file . [CODESPLIT] def relative_path ( path ) : return os . path . join ( os . path . dirname ( __file__ ) , path )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete a directory if it s present . If it s not present no - op . [CODESPLIT] def safe_rmtree ( directory ) : if os . path . exists ( directory ) : shutil . rmtree ( directory , True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Double Exponential Moving Average . [CODESPLIT] def double_exponential_moving_average ( data , period ) : catch_errors . check_for_period_error ( data , period ) dema = ( 2 * ema ( data , period ) ) - ema ( ema ( data , period ) , period ) return dema", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns true if the given url is a file url [CODESPLIT] def is_file_url ( url ) : from . misc import to_text if not url : return False if not isinstance ( url , six . string_types ) : try : url = getattr ( url , \"url\" ) except AttributeError : raise ValueError ( \"Cannot parse url from unknown type: {0!r}\" . format ( url ) ) url = to_text ( url , encoding = \"utf-8\" ) return urllib_parse . urlparse ( url . lower ( ) ) . scheme == \"file\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def save_image ( pdf_path , img_path , page_num ) : pdf_img = Image ( filename = \"{}[{}]\" . format ( pdf_path , page_num ) ) with pdf_img . convert ( \"png\" ) as converted : # Set white background. converted . background_color = Color ( \"white\" ) converted . alpha_channel = \"remove\" converted . save ( filename = img_path )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Go to the end of the current line and create a new line [CODESPLIT] def go_to_new_line ( self ) : self . stdkey_end ( False , False ) self . insert_text ( self . get_line_separator ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "For Python3 compatibility of generator . [CODESPLIT] def __next__ ( self , reward , ask_id , lbl ) : return self . next ( reward , ask_id , lbl )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Download the given JSON file and pretty - print before we output it . [CODESPLIT] def download_json ( local_filename , url , clobber = False ) : with open ( local_filename , 'w' ) as json_file : json_file . write ( json . dumps ( requests . get ( url ) . json ( ) , sort_keys = True , indent = 2 , separators = ( ',' , ': ' ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform check_array ( X ) after removing infinite values ( numpy . inf ) from the given distance matrix . [CODESPLIT] def check_precomputed_distance_matrix ( X ) : tmp = X . copy ( ) tmp [ np . isinf ( tmp ) ] = 1 check_array ( tmp )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Invoked atexit this removes our tmpdir [CODESPLIT] def clean_tmpdir ( path ) : if os . path . exists ( path ) and os . path . isdir ( path ) : rmtree ( path )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Maxheap version of a heappop . [CODESPLIT] def _heappop_max ( heap ) : lastelt = heap . pop ( ) # raises appropriate IndexError if heap is empty if heap : returnitem = heap [ 0 ] heap [ 0 ] = lastelt _siftup_max ( heap , 0 ) return returnitem return lastelt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Loop over an iterable and track progress including first and last state . On each iteration yield an Iteration named tuple with the first and last flags current element index total iterable length ( if possible to acquire ) and value in that order . for iteration in iterate ( something ) : iteration . value # Do something . You can unpack these safely : for first last index total value in iterate ( something ) : pass If you want to unpack the values you are iterating across you can by wrapping the nested unpacking in parenthesis : for first last index total ( foo bar baz ) in iterate ( something ) : pass Even if the length of the iterable can t be reliably determined this function will still capture the last state of the final loop iteration . ( Basically : this works with generators . ) This process is about 10x slower than simple enumeration on CPython 3 . 4 so only use it where you actually need to track state . Use enumerate () elsewhere . [CODESPLIT] def iterate ( obj ) : global next , Iteration next = next Iteration = Iteration total = len ( obj ) if isinstance ( obj , Sized ) else None iterator = iter ( obj ) first = True last = False i = 0 try : value = next ( iterator ) except StopIteration : return while True : try : next_value = next ( iterator ) except StopIteration : last = True yield Iteration ( first , last , i , total , value ) if last : return value = next_value i += 1 first = False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns given method name . [CODESPLIT] def get_method_name ( method ) : name = get_object_name ( method ) if name . startswith ( \"__\" ) and not name . endswith ( \"__\" ) : name = \"_{0}{1}\" . format ( get_object_name ( method . im_class ) , name ) return name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Just the last entry . [CODESPLIT] def get_last ( self , table = None ) : if table is None : table = self . main_table query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table return self . own_cursor . execute ( query ) . fetchone ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the short - time Fourier transform magnitude . [CODESPLIT] def stft_magnitude ( signal , fft_length , hop_length = None , window_length = None ) : frames = frame ( signal , window_length , hop_length ) # Apply frame window to each frame. We use a periodic Hann (cosine of period # window_length) instead of the symmetric Hann of np.hanning (period # window_length-1). window = periodic_hann ( window_length ) windowed_frames = frames * window return np . abs ( np . fft . rfft ( windowed_frames , int ( fft_length ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Download the page into a string [CODESPLIT] def wget ( url ) : import urllib . parse request = urllib . request . urlopen ( url ) filestring = request . read ( ) return filestring", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper that reads the UTF - 8 content of the specified file or None if the file doesn t exist . This returns a unicode string . [CODESPLIT] def _read_text ( self , filename ) : with io . open ( filename , 'rt' , encoding = 'utf-8' ) as f : return f . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A list of kubernetes pods corresponding to current workers [CODESPLIT] def pods ( self ) : return self . core_api . list_namespaced_pod ( self . namespace , label_selector = format_labels ( self . pod_template . metadata . labels ) ) . items", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of dictionaries which are sorted for only unique entries . [CODESPLIT] def unique_list_dicts ( dlist , key ) : return list ( dict ( ( val [ key ] , val ) for val in dlist ) . values ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fill all null values with NaN values in a column . Null values are None or en empty string [CODESPLIT] def fill_nulls ( self , col : str ) : n = [ None , \"\" ] try : self . df [ col ] = self . df [ col ] . replace ( n , nan ) except Exception as e : self . err ( e )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the display length of a string . This can differ from the character length if the string contains wide characters . [CODESPLIT] def display_len ( text ) : text = unicodedata . normalize ( 'NFD' , text ) return sum ( char_width ( char ) for char in text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get max for queryset . [CODESPLIT] def get_max ( qs , field ) : max_field = '%s__max' % field num = qs . aggregate ( Max ( field ) ) [ max_field ] return num if num else 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fill NaNs with the previous value the next value or if all are NaN then 1 . 0 [CODESPLIT] def clean_dataframe ( df ) : df = df . fillna ( method = 'ffill' ) df = df . fillna ( 0.0 ) return df", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of entries in a table by counting them . [CODESPLIT] def count_rows ( self , table_name ) : self . table_must_exist ( table_name ) query = \"SELECT COUNT (*) FROM `%s`\" % table_name . lower ( ) self . own_cursor . execute ( query ) return int ( self . own_cursor . fetchone ( ) [ 0 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def _drop_str_columns ( df ) : str_columns = filter ( lambda pair : pair [ 1 ] . char == 'S' , df . _gather_dtypes ( ) . items ( ) ) str_column_names = list ( map ( lambda pair : pair [ 0 ] , str_columns ) ) return df . drop ( str_column_names )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Provide a password prompt . [CODESPLIT] def getpass ( self , prompt , default = None ) : return click . prompt ( prompt , hide_input = True , default = default )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dataframe that is a cross between dataframes df1 and df2 [CODESPLIT] def cross_join ( df1 , df2 ) : if len ( df1 ) == 0 : return df2 if len ( df2 ) == 0 : return df1 # Add as lists so that the new index keeps the items in # the order that they are added together all_columns = pd . Index ( list ( df1 . columns ) + list ( df2 . columns ) ) df1 [ 'key' ] = 1 df2 [ 'key' ] = 1 return pd . merge ( df1 , df2 , on = 'key' ) . loc [ : , all_columns ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate angle between two vectors [CODESPLIT] def vec_angle ( a , b ) : cosang = np . dot ( a , b ) sinang = fast_norm ( np . cross ( a , b ) ) return np . arctan2 ( sinang , cosang )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print warning about interrupt and empty the job queue . [CODESPLIT] def finish ( ) : out . warn ( \"Interrupted!\" ) for t in threads : t . stop ( ) jobs . clear ( ) out . warn ( \"Waiting for download threads to finish.\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "When converting Spark SQL records to Pandas DataFrame the inferred data type may be wrong . This method gets the corrected data type for Pandas if that type may be inferred uncorrectly . [CODESPLIT] def _to_corrected_pandas_type ( dt ) : import numpy as np if type ( dt ) == ByteType : return np . int8 elif type ( dt ) == ShortType : return np . int16 elif type ( dt ) == IntegerType : return np . int32 elif type ( dt ) == FloatType : return np . float32 else : return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find and kill child processes of a process . [CODESPLIT] def kill_process_children ( pid ) : if sys . platform == \"darwin\" : kill_process_children_osx ( pid ) elif sys . platform == \"linux\" : kill_process_children_unix ( pid ) else : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns all intervals that overlap the point_list . [CODESPLIT] def search_overlap ( self , point_list ) : result = set ( ) for j in point_list : self . search_point ( j , result ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Guess string encoding . [CODESPLIT] def guess_encoding ( text , default = DEFAULT_ENCODING ) : result = chardet . detect ( text ) return normalize_result ( result , default = default )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "in comparison to argrelmax () more simple and reliable peak finder [CODESPLIT] def findMax ( arr ) : out = np . zeros ( shape = arr . shape , dtype = bool ) _calcMax ( arr , out ) return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of the table names in the database . [CODESPLIT] def get_table_names ( connection ) : cursor = connection . cursor ( ) cursor . execute ( \"SELECT name FROM sqlite_master WHERE type == 'table'\" ) return [ name for ( name , ) in cursor ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the depth of the longest branch of the tree [CODESPLIT] def maxDepth ( self , currentDepth = 0 ) : if not any ( ( self . left , self . right ) ) : return currentDepth result = 0 for child in ( self . left , self . right ) : if child : result = max ( result , child . maxDepth ( currentDepth + 1 ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "http : // stackoverflow . com / questions / 5098580 / implementing - argmax - in - python [CODESPLIT] def argmax ( l , f = None ) : if f : l = [ f ( i ) for i in l ] return max ( enumerate ( l ) , key = lambda x : x [ 1 ] ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create directory with template for topic of the current environment [CODESPLIT] def mkdir ( dir , enter ) : if not os . path . exists ( dir ) : os . makedirs ( dir )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": type root : TreeNode : rtype : int [CODESPLIT] def min_depth ( self , root ) : if root is None : return 0 if root . left is not None or root . right is not None : return max ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1 return min ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function for running binary search on a sorted list . [CODESPLIT] def binSearch ( arr , val ) : i = bisect_left ( arr , val ) if i != len ( arr ) and arr [ i ] == val : return i return - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Main window move event [CODESPLIT] def OnMove ( self , event ) : # Store window position in config position = self . main_window . GetScreenPositionTuple ( ) config [ \"window_position\" ] = repr ( position )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the index of the toc entry with name NAME . [CODESPLIT] def find ( self , name ) : for i , nm in enumerate ( self . data ) : if nm [ - 1 ] == name : return i return - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a Vector as the product of the vector and a real number . [CODESPLIT] def multiply ( self , number ) : return self . from_list ( [ x * number for x in self . to_list ( ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the largest real value h such that all elements in x are integer multiples of h . [CODESPLIT] def _gcd_array ( X ) : greatest_common_divisor = 0.0 for x in X : greatest_common_divisor = _gcd ( greatest_common_divisor , x ) return greatest_common_divisor", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read text from stdin and print a helpful message for ttys . [CODESPLIT] def read_stdin ( ) : if sys . stdin . isatty ( ) and sys . stdout . isatty ( ) : print ( '\\nReading from stdin until end of file (Ctrl + D)...' ) return sys . stdin . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply the coefficients from a linear fit to an array of x y positions . [CODESPLIT] def apply_fit ( xy , coeffs ) : x_new = coeffs [ 0 ] [ 2 ] + coeffs [ 0 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 0 ] [ 1 ] * xy [ : , 1 ] y_new = coeffs [ 1 ] [ 2 ] + coeffs [ 1 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 1 ] [ 1 ] * xy [ : , 1 ] return x_new , y_new", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Blocks until a keyboard event happens then returns that event s name or if missing its scan code . [CODESPLIT] def read_key ( suppress = False ) : event = read_event ( suppress ) return event . name or event . scan_code", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Learn vocabulary and idf return term - document matrix . This is equivalent to fit followed by transform but more efficiently implemented . Parameters ---------- raw_documents : iterable an iterable which yields either str unicode or file objects Returns ------- X : sparse matrix [ n_samples n_features ] Tf - idf - weighted document - term matrix . [CODESPLIT] def fit_transform ( self , raw_documents , y = None ) : documents = super ( TfidfVectorizer , self ) . fit_transform ( raw_documents = raw_documents , y = y ) count = CountVectorizer ( encoding = self . encoding , decode_error = self . decode_error , strip_accents = self . strip_accents , lowercase = self . lowercase , preprocessor = self . preprocessor , tokenizer = self . tokenizer , stop_words = self . stop_words , token_pattern = self . token_pattern , ngram_range = self . ngram_range , analyzer = self . analyzer , max_df = self . max_df , min_df = self . min_df , max_features = self . max_features , vocabulary = self . vocabulary_ , binary = self . binary , dtype = self . dtype ) count . fit_transform ( raw_documents = raw_documents , y = y ) self . period_ = count . period_ self . df_ = count . df_ self . n = count . n return documents", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the given command ( with shell = False ) and return a tuple of ( int returncode str output ) . Strip the output of enclosing whitespace . [CODESPLIT] def call_out ( command ) : # start external command process p = subprocess . Popen ( command , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) # get outputs out , _ = p . communicate ( ) return p . returncode , out . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a stdout and print it s lines to output if lines are present . [CODESPLIT] def report_stdout ( host , stdout ) : lines = stdout . readlines ( ) if lines : print ( \"STDOUT from {host}:\" . format ( host = host ) ) for line in lines : print ( line . rstrip ( ) , file = sys . stdout )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if URL is safe to redirect to . [CODESPLIT] def is_local_url ( target ) : ref_url = urlparse ( request . host_url ) test_url = urlparse ( urljoin ( request . host_url , target ) ) return test_url . scheme in ( 'http' , 'https' ) and ref_url . netloc == test_url . netloc", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flat nested list of lists into a single list . [CODESPLIT] def flatten ( l , types = ( list , float ) ) : l = [ item if isinstance ( item , types ) else [ item ] for item in l ] return [ item for sublist in l for item in sublist ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def export_all ( self ) : query = \"\"\"\n\t\t\tSELECT quote, library, logid\n\t\t\tfrom quotes\n\t\t\tleft outer join quote_log on quotes.quoteid = quote_log.quoteid\n\t\t\t\"\"\" fields = 'text' , 'library' , 'log_id' return ( dict ( zip ( fields , res ) ) for res in self . db . execute ( query ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Nested lists to single - level list does not split strings [CODESPLIT] def flatten_list ( l ) : return list ( chain . from_iterable ( repeat ( x , 1 ) if isinstance ( x , str ) else x for x in l ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "rotates a 2d array to a multiple of 90 deg . 0 = default 1 = 90 deg . cw 2 = 180 deg . 3 = 90 deg . ccw [CODESPLIT] def rotateImage ( image , angle ) : image = [ list ( row ) for row in image ] for n in range ( angle % 4 ) : image = list ( zip ( * image [ : : - 1 ] ) ) return image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a list possibly nested to any level return it flattened . [CODESPLIT] def flatten ( lis ) : new_lis = [ ] for item in lis : if isinstance ( item , collections . Sequence ) and not isinstance ( item , basestring ) : new_lis . extend ( flatten ( item ) ) else : new_lis . append ( item ) return new_lis", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the unit tests . [CODESPLIT] def test ( ) : import unittest tests = unittest . TestLoader ( ) . discover ( 'tests' ) unittest . TextTestRunner ( verbosity = 2 ) . run ( tests )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Horizontally flip the given PIL Image . [CODESPLIT] def hflip ( img ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) return img . transpose ( Image . FLIP_LEFT_RIGHT )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate seed for random number generator [CODESPLIT] def generate_seed ( seed ) : if seed is None : random . seed ( ) seed = random . randint ( 0 , sys . maxsize ) random . seed ( a = seed ) return seed", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clears the input and output buffers [CODESPLIT] def __clear_buffers ( self ) : try : self . _port . reset_input_buffer ( ) self . _port . reset_output_buffer ( ) except AttributeError : #pySerial 2.7 self . _port . flushInput ( ) self . _port . flushOutput ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make bars in horizontal bar chart thinner [CODESPLIT] def _change_height ( self , ax , new_value ) : for patch in ax . patches : current_height = patch . get_height ( ) diff = current_height - new_value # we change the bar height patch . set_height ( new_value ) # we recenter the bar patch . set_y ( patch . get_y ( ) + diff * .5 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flush all items from cache . [CODESPLIT] def Flush ( self ) : while self . _age : node = self . _age . PopLeft ( ) self . KillObject ( node . data ) self . _hash = dict ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tests if an object is a collection . [CODESPLIT] def is_collection ( obj ) : col = getattr ( obj , '__getitem__' , False ) val = False if ( not col ) else True if isinstance ( obj , basestring ) : val = False return val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Terminate a running script . [CODESPLIT] async def terminate ( self ) : self . proc . terminate ( ) await asyncio . wait_for ( self . proc . wait ( ) , self . kill_delay ) if self . proc . returncode is None : self . proc . kill ( ) await self . proc . wait ( ) await super ( ) . terminate ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determines whether the passed value is a string safe for 2 / 3 . [CODESPLIT] def is_string ( val ) : try : basestring except NameError : return isinstance ( val , str ) return isinstance ( val , basestring )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Daemonize the running process . [CODESPLIT] def go_to_background ( ) : try : if os . fork ( ) : sys . exit ( ) except OSError as errmsg : LOGGER . error ( 'Fork failed: {0}' . format ( errmsg ) ) sys . exit ( 'Fork failed' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wait until the user accepted or rejected the request [CODESPLIT] def _wait_for_response ( self ) : while not self . server . response_code : time . sleep ( 2 ) time . sleep ( 5 ) self . server . shutdown ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Redraw event handler for the figure panel [CODESPLIT] def OnUpdateFigurePanel ( self , event ) : if self . updating : return self . updating = True self . figure_panel . update ( self . get_figure ( self . code ) ) self . updating = False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Formats a list of elements using the given line style [CODESPLIT] def format_line ( data , linestyle ) : return linestyle . begin + linestyle . sep . join ( data ) + linestyle . end", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format a string for screen printing . [CODESPLIT] def format_screen ( strng ) : # Paragraph continue par_re = re . compile ( r'\\\\$' , re . MULTILINE ) strng = par_re . sub ( '' , strng ) return strng", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a percentage string representation from the given number . The number is multiplied by 100 before adding a % character . [CODESPLIT] def to_percentage ( number , rounding = 2 ) : number = float ( number ) * 100 number_as_int = int ( number ) rounded = round ( number , rounding ) return '{}%' . format ( number_as_int if number_as_int == rounded else rounded )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Start web application [CODESPLIT] def web ( host , port ) : from . webserver . web import get_app get_app ( ) . run ( host = host , port = port )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a background thread for httpd and serve forever [CODESPLIT] def start ( self ) : self . _process = threading . Thread ( target = self . _background_runner ) self . _process . start ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the inverse of the multi - dimensional discrete Fourier transform for real input . This function is a wrapper for : func : pyfftw . interfaces . numpy_fft . irfftn with an interface similar to that of : func : numpy . fft . irfftn . [CODESPLIT] def irfftn ( a , s , axes = None ) : return pyfftw . interfaces . numpy_fft . irfftn ( a , s = s , axes = axes , overwrite_input = False , planner_effort = 'FFTW_MEASURE' , threads = pyfftw_threads )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the index of the closest in xarr to value val [CODESPLIT] def closest ( xarr , val ) : idx_closest = np . argmin ( np . abs ( np . array ( xarr ) - val ) ) return idx_closest", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the most common element in iterable . [CODESPLIT] def _most_common ( iterable ) : data = Counter ( iterable ) return max ( data , key = data . __getitem__ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transpose the columns into rows remove all of the rows that are empty after the first cell then transpose back . The result is that columns that have a header but no data in the body are removed assuming the header is the first row . [CODESPLIT] def drop_empty ( rows ) : return zip ( * [ col for col in zip ( * rows ) if bool ( filter ( bool , col [ 1 : ] ) ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts camel - case identifiers to snake - case . [CODESPLIT] def to_snake_case ( s ) : return re . sub ( '([^_A-Z])([A-Z])' , lambda m : m . group ( 1 ) + '_' + m . group ( 2 ) . lower ( ) , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test the speed of a function . [CODESPLIT] def speedtest ( func , * args , * * kwargs ) : n = 100 start = time . time ( ) for i in range ( n ) : func ( * args , * * kwargs ) end = time . time ( ) return ( end - start ) / n", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check that value is in values [CODESPLIT] def isin ( value , values ) : for i , v in enumerate ( value ) : if v not in np . array ( values ) [ : , i ] : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert version like string to a tuple of integers . [CODESPLIT] def ver_to_tuple ( value ) : return tuple ( int ( _f ) for _f in re . split ( r'\\D+' , value ) if _f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if a line consists only of a single punctuation character . [CODESPLIT] def is_delimiter ( line ) : return bool ( line ) and line [ 0 ] in punctuation and line [ 0 ] * len ( line ) == line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a str of decimal with two digits after a decimal mark . [CODESPLIT] def money ( min = 0 , max = 10 ) : value = random . choice ( range ( min * 100 , max * 100 ) ) return \"%1.2f\" % ( float ( value ) / 100 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove commas from a float [CODESPLIT] def clean_float ( v ) : if v is None or not str ( v ) . strip ( ) : return None return float ( str ( v ) . replace ( ',' , '' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a str of decimal with two digits after a decimal mark . [CODESPLIT] def money ( min = 0 , max = 10 ) : value = random . choice ( range ( min * 100 , max * 100 ) ) return \"%1.2f\" % ( float ( value ) / 100 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove arduino / examples / all directory . [CODESPLIT] def remove_examples_all ( ) : d = examples_all_dir ( ) if d . exists ( ) : log . debug ( 'remove %s' , d ) d . rmtree ( ) else : log . debug ( 'nothing to remove: %s' , d )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a random string from a - zA - Z : param n : length of the string : return : the random string [CODESPLIT] def random_letters ( n ) : return '' . join ( random . SystemRandom ( ) . choice ( string . ascii_letters ) for _ in range ( n ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "if we have a compatible fill_value and arr dtype then fill [CODESPLIT] def _maybe_fill ( arr , fill_value = np . nan ) : if _isna_compat ( arr , fill_value ) : arr . fill ( fill_value ) return arr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Emit a sine wave at the given frequency . [CODESPLIT] def sine_wave ( frequency ) : xs = tf . reshape ( tf . range ( _samples ( ) , dtype = tf . float32 ) , [ 1 , _samples ( ) , 1 ] ) ts = xs / FLAGS . sample_rate return tf . sin ( 2 * math . pi * frequency * ts )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if an input is a file and exists . [CODESPLIT] def _file_and_exists ( val , input_files ) : return ( ( os . path . exists ( val ) and os . path . isfile ( val ) ) or val in input_files )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract a uint from a position in a sequence . [CODESPLIT] def read_uint ( data , start , length ) : return int . from_bytes ( data [ start : start + length ] , byteorder = 'big' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Try to remove all comments from a file and save it if changes were made . [CODESPLIT] def example_write_file_to_disk_if_changed ( ) : my_file = FileAsObj ( '/tmp/example_file.txt' ) my_file . rm ( my_file . egrep ( '^#' ) ) if my_file . changed : my_file . save ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function that gets relative path to the filename [CODESPLIT] def rel_path ( filename ) : return os . path . join ( os . getcwd ( ) , os . path . dirname ( __file__ ) , filename )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the string is only composed of hex characters . [CODESPLIT] def is_hex_string ( string ) : pattern = re . compile ( r'[A-Fa-f0-9]+' ) if isinstance ( string , six . binary_type ) : string = str ( string ) return pattern . match ( string ) is not None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns all dates between two dates . [CODESPLIT] def dates_in_range ( start_date , end_date ) : return [ start_date + timedelta ( n ) for n in range ( int ( ( end_date - start_date ) . days ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Small routine for checking whether a string is empty even a string [CODESPLIT] def chkstr ( s , v ) : if type ( s ) != str : raise TypeError ( \"{var} must be str\" . format ( var = v ) ) if not s : raise ValueError ( \"{var} cannot be empty\" . format ( var = v ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return list of Logger classes . [CODESPLIT] def _get_loggers ( ) : from . . import loader modules = loader . get_package_modules ( 'logger' ) return list ( loader . get_plugins ( modules , [ _Logger ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses box coordinates to crop an image without resizing it first . [CODESPLIT] def crop_box ( im , box = False , * * kwargs ) : if box : im = im . crop ( box ) return im", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the file name from an url Parameters ---------- url : str [CODESPLIT] def get_url_file_name ( url ) : assert isinstance ( url , ( str , _oldstr ) ) return urlparse . urlparse ( url ) . path . split ( '/' ) [ - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for matplotlib imshow [CODESPLIT] def extent ( self ) : return ( self . intervals [ 1 ] . pix1 - 0.5 , self . intervals [ 1 ] . pix2 - 0.5 , self . intervals [ 0 ] . pix1 - 0.5 , self . intervals [ 0 ] . pix2 - 0.5 , )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a new Image instance with the given size . [CODESPLIT] def resize ( self , size ) : return Image ( self . pil_image . resize ( size , PIL . Image . ANTIALIAS ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the current time . [CODESPLIT] def now_time ( str = False ) : if str : return datetime . datetime . now ( ) . strftime ( \"%Y-%m-%d %H:%M:%S\" ) return datetime . datetime . now ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the shape of img . [CODESPLIT] def get_shape ( img ) : if hasattr ( img , 'shape' ) : shape = img . shape else : shape = img . get_data ( ) . shape return shape", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets up the python include paths to include src [CODESPLIT] def setup_path ( ) : import os . path import sys if sys . argv [ 0 ] : top_dir = os . path . dirname ( os . path . abspath ( sys . argv [ 0 ] ) ) sys . path = [ os . path . join ( top_dir , \"src\" ) ] + sys . path pass return", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a date object and return the first day of the month . [CODESPLIT] def monthly ( date = datetime . date . today ( ) ) : return datetime . date ( date . year , date . month , 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Writes padding bytes given the currently written size . [CODESPLIT] def write_padding ( fp , size , divisor = 2 ) : remainder = size % divisor if remainder : return write_bytes ( fp , struct . pack ( '%dx' % ( divisor - remainder ) ) ) return 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return first occurrence matching f otherwise None [CODESPLIT] def findfirst ( f , coll ) : result = list ( dropwhile ( f , coll ) ) return result [ 0 ] if result else None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Increment the key by the given amount . [CODESPLIT] def incr ( self , key , incr_by = 1 ) : return self . database . hincrby ( self . key , key , incr_by )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses OLS to fit the regression . [CODESPLIT] def fit_linear ( X , y ) : model = linear_model . LinearRegression ( ) model . fit ( X , y ) return model", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Universal indexing for numpy and pandas objects . [CODESPLIT] def idx ( df , index ) : if isinstance ( df , ( pd . DataFrame , pd . Series ) ) : return df . iloc [ index ] else : return df [ index , : ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Frequencies of each residue type ( totaling 1 . 0 ) in a single column . [CODESPLIT] def col_frequencies ( col , weights = None , gap_chars = '-.' ) : counts = col_counts ( col , weights , gap_chars ) # Reduce to frequencies scale = 1.0 / sum ( counts . values ( ) ) return dict ( ( aa , cnt * scale ) for aa , cnt in counts . iteritems ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialize the server logging configuration . [CODESPLIT] def ServerLoggingStartupInit ( ) : global LOGGER if local_log : logging . debug ( \"Using local LogInit from %s\" , local_log ) local_log . LogInit ( ) logging . debug ( \"Using local AppLogInit from %s\" , local_log ) LOGGER = local_log . AppLogInit ( ) else : LogInit ( ) LOGGER = AppLogInit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get trace_id from flask request headers . [CODESPLIT] def get_trace_id_from_flask ( ) : if flask is None or not flask . request : return None header = flask . request . headers . get ( _FLASK_TRACE_HEADER ) if header is None : return None trace_id = header . split ( \"/\" , 1 ) [ 0 ] return trace_id", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if we are in a tty . [CODESPLIT] def intty ( cls ) : # XXX: temporary hack until we can detect if we are in a pipe or not return True if hasattr ( sys . stdout , 'isatty' ) and sys . stdout . isatty ( ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Translate the key into the central cell [CODESPLIT] def wrap_key ( self , key ) : return tuple ( np . round ( self . integer_cell . shortest_vector ( key ) ) . astype ( int ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a string composed of elements in inlist with each element separated by delimiter . Used by function writedelimited . Use \\ t for tab - delimiting . [CODESPLIT] def linedelimited ( inlist , delimiter ) : outstr = '' for item in inlist : if type ( item ) != StringType : item = str ( item ) outstr = outstr + item + delimiter outstr = outstr [ 0 : - 1 ] return outstr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a PDF by embedding the first page from the given image and writes some text to it . [CODESPLIT] def main ( filename ) : # Prepare font. font_family = 'arial' font = Font ( font_family , bold = True ) if not font : raise RuntimeError ( 'No font found for %r' % font_family ) # Initialize PDF document on a stream. with Document ( 'output.pdf' ) as document : # Initialize a new page and begin its context. with document . Page ( ) as ctx : # Open the image to embed. with Image ( filename ) as embed : # Set the media box for the page to the same as the # image to embed. ctx . box = embed . box # Embed the image. ctx . embed ( embed ) # Write some text. ctx . add ( Text ( 'Hello World' , font , size = 14 , x = 100 , y = 60 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def _index_ordering ( redshift_list ) : redshift_list = np . array ( redshift_list ) sort_index = np . argsort ( redshift_list ) return sort_index", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handle the * operator . [CODESPLIT] def __mul__ ( self , other ) : return self . _handle_type ( other ) ( self . value * other . value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the host s ip number . [CODESPLIT] def get_own_ip ( ) : sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) try : sock . connect ( ( \"8.8.8.8\" , 80 ) ) except socket . gaierror : ip_ = \"127.0.0.1\" else : ip_ = sock . getsockname ( ) [ 0 ] finally : sock . close ( ) return ip_", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the 1 - based index of the last object on this page relative to total objects found ( hits ) . [CODESPLIT] def end_index ( self ) : return ( ( self . number - 1 ) * self . paginator . per_page + len ( self . object_list ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return unix SECOND timestamp of num mondays ago [CODESPLIT] def prevmonday ( num ) : today = get_today ( ) lastmonday = today - timedelta ( days = today . weekday ( ) , weeks = num ) return lastmonday", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the approximate size of the queue ( not reliable! ) . [CODESPLIT] def qsize ( self ) : self . mutex . acquire ( ) n = self . _qsize ( ) self . mutex . release ( ) return n", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the maximum value of the domain . [CODESPLIT] def max ( self ) : return int ( self . _max ) if not np . isinf ( self . _max ) else self . _max", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return line ending . [CODESPLIT] def get_line_ending ( line ) : non_whitespace_index = len ( line . rstrip ( ) ) - len ( line ) if not non_whitespace_index : return '' else : return line [ non_whitespace_index : ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get an entry from a dict of dicts by the list of keys to follow [CODESPLIT] def subkey ( dct , keys ) : key = keys [ 0 ] if len ( keys ) == 1 : return dct [ key ] return subkey ( dct [ key ] , keys [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield all non - sytem collections in db . [CODESPLIT] def all_collections ( db ) : include_pattern = r'(?!system\\.)' return ( db [ name ] for name in db . list_collection_names ( ) if re . match ( include_pattern , name ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Interpolate linearly variable x in rangeX onto rangeY . [CODESPLIT] def lin_interp ( x , rangeX , rangeY ) : s = ( x - rangeX [ 0 ] ) / mag ( rangeX [ 1 ] - rangeX [ 0 ] ) y = rangeY [ 0 ] * ( 1 - s ) + rangeY [ 1 ] * s return y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Looks at the files in a git root directory and grabs the last modified timestamp [CODESPLIT] def get_last_modified_timestamp ( self ) : cmd = \"find . -print0 | xargs -0 stat -f '%T@ %p' | sort -n | tail -1 | cut -f2- -d' '\" ps = subprocess . Popen ( cmd , shell = True , stdout = subprocess . PIPE , stderr = subprocess . STDOUT ) output = ps . communicate ( ) [ 0 ] print output", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the closes point for a given set of lines in 3D . [CODESPLIT] def intersect_3d ( p1 , p2 ) : v = p2 - p1 normed_v = unit_vector ( v ) nx = normed_v [ : , 0 ] ny = normed_v [ : , 1 ] nz = normed_v [ : , 2 ] xx = np . sum ( nx ** 2 - 1 ) yy = np . sum ( ny ** 2 - 1 ) zz = np . sum ( nz ** 2 - 1 ) xy = np . sum ( nx * ny ) xz = np . sum ( nx * nz ) yz = np . sum ( ny * nz ) M = np . array ( [ ( xx , xy , xz ) , ( xy , yy , yz ) , ( xz , yz , zz ) ] ) x = np . sum ( p1 [ : , 0 ] * ( nx ** 2 - 1 ) + p1 [ : , 1 ] * ( nx * ny ) + p1 [ : , 2 ] * ( nx * nz ) ) y = np . sum ( p1 [ : , 0 ] * ( nx * ny ) + p1 [ : , 1 ] * ( ny * ny - 1 ) + p1 [ : , 2 ] * ( ny * nz ) ) z = np . sum ( p1 [ : , 0 ] * ( nx * nz ) + p1 [ : , 1 ] * ( ny * nz ) + p1 [ : , 2 ] * ( nz ** 2 - 1 ) ) return np . linalg . lstsq ( M , np . array ( ( x , y , z ) ) , rcond = None ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return n size lists from a given list l [CODESPLIT] def chunk_list ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if obj is a sequence but not a string or bytes . [CODESPLIT] def is_sequence ( obj ) : return isinstance ( obj , Sequence ) and not ( isinstance ( obj , str ) or BinaryClass . is_valid_type ( obj ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of days since January 1 of the given year . [CODESPLIT] def gday_of_year ( self ) : return ( self . date - dt . date ( self . date . year , 1 , 1 ) ) . days", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the number of rows of the main dataframe [CODESPLIT] def count_ ( self ) : try : num = len ( self . df . index ) except Exception as e : self . err ( e , \"Can not count data\" ) return return num", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Random uniform variates . [CODESPLIT] def runiform ( lower , upper , size = None ) : return np . random . uniform ( lower , upper , size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs a shell command returns console output . [CODESPLIT] def _run_cmd_get_output ( cmd ) : process = subprocess . Popen ( cmd . split ( ) , stdout = subprocess . PIPE ) out , err = process . communicate ( ) return out or err", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a generator that spits an iteratable into n - sized chunks . The last chunk may have less than n elements . [CODESPLIT] def split_every ( n , iterable ) : items = iter ( iterable ) return itertools . takewhile ( bool , ( list ( itertools . islice ( items , n ) ) for _ in itertools . count ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the topmost parent of the current category . [CODESPLIT] def root_parent ( self , category = None ) : return next ( filter ( lambda c : c . is_root , self . hierarchy ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Stops iterating before yielding the specified idx . [CODESPLIT] def stop_at ( iterable , idx ) : for i , item in enumerate ( iterable ) : if i == idx : return yield item", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return pinyin of string the string must be unicode [CODESPLIT] def get ( s , delimiter = '' , format = \"diacritical\" ) : return delimiter . join ( _pinyin_generator ( u ( s ) , format = format ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Internal helper to return the values of a dictionary sorted by key . [CODESPLIT] def _dict_values_sorted_by_key ( dictionary ) : # This should be a yield from instead. for _ , value in sorted ( dictionary . iteritems ( ) , key = operator . itemgetter ( 0 ) ) : yield value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return all links on a page including potentially rel = links . [CODESPLIT] def links ( cls , page ) : for match in cls . HREF_RE . finditer ( page ) : yield cls . href_match_to_url ( match )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the size in bytes if path is a file or the size of all files in path if it s a directory . Analogous to du - s . [CODESPLIT] def get_size ( path ) : if os . path . isfile ( path ) : return os . path . getsize ( path ) return sum ( get_size ( os . path . join ( path , f ) ) for f in os . listdir ( path ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the memory byte size of a Numpy array as an integer . [CODESPLIT] def bytesize ( arr ) : byte_size = np . prod ( arr . shape ) * np . dtype ( arr . dtype ) . itemsize return byte_size", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Advance the iterator without returning the old head . [CODESPLIT] def _fill ( self ) : try : self . _head = self . _iterable . next ( ) except StopIteration : self . _head = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Total array cell + indexes size [CODESPLIT] def memsize ( self ) : return self . size + 1 + TYPE . size ( gl . BOUND_TYPE ) * len ( self . bounds )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Advance the iterator without returning the old head . [CODESPLIT] def _fill ( self ) : try : self . _head = self . _iterable . next ( ) except StopIteration : self . _head = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Conveinience : [CODESPLIT] def get_tablenames ( cur ) : cur . execute ( \"SELECT name FROM sqlite_master WHERE type='table'\" ) tablename_list_ = cur . fetchall ( ) tablename_list = [ str ( tablename [ 0 ] ) for tablename in tablename_list_ ] return tablename_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "given a bytes object should return a base python data structure that represents the object . [CODESPLIT] def load ( raw_bytes ) : try : if not isinstance ( raw_bytes , string_type ) : raw_bytes = raw_bytes . decode ( ) return json . loads ( raw_bytes ) except ValueError as e : raise SerializationException ( str ( e ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract text from a given lxml node . [CODESPLIT] def _extract_node_text ( node ) : texts = map ( six . text_type . strip , map ( six . text_type , map ( unescape , node . xpath ( \".//text()\" ) ) ) ) return \" \" . join ( text for text in texts if text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compose all given tuples together . [CODESPLIT] def compose_all ( tups ) : from . import ast # I weep for humanity return functools . reduce ( lambda x , y : x . compose ( y ) , map ( ast . make_tuple , tups ) , ast . make_tuple ( { } ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the first sunday of a month . [CODESPLIT] def first_sunday ( self , year , month ) : date = datetime ( year , month , 1 , 0 ) days_until_sunday = 6 - date . weekday ( ) return date + timedelta ( days = days_until_sunday )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes JSON formatted data converting it into native Python objects [CODESPLIT] def json ( body , charset = 'utf-8' , * * kwargs ) : return json_converter . loads ( text ( body , charset = charset ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns background color rgb tuple of right line [CODESPLIT] def _get_background_color ( self ) : color = self . cell_attributes [ self . key ] [ \"bgcolor\" ] return tuple ( c / 255.0 for c in color_pack2rgb ( color ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses an ISO8601 formatted datetime from a string value [CODESPLIT] def parse_json_date ( value ) : if not value : return None return datetime . datetime . strptime ( value , JSON_DATETIME_FORMAT ) . replace ( tzinfo = pytz . UTC )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Official way to get the extension of compiled files ( . pyc or . pyo ) [CODESPLIT] def _get_compiled_ext ( ) : for ext , mode , typ in imp . get_suffixes ( ) : if typ == imp . PY_COMPILED : return ext", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the file extension for an abi3 - compliant Extension () [CODESPLIT] def get_abi3_suffix ( ) : for suffix , _ , _ in ( s for s in imp . get_suffixes ( ) if s [ 2 ] == imp . C_EXTENSION ) : if '.abi3' in suffix : # Unix return suffix elif suffix == '.pyd' : # Windows return suffix", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Dump Python object as JSON string . [CODESPLIT] def dump_json ( obj ) : return simplejson . dumps ( obj , ignore_nan = True , default = json_util . default )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Serializer for consistency [CODESPLIT] def json_dumps ( self , obj ) : return json . dumps ( obj , sort_keys = True , indent = 4 , separators = ( ',' , ': ' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the number of rows of the main dataframe [CODESPLIT] def count_ ( self ) : try : num = len ( self . df . index ) except Exception as e : self . err ( e , \"Can not count data\" ) return return num", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a json string representing the python object obj . [CODESPLIT] def to_json ( obj ) : i = StringIO . StringIO ( ) w = Writer ( i , encoding = 'UTF-8' ) w . write_value ( obj ) return i . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cumulative product of a list . [CODESPLIT] def _cumprod ( l ) : ret = [ 1 ] for item in l : ret . append ( ret [ - 1 ] * item ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Serializer for consistency [CODESPLIT] def json_dumps ( self , obj ) : return json . dumps ( obj , sort_keys = True , indent = 4 , separators = ( ',' , ': ' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the type of obj as a string . More descriptive and specific than type ( obj ) and safe for any object unlike __class__ . [CODESPLIT] def typename ( obj ) : if hasattr ( obj , '__class__' ) : return getattr ( obj , '__class__' ) . __name__ else : return type ( obj ) . __name__", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tests if an object is a collection . [CODESPLIT] def is_collection ( obj ) : col = getattr ( obj , '__getitem__' , False ) val = False if ( not col ) else True if isinstance ( obj , basestring ) : val = False return val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Method to extract keywords from the text provided . [CODESPLIT] def extract_keywords_from_text ( self , text ) : sentences = nltk . tokenize . sent_tokenize ( text ) self . extract_keywords_from_sentences ( sentences )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a pretty - printed XML string for the Element . [CODESPLIT] def prettify ( elem ) : rough_string = ET . tostring ( elem , 'utf-8' ) reparsed = minidom . parseString ( rough_string ) return reparsed . toprettyxml ( indent = \"\\t\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find and kill child processes of a process . [CODESPLIT] def kill_process_children ( pid ) : if sys . platform == \"darwin\" : kill_process_children_osx ( pid ) elif sys . platform == \"linux\" : kill_process_children_unix ( pid ) else : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an array of K - Means cluster classes for an array of shapely . geometry . Point objects . [CODESPLIT] def classify_clusters ( points , n = 10 ) : arr = [ [ p . x , p . y ] for p in points . values ] clf = KMeans ( n_clusters = n ) clf . fit ( arr ) classes = clf . predict ( arr ) return classes", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get single system variable from CCU / Homegear [CODESPLIT] def getSystemVariable ( self , remote , name ) : if self . _server is not None : return self . _server . getSystemVariable ( remote , name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like dict ( ** kwargs ) but where the source key is special . [CODESPLIT] def _sourced_dict ( self , source = None , * * kwargs ) : if source : kwargs [ 'source' ] = source elif self . source : kwargs [ 'source' ] = self . source return kwargs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap an AST Call node to lambda expression node . call : ast . Call node [CODESPLIT] def make_lambda ( call ) : empty_args = ast . arguments ( args = [ ] , vararg = None , kwarg = None , defaults = [ ] ) return ast . Lambda ( args = empty_args , body = call )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if current project has any noncommited changes . [CODESPLIT] def is_changed ( ) : executed , changed_lines = execute_git ( 'status --porcelain' , output = False ) merge_not_finished = mod_path . exists ( '.git/MERGE_HEAD' ) return changed_lines . strip ( ) or merge_not_finished", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call color function base on name [CODESPLIT] def color_func ( func_name ) : if str ( func_name ) . isdigit ( ) : return term_color ( int ( func_name ) ) return globals ( ) [ func_name ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates requests session user - agent with the driver s user agent [CODESPLIT] def copy_user_agent_from_driver ( self ) : selenium_user_agent = self . driver . execute_script ( \"return navigator.userAgent;\" ) self . headers . update ( { \"user-agent\" : selenium_user_agent } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty printing for numpy matrix X [CODESPLIT] def print_matrix ( X , decimals = 1 ) : for row in np . round ( X , decimals = decimals ) : print ( row )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets the width of the table that would be printed . : rtype : int [CODESPLIT] def get_table_width ( table ) : columns = transpose_table ( prepare_rows ( table ) ) widths = [ max ( len ( cell ) for cell in column ) for column in columns ] return len ( '+' + '|' . join ( '-' * ( w + 2 ) for w in widths ) + '+' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "mono - exponential curve . [CODESPLIT] def algo_exp ( x , m , t , b ) : return m * np . exp ( - t * x ) + b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Constrain numbers to ( 0 1 ) interval [CODESPLIT] def open01 ( x , limit = 1.e-6 ) : try : return np . array ( [ min ( max ( y , limit ) , 1. - limit ) for y in x ] ) except TypeError : return min ( max ( x , limit ) , 1. - limit )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check if we need graphviz for different output format [CODESPLIT] def _check_graphviz_available ( output_format ) : try : subprocess . call ( [ \"dot\" , \"-V\" ] , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) except OSError : print ( \"The output format '%s' is currently not available.\\n\" \"Please install 'Graphviz' to have other output formats \" \"than 'dot' or 'vcg'.\" % output_format ) sys . exit ( 32 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Select rows where the given field is greater than the given value . [CODESPLIT] def selectgt ( table , field , value , complement = False ) : value = Comparable ( value ) return selectop ( table , field , value , operator . gt , complement = complement )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the indices of all the val in m [CODESPLIT] def index ( m , val ) : mm = np . array ( m ) idx_tuple = np . where ( mm == val ) idx = idx_tuple [ 0 ] . tolist ( ) return idx", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if an executable is available on the system . [CODESPLIT] def executable_exists ( executable ) : for directory in os . getenv ( \"PATH\" ) . split ( \":\" ) : if os . path . exists ( os . path . join ( directory , executable ) ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return a list of all state values [CODESPLIT] def values ( self ) : values = [ ] for __ , data in self . items ( ) : values . append ( data ) return values", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a P2SH address from a hex script [CODESPLIT] def btc_make_p2sh_address ( script_hex ) : h = hashing . bin_hash160 ( binascii . unhexlify ( script_hex ) ) addr = bin_hash160_to_address ( h , version_byte = multisig_version_byte ) return addr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the channels of a colorbar . [CODESPLIT] def colorbar ( height , length , colormap ) : cbar = np . tile ( np . arange ( length ) * 1.0 / ( length - 1 ) , ( height , 1 ) ) cbar = ( cbar * ( colormap . values . max ( ) - colormap . values . min ( ) ) + colormap . values . min ( ) ) return colormap . colorize ( cbar )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get list of datetime objects extracted from a filename [CODESPLIT] def get_dt_list ( fn_list ) : dt_list = np . array ( [ fn_getdatetime ( fn ) for fn in fn_list ] ) return dt_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "abstract method [CODESPLIT] def poke_array ( self , store , name , elemtype , elements , container , visited , _stack ) : raise NotImplementedError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Computes average length of words [CODESPLIT] def get_average_length_of_string ( strings ) : if not strings : return 0 return sum ( len ( word ) for word in strings ) / len ( strings )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Email address validation method . [CODESPLIT] def is_valid ( email ) : if isinstance ( email , basestring ) and EMAIL_RE . match ( email ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Refresh the screen . You don t need to override this except to update only small portins of the screen . [CODESPLIT] def update_screen ( self ) : self . clock . tick ( self . FPS ) pygame . display . update ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function should be called instead of direct spio . loadmat as it cures the problem of not properly recovering python dictionaries from mat files . It calls the function check keys to cure all entries which are still mat - objects [CODESPLIT] def loadmat ( filename ) : data = sploadmat ( filename , struct_as_record = False , squeeze_me = True ) return _check_keys ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deserialize s ( a str ) to a Python object . [CODESPLIT] def loads ( s , model = None , parser = None ) : with StringIO ( s ) as f : return load ( f , model = model , parser = parser )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if two numbers are equal up to the specified number of places after the decimal point . [CODESPLIT] def _float_almost_equal ( float1 , float2 , places = 7 ) : if round ( abs ( float2 - float1 ) , places ) == 0 : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Called by remote workers . Useful to populate main module globals () for interactive shells . Retrieves the serialized function . [CODESPLIT] def getFunction ( self ) : return functionFactory ( self . code , self . name , self . defaults , self . globals , self . imports , )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns True if object is text - like [CODESPLIT] def is_text ( obj , name = None ) : try : # python2 ans = isinstance ( obj , basestring ) except NameError : # python3 ans = isinstance ( obj , str ) if name : print ( \"is_text: (%s) %s = %s\" % ( ans , name , obj . __class__ ) , file = sys . stderr ) return ans", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a thread local stack uniquified by the given name . [CODESPLIT] def _get_or_create_stack ( name ) : stack = getattr ( _LOCAL_STACKS , name , None ) if stack is None : stack = [ ] setattr ( _LOCAL_STACKS , name , stack ) return stack", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Forget all loaded coordinates . [CODESPLIT] def forget_coords ( self ) : self . w . ntotal . set_text ( '0' ) self . coords_dict . clear ( ) self . redo ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Localize a datetime object to local time . [CODESPLIT] def localize ( dt ) : if dt . tzinfo is UTC : return ( dt + LOCAL_UTC_OFFSET ) . replace ( tzinfo = None ) # No TZ info so not going to assume anything, return as-is. return dt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Closes the session to the database . [CODESPLIT] def unlock ( self ) : if not hasattr ( self , 'session' ) : raise RuntimeError ( 'Error detected! The session that you want to close does not exist any more!' ) logger . debug ( \"Closed database session of '%s'\" % self . _database ) self . session . close ( ) del self . session", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Log - normal function from scipy [CODESPLIT] def lognorm ( x , mu , sigma = 1.0 ) : return stats . lognorm ( sigma , scale = mu ) . pdf ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert audio data into a frequency - amplitude table using fast fourier transformation . [CODESPLIT] def find_frequencies ( data , freq = 44100 , bits = 16 ) : # Fast fourier transform n = len ( data ) p = _fft ( data ) uniquePts = numpy . ceil ( ( n + 1 ) / 2.0 ) # Scale by the length (n) and square the value to get the amplitude p = [ ( abs ( x ) / float ( n ) ) ** 2 * 2 for x in p [ 0 : uniquePts ] ] p [ 0 ] = p [ 0 ] / 2 if n % 2 == 0 : p [ - 1 ] = p [ - 1 ] / 2 # Generate the frequencies and zip with the amplitudes s = freq / float ( n ) freqArray = numpy . arange ( 0 , uniquePts * s , s ) return zip ( freqArray , p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "print the message to the predefined log file without newline [CODESPLIT] def log_no_newline ( self , msg ) : self . print2file ( self . logfile , False , False , msg )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Display all available logging information . [CODESPLIT] def pylog ( self , * args , * * kwargs ) : printerr ( self . name , args , kwargs , traceback . format_exc ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform actions before parent main window is closed [CODESPLIT] def closing_plugin ( self , cancelable = False ) : self . dialog_manager . close_all ( ) self . shell . exit_interpreter ( ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Close log [CODESPLIT] def close_log ( log , verbose = True ) : if verbose : print ( 'Closing log file:' , log . name ) # Send closing message. log . info ( 'The log file has been closed.' ) # Remove all handlers from log. [ log . removeHandler ( handler ) for handler in log . handlers ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load logger config from file Keyword arguments : filename -- configuration filename ( Default : logging . ini ) * args -- options passed to fileConfig ** kwargs -- options passed to fileConfigg [CODESPLIT] def load_config ( filename = \"logging.ini\" , * args , * * kwargs ) : logging . config . fileConfig ( filename , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Lookup country for IP address . [CODESPLIT] def get_geoip ( ip ) : reader = geolite2 . reader ( ) ip_data = reader . get ( ip ) or { } return ip_data . get ( 'country' , { } ) . get ( 'iso_code' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sends all messages to logger . [ mthd ] () for handling [CODESPLIT] def setLoggerAll ( self , mthd ) : for key in self . _logger_methods : self . _logger_methods [ key ] = mthd", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param str from_ : : param str to : [CODESPLIT] def time_range ( from_ = None , to = None ) : # todo datetime conversion args = locals ( ) return { k . replace ( '_' , '' ) : v for k , v in args . items ( ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dataframe that is a cross between dataframes df1 and df2 [CODESPLIT] def cross_join ( df1 , df2 ) : if len ( df1 ) == 0 : return df2 if len ( df2 ) == 0 : return df1 # Add as lists so that the new index keeps the items in # the order that they are added together all_columns = pd . Index ( list ( df1 . columns ) + list ( df2 . columns ) ) df1 [ 'key' ] = 1 df2 [ 'key' ] = 1 return pd . merge ( df1 , df2 , on = 'key' ) . loc [ : , all_columns ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A Bark logging handler logging output to a named file . At intervals specified by the when the file will be rotated under control of backupCount . [CODESPLIT] def timed_rotating_file_handler ( name , logname , filename , when = 'h' , interval = 1 , backupCount = 0 , encoding = None , delay = False , utc = False ) : return wrap_log_handler ( logging . handlers . TimedRotatingFileHandler ( filename , when = when , interval = interval , backupCount = backupCount , encoding = encoding , delay = delay , utc = utc ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handle logging . [CODESPLIT] def logger ( message , level = 10 ) : logging . getLogger ( __name__ ) . log ( level , str ( message ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the given path relative to this file . [CODESPLIT] def relative_path ( path ) : return os . path . join ( os . path . dirname ( __file__ ) , path )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit without garbage collection this speeds up exit by about 10ms for things like bash completion . [CODESPLIT] def fast_exit ( code ) : sys . stdout . flush ( ) sys . stderr . flush ( ) os . _exit ( code )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Start web application [CODESPLIT] def web ( host , port ) : from . webserver . web import get_app get_app ( ) . run ( host = host , port = port )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "validate that we can store the multi - index ; reset and return the new object [CODESPLIT] def validate_multiindex ( self , obj ) : levels = [ l if l is not None else \"level_{0}\" . format ( i ) for i , l in enumerate ( obj . index . names ) ] try : return obj . reset_index ( ) , levels except ValueError : raise ValueError ( \"duplicate names/columns in the multi-index when \" \"storing as a table\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "DEBUG FUNC modify argv to look like you ran a command [CODESPLIT] def aug_sysargv ( cmdstr ) : import shlex argv = shlex . split ( cmdstr ) sys . argv . extend ( argv )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compare items in 2 arrays . Returns sum ( abs ( a ( i ) - b ( i ))) [CODESPLIT] def compare ( a , b ) : s = 0 for i in range ( len ( a ) ) : s = s + abs ( a [ i ] - b [ i ] ) return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convenient shorthand for toarray ( * args ** kwargs ) . view ( np . recarray ) . [CODESPLIT] def torecarray ( * args , * * kwargs ) : import numpy as np return toarray ( * args , * * kwargs ) . view ( np . recarray )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts CamelCase to camel / case [CODESPLIT] def camelcase_to_slash ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1/\\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1/\\2' , s1 ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take stderr bytes returned from MicroPython and attempt to create a non - verbose error message . [CODESPLIT] def clean_error ( err ) : if err : decoded = err . decode ( 'utf-8' ) try : return decoded . split ( '\\r\\n' ) [ - 2 ] except Exception : return decoded return 'There was an error.'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract text from a given lxml node . [CODESPLIT] def _extract_node_text ( node ) : texts = map ( six . text_type . strip , map ( six . text_type , map ( unescape , node . xpath ( \".//text()\" ) ) ) ) return \" \" . join ( text for text in texts if text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run a Tensorflow model on the Iris dataset . [CODESPLIT] def main ( argv = None ) : args = parse_arguments ( sys . argv if argv is None else argv ) tf . logging . set_verbosity ( tf . logging . INFO ) learn_runner . run ( experiment_fn = get_experiment_fn ( args ) , output_dir = args . job_dir )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract text from a given lxml node . [CODESPLIT] def _extract_node_text ( node ) : texts = map ( six . text_type . strip , map ( six . text_type , map ( unescape , node . xpath ( \".//text()\" ) ) ) ) return \" \" . join ( text for text in texts if text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add suffix to a full file name [CODESPLIT] def add_suffix ( fullname , suffix ) : name , ext = os . path . splitext ( fullname ) return name + '_' + suffix + ext", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def process_instance ( self , instance ) : self . log . debug ( \"e = mc^2\" ) self . log . info ( \"About to fail..\" ) self . log . warning ( \"Failing.. soooon..\" ) self . log . critical ( \"Ok, you're done.\" ) assert False , \"\"\"ValidateFailureMock was destined to fail..\n\nHere's some extended information about what went wrong.\n\nIt has quite the long string associated with it, including\na few newlines and a list.\n\n- Item 1\n- Item 2\n\n\"\"\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a spec to a mock . spec can either be an object or a list of strings . Only attributes on the spec can be fetched as attributes from the mock . [CODESPLIT] def mock_add_spec ( self , spec , spec_set = False ) : self . _mock_add_spec ( spec , spec_set ) self . _mock_set_magics ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add css requirements to HTML . [CODESPLIT] def markdown_media_css ( ) : return dict ( CSS_SET = posixpath . join ( settings . MARKDOWN_SET_PATH , settings . MARKDOWN_SET_NAME , 'style.css' ) , CSS_SKIN = posixpath . join ( 'django_markdown' , 'skins' , settings . MARKDOWN_EDITOR_SKIN , 'style.css' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Idempotent and None - safe version of strict_bool . [CODESPLIT] def less_strict_bool ( x ) : if x is None : return False elif x is True or x is False : return x else : return strict_bool ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns Gaussian smoothed image . [CODESPLIT] def smooth_gaussian ( image , sigma = 1 ) : return scipy . ndimage . filters . gaussian_filter ( image , sigma = sigma , mode = \"nearest\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "From : http : // book . opensourceproject . org . cn / lamp / python / pythoncook2 / opensource / 0596007973 / pythoncook2 - chp - 19 - sect - 9 . html [CODESPLIT] def cross_list ( * sequences ) : result = [ [ ] ] for seq in sequences : result = [ sublist + [ item ] for sublist in result for item in seq ] return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the path to the javascript bundle [CODESPLIT] def default_static_path ( ) : fdir = os . path . dirname ( __file__ ) return os . path . abspath ( os . path . join ( fdir , '../assets/' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fill NaNs with the previous value the next value or if all are NaN then 1 . 0 [CODESPLIT] def clean_dataframe ( df ) : df = df . fillna ( method = 'ffill' ) df = df . fillna ( 0.0 ) return df", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Use openpyxl to read an Excel file . [CODESPLIT] def _openpyxl_read_xl ( xl_path : str ) : try : wb = load_workbook ( filename = xl_path , read_only = True ) except : raise else : return wb", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a date into a datetime [CODESPLIT] def date_to_datetime ( x ) : if not isinstance ( x , datetime ) and isinstance ( x , date ) : return datetime . combine ( x , time ( ) ) return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Use openpyxl to read an Excel file . [CODESPLIT] def _openpyxl_read_xl ( xl_path : str ) : try : wb = load_workbook ( filename = xl_path , read_only = True ) except : raise else : return wb", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Python s input () is blocking which means the event loop we set above can t be running while we re blocking there . This method will let the loop run while we wait for input . [CODESPLIT] async def async_input ( prompt ) : print ( prompt , end = '' , flush = True ) return ( await loop . run_in_executor ( None , sys . stdin . readline ) ) . rstrip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Average every 4 elements ( 2x2 ) in a 2D array [CODESPLIT] def aggregate ( d , y_size , x_size ) : if d . ndim != 2 : # we can't guarantee what blocks we are getting and how # it should be reshaped to do the averaging. raise ValueError ( \"Can't aggregrate (reduce) data arrays with \" \"more than 2 dimensions.\" ) if not ( x_size . is_integer ( ) and y_size . is_integer ( ) ) : raise ValueError ( \"Aggregation factors are not integers\" ) for agg_size , chunks in zip ( [ y_size , x_size ] , d . chunks ) : for chunk_size in chunks : if chunk_size % agg_size != 0 : raise ValueError ( \"Aggregation requires arrays with \" \"shapes and chunks divisible by the \" \"factor\" ) new_chunks = ( tuple ( int ( x / y_size ) for x in d . chunks [ 0 ] ) , tuple ( int ( x / x_size ) for x in d . chunks [ 1 ] ) ) return da . core . map_blocks ( _mean , d , y_size , x_size , dtype = d . dtype , chunks = new_chunks )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility function to create regexp for matching escaped separators in strings . [CODESPLIT] def make_regex ( separator ) : return re . compile ( r'(?:' + re . escape ( separator ) + r')?((?:[^' + re . escape ( separator ) + r'\\\\]|\\\\.)+)' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert record array to a dictionaries [CODESPLIT] def to_dicts ( recarray ) : for rec in recarray : yield dict ( zip ( recarray . dtype . names , rec . tolist ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Softsign op . [CODESPLIT] def Softsign ( a ) : return np . divide ( a , np . add ( np . abs ( a ) , 1 ) ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Scan through string looking for a location where this word produces a match and return a corresponding MatchObject instance . Return None if no position in the string matches the pattern ; note that this is different from finding a zero - length match at some point in the string . [CODESPLIT] def find_whole_word ( w ) : return re . compile ( r'\\b({0})\\b' . format ( w ) , flags = re . IGNORECASE ) . search", "target": 1, "target_options": ["no_match", "match"]}
{"input": "variance of the values must have 2 or more entries . [CODESPLIT] def variance ( arr ) : avg = average ( arr ) return sum ( [ ( float ( x ) - avg ) ** 2 for x in arr ] ) / float ( len ( arr ) - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Plot the empirical histogram versus best - fit distribution s PDF . [CODESPLIT] def plot ( self ) : plt . plot ( self . bin_edges , self . hist , self . bin_edges , self . best_pdf )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the RMS of the audio [CODESPLIT] def calc_volume ( self , sample : np . ndarray ) : return sqrt ( np . mean ( np . square ( sample ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a histogram for the data to the axes . [CODESPLIT] def _histplot_op ( ax , data , * * kwargs ) : bins = get_bins ( data ) ax . hist ( data , bins = bins , align = \"left\" , density = True , * * kwargs ) return ax", "target": 1, "target_options": ["no_match", "match"]}
{"input": "variance of the values must have 2 or more entries . [CODESPLIT] def variance ( arr ) : avg = average ( arr ) return sum ( [ ( float ( x ) - avg ) ** 2 for x in arr ] ) / float ( len ( arr ) - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get rid of all axis ticks lines etc . [CODESPLIT] def axes_off ( ax ) : ax . set_frame_on ( False ) ax . axes . get_yaxis ( ) . set_visible ( False ) ax . axes . get_xaxis ( ) . set_visible ( False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts snake_cased_names to CamelCaseNames . [CODESPLIT] def to_camel_case ( snake_case_name ) : bits = snake_case_name . split ( '_' ) return '' . join ( [ bit . capitalize ( ) for bit in bits ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "manually set the default figure size of plots :: Arguments :: x ( float ) : x - axis size y ( float ) : y - axis size aspect ( float ) : aspect ratio scalar [CODESPLIT] def figsize ( x = 8 , y = 7. , aspect = 1. ) : # update rcparams with adjusted figsize params mpl . rcParams . update ( { 'figure.figsize' : ( x * aspect , y ) } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Just the last entry . [CODESPLIT] def get_last ( self , table = None ) : if table is None : table = self . main_table query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table return self . own_cursor . execute ( query ) . fetchone ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Jacobian matrix given Christophe s suggestion of f [CODESPLIT] def jac ( x , a ) : return ( x - a ) / np . sqrt ( ( ( x - a ) ** 2 ) . sum ( 1 ) ) [ : , np . newaxis ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform list into a maxheap in - place in O ( len ( x )) time . [CODESPLIT] def _heapify_max ( x ) : n = len ( x ) for i in reversed ( range ( n // 2 ) ) : _siftup_max ( x , i )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Join the given iterable with [CODESPLIT] def commajoin_as_strings ( iterable ) : return _ ( u',' ) . join ( ( six . text_type ( i ) for i in iterable ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Segmented max op . [CODESPLIT] def SegmentMax ( a , ids ) : func = lambda idxs : np . amax ( a [ idxs ] , axis = 0 ) return seg_map ( func , a , ids ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility function which converts lists to tuples . [CODESPLIT] def as_tuple ( self , value ) : if isinstance ( value , list ) : value = tuple ( value ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return possible range for min function . [CODESPLIT] def min_values ( args ) : return Interval ( min ( x . low for x in args ) , min ( x . high for x in args ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the md5 hash of the given file - object [CODESPLIT] def md5_hash_file ( fh ) : md5 = hashlib . md5 ( ) while True : data = fh . read ( 8192 ) if not data : break md5 . update ( data ) return md5 . hexdigest ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Change cell in position ( x ; y ) . [CODESPLIT] def change_cell ( self , x , y , ch , fg , bg ) : self . console . draw_char ( x , y , ch , fg , bg )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "set colouring on if STDOUT is a terminal device off otherwise [CODESPLIT] def auto ( ) : try : Style . enabled = False Style . enabled = sys . stdout . isatty ( ) except ( AttributeError , TypeError ) : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a ( width height ) pair representing the size of * text * in English Metric Units ( EMU ) when rendered at * point_size * in the font defined in * font_file * . [CODESPLIT] def _rendered_size ( text , point_size , font_file ) : emu_per_inch = 914400 px_per_inch = 72.0 font = _Fonts . font ( font_file , point_size ) px_width , px_height = font . getsize ( text ) emu_width = int ( px_width / px_per_inch * emu_per_inch ) emu_height = int ( px_height / px_per_inch * emu_per_inch ) return emu_width , emu_height", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Changes a column name in a DataFrame Parameters : df - DataFrame DataFrame to operate on col_name - string Name of column to change new_col_name - string New name of column [CODESPLIT] def col_rename ( df , col_name , new_col_name ) : col_list = list ( df . columns ) for index , value in enumerate ( col_list ) : if value == col_name : col_list [ index ] = new_col_name break df . columns = col_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert to float if object is a float string . [CODESPLIT] def _tofloat ( obj ) : if \"inf\" in obj . lower ( ) . strip ( ) : return obj try : return int ( obj ) except ValueError : try : return float ( obj ) except ValueError : return obj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update conda packages in a conda env [CODESPLIT] def update ( packages , env = None , user = None ) : packages = ' ' . join ( packages . split ( ',' ) ) cmd = _create_conda_cmd ( 'update' , args = [ packages , '--yes' , '-q' ] , env = env , user = user ) return _execcmd ( cmd , user = user )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper parse action to convert tokens to lower case . [CODESPLIT] def downcaseTokens ( s , l , t ) : return [ tt . lower ( ) for tt in map ( _ustr , t ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a function that checks whether a scalar or array is of a given kind ( e . g . float int datetime timedelta ) . [CODESPLIT] def make_kind_check ( python_types , numpy_kind ) : def check ( value ) : if hasattr ( value , 'dtype' ) : return value . dtype . kind == numpy_kind return isinstance ( value , python_types ) return check", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check file position matches blocksize [CODESPLIT] def _check_fpos ( self , fp_ , fpos , offset , block ) : if ( fp_ . tell ( ) + offset != fpos ) : warnings . warn ( \"Actual \" + block + \" header size does not match expected\" ) return", "target": 1, "target_options": ["no_match", "match"]}
{"input": "assert the mock has been called with the specified arguments . [CODESPLIT] def assert_any_call ( self , * args , * * kwargs ) : kall = call ( * args , * * kwargs ) if kall not in self . call_args_list : expected_string = self . _format_mock_call_signature ( args , kwargs ) raise AssertionError ( '%s call not found' % expected_string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "An argparse type representing an email address . [CODESPLIT] def email_type ( arg ) : if not is_valid_email_address ( arg ) : raise argparse . ArgumentTypeError ( \"{0} is not a valid email address\" . format ( repr ( arg ) ) ) return arg", "target": 1, "target_options": ["no_match", "match"]}
{"input": "assert the mock has been called with the specified arguments . [CODESPLIT] def assert_any_call ( self , * args , * * kwargs ) : kall = call ( * args , * * kwargs ) if kall not in self . call_args_list : expected_string = self . _format_mock_call_signature ( args , kwargs ) raise AssertionError ( '%s call not found' % expected_string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Match two names . [CODESPLIT] def _match_literal ( self , a , b = None ) : return a . lower ( ) == b if not self . case_sensitive else a == b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A handy update () method which returns self : ) [CODESPLIT] def update ( self , * args , * * kwargs ) : super ( DictProxy , self ) . update ( * args , * * kwargs ) return self", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ensures that the argument is a list that either is empty or contains only strings : param arr : list : return : [CODESPLIT] def all_strings ( arr ) : if not isinstance ( [ ] , list ) : raise TypeError ( \"non-list value found where list is expected\" ) return all ( isinstance ( x , str ) for x in arr )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Installs ScoutApm SQL Instrumentation by monkeypatching the cursor method of BaseDatabaseWrapper to return a wrapper that instruments any calls going through it . [CODESPLIT] def install ( ) : @ monkeypatch_method ( BaseDatabaseWrapper ) def cursor ( original , self , * args , * * kwargs ) : result = original ( * args , * * kwargs ) return _DetailedTracingCursorWrapper ( result , self ) logger . debug ( \"Monkey patched SQL\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is this an integer . [CODESPLIT] def is_integer ( obj ) : if PYTHON3 : return isinstance ( obj , int ) return isinstance ( obj , ( int , long ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a function that checks whether a scalar or array is of a given kind ( e . g . float int datetime timedelta ) . [CODESPLIT] def make_kind_check ( python_types , numpy_kind ) : def check ( value ) : if hasattr ( value , 'dtype' ) : return value . dtype . kind == numpy_kind return isinstance ( value , python_types ) return check", "target": 1, "target_options": ["no_match", "match"]}
{"input": "if the value is in the list move it to the front and return it . [CODESPLIT] def list_move_to_front ( l , value = 'other' ) : l = list ( l ) if value in l : l . remove ( value ) l . insert ( 0 , value ) return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if an array is a square matrix . [CODESPLIT] def is_square_matrix ( mat ) : mat = np . array ( mat ) if mat . ndim != 2 : return False shape = mat . shape return shape [ 0 ] == shape [ 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Align the position in the file to the next block of specified size [CODESPLIT] def align_file_position ( f , size ) : align = ( size - 1 ) - ( f . tell ( ) % size ) f . seek ( align , 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a tuple of strings that match the regular expression pattern . [CODESPLIT] def filter_regex ( names , regex ) : return tuple ( name for name in names if regex . search ( name ) is not None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Move all file found by glob . glob ( pattern ) to destination directory . [CODESPLIT] def gmove ( pattern , destination ) : for item in glob . glob ( pattern ) : if not move ( item , destination ) : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "x is a 2D sparse matrix with it s first shape equal to 1 . [CODESPLIT] def is_sparse_vector ( x ) : return sp . issparse ( x ) and len ( x . shape ) == 2 and x . shape [ 0 ] == 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates the moving average ( rolling mean ) of an array of a certain window size . [CODESPLIT] def movingaverage ( arr , window ) : m = np . ones ( int ( window ) ) / int ( window ) return scipy . ndimage . convolve1d ( arr , m , axis = 0 , mode = 'reflect' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a numpy dtype determines whether it is a string . Returns True if the dtype is string or unicode . [CODESPLIT] def _isstring ( dtype ) : return dtype . type == numpy . unicode_ or dtype . type == numpy . string_", "target": 1, "target_options": ["no_match", "match"]}
{"input": "validate that we can store the multi - index ; reset and return the new object [CODESPLIT] def validate_multiindex ( self , obj ) : levels = [ l if l is not None else \"level_{0}\" . format ( i ) for i , l in enumerate ( obj . index . names ) ] try : return obj . reset_index ( ) , levels except ValueError : raise ValueError ( \"duplicate names/columns in the multi-index when \" \"storing as a table\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Similar to : attr : . Guild . me except it may return the : class : . ClientUser in private message contexts . [CODESPLIT] def me ( self ) : return self . guild . me if self . guild is not None else self . bot . user", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a multiline string into a list excluding blank lines . [CODESPLIT] def split_multiline ( value ) : return [ element for element in ( line . strip ( ) for line in value . split ( '\\n' ) ) if element ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if a file is located within the given directory . [CODESPLIT] def contained_in ( filename , directory ) : filename = os . path . normcase ( os . path . abspath ( filename ) ) directory = os . path . normcase ( os . path . abspath ( directory ) ) return os . path . commonprefix ( [ filename , directory ] ) == directory", "target": 1, "target_options": ["no_match", "match"]}
{"input": "detect if a model has a given field has [CODESPLIT] def has_field ( mc , field_name ) : try : mc . _meta . get_field ( field_name ) except FieldDoesNotExist : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if an element from a list is in a string . [CODESPLIT] def isin ( elems , line ) : found = False for e in elems : if e in line . lower ( ) : found = True break return found", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like many_until but must consume at least one of these . [CODESPLIT] def many_until1 ( these , term ) : first = [ these ( ) ] these_results , term_result = many_until ( these , term ) return ( first + these_results , term_result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the number of cores reserved in this moment . A core is reserved if it s still not running but we have submitted the task to the queue manager . [CODESPLIT] def ncores_reserved ( self ) : return sum ( task . manager . num_cores for task in self if task . status == task . S_SUB )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the number of cores reserved in this moment . A core is reserved if it s still not running but we have submitted the task to the queue manager . [CODESPLIT] def ncores_reserved ( self ) : return sum ( task . manager . num_cores for task in self if task . status == task . S_SUB )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if the given object is a Pandas Data Frame . [CODESPLIT] def is_dataframe ( obj ) : try : # This is the best method of type checking from pandas import DataFrame return isinstance ( obj , DataFrame ) except ImportError : # Pandas is not a dependency, so this is scary return obj . __class__ . __name__ == \"DataFrame\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "stop server [CODESPLIT] def stop ( self ) : try : self . shutdown ( ) except ( PyMongoError , ServersError ) as exc : logger . info ( \"Killing %s with signal, shutdown command failed: %r\" , self . name , exc ) return process . kill_mprocess ( self . proc )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a function which validates that the value is a list of items which are validated using item_validator . [CODESPLIT] def build_list_type_validator ( item_validator ) : def validate_list_of_type ( value ) : return [ item_validator ( item ) for item in validate_list ( value ) ] return validate_list_of_type", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Callable function for the multiprocessing pool . [CODESPLIT] def compute ( args ) : x , y , params = args return x , y , mandelbrot ( x , y , params )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tries to determine if a buffer is empty . [CODESPLIT] def allZero ( buffer ) : allZero = True for byte in buffer : if byte != \"\\x00\" : allZero = False break return allZero", "target": 1, "target_options": ["no_match", "match"]}
{"input": "execute jobs in processes using N threads [CODESPLIT] def parallel ( processes , threads ) : pool = multithread ( threads ) pool . map ( run_process , processes ) pool . close ( ) pool . join ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convenience method that works with all 2 . x versions of Python to determine whether or not something is stringlike . [CODESPLIT] def isString ( s ) : try : return isinstance ( s , unicode ) or isinstance ( s , basestring ) except NameError : return isinstance ( s , str )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "execute jobs in processes using N threads [CODESPLIT] def parallel ( processes , threads ) : pool = multithread ( threads ) pool . map ( run_process , processes ) pool . close ( ) pool . join ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Connect to MySQL with retries . [CODESPLIT] def connect_mysql ( host , port , user , password , database ) : return pymysql . connect ( host = host , port = port , user = user , passwd = password , db = database )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Report whether the given value is a byte or unicode string . [CODESPLIT] def isstring ( value ) : classes = ( str , bytes ) if pyutils . PY3 else basestring # noqa: F821 return isinstance ( value , classes )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get single value from select () query i . e . for aggregation . [CODESPLIT] async def scalar ( self , query , as_tuple = False ) : query = self . _swap_database ( query ) return ( await scalar ( query , as_tuple = as_tuple ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Drops and re - creates the SQL schema [CODESPLIT] def init_db ( ) : db . drop_all ( ) db . configure_mappers ( ) db . create_all ( ) db . session . commit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prepare a database query or command and then execute it against all parameter sequences found in the sequence seq_of_params . [CODESPLIT] def executemany ( self , sql , * params ) : fut = self . _run_operation ( self . _impl . executemany , sql , * params ) return fut", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check to see if the internet is on by pinging a set address . : param address : the IP or address to hit : return : a boolean - true if can be reached false if not . [CODESPLIT] def _internet_on ( address ) : try : urllib2 . urlopen ( address , timeout = 1 ) return True except urllib2 . URLError as err : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform a named tuple into a dictionary [CODESPLIT] def dictify ( a_named_tuple ) : return dict ( ( s , getattr ( a_named_tuple , s ) ) for s in a_named_tuple . _fields )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the file exif [CODESPLIT] def information ( filename ) : check_if_this_file_exist ( filename ) filename = os . path . abspath ( filename ) result = get_json ( filename ) result = result [ 0 ] return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility to generate enum classes used by annotations . [CODESPLIT] def _Enum ( docstring , * names ) : enums = dict ( zip ( names , range ( len ( names ) ) ) ) reverse = dict ( ( value , key ) for key , value in enums . iteritems ( ) ) enums [ 'reverse_mapping' ] = reverse enums [ '__doc__' ] = docstring return type ( 'Enum' , ( object , ) , enums )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks to see if a 2D list is a valid 2D matrix [CODESPLIT] def _rectangular ( n ) : for i in n : if len ( i ) != len ( n [ 0 ] ) : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets up the python include paths to include src [CODESPLIT] def setup_path ( ) : import os . path import sys if sys . argv [ 0 ] : top_dir = os . path . dirname ( os . path . abspath ( sys . argv [ 0 ] ) ) sys . path = [ os . path . join ( top_dir , \"src\" ) ] + sys . path pass return", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Path references an executable file . [CODESPLIT] def is_exe ( fpath ) : return os . path . isfile ( fpath ) and os . access ( fpath , os . X_OK )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if pip exists inside the virtual environment . Can be used as a naive way to verify that the environment is installed . [CODESPLIT] def _pip_exists ( self ) : return os . path . isfile ( os . path . join ( self . path , 'bin' , 'pip' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get adjacency matrix . [CODESPLIT] def get_adjacent_matrix ( self ) : edges = self . edges num_edges = len ( edges ) + 1 adj = np . zeros ( [ num_edges , num_edges ] ) for k in range ( num_edges - 1 ) : adj [ edges [ k ] . L , edges [ k ] . R ] = 1 adj [ edges [ k ] . R , edges [ k ] . L ] = 1 return adj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the size of the shared memory file system . [CODESPLIT] def get_shared_memory_bytes ( ) : # Make sure this is only called on Linux. assert sys . platform == \"linux\" or sys . platform == \"linux2\" shm_fd = os . open ( \"/dev/shm\" , os . O_RDONLY ) try : shm_fs_stats = os . fstatvfs ( shm_fd ) # The value shm_fs_stats.f_bsize is the block size and the # value shm_fs_stats.f_bavail is the number of available # blocks. shm_avail = shm_fs_stats . f_bsize * shm_fs_stats . f_bavail finally : os . close ( shm_fd ) return shm_avail", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert json string representation into class instance . [CODESPLIT] def from_json_str ( cls , json_str ) : return cls . from_json ( json . loads ( json_str , cls = JsonDecoder ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yaml either have automatically converted it to a datetime object or it is a string that will be validated later . [CODESPLIT] def is_timestamp ( obj ) : return isinstance ( obj , datetime . datetime ) or is_string ( obj ) or is_int ( obj ) or is_float ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create an array . Keyword arguments as per : func : zarr . creation . zeros . [CODESPLIT] def zeros ( self , name , * * kwargs ) : return self . _write_op ( self . _zeros_nosync , name , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Chunk named entities . [CODESPLIT] def ner_chunk ( args ) : chunker = NEChunker ( lang = args . lang ) tag ( chunker , args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert JSON object to a string [CODESPLIT] def get_prep_value ( self , value ) : if self . null and value is None : return None return json . dumps ( value , * * self . dump_kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of the input excluding all None values . [CODESPLIT] def _get_non_empty_list ( cls , iter ) : res = [ ] for value in iter : if hasattr ( value , 'items' ) : value = cls . _get_non_empty_dict ( value ) or None if value is not None : res . append ( value ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flush all items from cache . [CODESPLIT] def Flush ( self ) : while self . _age : node = self . _age . PopLeft ( ) self . KillObject ( node . data ) self . _hash = dict ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "rescales a numpy array so that min is 0 and max is 255 [CODESPLIT] def _normalize ( mat : np . ndarray ) : return ( ( mat - mat . min ( ) ) * ( 255 / mat . max ( ) ) ) . astype ( np . uint8 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cleanup any necessary opened files [CODESPLIT] def __exit__ ( self , * args ) : if self . _output_file_handle : self . _output_file_handle . close ( ) self . _output_file_handle = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "equivalent to scipy . preprocessing . normalize on sparse matrices but lets avoid another depedency just for a small utility function [CODESPLIT] def normalize ( X ) : X = coo_matrix ( X ) X . data = X . data / sqrt ( bincount ( X . row , X . data ** 2 ) ) [ X . row ] return X", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of values for the given selection . [CODESPLIT] def get_selected_values ( self , selection ) : return [ v for b , v in self . _choices if b & selection ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "I check to see if a method on a TestCase has been disabled via nose s convention for disabling a TestCase . This makes it so that users can mix nose s parameterized tests with green as a runner . [CODESPLIT] def isTestCaseDisabled ( test_case_class , method_name ) : test_method = getattr ( test_case_class , method_name ) return getattr ( test_method , \"__test__\" , 'not nose' ) is False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compare items in 2 arrays . Returns sum ( abs ( a ( i ) - b ( i ))) [CODESPLIT] def compare ( a , b ) : s = 0 for i in range ( len ( a ) ) : s = s + abs ( a [ i ] - b [ i ] ) return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the * cmd * and exit with the proper exit code . [CODESPLIT] def call_and_exit ( self , cmd , shell = True ) : sys . exit ( subprocess . call ( cmd , shell = shell ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate equality between two ( Comparable ) objects . [CODESPLIT] def equal ( obj1 , obj2 ) : Comparable . log ( obj1 , obj2 , '==' ) equality = obj1 . equality ( obj2 ) Comparable . log ( obj1 , obj2 , '==' , result = equality ) return equality", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove null items from a dictionary [CODESPLIT] def purge_dict ( idict ) : odict = { } for key , val in idict . items ( ) : if is_null ( val ) : continue odict [ key ] = val return odict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets the median of a list of values Returns a float / int [CODESPLIT] def getMedian ( numericValues ) : theValues = sorted ( numericValues ) if len ( theValues ) % 2 == 1 : return theValues [ ( len ( theValues ) + 1 ) / 2 - 1 ] else : lower = theValues [ len ( theValues ) / 2 - 1 ] upper = theValues [ len ( theValues ) / 2 ] return ( float ( lower + upper ) ) / 2", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Avoid overwriting some files accidentally . [CODESPLIT] def check_exists ( filename , oappend = False ) : if op . exists ( filename ) : if oappend : return oappend logging . error ( \"`{0}` found, overwrite (Y/N)?\" . format ( filename ) ) overwrite = ( raw_input ( ) == 'Y' ) else : overwrite = True return overwrite", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper : compute the output shape for the pooling layer . [CODESPLIT] def _pooling_output_shape ( input_shape , pool_size = ( 2 , 2 ) , strides = None , padding = 'VALID' ) : dims = ( 1 , ) + pool_size + ( 1 , ) # NHWC spatial_strides = strides or ( 1 , ) * len ( pool_size ) strides = ( 1 , ) + spatial_strides + ( 1 , ) pads = padtype_to_pads ( input_shape , dims , strides , padding ) operand_padded = onp . add ( input_shape , onp . add ( * zip ( * pads ) ) ) t = onp . floor_divide ( onp . subtract ( operand_padded , dims ) , strides ) + 1 return tuple ( t )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "last row or column of square A [CODESPLIT] def other_ind ( self ) : return np . full ( self . n_min , self . size - 1 , dtype = np . int )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Max reduction op . [CODESPLIT] def Max ( a , axis , keep_dims ) : return np . amax ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a structured NumPy array into a Table . [CODESPLIT] def from_array ( cls , arr ) : return cls ( ) . with_columns ( [ ( f , arr [ f ] ) for f in arr . dtype . names ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create an instance from a dictionary . [CODESPLIT] def from_dict ( cls , d ) : return cls ( * * { k : v for k , v in d . items ( ) if k in cls . ENTRIES } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns data as : class : numpy . recarray . [CODESPLIT] def recarray ( self ) : return numpy . rec . fromrecords ( self . records , names = self . names )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine the number of leaves in a tree [CODESPLIT] def num_leaves ( tree ) : if tree . is_leaf : return 1 else : return num_leaves ( tree . left_child ) + num_leaves ( tree . right_child )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute standard deviation with ddof degrees of freedom [CODESPLIT] def _std ( self , x ) : return np . nanstd ( x . values , ddof = self . _ddof )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return the count of objects of key [CODESPLIT] def objectcount ( data , key ) : objkey = key . upper ( ) return len ( data . dt [ objkey ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Expand dimensions by iteratively append empty axes . [CODESPLIT] def iterexpand ( arry , extra ) : for d in range ( arry . ndim , arry . ndim + extra ) : arry = expand_dims ( arry , axis = d ) return arry", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a AWS Key ID into a UID [CODESPLIT] def aws_to_unix_id ( aws_key_id ) : uid_bytes = hashlib . sha256 ( aws_key_id . encode ( ) ) . digest ( ) [ - 2 : ] if USING_PYTHON2 : return 2000 + int ( from_bytes ( uid_bytes ) // 2 ) else : return 2000 + ( int . from_bytes ( uid_bytes , byteorder = sys . byteorder ) // 2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a conda environment inside the current sandbox for the given list of dependencies and options . [CODESPLIT] def create_conda_env ( sandbox_dir , env_name , dependencies , options = ( ) ) : env_dir = os . path . join ( sandbox_dir , env_name ) cmdline = [ \"conda\" , \"create\" , \"--yes\" , \"--copy\" , \"--quiet\" , \"-p\" , env_dir ] + list ( options ) + dependencies log . info ( \"Creating conda environment: \" ) log . info ( \"  command line: %s\" , cmdline ) subprocess . check_call ( cmdline , stderr = subprocess . PIPE , stdout = subprocess . PIPE ) log . debug ( \"Environment created\" ) return env_dir , env_name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given two data points [ X Y ] linearly interpolate those at x . [CODESPLIT] def _linear_interpolation ( x , X , Y ) : return ( Y [ 1 ] * ( x - X [ 0 ] ) + Y [ 0 ] * ( X [ 1 ] - x ) ) / ( X [ 1 ] - X [ 0 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Combine the outer and inner keys of nested dictionaries into a single ordering . [CODESPLIT] def flattened_nested_key_indices ( nested_dict ) : outer_keys , inner_keys = collect_nested_keys ( nested_dict ) combined_keys = list ( sorted ( set ( outer_keys + inner_keys ) ) ) return { k : i for ( i , k ) in enumerate ( combined_keys ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Connect and run bot in event loop . [CODESPLIT] def run ( self , * args , * * kwargs ) : self . eventloop . run_until_complete ( self . connect ( * args , * * kwargs ) ) try : self . eventloop . run_forever ( ) finally : self . eventloop . stop ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Se asegura de que un directorio exista . [CODESPLIT] def ensure_dir_exists ( directory ) : if directory and not os . path . exists ( directory ) : os . makedirs ( directory )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a tif file to a 2D NumPy array [CODESPLIT] def ReadTif ( tifFile ) : img = Image . open ( tifFile ) img = np . array ( img ) return img", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a new scope in the current frame . [CODESPLIT] def append_scope ( self ) : self . stack . current . append ( Scope ( self . stack . current . current ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return if each value is NaN . [CODESPLIT] def _isnan ( self ) : if self . _can_hold_na : return isna ( self ) else : # shouldn't reach to this condition by checking hasnans beforehand values = np . empty ( len ( self ) , dtype = np . bool_ ) values . fill ( False ) return values", "target": 1, "target_options": ["no_match", "match"]}
{"input": "arr_out = round_array ( array_in ) [CODESPLIT] def round_array ( array_in ) : if isinstance ( array_in , ndarray ) : return np . round ( array_in ) . astype ( int ) else : return int ( np . round ( array_in ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "arr_out = round_array ( array_in ) [CODESPLIT] def round_array ( array_in ) : if isinstance ( array_in , ndarray ) : return np . round ( array_in ) . astype ( int ) else : return int ( np . round ( array_in ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a symbolic link [CODESPLIT] def symlink ( source , destination ) : log ( \"Symlinking {} as {}\" . format ( source , destination ) ) cmd = [ 'ln' , '-sf' , source , destination , ] subprocess . check_call ( cmd )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Serializes a numpy array to a compressed base64 string [CODESPLIT] def _array2cstr ( arr ) : out = StringIO ( ) np . save ( out , arr ) return b64encode ( out . getvalue ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reshape data into ( num_example batch_size ) [CODESPLIT] def batchify ( data , batch_size ) : nbatch = data . shape [ 0 ] // batch_size data = data [ : nbatch * batch_size ] data = data . reshape ( ( batch_size , nbatch ) ) . T return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Max reduction op . [CODESPLIT] def Max ( a , axis , keep_dims ) : return np . amax ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clips a prefix from the beginning of a string if it exists . [CODESPLIT] def _clip ( sid , prefix ) : return sid [ len ( prefix ) : ] if sid . startswith ( prefix ) else sid", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coerce value to an JSON - compatible representation . [CODESPLIT] def _time_to_json ( value ) : if isinstance ( value , datetime . time ) : value = value . isoformat ( ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility to generate enum classes used by annotations . [CODESPLIT] def _Enum ( docstring , * names ) : enums = dict ( zip ( names , range ( len ( names ) ) ) ) reverse = dict ( ( value , key ) for key , value in enums . iteritems ( ) ) enums [ 'reverse_mapping' ] = reverse enums [ '__doc__' ] = docstring return type ( 'Enum' , ( object , ) , enums )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn an SQLAlchemy model into a dict of field names and values . [CODESPLIT] def object_as_dict ( obj ) : return { c . key : getattr ( obj , c . key ) for c in inspect ( obj ) . mapper . column_attrs }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extracts the real value to be returned from the wrapping callable . [CODESPLIT] def return_value ( self , * args , * * kwargs ) : self . _called ( ) return self . _return_value ( * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses OLS to fit the regression . [CODESPLIT] def fit_linear ( X , y ) : model = linear_model . LinearRegression ( ) model . fit ( X , y ) return model", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete a file or directory path only if it exists . [CODESPLIT] def remover ( file_path ) : if os . path . isfile ( file_path ) : os . remove ( file_path ) return True elif os . path . isdir ( file_path ) : shutil . rmtree ( file_path ) return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete a label by name . [CODESPLIT] def del_label ( self , name ) : labels_tag = self . root [ 0 ] labels_tag . remove ( self . _find_label ( name ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a n + 1 dim one - hot array from n dim int - categorical array . [CODESPLIT] def one_hot ( x , size , dtype = np . float32 ) : return np . array ( x [ ... , np . newaxis ] == np . arange ( size ) , dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete a file safely . If it s not present no - op . [CODESPLIT] def safe_delete ( filename ) : try : os . unlink ( filename ) except OSError as e : if e . errno != errno . ENOENT : raise", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read and return filename in root dir of project and return string [CODESPLIT] def read ( filename ) : return codecs . open ( os . path . join ( __DIR__ , filename ) , 'r' ) . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete an image . [CODESPLIT] def cli ( env , identifier ) : image_mgr = SoftLayer . ImageManager ( env . client ) image_id = helpers . resolve_id ( image_mgr . resolve_ids , identifier , 'image' ) image_mgr . delete_image ( image_id )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read entire contents of file into a string . [CODESPLIT] def read_string_from_file ( path , encoding = \"utf8\" ) : with codecs . open ( path , \"rb\" , encoding = encoding ) as f : value = f . read ( ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove arduino / examples / all directory . [CODESPLIT] def remove_examples_all ( ) : d = examples_all_dir ( ) if d . exists ( ) : log . debug ( 'remove %s' , d ) d . rmtree ( ) else : log . debug ( 'nothing to remove: %s' , d )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a symmetrical binary tree with [CODESPLIT] def make_bintree ( levels ) : G = nx . DiGraph ( ) root = '0' G . add_node ( root ) add_children ( G , root , levels , 2 ) return G", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Collect digits from a string [CODESPLIT] def str2int ( string_with_int ) : return int ( \"\" . join ( [ char for char in string_with_int if char in string . digits ] ) or 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return BGR image read by opencv [CODESPLIT] def imdecode ( image_path ) : import os assert os . path . exists ( image_path ) , image_path + ' not found' im = cv2 . imread ( image_path ) return im", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create : class : PNG from raw bytes . : arg bytes b : The raw bytes of the PNG file . : rtype : : class : PNG [CODESPLIT] def from_bytes ( cls , b ) : im = cls ( ) im . chunks = list ( parse_chunks ( b ) ) im . init ( ) return im", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if an element from a list is in a string . [CODESPLIT] def isin ( elems , line ) : found = False for e in elems : if e in line . lower ( ) : found = True break return found", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Defines the ideal rate at which computation is to be performed [CODESPLIT] def set_rate ( rate ) : if not ( isinstance ( rate , int ) or isinstance ( rate , float ) ) : raise TypeError ( \"argument to set_rate is expected to be int or float\" ) global loop_duration loop_duration = 1.0 / rate", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns . so . pyd or . dylib depending on linux win or mac . On python3 return the previous with and without abi ( e . g . . cpython - 35m - x86_64 - linux - gnu ) flags . On python2 returns with and without multiarch . [CODESPLIT] def _platform_pylib_exts ( ) : # nocover import sysconfig valid_exts = [ ] if six . PY2 : # see also 'SHLIB_EXT' base_ext = '.' + sysconfig . get_config_var ( 'SO' ) . split ( '.' ) [ - 1 ] else : # return with and without API flags # handle PEP 3149 -- ABI version tagged .so files base_ext = '.' + sysconfig . get_config_var ( 'EXT_SUFFIX' ) . split ( '.' ) [ - 1 ] for tag in _extension_module_tags ( ) : valid_exts . append ( '.' + tag + base_ext ) valid_exts . append ( base_ext ) return tuple ( valid_exts )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply the argument parser . [CODESPLIT] def apply_argument_parser ( argumentsParser , options = None ) : if options is not None : args = argumentsParser . parse_args ( options ) else : args = argumentsParser . parse_args ( ) return args", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the the number of columns required to display a string [CODESPLIT] def _visual_width ( line ) : return len ( re . sub ( colorama . ansitowin32 . AnsiToWin32 . ANSI_CSI_RE , \"\" , line ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return the usage string for available options [CODESPLIT] def help ( self , level = 0 ) : self . cmdline_parser . formatter . output_level = level with _patch_optparse ( ) : return self . cmdline_parser . format_help ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "cv2 Image of current window screen [CODESPLIT] def screen_cv2 ( self ) : pil_image = self . screen . convert ( 'RGB' ) cv2_image = np . array ( pil_image ) pil_image . close ( ) # Convert RGB to BGR \n cv2_image = cv2_image [ : , : , : : - 1 ] return cv2_image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "rescales a numpy array so that min is 0 and max is 255 [CODESPLIT] def _normalize ( mat : np . ndarray ) : return ( ( mat - mat . min ( ) ) * ( 255 / mat . max ( ) ) ) . astype ( np . uint8 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pad a matrix with zeros on all sides . [CODESPLIT] def zero_pad ( m , n = 1 ) : return np . pad ( m , ( n , n ) , mode = 'constant' , constant_values = [ 0 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "quit crash [CODESPLIT] def _quit ( self , * args ) : self . logger . warn ( 'Bye!' ) sys . exit ( self . exit ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pad a matrix with zeros on all sides . [CODESPLIT] def zero_pad ( m , n = 1 ) : return np . pad ( m , ( n , n ) , mode = 'constant' , constant_values = [ 0 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "mono - exponential curve . [CODESPLIT] def algo_exp ( x , m , t , b ) : return m * np . exp ( - t * x ) + b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether a certain column exists [CODESPLIT] def column_exists ( cr , table , column ) : cr . execute ( 'SELECT count(attname) FROM pg_attribute ' 'WHERE attrelid = ' '( SELECT oid FROM pg_class WHERE relname = %s ) ' 'AND attname = %s' , ( table , column ) ) return cr . fetchone ( ) [ 0 ] == 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Performs a join using the union join function . [CODESPLIT] def merge ( left , right , how = 'inner' , key = None , left_key = None , right_key = None , left_as = 'left' , right_as = 'right' ) : return join ( left , right , how , key , left_key , right_key , join_fn = make_union_join ( left_as , right_as ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Let the DBMS perform a sum on a queryset [CODESPLIT] def query_sum ( queryset , field ) : return queryset . aggregate ( s = models . functions . Coalesce ( models . Sum ( field ) , 0 ) ) [ 's' ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap vertical table in a function for TabularOutputFormatter . [CODESPLIT] def adapter ( data , headers , * * kwargs ) : keys = ( 'sep_title' , 'sep_character' , 'sep_length' ) return vertical_table ( data , headers , * * filter_dict_by_key ( kwargs , keys ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse information from the provider . [CODESPLIT] def user_parse ( data ) : _user = data . get ( 'response' , { } ) . get ( 'user' , { } ) yield 'id' , _user . get ( 'name' ) yield 'username' , _user . get ( 'name' ) yield 'link' , _user . get ( 'blogs' , [ { } ] ) [ 0 ] . get ( 'url' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clip an image or an image batch with upper and lower threshold . [CODESPLIT] def clip_image ( image , clip_min , clip_max ) : return np . minimum ( np . maximum ( clip_min , image ) , clip_max )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a datetime from the Amazon - provided datetime string [CODESPLIT] def clean_time ( time_string ) : # Get a timezone-aware datetime object from the string time = dateutil . parser . parse ( time_string ) if not settings . USE_TZ : # If timezone support is not active, convert the time to UTC and # remove the timezone field time = time . astimezone ( timezone . utc ) . replace ( tzinfo = None ) return time", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Primary entry point to turn kwargs into properties [CODESPLIT] def updateFromKwargs ( self , properties , kwargs , collector , * * unused ) : properties [ self . name ] = self . getFromKwargs ( kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pull comma separated string values out of a text file and converts them to float list [CODESPLIT] def string_to_float_list ( string_var ) : try : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ', ' ) ] except : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ',' ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Download the page into a string [CODESPLIT] def wget ( url ) : import urllib . parse request = urllib . request . urlopen ( url ) filestring = request . read ( ) return filestring", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses an ISO8601 formatted datetime from a string value [CODESPLIT] def parse_json_date ( value ) : if not value : return None return datetime . datetime . strptime ( value , JSON_DATETIME_FORMAT ) . replace ( tzinfo = pytz . UTC )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove duplicates from a list preserving the order . [CODESPLIT] def dedupe_list ( l ) : result = [ ] for el in l : if el not in result : result . append ( el ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "parse_query_string : very simplistic . won t do the right thing with list values [CODESPLIT] def parse_query_string ( query ) : result = { } qparts = query . split ( '&' ) for item in qparts : key , value = item . split ( '=' ) key = key . strip ( ) value = value . strip ( ) result [ key ] = unquote_plus ( value ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns dictionary for each attribute from given obj . [CODESPLIT] def get_dict_for_attrs ( obj , attrs ) : data = { } for attr in attrs : data [ attr ] = getattr ( obj , attr ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap standard function to easily pass into map processing . [CODESPLIT] def map_wrap ( f ) : @ functools . wraps ( f ) def wrapper ( * args , * * kwargs ) : return f ( * args , * * kwargs ) return wrapper", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Thin wrapper around ElementTree . parse [CODESPLIT] def parse ( source , remove_comments = True , * * kw ) : return ElementTree . parse ( source , SourceLineParser ( ) , * * kw )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove missing values according to Baloo s convention . [CODESPLIT] def dropna ( self , subset = None ) : subset = check_and_obtain_subset_columns ( subset , self ) not_nas = [ v . notna ( ) for v in self [ subset ] . _iter ( ) ] and_filter = reduce ( lambda x , y : x & y , not_nas ) return self [ and_filter ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Primary entry point to turn kwargs into properties [CODESPLIT] def updateFromKwargs ( self , properties , kwargs , collector , * * unused ) : properties [ self . name ] = self . getFromKwargs ( kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert all keys of the dict d to ( ascii - ) strings . [CODESPLIT] def clean_dict_keys ( d ) : new_d = { } for ( k , v ) in d . iteritems ( ) : new_d [ str ( k ) ] = v return new_d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flags that a function is linear wrt all args [CODESPLIT] def def_linear ( fun ) : defjvp_argnum ( fun , lambda argnum , g , ans , args , kwargs : fun ( * subval ( args , argnum , g ) , * * kwargs ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test the multiprocess [CODESPLIT] def test3 ( ) : import time p = MVisionProcess ( ) p . start ( ) time . sleep ( 5 ) p . stop ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Display kwargs . [CODESPLIT] def reprkwargs ( kwargs , sep = ', ' , fmt = \"{0!s}={1!r}\" ) : return sep . join ( fmt . format ( k , v ) for k , v in kwargs . iteritems ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a string with punctuation removed . [CODESPLIT] def remove_punctuation ( text , exceptions = [ ] ) : all_but = [ r'\\w' , r'\\s' ] all_but . extend ( exceptions ) pattern = '[^{}]' . format ( '' . join ( all_but ) ) return re . sub ( pattern , '' , text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if a Path or string is a file on the file system . [CODESPLIT] def is_file ( path ) : try : return path . expanduser ( ) . absolute ( ) . is_file ( ) except AttributeError : return os . path . isfile ( os . path . abspath ( os . path . expanduser ( str ( path ) ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is builtin in python2 but we have to roll our own on py3 . [CODESPLIT] def execfile ( fname , variables ) : with open ( fname ) as f : code = compile ( f . read ( ) , fname , 'exec' ) exec ( code , variables )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "with dir_path ( path ) to change into a directory . [CODESPLIT] def dir_path ( dir ) : old_dir = os . getcwd ( ) os . chdir ( dir ) yield os . chdir ( old_dir )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exits the runtime with a nonzero exit code indicating failure . [CODESPLIT] def exit_and_fail ( self , msg = None , out = None ) : self . exit ( result = PANTS_FAILED_EXIT_CODE , msg = msg , out = out )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit the shell session . [CODESPLIT] def do_exit ( self , arg ) : if self . current : self . current . close ( ) self . resource_manager . close ( ) del self . resource_manager return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function is called when a return trap is set here . [CODESPLIT] def user_return ( self , frame , return_value ) : pdb . Pdb . user_return ( self , frame , return_value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract a ZIP archive to a directory [CODESPLIT] def unzip_file_to_dir ( path_to_zip , output_directory ) : z = ZipFile ( path_to_zip , 'r' ) z . extractall ( output_directory ) z . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Construct a single page PDF from the provided page in memory [CODESPLIT] def _single_page_pdf ( page ) : pdf = Pdf . new ( ) pdf . pages . append ( page ) bio = BytesIO ( ) pdf . save ( bio ) bio . seek ( 0 ) return bio . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns obj . field data as a dict [CODESPLIT] def _basic_field_data ( field , obj ) : value = field . value_from_object ( obj ) return { Field . TYPE : FieldType . VAL , Field . VALUE : value }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Translate an image in fourier - space with plane waves [CODESPLIT] def translate_fourier ( image , dx ) : N = image . shape [ 0 ] f = 2 * np . pi * np . fft . fftfreq ( N ) kx , ky , kz = np . meshgrid ( * ( f , ) * 3 , indexing = 'ij' ) kv = np . array ( [ kx , ky , kz ] ) . T q = np . fft . fftn ( image ) * np . exp ( - 1.j * ( kv * dx ) . sum ( axis = - 1 ) ) . T return np . real ( np . fft . ifftn ( q ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A handy wrapper to get a remote file content [CODESPLIT] def get_remote_content ( filepath ) : with hide ( 'running' ) : temp = BytesIO ( ) get ( filepath , temp ) content = temp . getvalue ( ) . decode ( 'utf-8' ) return content . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a new Vec3 that is translated version of vec . [CODESPLIT] def translate_v3 ( vec , amount ) : return Vec3 ( vec . x + amount , vec . y + amount , vec . z + amount )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return BGR image read by opencv [CODESPLIT] def imdecode ( image_path ) : import os assert os . path . exists ( image_path ) , image_path + ' not found' im = cv2 . imread ( image_path ) return im", "target": 1, "target_options": ["no_match", "match"]}
{"input": "cv2 Image of current window screen [CODESPLIT] def screen_cv2 ( self ) : pil_image = self . screen . convert ( 'RGB' ) cv2_image = np . array ( pil_image ) pil_image . close ( ) # Convert RGB to BGR \n cv2_image = cv2_image [ : , : , : : - 1 ] return cv2_image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return list of the key property names for a class [CODESPLIT] def get_keys_from_class ( cc ) : return [ prop . name for prop in cc . properties . values ( ) if 'key' in prop . qualifiers ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a new Image instance with the given size . [CODESPLIT] def resize ( self , size ) : return Image ( self . pil_image . resize ( size , PIL . Image . ANTIALIAS ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns file group s create aware * datetime * in UTC format . [CODESPLIT] def datetime_created ( self ) : if self . info ( ) . get ( 'datetime_created' ) : return dateutil . parser . parse ( self . info ( ) [ 'datetime_created' ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convenient access to shared context [CODESPLIT] def context ( self ) : if self . _context is not None : return self . _context else : logger . warning ( \"Using shared context without a lock\" ) return self . _executor . _shared_context", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simplest required implementation of collections . Counter . Required as 2 . 6 does not have Counter in collections . [CODESPLIT] def counter ( items ) : results = { } for item in items : results [ item ] = results . get ( item , 0 ) + 1 return results", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all child objects in nested lists of strings . [CODESPLIT] def as_list ( self ) : return [ self . name , self . value , [ x . as_list for x in self . children ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "filter to keep bolts [CODESPLIT] def filter_bolts ( table , header ) : bolts_info = [ ] for row in table : if row [ 0 ] == 'bolt' : bolts_info . append ( row ) return bolts_info , header", "target": 1, "target_options": ["no_match", "match"]}
{"input": "prints the top n lines of a file [CODESPLIT] def head ( filename , n = 10 ) : with freader ( filename ) as fr : for _ in range ( n ) : print ( fr . readline ( ) . strip ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Use check_output to run pylint . Because pylint changes the exit code based on the code score we have to wrap it in a try / except block . [CODESPLIT] def pylint_raw ( options ) : command = [ 'pylint' ] command . extend ( options ) proc = subprocess . Popen ( command , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) outs , __ = proc . communicate ( ) return outs . decode ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print the values of all this object s Parameters . [CODESPLIT] def print_param_values ( self_ ) : self = self_ . self for name , val in self . param . get_param_values ( ) : print ( '%s.%s = %s' % ( self . name , name , val ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If given environment key is defined print it out . [CODESPLIT] def print_env_info ( key , out = sys . stderr ) : value = os . getenv ( key ) if value is not None : print ( key , \"=\" , repr ( value ) , file = out )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a random string from a - zA - Z : param n : length of the string : return : the random string [CODESPLIT] def random_letters ( n ) : return '' . join ( random . SystemRandom ( ) . choice ( string . ascii_letters ) for _ in range ( n ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print emphasized neutral the given txt message [CODESPLIT] def info ( txt ) : print ( \"%s# %s%s%s\" % ( PR_EMPH_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a 20 char passphrase with easily typeable chars . [CODESPLIT] def GeneratePassphrase ( length = 20 ) : valid_chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" valid_chars += \"0123456789 ,-_&$#\" return \"\" . join ( random . choice ( valid_chars ) for i in range ( length ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like pretty but print to stdout . [CODESPLIT] def pprint ( obj , verbose = False , max_width = 79 , newline = '\\n' ) : printer = RepresentationPrinter ( sys . stdout , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) sys . stdout . write ( newline ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Batches a list into a list of lists with sub - lists sized by a specified batch size . [CODESPLIT] def batch ( items , size ) : return [ items [ x : x + size ] for x in xrange ( 0 , len ( items ) , size ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If output is string then print the string and also time used [CODESPLIT] def timeit ( output ) : b = time . time ( ) yield print output , 'time used: %.3fs' % ( time . time ( ) - b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Store all test reports for evaluation on finish [CODESPLIT] def pytest_runtest_logreport ( self , report ) : rep = report res = self . config . hook . pytest_report_teststatus ( report = rep ) cat , letter , word = res self . stats . setdefault ( cat , [ ] ) . append ( rep )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print dicttree in Json - like format . keys are sorted [CODESPLIT] def prettyprint ( d ) : print ( json . dumps ( d , sort_keys = True , indent = 4 , separators = ( \",\" , \": \" ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "printdict [CODESPLIT] def printdict ( adict ) : dlist = list ( adict . keys ( ) ) dlist . sort ( ) for i in range ( 0 , len ( dlist ) ) : print ( dlist [ i ] , adict [ dlist [ i ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If we are in a progress scope and no log messages have been shown write out another . [CODESPLIT] def show_progress ( self ) : if self . in_progress_hanging : sys . stdout . write ( '.' ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a list of coords for 3 points Compute the area of this triangle . [CODESPLIT] def get_tri_area ( pts ) : a , b , c = pts [ 0 ] , pts [ 1 ] , pts [ 2 ] v1 = np . array ( b ) - np . array ( a ) v2 = np . array ( c ) - np . array ( a ) area_tri = abs ( sp . linalg . norm ( sp . cross ( v1 , v2 ) ) / 2 ) return area_tri", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty - print a Python o to a stream [ default is sys . stdout ] . [CODESPLIT] def pprint ( o , stream = None , indent = 1 , width = 80 , depth = None ) : printer = PrettyPrinter ( stream = stream , indent = indent , width = width , depth = depth ) printer . pprint ( o )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the given command ( with shell = False ) and return a tuple of ( int returncode str output ) . Strip the output of enclosing whitespace . [CODESPLIT] def call_out ( command ) : # start external command process p = subprocess . Popen ( command , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) # get outputs out , _ = p . communicate ( ) return p . returncode , out . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of tuples specifying the column name and type [CODESPLIT] def get_table_columns ( dbconn , tablename ) : cur = dbconn . cursor ( ) cur . execute ( \"PRAGMA table_info('%s');\" % tablename ) info = cur . fetchall ( ) cols = [ ( i [ 1 ] , i [ 2 ] ) for i in info ] return cols", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Writes the string to stdout [CODESPLIT] def _stdout_raw ( self , s ) : print ( s , end = '' , file = sys . stdout ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a : py : class : datetime . datetime instance representing the current time . [CODESPLIT] def now ( self ) : if self . use_utc : return datetime . datetime . utcnow ( ) else : return datetime . datetime . now ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "exactly like s but doesn t return variable names or file positions ( useful for logging ) [CODESPLIT] def ss ( * args , * * kwargs ) : if not args : raise ValueError ( \"you didn't pass any arguments to print out\" ) with Reflect . context ( args , * * kwargs ) as r : instance = V_CLASS ( r , stream , * * kwargs ) return instance . value ( ) . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate table chape considering index levels . [CODESPLIT] def _shape ( self , df ) : row , col = df . shape return row + df . columns . nlevels , col + df . index . nlevels", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the encoding type . [CODESPLIT] def get_encoding ( binary ) : try : from chardet import detect except ImportError : LOGGER . error ( \"Please install the 'chardet' module\" ) sys . exit ( 1 ) encoding = detect ( binary ) . get ( 'encoding' ) return 'iso-8859-1' if encoding == 'CP949' else encoding", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like pretty but print to stdout . [CODESPLIT] def pprint ( obj , verbose = False , max_width = 79 , newline = '\\n' ) : printer = RepresentationPrinter ( sys . stdout , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) sys . stdout . write ( newline ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dictionary of key / values from os . environ . [CODESPLIT] def _get_os_environ_dict ( keys ) : return { k : os . environ . get ( k , _UNDEFINED ) for k in keys }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return data as a JSON string . [CODESPLIT] def to_json ( data ) : return json . dumps ( data , default = lambda x : x . __dict__ , sort_keys = True , indent = 4 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert values from cgi . Field objects to plain values . [CODESPLIT] def getfield ( f ) : if isinstance ( f , list ) : return [ getfield ( x ) for x in f ] else : return f . value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns time in seconds as a string formatted HHHH : MM : SS . [CODESPLIT] def time_string ( seconds ) : s = int ( round ( seconds ) ) # round to nearest second h , s = divmod ( s , 3600 ) # get hours and remainder m , s = divmod ( s , 60 ) # split remainder into minutes and seconds return \"%2i:%02i:%02i\" % ( h , m , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the list of field names of the model . [CODESPLIT] def fields ( self ) : return ( self . attributes . values ( ) + self . lists . values ( ) + self . references . values ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flushes the prompt before requesting the input [CODESPLIT] def _normal_prompt ( self ) : sys . stdout . write ( self . __get_ps1 ( ) ) sys . stdout . flush ( ) return safe_input ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given an index for the text return the corresponding ( row col ) tuple . ( 0 - based . Returns ( 0 0 ) for index = 0 . ) [CODESPLIT] def translate_index_to_position ( self , index ) : # Find start of this line. row , row_index = self . _find_line_start_index ( index ) col = index - row_index return row , col", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Private method that sets the value currently of the property [CODESPLIT] def _set_property ( self , val , * args ) : val = UserClassAdapter . _set_property ( self , val , * args ) if val : Adapter . _set_property ( self , val , * args ) return val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return indices of inputs to the node with the given index . [CODESPLIT] def get_inputs_from_cm ( index , cm ) : return tuple ( i for i in range ( cm . shape [ 0 ] ) if cm [ i ] [ index ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "google . protobuf . Message : the current operation metadata . [CODESPLIT] def metadata ( self ) : if not self . _operation . HasField ( \"metadata\" ) : return None return protobuf_helpers . from_any_pb ( self . _metadata_type , self . _operation . metadata )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "From : http : // stackoverflow . com / questions / 13062300 / convert - a - dict - to - sorted - dict - in - python [CODESPLIT] def format_result ( input ) : items = list ( iteritems ( input ) ) return OrderedDict ( sorted ( items , key = lambda x : x [ 0 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shut down a specific process . [CODESPLIT] def stop ( pid ) : if psutil . pid_exists ( pid ) : try : p = psutil . Process ( pid ) p . kill ( ) except Exception : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "dict . items () but with a separate row for each value in a MultiValueDict [CODESPLIT] def get_all_items ( obj ) : if hasattr ( obj , 'getlist' ) : items = [ ] for key in obj : for value in obj . getlist ( key ) : items . append ( ( key , value ) ) return items else : return obj . items ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Download the given JSON file and pretty - print before we output it . [CODESPLIT] def download_json ( local_filename , url , clobber = False ) : with open ( local_filename , 'w' ) as json_file : json_file . write ( json . dumps ( requests . get ( url ) . json ( ) , sort_keys = True , indent = 2 , separators = ( ',' , ': ' ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def get_translucent_cmap ( r , g , b ) : class TranslucentCmap ( BaseColormap ) : glsl_map = \"\"\"\n        vec4 translucent_fire(float t) {{\n            return vec4({0}, {1}, {2}, t);\n        }}\n        \"\"\" . format ( r , g , b ) return TranslucentCmap ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the Fully Qualified Name from an instance or class . [CODESPLIT] def get_qualified_name ( _object ) : module = _object . __module__ if hasattr ( _object , '__name__' ) : _class = _object . __name__ else : _class = _object . __class__ . __name__ return module + '.' + _class", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Just a pointer to engine . execute [CODESPLIT] def execute ( self , sql , params = None ) : # wrap in a transaction to ensure things are committed # https://github.com/smnorris/pgdata/issues/3 with self . engine . begin ( ) as conn : result = conn . execute ( sql , params ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the Fully Qualified Name from an instance or class . [CODESPLIT] def get_qualified_name ( _object ) : module = _object . __module__ if hasattr ( _object , '__name__' ) : _class = _object . __name__ else : _class = _object . __class__ . __name__ return module + '.' + _class", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Invoke pytest replacing argv . Return result code . [CODESPLIT] def run_tests ( self ) : with _save_argv ( _sys . argv [ : 1 ] + self . addopts ) : result_code = __import__ ( 'pytest' ) . main ( ) if result_code : raise SystemExit ( result_code )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterates through each image in the given directory . ( not recursive ) : param dir_path : Directory path where images files are present : return : Iterator to iterate through image files [CODESPLIT] def each_img ( dir_path ) : for fname in os . listdir ( dir_path ) : if fname . endswith ( '.jpg' ) or fname . endswith ( '.png' ) or fname . endswith ( '.bmp' ) : yield fname", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a naive datetime object for the given timezone . A timezone is any pytz - like or datetime . tzinfo - like timezone object . If no timezone is given then UTC is assumed . [CODESPLIT] def now ( timezone = None ) : d = datetime . datetime . utcnow ( ) if not timezone : return d return to_timezone ( d , timezone ) . replace ( tzinfo = None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove ticks tick labels and frame from axis [CODESPLIT] def clean_axis ( axis ) : axis . get_xaxis ( ) . set_ticks ( [ ] ) axis . get_yaxis ( ) . set_ticks ( [ ] ) for spine in list ( axis . spines . values ( ) ) : spine . set_visible ( False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the highest priority Processing Block from the queue . [CODESPLIT] def get ( self ) : with self . _mutex : entry = self . _queue . pop ( ) del self . _block_map [ entry [ 2 ] ] return entry [ 2 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a sequence convert it to a comma separated string . If however the argument is a single object return its string representation . [CODESPLIT] def seq_to_str ( obj , sep = \",\" ) : if isinstance ( obj , string_classes ) : return obj elif isinstance ( obj , ( list , tuple ) ) : return sep . join ( [ str ( x ) for x in obj ] ) else : return str ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return line ending . [CODESPLIT] def get_line_ending ( line ) : non_whitespace_index = len ( line . rstrip ( ) ) - len ( line ) if not non_whitespace_index : return '' else : return line [ non_whitespace_index : ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a string of random ascii characters or digits [CODESPLIT] def rndstr ( size = 16 ) : _basech = string . ascii_letters + string . digits return \"\" . join ( [ rnd . choice ( _basech ) for _ in range ( size ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return possible range for min function . [CODESPLIT] def min_values ( args ) : return Interval ( min ( x . low for x in args ) , min ( x . high for x in args ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the attributes of an object using dir . [CODESPLIT] def get_object_attrs ( obj ) : attrs = [ k for k in dir ( obj ) if not k . startswith ( '__' ) ] if not attrs : attrs = dir ( obj ) return attrs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the rank of the element . [CODESPLIT] def zrank ( self , name , value ) : with self . pipe as pipe : value = self . valueparse . encode ( value ) return pipe . zrank ( self . redis_key ( name ) , value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the absolute path to the directory containing the package data . [CODESPLIT] def data_directory ( ) : package_directory = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( package_directory , \"data\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to read bytes until a certain end byte is hit [CODESPLIT] def _readuntil ( f , end = _TYPE_END ) : buf = bytearray ( ) byte = f . read ( 1 ) while byte != end : if byte == b'' : raise ValueError ( 'File ended unexpectedly. Expected end byte {}.' . format ( end ) ) buf += byte byte = f . read ( 1 ) return buf", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show the source groups contributing the most to the highest IML [CODESPLIT] def view_extreme_groups ( token , dstore ) : data = dstore [ 'disagg_by_grp' ] . value data . sort ( order = 'extreme_poe' ) return rst_table ( data [ : : - 1 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get string from file . [CODESPLIT] def get_file_string ( filepath ) : with open ( os . path . abspath ( filepath ) ) as f : return f . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Collect digits from a string [CODESPLIT] def str2int ( string_with_int ) : return int ( \"\" . join ( [ char for char in string_with_int if char in string . digits ] ) or 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Quick way to read a file content . [CODESPLIT] def read ( fname ) : content = None with open ( os . path . join ( here , fname ) ) as f : content = f . read ( ) return content", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the index of an element in the list . [CODESPLIT] def get_list_index ( lst , index_or_name ) : if isinstance ( index_or_name , six . integer_types ) : return index_or_name return lst . index ( index_or_name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read entire contents of file into a string . [CODESPLIT] def read_string_from_file ( path , encoding = \"utf8\" ) : with codecs . open ( path , \"rb\" , encoding = encoding ) as f : value = f . read ( ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reset view to the root of the tree [CODESPLIT] def OnRootView ( self , event ) : self . adapter , tree , rows = self . RootNode ( ) self . squareMap . SetModel ( tree , self . adapter ) self . RecordHistory ( ) self . ConfigureViewTypeChoices ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "read text files in directory and returns them as array [CODESPLIT] def read_folder ( directory ) : res = [ ] for filename in os . listdir ( directory ) : with io . open ( os . path . join ( directory , filename ) , encoding = \"utf-8\" ) as f : content = f . read ( ) res . append ( content ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the number of bytes to represent this dtype . [CODESPLIT] def size ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'size' ) : return dtype . size return np . dtype ( dtype ) . itemsize", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generator for reading from standard input in nonblocking mode . [CODESPLIT] def _read_stdin ( ) : line = sys . stdin . readline ( ) while line : yield line line = sys . stdin . readline ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find rightmost value less than x [CODESPLIT] def find_lt ( a , x ) : i = bisect . bisect_left ( a , x ) if i : return a [ i - 1 ] raise ValueError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generator for reading from standard input in nonblocking mode . [CODESPLIT] def _read_stdin ( ) : line = sys . stdin . readline ( ) while line : yield line line = sys . stdin . readline ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the yticks labels of this grid used for plotting the y - axis ticks when visualizing a regular [CODESPLIT] def yticks ( self ) : return np . linspace ( np . min ( self [ : , 0 ] ) , np . max ( self [ : , 0 ] ) , 4 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Receive the content of url parse it as JSON and return the object . [CODESPLIT] def get_jsonparsed_data ( url ) : response = urlopen ( url ) data = response . read ( ) . decode ( 'utf-8' ) return json . loads ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get unique constraints info [CODESPLIT] def _model_unique ( ins ) : unique = [ ] for t in ins . tables : for c in t . constraints : if isinstance ( c , UniqueConstraint ) : unique . append ( tuple ( col . key for col in c . columns ) ) return unique", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a string from a file - like object . [CODESPLIT] def read_string ( buff , byteorder = 'big' ) : length = read_numeric ( USHORT , buff , byteorder ) return buff . read ( length ) . decode ( 'utf-8' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a dictionary from a URL params [CODESPLIT] def get_url_args ( url ) : url_data = urllib . parse . urlparse ( url ) arg_dict = urllib . parse . parse_qs ( url_data . query ) return arg_dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a tif file to a 2D NumPy array [CODESPLIT] def ReadTif ( tifFile ) : img = Image . open ( tifFile ) img = np . array ( img ) return img", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a tuple of numbers . e . g . vertices normals or teture coords . [CODESPLIT] def readTuple ( self , line , n = 3 ) : numbers = [ num for num in line . split ( ' ' ) if num ] return [ float ( num ) for num in numbers [ 1 : n + 1 ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Instantiate the object from a protocol buffer . [CODESPLIT] def from_pb ( cls , pb ) : obj = cls . _from_pb ( pb ) obj . _pb = pb return obj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is a compatibility function that takes a C { float } and converts it to an C { int } if the values are equal . [CODESPLIT] def _check_for_int ( x ) : try : y = int ( x ) except ( OverflowError , ValueError ) : pass else : # There is no way in AMF0 to distinguish between integers and floats if x == x and y == x : return y return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read list of numbers . [CODESPLIT] def r_num ( obj ) : if isinstance ( obj , ( list , tuple ) ) : it = iter else : it = LinesIterator dataset = Dataset ( [ Dataset . FLOAT ] ) return dataset . load ( it ( obj ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "inspect the source file to find encoding problem [CODESPLIT] def process_module ( self , module ) : if module . file_encoding : encoding = module . file_encoding else : encoding = \"ascii\" with module . stream ( ) as stream : for lineno , line in enumerate ( stream ) : self . _check_encoding ( lineno + 1 , line , encoding )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if the given type is a builtin one . [CODESPLIT] def is_builtin_type ( tp ) : return hasattr ( __builtins__ , tp . __name__ ) and tp is getattr ( __builtins__ , tp . __name__ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Connect stdin / stdout to controlling terminal even if the scripts input and output were redirected . This is useful in utilities based on termenu . [CODESPLIT] def redirect_std ( ) : stdin = sys . stdin stdout = sys . stdout if not sys . stdin . isatty ( ) : sys . stdin = open_raw ( \"/dev/tty\" , \"r\" , 0 ) if not sys . stdout . isatty ( ) : sys . stdout = open_raw ( \"/dev/tty\" , \"w\" , 0 ) return stdin , stdout", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Display both SQLAlchemy and Python help statements [CODESPLIT] def _help ( ) : statement = '%s%s' % ( shelp , phelp % ', ' . join ( cntx_ . keys ( ) ) ) print statement . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": see :: meth : RedisMap . __setitem__ [CODESPLIT] def __setitem__ ( self , field , value ) : return self . _client . hset ( self . key_prefix , field , self . _dumps ( value ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sends a message to websocket . [CODESPLIT] def send ( message , request_context = None , binary = False ) : if binary : return uwsgi . websocket_send_binary ( message , request_context ) return uwsgi . websocket_send ( message , request_context )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Connect to a redis instance . [CODESPLIT] def __connect ( ) : global redis_instance if use_tcp_socket : redis_instance = redis . StrictRedis ( host = hostname , port = port ) else : redis_instance = redis . StrictRedis ( unix_socket_path = unix_socket )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Closes the connection [CODESPLIT] def exit ( self ) : self . pubsub . unsubscribe ( ) self . client . connection_pool . disconnect ( ) logger . info ( \"Connection to Redis closed\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper method for POST calls . [CODESPLIT] def _post ( self , url , params , uploads = None ) : self . _call ( self . POST , url , params , uploads )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compile regex patterns . [CODESPLIT] def prep_regex ( patterns ) : flags = 0 if Config . options . case_sensitive else re . I return [ re . compile ( pattern , flags ) for pattern in patterns ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dataframe that is a cross between dataframes df1 and df2 [CODESPLIT] def cross_join ( df1 , df2 ) : if len ( df1 ) == 0 : return df2 if len ( df2 ) == 0 : return df1 # Add as lists so that the new index keeps the items in # the order that they are added together all_columns = pd . Index ( list ( df1 . columns ) + list ( df2 . columns ) ) df1 [ 'key' ] = 1 df2 [ 'key' ] = 1 return pd . merge ( df1 , df2 , on = 'key' ) . loc [ : , all_columns ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Matches a paren . [CODESPLIT] def match_paren ( self , tokens , item ) : match , = tokens return self . match ( match , item )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove legend for axes or gca . [CODESPLIT] def remove_legend ( ax = None ) : from pylab import gca , draw if ax is None : ax = gca ( ) ax . legend_ = None draw ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return unmatched part of re . Match object . [CODESPLIT] def unmatched ( match ) : start , end = match . span ( 0 ) return match . string [ : start ] + match . string [ end : ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Counts up sequentially from a number based on the current time [CODESPLIT] def seq ( ) : current_frame = inspect . currentframe ( ) . f_back trace_string = \"\" while current_frame . f_back : trace_string = trace_string + current_frame . f_back . f_code . co_name current_frame = current_frame . f_back return counter . get_from_trace ( trace_string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if email is valid [CODESPLIT] def is_valid_email ( email ) : pattern = re . compile ( r'[\\w\\.-]+@[\\w\\.-]+[.]\\w+' ) return bool ( pattern . match ( email ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Unify members of a group and accounts with the group as primary gid . [CODESPLIT] def _Members ( self , group ) : group . members = set ( group . members ) . union ( self . gids . get ( group . gid , [ ] ) ) return group", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns : a triple of integers from a version tag [CODESPLIT] def version_triple ( tag ) : groups = re . match ( r'v?(\\d+)\\.(\\d+)\\.(\\d+)' , tag ) . groups ( ) return tuple ( int ( n ) for n in groups )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Kill the browser . [CODESPLIT] def kill ( self ) : if self . process : self . process . kill ( ) self . process . wait ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find and kill child processes of a process . [CODESPLIT] def kill_process_children ( pid ) : if sys . platform == \"darwin\" : kill_process_children_osx ( pid ) elif sys . platform == \"linux\" : kill_process_children_unix ( pid ) else : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Objective function ( sum of squared residuals ) [CODESPLIT] def f ( x , a , c ) : v = g ( x , a , c ) return v . dot ( v )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shut down a specific process . [CODESPLIT] def stop ( pid ) : if psutil . pid_exists ( pid ) : try : p = psutil . Process ( pid ) p . kill ( ) except Exception : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "clean - remove build artifacts . [CODESPLIT] def clean ( ) : run ( 'rm -rf build/' ) run ( 'rm -rf dist/' ) run ( 'rm -rf puzzle.egg-info' ) run ( 'find . -name __pycache__ -delete' ) run ( 'find . -name *.pyc -delete' ) run ( 'find . -name *.pyo -delete' ) run ( 'find . -name *~ -delete' ) log . info ( 'cleaned up' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decide if the Ipython command line is running code . [CODESPLIT] def IPYTHON_MAIN ( ) : import pkg_resources runner_frame = inspect . getouterframes ( inspect . currentframe ( ) ) [ - 2 ] return ( getattr ( runner_frame , \"function\" , None ) == pkg_resources . load_entry_point ( \"ipython\" , \"console_scripts\" , \"ipython\" ) . __name__ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a new dict from an existing dict that only has the given keys [CODESPLIT] def filter_dict ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sanity check version information for corrupt virtualenv symlinks [CODESPLIT] def check_version ( ) : if sys . version_info [ 0 : 3 ] == PYTHON_VERSION_INFO [ 0 : 3 ] : return sys . exit ( ansi . error ( ) + ' your virtual env points to the wrong python version. ' 'This is likely because you used a python installer that clobbered ' 'the system installation, which breaks virtualenv creation. ' 'To fix, check this symlink, and delete the installation of python ' 'that it is brokenly pointing to, then delete the virtual env itself ' 'and rerun lore install: ' + os . linesep + os . linesep + BIN_PYTHON + os . linesep )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove dictionary keys whose value is None [CODESPLIT] def _remove_none_values ( dictionary ) : return list ( map ( dictionary . pop , [ i for i in dictionary if dictionary [ i ] is None ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Populate axis limits GUI with current plot values . [CODESPLIT] def set_xlimits_widgets ( self , set_min = True , set_max = True ) : xmin , xmax = self . tab_plot . ax . get_xlim ( ) if set_min : self . w . x_lo . set_text ( '{0}' . format ( xmin ) ) if set_max : self . w . x_hi . set_text ( '{0}' . format ( xmax ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes // - comments and single - line C - style / * * / comments . [CODESPLIT] def CleanseComments ( line ) : commentpos = line . find ( '//' ) if commentpos != - 1 and not IsCppString ( line [ : commentpos ] ) : line = line [ : commentpos ] . rstrip ( ) # get rid of /* ... */ return _RE_PATTERN_CLEANSE_LINE_C_COMMENTS . sub ( '' , line )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Lets a user join a room on a specific Namespace . [CODESPLIT] def join ( self , room ) : self . socket . rooms . add ( self . _get_room_name ( room ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns names of object columns in the DataFrame . [CODESPLIT] def get_obj_cols ( df ) : obj_cols = [ ] for idx , dt in enumerate ( df . dtypes ) : if dt == 'object' or is_category ( dt ) : obj_cols . append ( df . columns . values [ idx ] ) return obj_cols", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove files specified multiple times in a list . [CODESPLIT] def _remove_duplicate_files ( xs ) : seen = set ( [ ] ) out = [ ] for x in xs : if x [ \"path\" ] not in seen : out . append ( x ) seen . add ( x [ \"path\" ] ) return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deletes the specified file from the local filesystem . [CODESPLIT] def _delete_local ( self , filename ) : if os . path . exists ( filename ) : os . remove ( filename )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A magic method to implement shallow copy behavior . [CODESPLIT] def __copy__ ( self ) : return self . __class__ . load ( self . dump ( ) , context = self . context )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieves and removes the first task from the heap . [CODESPLIT] def PopTask ( self ) : try : _ , task = heapq . heappop ( self . _heap ) except IndexError : return None self . _task_identifiers . remove ( task . identifier ) return task", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a PyX curved path from ( x1 y1 ) to ( x2 y2 ) such that the slope at either end is zero . [CODESPLIT] def _curve ( x1 , y1 , x2 , y2 , hunit = HUNIT , vunit = VUNIT ) : ax1 , ax2 , axm = x1 * hunit , x2 * hunit , ( x1 + x2 ) * hunit / 2 ay1 , ay2 = y1 * vunit , y2 * vunit return pyx . path . curve ( ax1 , ay1 , axm , ay1 , axm , ay2 , ax2 , ay2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a text and drops all non - printable and non - ascii characters and also any whitespace characters that aren t space . [CODESPLIT] def drop_bad_characters ( text ) : # Strip all non-ascii and non-printable characters text = '' . join ( [ c for c in text if c in ALLOWED_CHARS ] ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param list_of_points : : return : list_of_points with None s removed [CODESPLIT] def filter_none ( list_of_points ) : remove_elementnone = filter ( lambda p : p is not None , list_of_points ) remove_sublistnone = filter ( lambda p : not contains_none ( p ) , remove_elementnone ) return list ( remove_sublistnone )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Union any overlapping intervals in the given set . [CODESPLIT] def union_overlapping ( intervals ) : disjoint_intervals = [ ] for interval in intervals : if disjoint_intervals and disjoint_intervals [ - 1 ] . overlaps ( interval ) : disjoint_intervals [ - 1 ] = disjoint_intervals [ - 1 ] . union ( interval ) else : disjoint_intervals . append ( interval ) return disjoint_intervals", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Method to generate contender phrases given the sentences of the text document . [CODESPLIT] def _generate_phrases ( self , sentences ) : phrase_list = set ( ) # Create contender phrases from sentences. for sentence in sentences : word_list = [ word . lower ( ) for word in wordpunct_tokenize ( sentence ) ] phrase_list . update ( self . _get_phrase_list_from_words ( word_list ) ) return phrase_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip apostrophe and s from the end of a string . [CODESPLIT] def unapostrophe ( text ) : text = re . sub ( r'[%s]s?$' % '' . join ( APOSTROPHES ) , '' , text ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the indent size in spaces at the start of a line of text . [CODESPLIT] def indentsize ( line ) : expline = string . expandtabs ( line ) return len ( expline ) - len ( string . lstrip ( expline ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip the possible prefix Table : from a table name . [CODESPLIT] def _do_remove_prefix ( name ) : res = name if isinstance ( res , str ) : if ( res . find ( 'Table: ' ) == 0 ) : res = res . replace ( 'Table: ' , '' , 1 ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list where the duplicates have been removed . [CODESPLIT] def distinct ( l ) : seen = set ( ) seen_add = seen . add return ( _ for _ in l if not ( _ in seen or seen_add ( _ ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert datetime / str to date : param arg : : return : [CODESPLIT] def _datetime_to_date ( arg ) : _arg = parse ( arg ) if isinstance ( _arg , datetime . datetime ) : _arg = _arg . date ( ) return _arg", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip agents from a string . [CODESPLIT] def strip_accents ( text ) : normalized_str = unicodedata . normalize ( 'NFD' , text ) return '' . join ( [ c for c in normalized_str if unicodedata . category ( c ) != 'Mn' ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uniformly format a path . [CODESPLIT] def fixpath ( path ) : return os . path . normpath ( os . path . realpath ( os . path . expanduser ( path ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Drops the trailinz zeros from decimal value . Returns a string [CODESPLIT] def drop_trailing_zeros_decimal ( num ) : out = str ( num ) return out . rstrip ( '0' ) . rstrip ( '.' ) if '.' in out else out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a symbolic link [CODESPLIT] def symlink ( source , destination ) : log ( \"Symlinking {} as {}\" . format ( source , destination ) ) cmd = [ 'ln' , '-sf' , source , destination , ] subprocess . check_call ( cmd )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Render our pages as a jinja template for fancy templating goodness . [CODESPLIT] def rstjinja ( app , docname , source ) : # Make sure we're outputting HTML if app . builder . format != 'html' : return src = source [ 0 ] rendered = app . builder . templates . render_string ( src , app . config . html_context ) source [ 0 ] = rendered", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate the Sphinx conf . py configuration file [CODESPLIT] def conf ( self ) : return self . env . get_template ( 'conf.py.j2' ) . render ( metadata = self . metadata , package = self . package )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string from snake case to camel case with the first letter capitalized . For example some_var would become SomeVar . [CODESPLIT] def to_capitalized_camel_case ( snake_case_string ) : parts = snake_case_string . split ( '_' ) return '' . join ( [ i . title ( ) for i in parts ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a JSON HttpResponse with rendered template HTML . [CODESPLIT] def render_to_json ( templates , context , request ) : html = render_to_string ( templates , context = context , request = request ) _json = json . dumps ( { \"html\" : html } ) return HttpResponse ( _json )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "helpful in situations where browser / app may recognize Unicode encoding in the \\ u0b8e type syntax but not actual unicode glyph / code - point [CODESPLIT] def to_unicode_repr ( _letter ) : # Python 2-3 compatible return u\"u'\" + u\"\" . join ( [ u\"\\\\u%04x\" % ord ( l ) for l in _letter ] ) + u\"'\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a name in camelCase return in snake_case [CODESPLIT] def to_snake_case ( name ) : s1 = FIRST_CAP_REGEX . sub ( r'\\1_\\2' , name ) return ALL_CAP_REGEX . sub ( r'\\1_\\2' , s1 ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Does a string replace with a list of search and replacements [CODESPLIT] def multi_replace ( instr , search_list = [ ] , repl_list = None ) : repl_list = [ '' ] * len ( search_list ) if repl_list is None else repl_list for ser , repl in zip ( search_list , repl_list ) : instr = instr . replace ( ser , repl ) return instr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return string as a comment [CODESPLIT] def _comment ( string ) : lines = [ line . strip ( ) for line in string . splitlines ( ) ] return \"# \" + ( \"%s# \" % linesep ) . join ( lines )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "For a range indicated from start to end replace with replacement . [CODESPLIT] def _replace_token_range ( tokens , start , end , replacement ) : tokens = tokens [ : start ] + replacement + tokens [ end : ] return tokens", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Appends tzinfo and assumes UTC if datetime object has no tzinfo already . [CODESPLIT] def make_aware ( dt ) : return dt if dt . tzinfo else dt . replace ( tzinfo = timezone . utc )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply re . sub to bunch of ( pattern repl ) [CODESPLIT] def _sub_patterns ( patterns , text ) : for pattern , repl in patterns : text = re . sub ( pattern , repl , text ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A method used to round a number in the way that UsefulUtils rounds . [CODESPLIT] def specialRound ( number , rounding ) : temp = 0 if rounding == 0 : temp = number else : temp = round ( number , rounding ) if temp % 1 == 0 : return int ( temp ) else : return float ( temp )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Requests - mock requests . request wrapper . [CODESPLIT] def requests_request ( method , url , * * kwargs ) : session = local_sessions . session response = session . request ( method = method , url = url , * * kwargs ) session . close ( ) return response", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a variable name unique by appending a number if needed . [CODESPLIT] def unique ( self , name ) : # Make sure the name is valid name = self . valid ( name ) # Make sure it's not too long name = self . trim ( name ) # Now make sure it's unique unique_name = name i = 2 while unique_name in self . names : unique_name = name + str ( i ) i += 1 self . names . add ( unique_name ) return unique_name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform auth request for token . [CODESPLIT] def auth_request ( self , url , headers , body ) : return self . req . post ( url , headers , body = body )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ensure that param_list is a list with the expected length . Raises a helpful ValueError if this is not the case . [CODESPLIT] def check_type_and_size_of_param_list ( param_list , expected_length ) : try : assert isinstance ( param_list , list ) assert len ( param_list ) == expected_length except AssertionError : msg = \"param_list must be a list containing {} elements.\" raise ValueError ( msg . format ( expected_length ) ) return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if exception was raised because of too many executed requests . ( This is a temporal solution and will be changed in later package versions . ) [CODESPLIT] def _request_limit_reached ( exception ) : return isinstance ( exception , requests . HTTPError ) and exception . response . status_code == requests . status_codes . codes . TOO_MANY_REQUESTS", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks whether a variable is a numpy float array . [CODESPLIT] def is_float_array ( val ) : return is_np_array ( val ) and issubclass ( val . dtype . type , np . floating )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a dict to a querystring suitable to be appended to a URL . [CODESPLIT] def dict_to_querystring ( dictionary ) : s = u\"\" for d in dictionary . keys ( ) : s = unicode . format ( u\"{0}{1}={2}&\" , s , d , dictionary [ d ] ) return s [ : - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decrement connection count [CODESPLIT] def _log_disconnect ( self ) : if self . logged : self . server . stats . connectionClosed ( ) self . logged = False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Downloads the SDK and returns a file - like object for the zip content . [CODESPLIT] def download_sdk ( url ) : r = requests . get ( url ) r . raise_for_status ( ) return StringIO ( r . content )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Merge any number of dictionaries [CODESPLIT] def merge_dict ( data , * args ) : results = { } for current in ( data , ) + args : results . update ( current ) return results", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strips trailing whitespace from string lowercases it and replaces spaces with underscores [CODESPLIT] def normalise_string ( string ) : string = ( string . strip ( ) ) . lower ( ) return re . sub ( r'\\W+' , '_' , string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Move all file found by glob . glob ( pattern ) to destination directory . [CODESPLIT] def gmove ( pattern , destination ) : for item in glob . glob ( pattern ) : if not move ( item , destination ) : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This parallel fetcher uses gevent one uses gevent [CODESPLIT] def fetch_event ( urls ) : rs = ( grequests . get ( u ) for u in urls ) return [ content . json ( ) for content in grequests . map ( rs ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Suppress warning about untrusted SSL certificate . [CODESPLIT] def disable_insecure_request_warning ( ) : import requests from requests . packages . urllib3 . exceptions import InsecureRequestWarning requests . packages . urllib3 . disable_warnings ( InsecureRequestWarning )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return a normalized version of abmn [CODESPLIT] def _normalize_abmn ( abmn ) : abmn_2d = np . atleast_2d ( abmn ) abmn_normalized = np . hstack ( ( np . sort ( abmn_2d [ : , 0 : 2 ] , axis = 1 ) , np . sort ( abmn_2d [ : , 2 : 4 ] , axis = 1 ) , ) ) return abmn_normalized", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resize and image to fit the passed in width keeping the aspect ratio the same [CODESPLIT] def resize_image_to_fit_width ( image , dest_w ) : scale_factor = dest_w / image . size [ 0 ] dest_h = image . size [ 1 ] * scale_factor scaled_image = image . resize ( ( int ( dest_w ) , int ( dest_h ) ) , PIL . Image . ANTIALIAS ) return scaled_image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a decimal price and rounds to a number of decimal places [CODESPLIT] def price_rounding ( price , decimals = 2 ) : try : exponent = D ( '.' + decimals * '0' ) except InvalidOperation : # Currencies with no decimal places, ex. JPY, HUF exponent = D ( ) return price . quantize ( exponent , rounding = ROUND_UP )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list with the order that features requested appear in dataset [CODESPLIT] def get_feature_order ( dataset , features ) : all_features = dataset . get_feature_names ( ) i = [ all_features . index ( f ) for f in features ] return i", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load a JSON response . [CODESPLIT] def process_response ( self , response ) : if response . status_code != 200 : raise TwilioException ( 'Unable to fetch page' , response ) return json . loads ( response . text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pad the text . [CODESPLIT] def _pad ( self , text ) : top_bottom = ( \"\\n\" * self . _padding ) + \" \" right_left = \" \" * self . _padding * self . PAD_WIDTH return top_bottom + right_left + text + right_left + top_bottom", "target": 1, "target_options": ["no_match", "match"]}
{"input": "HTTP response for forbidden access ( status code 403 ) [CODESPLIT] def HttpResponse403 ( request , template = KEY_AUTH_403_TEMPLATE , content = KEY_AUTH_403_CONTENT , content_type = KEY_AUTH_403_CONTENT_TYPE ) : return AccessFailedResponse ( request , template , content , content_type , status = 403 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Invoke pytest replacing argv . Return result code . [CODESPLIT] def run_tests ( self ) : with _save_argv ( _sys . argv [ : 1 ] + self . addopts ) : result_code = __import__ ( 'pytest' ) . main ( ) if result_code : raise SystemExit ( result_code )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Advance the iterator without returning the old head . [CODESPLIT] def _fill ( self ) : try : self . _head = self . _iterable . next ( ) except StopIteration : self . _head = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Encode from strings to token ids . [CODESPLIT] def encode_dataset ( dataset , vocabulary ) : def encode ( features ) : return { k : vocabulary . encode_tf ( v ) for k , v in features . items ( ) } return dataset . map ( encode , num_parallel_calls = tf . data . experimental . AUTOTUNE )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Support instance methods . [CODESPLIT] def __get__ ( self , obj , objtype ) : if not self . is_method : self . is_method = True return functools . partial ( self . __call__ , obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def matrixTimesVector ( MM , aa ) : bb = np . zeros ( 3 , np . float ) for ii in range ( 3 ) : bb [ ii ] = np . sum ( MM [ ii , : ] * aa ) return bb", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the host s ip number . [CODESPLIT] def get_own_ip ( ) : sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) try : sock . connect ( ( \"8.8.8.8\" , 80 ) ) except socket . gaierror : ip_ = \"127.0.0.1\" else : ip_ = sock . getsockname ( ) [ 0 ] finally : sock . close ( ) return ip_", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Each called in the code to this function is guaranteed to return True the first time and False afterwards . [CODESPLIT] def execute_only_once ( ) : f = inspect . currentframe ( ) . f_back ident = ( f . f_code . co_filename , f . f_lineno ) if ident in _EXECUTE_HISTORY : return False _EXECUTE_HISTORY . add ( ident ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Plot the empirical histogram versus best - fit distribution s PDF . [CODESPLIT] def plot ( self ) : plt . plot ( self . bin_edges , self . hist , self . bin_edges , self . best_pdf )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the estimated standard error of the mean ( sx - bar ) of the values in the passed list . sem = stdev / sqrt ( n ) [CODESPLIT] def sem ( inlist ) : sd = stdev ( inlist ) n = len ( inlist ) return sd / math . sqrt ( n )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a list of all ancestors in descending order of level including a new instance of self [CODESPLIT] def unwind ( self ) : return [ QuadKey ( self . key [ : l + 1 ] ) for l in reversed ( range ( len ( self . key ) ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Plot the empirical histogram versus best - fit distribution s PDF . [CODESPLIT] def plot ( self ) : plt . plot ( self . bin_edges , self . hist , self . bin_edges , self . best_pdf )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the index of the closest in xarr to value val [CODESPLIT] def closest ( xarr , val ) : idx_closest = np . argmin ( np . abs ( np . array ( xarr ) - val ) ) return idx_closest", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Draw a set of lines [CODESPLIT] def polyline ( self , arr ) : for i in range ( 0 , len ( arr ) - 1 ) : self . line ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] , arr [ i + 1 ] [ 0 ] , arr [ i + 1 ] [ 1 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the integer index of * series * in this sequence . [CODESPLIT] def series_index ( self , series ) : for idx , s in enumerate ( self ) : if series is s : return idx raise ValueError ( 'series not in chart data object' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function executes the request with the provided json payload and return the json response [CODESPLIT] def make_post_request ( self , url , auth , json_payload ) : response = requests . post ( url , auth = auth , json = json_payload ) return response . json ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the leftmost index of an element in a list using binary search . [CODESPLIT] def bisect_index ( a , x ) : i = bisect . bisect_left ( a , x ) if i != len ( a ) and a [ i ] == x : return i raise ValueError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print dicttree in Json - like format . keys are sorted [CODESPLIT] def prettyprint ( d ) : print ( json . dumps ( d , sort_keys = True , indent = 4 , separators = ( \",\" , \": \" ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "print just one that returns what you give it instead of None [CODESPLIT] def print ( * a ) : try : _print ( * a ) return a [ 0 ] if len ( a ) == 1 else a except : _print ( * a )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The number of days in the month of the given date [CODESPLIT] def _days_in_month ( date ) : if date . month == 12 : reference = type ( date ) ( date . year + 1 , 1 , 1 ) else : reference = type ( date ) ( date . year , date . month + 1 , 1 ) return ( reference - timedelta ( days = 1 ) ) . day", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty Prints seconds as Hours : Minutes : Seconds . MilliSeconds [CODESPLIT] def pprint ( self , seconds ) : return ( \"%d:%02d:%02d.%03d\" , reduce ( lambda ll , b : divmod ( ll [ 0 ] , b ) + ll [ 1 : ] , [ ( seconds * 1000 , ) , 1000 , 60 , 60 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the index of elem in the reversed iterator . [CODESPLIT] def index ( self , elem ) : return _coconut . len ( self . _iter ) - self . _iter . index ( elem ) - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Display error message via stderr or GUI . [CODESPLIT] def error ( * args ) : if sys . stdin . isatty ( ) : print ( 'ERROR:' , * args , file = sys . stderr ) else : notify_error ( * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns are under the ROC curve [CODESPLIT] def roc_auc ( y_true , y_score ) : notnull = ~ np . isnan ( y_true ) fpr , tpr , thresholds = sklearn . metrics . roc_curve ( y_true [ notnull ] , y_score [ notnull ] ) return sklearn . metrics . auc ( fpr , tpr )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a string containing the type and text of the exception . [CODESPLIT] def format_exception ( e ) : from . utils . printing import fill return '\\n' . join ( fill ( line ) for line in traceback . format_exception_only ( type ( e ) , e ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "rotates a 2d array to a multiple of 90 deg . 0 = default 1 = 90 deg . cw 2 = 180 deg . 3 = 90 deg . ccw [CODESPLIT] def rotateImage ( image , angle ) : image = [ list ( row ) for row in image ] for n in range ( angle % 4 ) : image = list ( zip ( * image [ : : - 1 ] ) ) return image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print in color . [CODESPLIT] def printc ( cls , txt , color = colors . red ) : print ( cls . color_txt ( txt , color ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a vector with the elements rounded to the given number of digits . [CODESPLIT] def get_rounded ( self , digits ) : result = self . copy ( ) result . round ( digits ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take stderr bytes returned from MicroPython and attempt to create a non - verbose error message . [CODESPLIT] def clean_error ( err ) : if err : decoded = err . decode ( 'utf-8' ) try : return decoded . split ( '\\r\\n' ) [ - 2 ] except Exception : return decoded return 'There was an error.'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse the xmlrpc response . [CODESPLIT] def parse_response ( self , resp ) : p , u = self . getparser ( ) p . feed ( resp . content ) p . close ( ) return u . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get object from string reference . [CODESPLIT] def get_obj ( ref ) : oid = int ( ref ) return server . id2ref . get ( oid ) or server . id2obj [ oid ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a new image by copying the image on a * color * background . [CODESPLIT] def copy_image_on_background ( image , color = WHITE ) : background = Image . new ( \"RGB\" , image . size , color ) background . paste ( image , mask = image . split ( ) [ 3 ] ) return background", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Use the S3 SWAG backend . [CODESPLIT] def s3 ( ctx , bucket_name , data_file , region ) : if not ctx . data_file : ctx . data_file = data_file if not ctx . bucket_name : ctx . bucket_name = bucket_name if not ctx . region : ctx . region = region ctx . type = 's3'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the selected fields or expressions as a SQL string . [CODESPLIT] def select_fields_as_sql ( self ) : return comma_join ( list ( self . _fields ) + [ '%s AS %s' % ( v , k ) for k , v in self . _calculated_fields . items ( ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "save something to a pickle file [CODESPLIT] def pickle_save ( thing , fname ) : pickle . dump ( thing , open ( fname , \"wb\" ) , pickle . HIGHEST_PROTOCOL ) return thing", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fetch a subset of randomzied GUIDs from the whitelist [CODESPLIT] def get_randomized_guid_sample ( self , item_count ) : dataset = self . get_whitelist ( ) random . shuffle ( dataset ) return dataset [ : item_count ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Used when the plot method defined does not create a figure nor calls save_plot Then the plot method has to use self . fig [CODESPLIT] def plot_and_save ( self , * * kwargs ) : self . fig = pyplot . figure ( ) self . plot ( ) self . axes = pyplot . gca ( ) self . save_plot ( self . fig , self . axes , * * kwargs ) pyplot . close ( self . fig )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Recieving the JSON file from uulm [CODESPLIT] def get ( url ) : response = urllib . request . urlopen ( url ) data = response . read ( ) data = data . decode ( \"utf-8\" ) data = json . loads ( data ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Saves the dictionary in json format : param fname : file to save to [CODESPLIT] def save ( self , fname ) : with open ( fname , 'wb' ) as f : json . dump ( self , f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterate chunks of size chunk_size from a file - like object [CODESPLIT] def iterate_chunks ( file , chunk_size ) : chunk = file . read ( chunk_size ) while chunk : yield chunk chunk = file . read ( chunk_size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take stderr bytes returned from MicroPython and attempt to create a non - verbose error message . [CODESPLIT] def clean_error ( err ) : if err : decoded = err . decode ( 'utf-8' ) try : return decoded . split ( '\\r\\n' ) [ - 2 ] except Exception : return decoded return 'There was an error.'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validate that the input is a list of strings . [CODESPLIT] def validate_string_list ( lst ) : if not isinstance ( lst , list ) : raise ValueError ( 'input %r must be a list' % lst ) for x in lst : if not isinstance ( x , basestring ) : raise ValueError ( 'element %r in list must be a string' % x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses CREATE INDEX CONCURRENTLY to create a duplicate index then tries to swap the new index for the original . [CODESPLIT] def cmd_reindex ( ) : db = connect ( args . database ) for idx in args . indexes : pg_reindex ( db , idx )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if arg is a valid file that already exists on the file system . [CODESPLIT] def is_valid_folder ( parser , arg ) : arg = os . path . abspath ( arg ) if not os . path . isdir ( arg ) : parser . error ( \"The folder %s does not exist!\" % arg ) else : return arg", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clean a pandas dataframe by : 1 . Filling empty values with Nan 2 . Dropping columns with all empty values [CODESPLIT] def clean_df ( df , fill_nan = True , drop_empty_columns = True ) : if fill_nan : df = df . fillna ( value = np . nan ) if drop_empty_columns : df = df . dropna ( axis = 1 , how = 'all' ) return df . sort_index ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a copy of this tabarray in the form of a numpy ndarray . [CODESPLIT] def extract ( self ) : return np . vstack ( [ self [ r ] for r in self . dtype . names ] ) . T . squeeze ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete an object from the redis table [CODESPLIT] def delete_entry ( self , key ) : pipe = self . client . pipeline ( ) pipe . srem ( self . keys_container , key ) pipe . delete ( key ) pipe . execute ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a string with punctuation removed . [CODESPLIT] def remove_punctuation ( text , exceptions = [ ] ) : all_but = [ r'\\w' , r'\\s' ] all_but . extend ( exceptions ) pattern = '[^{}]' . format ( '' . join ( all_but ) ) return re . sub ( pattern , '' , text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the index of the value at the Qth percentile in array a . [CODESPLIT] def percentile_index ( a , q ) : return np . where ( a == np . percentile ( a , q , interpolation = 'nearest' ) ) [ 0 ] [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove duplicates from an iterable preserving the order . [CODESPLIT] def delete_duplicates ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Djeffify data between tags [CODESPLIT] def handle_data ( self , data ) : if data . strip ( ) : data = djeffify_string ( data ) self . djhtml += data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap os . path . splitext to return the name and the extension without the . ( e . g . csv instead of . csv ) [CODESPLIT] def splitext_no_dot ( filename ) : name , ext = os . path . splitext ( filename ) ext = ext . lower ( ) return name , ext . strip ( '.' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "autoscan will check all of the serial ports to see if they have a matching VID : PID for a MicroPython board . [CODESPLIT] def autoscan ( ) : for port in serial . tools . list_ports . comports ( ) : if is_micropython_usb_device ( port ) : connect_serial ( port [ 0 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Modified form of the g format specifier . [CODESPLIT] def format_float ( value ) : # not used string = \"{:g}\" . format ( value ) . replace ( \"e+\" , \"e\" ) string = re . sub ( \"e(-?)0*(\\d+)\" , r\"e\\1\\2\" , string ) return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "replace nan in a by val and returns the replaced array and the nan position [CODESPLIT] def _replace_nan ( a , val ) : mask = isnull ( a ) return where_method ( val , mask , a ) , mask", "target": 1, "target_options": ["no_match", "match"]}
{"input": "internal state reset . used e . g . in unittests [CODESPLIT] def internal_reset ( self ) : log . critical ( \"PIA internal_reset()\" ) self . empty_key_toggle = True self . current_input_char = None self . input_repead = 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a member from an object by ( string ) name [CODESPLIT] def get_member ( thing_obj , member_string ) : mems = { x [ 0 ] : x [ 1 ] for x in inspect . getmembers ( thing_obj ) } if member_string in mems : return mems [ member_string ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace index in list with service [CODESPLIT] def _replace_service_arg ( self , name , index , args ) : args [ index ] = self . get_instantiated_service ( name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if value can be part of binary / bitwise operations . [CODESPLIT] def isbinary ( * args ) : return all ( map ( lambda c : isnumber ( c ) or isbool ( c ) , args ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Underlying synchronized wrapper . [CODESPLIT] def _synced ( method , self , args , kwargs ) : with self . _lock : return method ( * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add dots . [CODESPLIT] def _dotify ( cls , data ) : return '' . join ( char if char in cls . PRINTABLE_DATA else '.' for char in data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if variable is a set [CODESPLIT] def is_set ( self , key ) : data = self . model . get_data ( ) return isinstance ( data [ key ] , set )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns MultiIndex without any rows containing null values according to Baloo s convention . [CODESPLIT] def dropna ( self ) : not_nas = [ v . notna ( ) for v in self . values ] and_filter = reduce ( lambda x , y : x & y , not_nas ) return self [ and_filter ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "arr_out = round_array ( array_in ) [CODESPLIT] def round_array ( array_in ) : if isinstance ( array_in , ndarray ) : return np . round ( array_in ) . astype ( int ) else : return int ( np . round ( array_in ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resets the internal default logger to the initial configuration [CODESPLIT] def reset_default_logger ( ) : global logger global _loglevel global _logfile global _formatter _loglevel = logging . DEBUG _logfile = None _formatter = None logger = setup_logger ( name = LOGZERO_DEFAULT_LOGGER , logfile = _logfile , level = _loglevel , formatter = _formatter )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "execute jobs in processes using N threads [CODESPLIT] def parallel ( processes , threads ) : pool = multithread ( threads ) pool . map ( run_process , processes ) pool . close ( ) pool . join ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove element from the RangeSet if it is a member . [CODESPLIT] def discard ( self , element ) : try : i = int ( element ) set . discard ( self , i ) except ValueError : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Saves a pdf of the current matplotlib figure . [CODESPLIT] def save_pdf ( path ) : pp = PdfPages ( path ) pp . savefig ( pyplot . gcf ( ) ) pp . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate new UUID [CODESPLIT] def generate_id ( ) : # TODO: Use six.string_type to Py3 compat try : return unicode ( uuid1 ( ) ) . replace ( u\"-\" , u\"\" ) except NameError : return str ( uuid1 ( ) ) . replace ( u\"-\" , u\"\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "write the html file contents to disk [CODESPLIT] def _save_file ( self , filename , contents ) : with open ( filename , 'w' ) as f : f . write ( contents )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if variable is a set [CODESPLIT] def is_set ( self , key ) : data = self . model . get_data ( ) return isinstance ( data [ key ] , set )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get all attribute members ( attribute property style method ) . [CODESPLIT] def get_all_attributes ( klass_or_instance ) : pairs = list ( ) for attr , value in inspect . getmembers ( klass_or_instance , lambda x : not inspect . isroutine ( x ) ) : if not ( attr . startswith ( \"__\" ) or attr . endswith ( \"__\" ) ) : pairs . append ( ( attr , value ) ) return pairs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Solution found here : http : // stackoverflow . com / questions / 480214 / how - do - you - remove - duplicates - from - a - list - in - python - whilst - preserving - order [CODESPLIT] def unique_everseen ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns names of object columns in the DataFrame . [CODESPLIT] def get_obj_cols ( df ) : obj_cols = [ ] for idx , dt in enumerate ( df . dtypes ) : if dt == 'object' or is_category ( dt ) : obj_cols . append ( df . columns . values [ idx ] ) return obj_cols", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Traverses the object and sets the supplied attribute on the object . Supports Dimensioned and DimensionedPlot types . [CODESPLIT] def traverse_setter ( obj , attribute , value ) : obj . traverse ( lambda x : setattr ( x , attribute , value ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks syntax and validity of a variable name [CODESPLIT] def is_valid_varname ( varname ) : if not isinstance ( varname , six . string_types ) : return False match_obj = re . match ( varname_regex , varname ) valid_syntax = match_obj is not None valid_name = not keyword . iskeyword ( varname ) isvalid = valid_syntax and valid_name return isvalid", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets the auto - range of the axis on . [CODESPLIT] def setAutoRangeOn ( self , axisNumber ) : setXYAxesAutoRangeOn ( self , self . xAxisRangeCti , self . yAxisRangeCti , axisNumber )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Just the last entry . [CODESPLIT] def get_last ( self , table = None ) : if table is None : table = self . main_table query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table return self . own_cursor . execute ( query ) . fetchone ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sends a file via FTP . [CODESPLIT] def _send_file ( self , filename ) : # pylint: disable=E1101 ftp = ftplib . FTP ( host = self . host ) ftp . login ( user = self . user , passwd = self . password ) ftp . set_pasv ( True ) ftp . storbinary ( \"STOR %s\" % os . path . basename ( filename ) , file ( filename , 'rb' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get trace_id from flask request headers . [CODESPLIT] def get_trace_id_from_flask ( ) : if flask is None or not flask . request : return None header = flask . request . headers . get ( _FLASK_TRACE_HEADER ) if header is None : return None trace_id = header . split ( \"/\" , 1 ) [ 0 ] return trace_id", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Send photo to this peer . : param photo : File path to photo to send . : param caption : Caption for photo : param reply : Message object or message_id to reply to . : param on_success : Callback to call when call is complete . [CODESPLIT] def send_photo ( self , photo : str , caption : str = None , reply : Message = None , on_success : callable = None , reply_markup : botapi . ReplyMarkup = None ) : self . twx . send_photo ( peer = self , photo = photo , caption = caption , reply = reply , reply_markup = reply_markup , on_success = on_success )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check AniDB response XML tree for errors . [CODESPLIT] def _check_for_errors ( etree : ET . ElementTree ) : if etree . getroot ( ) . tag == 'error' : raise APIError ( etree . getroot ( ) . text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If holiday falls on Saturday or Sunday use previous Friday instead . [CODESPLIT] def previous_friday ( dt ) : if dt . weekday ( ) == 5 : return dt - timedelta ( 1 ) elif dt . weekday ( ) == 6 : return dt - timedelta ( 2 ) return dt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set currently authenticated user as the author of the gallery . [CODESPLIT] def save_model ( self , request , obj , form , change ) : obj . author = request . user obj . save ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the upper bound of a constraint . [CODESPLIT] def set_constraint_bound ( self , name , value ) : index = self . _get_constraint_index ( name ) self . upper_bounds [ index ] = value self . _reset_solution ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Toggle linear / log scale for Y - axis . [CODESPLIT] def log_y_cb ( self , w , val ) : self . tab_plot . logy = val self . plot_two_columns ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set additionnal options as plain text . [CODESPLIT] def set_axis_options ( self , row , column , text ) : subplot = self . get_subplot_at ( row , column ) subplot . set_axis_options ( text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the default value for this key . Default only used when no value is provided by the user via arg config or env . [CODESPLIT] def set_default ( self , key , value ) : k = self . _real_key ( key . lower ( ) ) self . _defaults [ k ] = value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reshape data into ( num_example batch_size ) [CODESPLIT] def batchify ( data , batch_size ) : nbatch = data . shape [ 0 ] // batch_size data = data [ : nbatch * batch_size ] data = data . reshape ( ( batch_size , nbatch ) ) . T return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a string with terminal colors . [CODESPLIT] def stringc ( text , color ) : if has_colors : text = str ( text ) return \"\\033[\" + codeCodes [ color ] + \"m\" + text + \"\\033[0m\" else : return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for matplotlib imshow [CODESPLIT] def extent ( self ) : return ( self . intervals [ 1 ] . pix1 - 0.5 , self . intervals [ 1 ] . pix2 - 0.5 , self . intervals [ 0 ] . pix1 - 0.5 , self . intervals [ 0 ] . pix2 - 0.5 , )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a re . match object if an empty comment was found on line . [CODESPLIT] def _match_space_at_line ( line ) : regex = re . compile ( r\"^{0}$\" . format ( _MDL_COMMENT ) ) return regex . match ( line )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield successive n - sized chunks from an iterable . [CODESPLIT] def chunks ( iterable , chunk ) : for i in range ( 0 , len ( iterable ) , chunk ) : yield iterable [ i : i + chunk ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Slicing op . [CODESPLIT] def Slice ( a , begin , size ) : return np . copy ( a ) [ [ slice ( * tpl ) for tpl in zip ( begin , begin + size ) ] ] ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Auto cached queryset and generate results . [CODESPLIT] def cached_query ( qs , timeout = None ) : cache_key = generate_cache_key ( qs ) return get_cached ( cache_key , list , args = ( qs , ) , timeout = None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "sort a list of files by filename only ignoring the directory names [CODESPLIT] def sort_filenames ( filenames ) : basenames = [ os . path . basename ( x ) for x in filenames ] indexes = [ i [ 0 ] for i in sorted ( enumerate ( basenames ) , key = lambda x : x [ 1 ] ) ] return [ filenames [ x ] for x in indexes ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Order - preserving sorting function . [CODESPLIT] def csort ( objs , key ) : idxs = dict ( ( obj , i ) for ( i , obj ) in enumerate ( objs ) ) return sorted ( objs , key = lambda obj : ( key ( obj ) , idxs [ obj ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "We have a full length slice . [CODESPLIT] def is_full_slice ( obj , l ) : return ( isinstance ( obj , slice ) and obj . start == 0 and obj . stop == l and obj . step is None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "sort a list of files by filename only ignoring the directory names [CODESPLIT] def sort_filenames ( filenames ) : basenames = [ os . path . basename ( x ) for x in filenames ] indexes = [ i [ 0 ] for i in sorted ( enumerate ( basenames ) , key = lambda x : x [ 1 ] ) ] return [ filenames [ x ] for x in indexes ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "We have a full length slice . [CODESPLIT] def is_full_slice ( obj , l ) : return ( isinstance ( obj , slice ) and obj . start == 0 and obj . stop == l and obj . step is None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the slice after at sub in string astr [CODESPLIT] def fsliceafter ( astr , sub ) : findex = astr . find ( sub ) return astr [ findex + len ( sub ) : ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take an str / unicode type_ and raise a ValueError if it s not a valid type for the object . A valid type for a field is a value from the types_set attribute of that field s class . [CODESPLIT] def validate_type ( self , type_ ) : if type_ is not None and type_ not in self . types_set : raise ValueError ( 'Invalid type for %s:%s' % ( self . __class__ , type_ ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates the moving average ( rolling mean ) of an array of a certain window size . [CODESPLIT] def movingaverage ( arr , window ) : m = np . ones ( int ( window ) ) / int ( window ) return scipy . ndimage . convolve1d ( arr , m , axis = 0 , mode = 'reflect' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Places a legend box outside a matplotlib Axes instance . [CODESPLIT] def mpl_outside_legend ( ax , * * kwargs ) : box = ax . get_position ( ) ax . set_position ( [ box . x0 , box . y0 , box . width * 0.75 , box . height ] ) # Put a legend to the right of the current axis ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1 , 1 ) , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def smooth_array ( array , amount = 1 ) : if amount == 0 : return array # we have to store the old values in a temp array to keep the # smoothing from affecting the smoothing new_array = _n . array ( array ) for n in range ( len ( array ) ) : new_array [ n ] = smooth ( array , n , amount ) return new_array", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses dynamic programming to infer the location of spaces in a string without spaces . [CODESPLIT] def split ( s ) : l = [ _split ( x ) for x in _SPLIT_RE . split ( s ) ] return [ item for sublist in l for item in sublist ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pick an unused port . There is a slight chance that this wont work . [CODESPLIT] def pick_unused_port ( self ) : s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . bind ( ( '127.0.0.1' , 0 ) ) _ , port = s . getsockname ( ) s . close ( ) return port", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses dynamic programming to infer the location of spaces in a string without spaces . [CODESPLIT] def split ( s ) : l = [ _split ( x ) for x in _SPLIT_RE . split ( s ) ] return [ item for sublist in l for item in sublist ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the Webserver / SocketIO and app [CODESPLIT] def run ( context , port ) : global ctx ctx = context app . run ( port = port )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "split string into list of strings by specified number . [CODESPLIT] def _split_str ( s , n ) : length = len ( s ) return [ s [ i : i + n ] for i in range ( 0 , length , n ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Enter a room . [CODESPLIT] def enter_room ( self , sid , room , namespace = None ) : return self . server . enter_room ( sid , room , namespace = namespace or self . namespace )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "End of the Glances server session . [CODESPLIT] def end ( self ) : if not self . args . disable_autodiscover : self . autodiscover_client . close ( ) self . server . end ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like argsort but returns an index suitable for sorting the the original array even if that array is multidimensional [CODESPLIT] def argsort_indices ( a , axis = - 1 ) : a = np . asarray ( a ) ind = list ( np . ix_ ( * [ np . arange ( d ) for d in a . shape ] ) ) ind [ axis ] = a . argsort ( axis ) return tuple ( ind )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A basic slug version of a given parameter list . [CODESPLIT] def delistify ( x ) : if isinstance ( x , list ) : x = [ e . replace ( \"'\" , \"\" ) for e in x ] return '-' . join ( sorted ( x ) ) return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Key function used to sort transcripts . Taking the negative of protein sequence length and nucleotide sequence length so that the transcripts with longest sequences come first in the list . This couldn t be accomplished with reverse = True since we re also sorting by transcript name ( which places TP53 - 001 before TP53 - 002 ) . [CODESPLIT] def transcript_sort_key ( transcript ) : return ( - len ( transcript . protein_sequence ) , - len ( transcript . sequence ) , transcript . name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform a ( multidimensional ) variable access to a flattend sympy expression . [CODESPLIT] def access_to_sympy ( self , var_name , access ) : base_sizes = self . variables [ var_name ] [ 1 ] expr = sympy . Number ( 0 ) for dimension , a in enumerate ( access ) : base_size = reduce ( operator . mul , base_sizes [ dimension + 1 : ] , sympy . Integer ( 1 ) ) expr += base_size * a return expr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Internal helper to return the values of a dictionary sorted by key . [CODESPLIT] def _dict_values_sorted_by_key ( dictionary ) : # This should be a yield from instead. for _ , value in sorted ( dictionary . iteritems ( ) , key = operator . itemgetter ( 0 ) ) : yield value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Let the DBMS perform a sum on a queryset [CODESPLIT] def query_sum ( queryset , field ) : return queryset . aggregate ( s = models . functions . Coalesce ( models . Sum ( field ) , 0 ) ) [ 's' ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "sort a list of files by filename only ignoring the directory names [CODESPLIT] def sort_filenames ( filenames ) : basenames = [ os . path . basename ( x ) for x in filenames ] indexes = [ i [ 0 ] for i in sorted ( enumerate ( basenames ) , key = lambda x : x [ 1 ] ) ] return [ filenames [ x ] for x in indexes ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call a system command in the background disown it and hide it s output . [CODESPLIT] def disown ( cmd ) : subprocess . Popen ( cmd , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "sort a list of files by filename only ignoring the directory names [CODESPLIT] def sort_filenames ( filenames ) : basenames = [ os . path . basename ( x ) for x in filenames ] indexes = [ i [ 0 ] for i in sorted ( enumerate ( basenames ) , key = lambda x : x [ 1 ] ) ] return [ filenames [ x ] for x in indexes ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string from snake case to camel case with the first letter capitalized . For example some_var would become SomeVar . [CODESPLIT] def to_capitalized_camel_case ( snake_case_string ) : parts = snake_case_string . split ( '_' ) return '' . join ( [ i . title ( ) for i in parts ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sort list elements by name . [CODESPLIT] def sort_by_name ( self ) : super ( JSSObjectList , self ) . sort ( key = lambda k : k . name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "inverse hyperbolic sine transformation [CODESPLIT] def inh ( table ) : t = [ ] for i in table : t . append ( np . ndarray . tolist ( np . arcsinh ( i ) ) ) return t", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieves and returns the source code for any Python files requested by the UI via the host agent [CODESPLIT] def get_py_source ( file ) : try : response = None pysource = \"\" if regexp_py . search ( file ) is None : response = { \"error\" : \"Only Python source files are allowed. (*.py)\" } else : with open ( file , 'r' ) as pyfile : pysource = pyfile . read ( ) response = { \"data\" : pysource } except Exception as e : response = { \"error\" : str ( e ) } finally : return response", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the root mean square error . [CODESPLIT] def _root_mean_square_error ( y , y_pred , w ) : return np . sqrt ( np . average ( ( ( y_pred - y ) ** 2 ) , weights = w ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a copy of the given string ( or list of strings ) in which all occurrences of the given source are replaced by the given dest . [CODESPLIT] def replace ( scope , strings , source , dest ) : return [ s . replace ( source [ 0 ] , dest [ 0 ] ) for s in strings ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts and image to matrix ( one pixel per line ) [CODESPLIT] def im2mat ( I ) : return I . reshape ( ( I . shape [ 0 ] * I . shape [ 1 ] , I . shape [ 2 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a copy of this SparseVector as a 1 - dimensional NumPy array . [CODESPLIT] def toArray ( self ) : arr = np . zeros ( ( self . size , ) , dtype = np . float64 ) arr [ self . indices ] = self . values return arr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if unicode string only contains ASCII characters . [CODESPLIT] def unicode_is_ascii ( u_string ) : assert isinstance ( u_string , str ) try : u_string . encode ( 'ascii' ) return True except UnicodeEncodeError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets cursor as beginning of next line . [CODESPLIT] def step_next_line ( self ) : self . _eol . append ( self . position ) self . _lineno += 1 self . _col_offset = 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Google AppEngine Helper to convert a data type into a string . [CODESPLIT] def datatype ( dbtype , description , cursor ) : dt = cursor . db . introspection . get_field_type ( dbtype , description ) if type ( dt ) is tuple : return dt [ 0 ] else : return dt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read the sphinx environment . pickle file at path pth . [CODESPLIT] def read_sphinx_environment ( pth ) : with open ( pth , 'rb' ) as fo : env = pickle . load ( fo ) return env", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if the image is a sequenced image . [CODESPLIT] def _is_image_sequenced ( image ) : try : image . seek ( 1 ) image . seek ( 0 ) result = True except EOFError : result = False return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Moves the text cursor to given line . [CODESPLIT] def go_to_line ( self , line ) : cursor = self . textCursor ( ) cursor . setPosition ( self . document ( ) . findBlockByNumber ( line - 1 ) . position ( ) ) self . setTextCursor ( cursor ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split text into list of sentences . [CODESPLIT] def split_into_sentences ( s ) : s = re . sub ( r\"\\s+\" , \" \" , s ) s = re . sub ( r\"[\\\\.\\\\?\\\\!]\" , \"\\n\" , s ) return s . split ( \"\\n\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Indicate whether the specified image file is valid or not . [CODESPLIT] def is_image_file_valid ( file_path_name ) : # Image.verify is only implemented for PNG images, and it only verifies # the CRC checksum in the image.  The only way to check from within # Pillow is to load the image in a try/except and check the error.  If # as much info as possible is from the image is needed, # ``ImageFile.LOAD_TRUNCATED_IMAGES=True`` needs to bet set and it # will attempt to parse as much as possible. try : with Image . open ( file_path_name ) as image : image . load ( ) except IOError : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check lowercase key item . [CODESPLIT] def __contains__ ( self , key ) : assert isinstance ( key , basestring ) return dict . __contains__ ( self , key . lower ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param source : some iterable source ( list file etc ) : param lineSep : string of separators ( chars ) that must be removed : return : list of non empty lines with removed separators [CODESPLIT] def cleanLines ( source , lineSep = os . linesep ) : stripped = ( line . strip ( lineSep ) for line in source ) return ( line for line in stripped if len ( line ) != 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Match and yield all the tokens of the input string . [CODESPLIT] def tokenize ( string ) : for match in TOKENS_REGEX . finditer ( string ) : yield Token ( match . lastgroup , match . group ( ) . strip ( ) , match . span ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "reinidents a string ( s ) by the given number of spaces ( numspaces ) [CODESPLIT] def reindent ( s , numspaces ) : leading_space = numspaces * ' ' lines = [ leading_space + line . strip ( ) for line in s . splitlines ( ) ] return '\\n' . join ( lines )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns number of wraps around given method . [CODESPLIT] def wrap_count ( method ) : number = 0 while hasattr ( method , '__aspects_orig' ) : number += 1 method = method . __aspects_orig return number", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert an integer list into a string list . [CODESPLIT] def list_i2str ( ilist ) : slist = [ ] for el in ilist : slist . append ( str ( el ) ) return slist", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Quit and Restart Spyder application . If reset True it allows to reset spyder on restart . [CODESPLIT] def restart ( self , reset = False ) : # Get start path to use in restart script\n spyder_start_directory = get_module_path ( 'spyder' ) restart_script = osp . join ( spyder_start_directory , 'app' , 'restart.py' ) # Get any initial argument passed when spyder was started\n # Note: Variables defined in bootstrap.py and spyder/app/start.py\n env = os . environ . copy ( ) bootstrap_args = env . pop ( 'SPYDER_BOOTSTRAP_ARGS' , None ) spyder_args = env . pop ( 'SPYDER_ARGS' ) # Get current process and python running spyder\n pid = os . getpid ( ) python = sys . executable # Check if started with bootstrap.py\n if bootstrap_args is not None : spyder_args = bootstrap_args is_bootstrap = True else : is_bootstrap = False # Pass variables as environment variables (str) to restarter subprocess\n env [ 'SPYDER_ARGS' ] = spyder_args env [ 'SPYDER_PID' ] = str ( pid ) env [ 'SPYDER_IS_BOOTSTRAP' ] = str ( is_bootstrap ) env [ 'SPYDER_RESET' ] = str ( reset ) if DEV : if os . name == 'nt' : env [ 'PYTHONPATH' ] = ';' . join ( sys . path ) else : env [ 'PYTHONPATH' ] = ':' . join ( sys . path ) # Build the command and popen arguments depending on the OS\n if os . name == 'nt' : # Hide flashing command prompt\n startupinfo = subprocess . STARTUPINFO ( ) startupinfo . dwFlags |= subprocess . STARTF_USESHOWWINDOW shell = False else : startupinfo = None shell = True command = '\"{0}\" \"{1}\"' command = command . format ( python , restart_script ) try : if self . closing ( True ) : subprocess . Popen ( command , shell = shell , env = env , startupinfo = startupinfo ) self . console . quit ( ) except Exception as error : # If there is an error with subprocess, Spyder should not quit and\n # the error can be inspected in the internal console\n print ( error ) # spyder: test-skip\n print ( command )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a binding from the sparql query result create a dict of plain text [CODESPLIT] def _bindingsToDict ( self , bindings ) : myDict = { } for key , val in bindings . iteritems ( ) : myDict [ key . toPython ( ) . replace ( '?' , '' ) ] = val . toPython ( ) return myDict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the pythonic string type . [CODESPLIT] def visit_Str ( self , node ) : self . result [ node ] = self . builder . NamedType ( pytype_to_ctype ( str ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a number of query results . This is faster than . count () on the query [CODESPLIT] def get_count ( self , query ) : count_q = query . statement . with_only_columns ( [ func . count ( ) ] ) . order_by ( None ) count = query . session . execute ( count_q ) . scalar ( ) return count", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Revert to a previous version [CODESPLIT] def downgrade ( directory , sql , tag , x_arg , revision ) : _downgrade ( directory , revision , sql , tag , x_arg )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Closes the session to the database . [CODESPLIT] def unlock ( self ) : if not hasattr ( self , 'session' ) : raise RuntimeError ( 'Error detected! The session that you want to close does not exist any more!' ) logger . debug ( \"Closed database session of '%s'\" % self . _database ) self . session . close ( ) del self . session", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Build a C ++ binary executable [CODESPLIT] def cpp_prog_builder ( build_context , target ) : yprint ( build_context . conf , 'Build CppProg' , target ) workspace_dir = build_context . get_workspace ( 'CppProg' , target . name ) build_cpp ( build_context , target , target . compiler_config , workspace_dir )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether a certain column exists [CODESPLIT] def column_exists ( cr , table , column ) : cr . execute ( 'SELECT count(attname) FROM pg_attribute ' 'WHERE attrelid = ' '( SELECT oid FROM pg_class WHERE relname = %s ) ' 'AND attname = %s' , ( table , column ) ) return cr . fetchone ( ) [ 0 ] == 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Unpacks sqlite rows as returned by fetchall into an array of simple dicts . [CODESPLIT] def sqliteRowsToDicts ( sqliteRows ) : return map ( lambda r : dict ( zip ( r . keys ( ) , r ) ) , sqliteRows )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a hash of the contents of a dictionary [CODESPLIT] def dict_hash ( dct ) : dct_s = json . dumps ( dct , sort_keys = True ) try : m = md5 ( dct_s ) except TypeError : m = md5 ( dct_s . encode ( ) ) return m . hexdigest ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve the type and length for a data record . [CODESPLIT] def get_type_len ( self ) : # Check types and set type/len self . get_sql ( ) return self . type , self . len , self . len_decimal", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace all the ocurrences ( in a file ) of a string with another value . [CODESPLIT] def replace_all ( filepath , searchExp , replaceExp ) : for line in fileinput . input ( filepath , inplace = 1 ) : if searchExp in line : line = line . replace ( searchExp , replaceExp ) sys . stdout . write ( line )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of the table names in the database . [CODESPLIT] def get_table_names ( connection ) : cursor = connection . cursor ( ) cursor . execute ( \"SELECT name FROM sqlite_master WHERE type == 'table'\" ) return [ name for ( name , ) in cursor ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert an integer list into a string list . [CODESPLIT] def list_i2str ( ilist ) : slist = [ ] for el in ilist : slist . append ( str ( el ) ) return slist", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determines if the specified file / folder exists even if it is on a remote server . [CODESPLIT] def exists ( self , filepath ) : if self . is_ssh ( filepath ) : self . _check_ftp ( ) remotepath = self . _get_remote ( filepath ) try : self . ftp . stat ( remotepath ) except IOError as e : if e . errno == errno . ENOENT : return False else : return True else : return os . path . exists ( filepath )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Try and make the given argument into a tuple . [CODESPLIT] def ensure_tuple ( obj ) : if obj is None : return tuple ( ) if isinstance ( obj , Iterable ) and not isinstance ( obj , six . string_types ) : return tuple ( obj ) return obj ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param sequence : Any sequence whose elements can be evaluated as booleans . : returns : true if all elements of the sequence satisfy True and x . [CODESPLIT] def All ( sequence ) : return bool ( reduce ( lambda x , y : x and y , sequence , True ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a 2 x m array indicating the min and max along each dimension . [CODESPLIT] def calculate_bounding_box ( data ) : mins = data . min ( 0 ) maxes = data . max ( 0 ) return mins , maxes", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A static value ( does not change at runtime ) which is known at compile time [CODESPLIT] def is_static ( * p ) : return all ( is_CONST ( x ) or is_number ( x ) or is_const ( x ) for x in p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a complete graph from the list of node ids . [CODESPLIT] def _create_complete_graph ( node_ids ) : g = nx . Graph ( ) g . add_nodes_from ( node_ids ) for ( i , j ) in combinations ( node_ids , 2 ) : g . add_edge ( i , j ) return g", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator which dynamically binds static methods to the model for later use . [CODESPLIT] def static_method ( cls , f ) : setattr ( cls , f . __name__ , staticmethod ( f ) ) return f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns path to packaged static files [CODESPLIT] def glr_path_static ( ) : return os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , '_static' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Connect to a redis instance . [CODESPLIT] def __connect ( ) : global redis_instance if use_tcp_socket : redis_instance = redis . StrictRedis ( host = hostname , port = port ) else : redis_instance = redis . StrictRedis ( unix_socket_path = unix_socket )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update a staticmethod update . [CODESPLIT] def _update_staticmethod ( self , oldsm , newsm ) : # While we can't modify the staticmethod object itself (it has no # mutable attributes), we *can* extract the underlying function # (by calling __get__(), which returns it) and update it in-place. # We don't have the class available to pass to __get__() but any # object except None will do. self . _update ( None , None , oldsm . __get__ ( 0 ) , newsm . __get__ ( 0 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update a staticmethod update . [CODESPLIT] def _update_staticmethod ( self , oldsm , newsm ) : # While we can't modify the staticmethod object itself (it has no # mutable attributes), we *can* extract the underlying function # (by calling __get__(), which returns it) and update it in-place. # We don't have the class available to pass to __get__() but any # object except None will do. self . _update ( None , None , oldsm . __get__ ( 0 ) , newsm . __get__ ( 0 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply a function in parallel to each element of the input [CODESPLIT] def apply ( f , obj , * args , * * kwargs ) : return vectorize ( f ) ( obj , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize the length of a vector to one [CODESPLIT] def norm_vec ( vector ) : assert len ( vector ) == 3 v = np . array ( vector ) return v / np . sqrt ( np . sum ( v ** 2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns OK then waits approximately 1 second and restarts container [CODESPLIT] async def restart ( request ) : def wait_and_restart ( ) : log . info ( 'Restarting server' ) sleep ( 1 ) os . system ( 'kill 1' ) Thread ( target = wait_and_restart ) . start ( ) return web . json_response ( { \"message\" : \"restarting\" } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses an ISO8601 formatted datetime from a string value [CODESPLIT] def parse_json_date ( value ) : if not value : return None return datetime . datetime . strptime ( value , JSON_DATETIME_FORMAT ) . replace ( tzinfo = pytz . UTC )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts datetime object to str if not yet an str . [CODESPLIT] def dt2str ( dt , flagSeconds = True ) : if isinstance ( dt , str ) : return dt return dt . strftime ( _FMTS if flagSeconds else _FMT )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Whether any of the strings contains any of the candidates . [CODESPLIT] def any_contains_any ( strings , candidates ) : for string in strings : for c in candidates : if c in string : return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Loads the flow from a JSON file . [CODESPLIT] def load ( cls , fname ) : with open ( fname ) as f : content = f . readlines ( ) return Flow . from_json ( '' . join ( content ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": type s str [CODESPLIT] def safe_format ( s , * * kwargs ) : return string . Formatter ( ) . vformat ( s , ( ) , defaultdict ( str , * * kwargs ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Squash self . out into string . [CODESPLIT] def build_output ( self , fout ) : fout . write ( '\\n' . join ( [ s for s in self . out ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write a config object to the settings . cfg file . [CODESPLIT] def _write_config ( config , cfg_file ) : directory = os . path . dirname ( cfg_file ) if not os . path . exists ( directory ) : os . makedirs ( directory ) with open ( cfg_file , \"w+\" ) as output_file : config . write ( output_file )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Return variable as a string to print with given precision . [CODESPLIT] def _strvar ( a , prec = '{:G}' ) : return ' ' . join ( [ prec . format ( i ) for i in np . atleast_1d ( a ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute entropy on the string [CODESPLIT] def entropy ( string ) : p , lns = Counter ( string ) , float ( len ( string ) ) return - sum ( count / lns * math . log ( count / lns , 2 ) for count in p . values ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a string return true if it matches the supplied list of patterns . [CODESPLIT] def match ( string , patterns ) : if patterns is None : return True else : return any ( re . match ( pattern , string ) for pattern in patterns )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Save printed statements in a file . [CODESPLIT] def dump_stmt_strings ( stmts , fname ) : with open ( fname , 'wb' ) as fh : for st in stmts : fh . write ( ( '%s\\n' % st ) . encode ( 'utf-8' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validate a list of strings [CODESPLIT] def validate_stringlist ( s ) : if isinstance ( s , six . string_types ) : return [ six . text_type ( v . strip ( ) ) for v in s . split ( ',' ) if v . strip ( ) ] else : try : return list ( map ( validate_str , s ) ) except TypeError as e : raise ValueError ( e . message )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "writes the line and count newlines after the line [CODESPLIT] def write_line ( self , line , count = 1 ) : self . write ( line ) self . write_newlines ( count )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper : returns String Slice node [CODESPLIT] def make_strslice ( lineno , s , lower , upper ) : return symbols . STRSLICE . make_node ( lineno , s , lower , upper )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Property providing access to the : class : . FileDataAPI [CODESPLIT] def filedata ( self ) : if self . _filedata_api is None : self . _filedata_api = self . get_filedata_api ( ) return self . _filedata_api", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a comma separated string to a list [CODESPLIT] def _str_to_list ( s ) : _list = s . split ( \",\" ) return list ( map ( lambda i : i . lstrip ( ) , _list ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "u Move back a character . [CODESPLIT] def backward_char ( self , e ) : # (C-b)\n self . l_buffer . backward_char ( self . argument_reset ) self . finalize ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prints the top row of a table [CODESPLIT] def top ( n , width = WIDTH , style = STYLE ) : return hrule ( n , width , linestyle = STYLES [ style ] . top )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the string without any initial or final quotes . [CODESPLIT] def _repr_strip ( mystring ) : r = repr ( mystring ) if r . startswith ( \"'\" ) and r . endswith ( \"'\" ) : return r [ 1 : - 1 ] else : return r", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts html content to plain text [CODESPLIT] def html_to_text ( content ) : text = None h2t = html2text . HTML2Text ( ) h2t . ignore_links = False text = h2t . handle ( content ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Whitespace normalization : [CODESPLIT] def text_remove_empty_lines ( text ) : lines = [ line . rstrip ( ) for line in text . splitlines ( ) if line . strip ( ) ] return \"\\n\" . join ( lines )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty print the object s representation . [CODESPLIT] def pretty ( obj , verbose = False , max_width = 79 , newline = '\\n' ) : stream = StringIO ( ) printer = RepresentationPrinter ( stream , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) return stream . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cleans trailing whitespaces and replaces also multiple whitespaces with a single space . [CODESPLIT] def strip_spaces ( value , sep = None , join = True ) : value = value . strip ( ) value = [ v . strip ( ) for v in value . split ( sep ) ] join_sep = sep or ' ' return join_sep . join ( value ) if join else value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Changes the permissions of the given file ( or list of files ) to the given mode . You probably want to use an octal representation for the integer e . g . chmod ( myfile 0644 ) . [CODESPLIT] def chmod ( scope , filename , mode ) : for file in filename : os . chmod ( file , mode [ 0 ] ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove comments and empty lines [CODESPLIT] def lines ( input ) : for raw_line in input : line = raw_line . strip ( ) if line and not line . startswith ( '#' ) : yield strip_comments ( line )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param sequence : Any sequence whose elements can be evaluated as booleans . : returns : true if all elements of the sequence satisfy True and x . [CODESPLIT] def All ( sequence ) : return bool ( reduce ( lambda x , y : x and y , sequence , True ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get letters from string only . [CODESPLIT] def return_letters_from_string ( text ) : out = \"\" for letter in text : if letter . isalpha ( ) : out += letter return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show the y - axis tick labels for a subplot . [CODESPLIT] def show_yticklabels ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . show_yticklabels ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Writes a file if it doesn t already exist with the same content . [CODESPLIT] def _replace_file ( path , content ) : if os . path . exists ( path ) : with open ( path , 'r' ) as f : if content == f . read ( ) : print ( \"Not overwriting {} because it is unchanged\" . format ( path ) , file = sys . stderr ) return with open ( path , 'w' ) as f : f . write ( content )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Communicate with the child process without closing stdin . [CODESPLIT] def correspond ( text ) : subproc . stdin . write ( text ) subproc . stdin . flush ( ) return drain ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true iff v is a number . [CODESPLIT] def numberp ( v ) : return ( not ( isinstance ( v , bool ) ) and ( isinstance ( v , int ) or isinstance ( v , float ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call a system command in the background disown it and hide it s output . [CODESPLIT] def disown ( cmd ) : subprocess . Popen ( cmd , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "must be a float [CODESPLIT] def is_float ( value ) : return isinstance ( value , float ) or isinstance ( value , int ) or isinstance ( value , np . float64 ) , float ( value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Let the DBMS perform a sum on a queryset [CODESPLIT] def query_sum ( queryset , field ) : return queryset . aggregate ( s = models . functions . Coalesce ( models . Sum ( field ) , 0 ) ) [ 's' ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace a node annotated by nni . variable . node : the AST node to replace annotation : annotation string [CODESPLIT] def replace_variable_node ( node , annotation ) : assert type ( node ) is ast . Assign , 'nni.variable is not annotating assignment expression' assert len ( node . targets ) == 1 , 'Annotated assignment has more than one left-hand value' name , expr = parse_nni_variable ( annotation ) assert test_variable_equal ( node . targets [ 0 ] , name ) , 'Annotated variable has wrong name' node . value = expr return node", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Swap i and j rows [CODESPLIT] def _swap_rows ( self , i , j ) : L = np . eye ( 3 , dtype = 'intc' ) L [ i , i ] = 0 L [ j , j ] = 0 L [ i , j ] = 1 L [ j , i ] = 1 self . _L . append ( L . copy ( ) ) self . _A = np . dot ( L , self . _A )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resets the scale on this image . Correctly aligns time scale undoes manual scaling [CODESPLIT] def resetScale ( self ) : self . img . scale ( 1. / self . imgScale [ 0 ] , 1. / self . imgScale [ 1 ] ) self . imgScale = ( 1. , 1. )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "DEBUG FUNC modify argv to look like you ran a command [CODESPLIT] def aug_sysargv ( cmdstr ) : import shlex argv = shlex . split ( cmdstr ) sys . argv . extend ( argv )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return geohash for given point with self . precision : param point : GeoPoint instance : return : string [CODESPLIT] def get_point_hash ( self , point ) : return geohash . encode ( point . latitude , point . longitude , self . precision )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "DEBUG FUNC modify argv to look like you ran a command [CODESPLIT] def aug_sysargv ( cmdstr ) : import shlex argv = shlex . split ( cmdstr ) sys . argv . extend ( argv )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tests on itemlist equality [CODESPLIT] def __eq__ ( self , anotherset ) : if not isinstance ( anotherset , LR0ItemSet ) : raise TypeError if len ( self . itemlist ) != len ( anotherset . itemlist ) : return False for element in self . itemlist : if element not in anotherset . itemlist : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Paint the table on terminal Currently only print out basic string format [CODESPLIT] def paint ( self , tbl ) : if not isinstance ( tbl , Table ) : logging . error ( \"unable to paint table: invalid object\" ) return False self . term . stream . write ( self . term . clear ) self . term . stream . write ( str ( tbl ) ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if number is integer or not . [CODESPLIT] def check_int ( integer ) : if not isinstance ( integer , str ) : return False if integer [ 0 ] in ( '-' , '+' ) : return integer [ 1 : ] . isdigit ( ) return integer . isdigit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string to a pythonized parameter . [CODESPLIT] def get_truetype ( value ) : if value in [ \"true\" , \"True\" , \"y\" , \"Y\" , \"yes\" ] : return True if value in [ \"false\" , \"False\" , \"n\" , \"N\" , \"no\" ] : return False if value . isdigit ( ) : return int ( value ) return str ( value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses dynamic programming to infer the location of spaces in a string without spaces . [CODESPLIT] def split ( s ) : l = [ _split ( x ) for x in _SPLIT_RE . split ( s ) ] return [ item for sublist in l for item in sublist ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pad a matrix with zeros on all sides . [CODESPLIT] def zero_pad ( m , n = 1 ) : return np . pad ( m , ( n , n ) , mode = 'constant' , constant_values = [ 0 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Step over the next statement [CODESPLIT] def do_next ( self , args ) : self . _do_print_from_last_cmd = True self . _interp . step_over ( ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Computes average length of words [CODESPLIT] def get_average_length_of_string ( strings ) : if not strings : return 0 return sum ( len ( word ) for word in strings ) / len ( strings )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If holiday falls on Saturday or Sunday use previous Friday instead . [CODESPLIT] def previous_friday ( dt ) : if dt . weekday ( ) == 5 : return dt - timedelta ( 1 ) elif dt . weekday ( ) == 6 : return dt - timedelta ( 2 ) return dt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns whether this is a complex floating point type . [CODESPLIT] def is_complex ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'is_complex' ) : return dtype . is_complex return np . issubdtype ( np . dtype ( dtype ) , np . complex )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get indent of text . https : // stackoverflow . com / questions / 2268532 / grab - a - lines - whitespace - indention - with - python [CODESPLIT] def get_indent ( text ) : indent = '' ret = re . match ( r'(\\s*)' , text ) if ret : indent = ret . group ( 1 ) return indent", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Assert that a value must be a given type . [CODESPLIT] def _assert_is_type ( name , value , value_type ) : if not isinstance ( value , value_type ) : if type ( value_type ) is tuple : types = ', ' . join ( t . __name__ for t in value_type ) raise ValueError ( '{0} must be one of ({1})' . format ( name , types ) ) else : raise ValueError ( '{0} must be {1}' . format ( name , value_type . __name__ ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns whether * obj * is iterable lazily such as generators range objects etc . [CODESPLIT] def is_lazy_iterable ( obj ) : return isinstance ( obj , ( types . GeneratorType , collections . MappingView , six . moves . range , enumerate ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If pair is in search_list return the index . Otherwise return - 1 [CODESPLIT] def is_in ( self , search_list , pair ) : index = - 1 for nr , i in enumerate ( search_list ) : if ( np . all ( i == pair ) ) : return nr return index", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if file is a regular file and is readable . [CODESPLIT] def is_readable ( filename ) : return os . path . isfile ( filename ) and os . access ( filename , os . R_OK )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "For a given value the function finds the nearest value in the array and returns its index . [CODESPLIT] def find_nearest_index ( arr , value ) : arr = np . array ( arr ) index = ( abs ( arr - value ) ) . argmin ( ) return index", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if the given string starts with one of the prefixes in the given list otherwise return False . [CODESPLIT] def starts_with_prefix_in_list ( text , prefixes ) : for prefix in prefixes : if text . startswith ( prefix ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the indices of all the val in m [CODESPLIT] def index ( m , val ) : mm = np . array ( m ) idx_tuple = np . where ( mm == val ) idx = idx_tuple [ 0 ] . tolist ( ) return idx", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Requests - mock requests . post wrapper . [CODESPLIT] def requests_post ( url , data = None , json = None , * * kwargs ) : return requests_request ( 'post' , url , data = data , json = json , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Performs a join using the union join function . [CODESPLIT] def merge ( left , right , how = 'inner' , key = None , left_key = None , right_key = None , left_as = 'left' , right_as = 'right' ) : return join ( left , right , how , key , left_key , right_key , join_fn = make_union_join ( left_as , right_as ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate an empty texture in OpenGL [CODESPLIT] def _genTex2D ( self ) : for face in range ( 6 ) : gl . glTexImage2D ( self . target0 + face , 0 , self . internal_fmt , self . width , self . height , 0 , self . pixel_fmt , gl . GL_UNSIGNED_BYTE , 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a new image by copying the image on a * color * background . [CODESPLIT] def copy_image_on_background ( image , color = WHITE ) : background = Image . new ( \"RGB\" , image . size , color ) background . paste ( image , mask = image . split ( ) [ 3 ] ) return background", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a percentile range from an array of values . [CODESPLIT] def ci ( a , which = 95 , axis = None ) : p = 50 - which / 2 , 50 + which / 2 return percentiles ( a , p , axis )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert an int of form yyyymmdd to a python date object . [CODESPLIT] def int_to_date ( date ) : year = date // 10 ** 4 month = date % 10 ** 4 // 10 ** 2 day = date % 10 ** 2 return datetime . date ( year , month , day )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve the previous quarter for dt [CODESPLIT] def previous_quarter ( d ) : from django_toolkit . datetime_util import quarter as datetime_quarter return quarter ( ( datetime_quarter ( datetime ( d . year , d . month , d . day ) ) [ 0 ] + timedelta ( days = - 1 ) ) . date ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Linear oldstyle interpolation of the transform matrix . [CODESPLIT] def _linearInterpolationTransformMatrix ( matrix1 , matrix2 , value ) : return tuple ( _interpolateValue ( matrix1 [ i ] , matrix2 [ i ] , value ) for i in range ( len ( matrix1 ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Start the receiver . [CODESPLIT] def start ( self ) : if not self . _is_running : self . _do_run = True self . _thread . start ( ) return self", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": return : True if it is a valid DHIS2 UID False if not [CODESPLIT] def is_valid_uid ( uid ) : pattern = r'^[A-Za-z][A-Za-z0-9]{10}$' if not isinstance ( uid , string_types ) : return False return bool ( re . compile ( pattern ) . match ( uid ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Underlying synchronized wrapper . [CODESPLIT] def _synced ( method , self , args , kwargs ) : with self . _lock : return method ( * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Note that the Executor must be close () d elsewhere or join () will never return . [CODESPLIT] def join ( self ) : self . inputfeeder_thread . join ( ) self . pool . join ( ) self . resulttracker_thread . join ( ) self . failuretracker_thread . join ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pause for this many seconds [CODESPLIT] def seconds ( num ) : now = pytime . time ( ) end = now + num until ( end )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Formats the given time into HH : MM : SS [CODESPLIT] def format_time ( time ) : h , r = divmod ( time / 1000 , 3600 ) m , s = divmod ( r , 60 ) return \"%02d:%02d:%02d\" % ( h , m , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Invert mapping of dictionary ( i . e . map values to list of keys ) [CODESPLIT] def invertDictMapping ( d ) : inv_map = { } for k , v in d . items ( ) : inv_map [ v ] = inv_map . get ( v , [ ] ) inv_map [ v ] . append ( k ) return inv_map", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return YYYY - MM - DD when the file was modified . [CODESPLIT] def fileModifiedTimestamp ( fname ) : modifiedTime = os . path . getmtime ( fname ) stamp = time . strftime ( '%Y-%m-%d' , time . localtime ( modifiedTime ) ) return stamp", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Activate the TypingStream on stdout [CODESPLIT] def start ( self ) : self . streams . append ( sys . stdout ) sys . stdout = self . stream", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Localize a datetime object to local time . [CODESPLIT] def localize ( dt ) : if dt . tzinfo is UTC : return ( dt + LOCAL_UTC_OFFSET ) . replace ( tzinfo = None ) # No TZ info so not going to assume anything, return as-is. return dt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility function which converts lists to tuples . [CODESPLIT] def as_tuple ( self , value ) : if isinstance ( value , list ) : value = tuple ( value ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns current utcoffset for a timezone . Uses DEFAULT_LOCAL_TZ by default . That value can be changed at runtime using the func below . [CODESPLIT] def current_offset ( local_tz = None ) : if local_tz is None : local_tz = DEFAULT_LOCAL_TZ dt = local_tz . localize ( datetime . now ( ) ) return dt . utcoffset ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return hash ( self ) . [CODESPLIT] def __hash__ ( self ) : return hash ( ( type ( self ) , self . domain , self . range , self . partition ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set cursor position [CODESPLIT] def set_cursor_position ( self , position ) : position = self . get_position ( position ) cursor = self . textCursor ( ) cursor . setPosition ( position ) self . setTextCursor ( cursor ) self . ensureCursorVisible ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper parse action to convert tokens to lower case . [CODESPLIT] def downcaseTokens ( s , l , t ) : return [ tt . lower ( ) for tt in map ( _ustr , t ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Scroll both categories Canvas and scrolling container [CODESPLIT] def _set_scroll_v ( self , * args ) : self . _canvas_categories . yview ( * args ) self . _canvas_scroll . yview ( * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gaussian model m is [ psill range nugget ] [CODESPLIT] def gaussian_variogram_model ( m , d ) : psill = float ( m [ 0 ] ) range_ = float ( m [ 1 ] ) nugget = float ( m [ 2 ] ) return psill * ( 1. - np . exp ( - d ** 2. / ( range_ * 4. / 7. ) ** 2. ) ) + nugget", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clear the contents of the TimeLine Canvas [CODESPLIT] def clear_timeline ( self ) : self . _timeline . delete ( tk . ALL ) self . _canvas_ticks . delete ( tk . ALL )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove duplicated elements in a list . Args : lista : List with elements to clean duplicates . [CODESPLIT] def remove_list_duplicates ( lista , unique = False ) : result = [ ] allready = [ ] for elem in lista : if elem not in result : result . append ( elem ) else : allready . append ( elem ) if unique : for elem in allready : result = list ( filter ( ( elem ) . __ne__ , result ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update inplace widgets position when doing vertical scroll [CODESPLIT] def yview ( self , * args ) : self . after_idle ( self . __updateWnds ) ttk . Treeview . yview ( self , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert to timestamp . [CODESPLIT] async def iso ( self , source ) : from datetime import datetime unix_timestamp = int ( source ) return datetime . fromtimestamp ( unix_timestamp ) . isoformat ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if a file is empty or not . [CODESPLIT] def file_empty ( fp ) : # for python 2 we need to use a homemade peek() if six . PY2 : contents = fp . read ( ) fp . seek ( 0 ) return not bool ( contents ) else : return not fp . peek ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A basic check of if the program is running in interactive mode [CODESPLIT] def isInteractive ( ) : if sys . stdout . isatty ( ) and os . name != 'nt' : #Hopefully everything but ms supports '\\r' try : import threading except ImportError : return False else : return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dict from entries in a scala . collection . immutable . Map [CODESPLIT] def get_python_dict ( scala_map ) : python_dict = { } keys = get_python_list ( scala_map . keys ( ) . toList ( ) ) for key in keys : python_dict [ key ] = scala_map . apply ( key ) return python_dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Render a jinja template [CODESPLIT] def render_template ( env , filename , values = None ) : if not values : values = { } tmpl = env . get_template ( filename ) return tmpl . render ( values )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Render our pages as a jinja template for fancy templating goodness . [CODESPLIT] def rstjinja ( app , docname , source ) : # Make sure we're outputting HTML if app . builder . format != 'html' : return src = source [ 0 ] rendered = app . builder . templates . render_string ( src , app . config . html_context ) source [ 0 ] = rendered", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Saves the Jupyter work_notebook to write_file [CODESPLIT] def save_notebook ( work_notebook , write_file ) : with open ( write_file , 'w' ) as out_nb : json . dump ( work_notebook , out_nb , indent = 2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "3x3 convolution with padding . Original code has had bias turned off because Batch Norm would remove the bias either way [CODESPLIT] def conv3x3 ( in_channels , out_channels , stride = 1 ) : return nn . Conv2d ( in_channels , out_channels , kernel_size = 3 , stride = stride , padding = 1 , bias = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert JSON string to an ordered defaultdict . [CODESPLIT] def _unjsonify ( x , isattributes = False ) : if isattributes : obj = json . loads ( x ) return dict_class ( obj ) return json . loads ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert CamelCase to camel_case [CODESPLIT] def camel_to_ ( s ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , s ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Serialises a protobuf object as json [CODESPLIT] def toJson ( protoObject , indent = None ) : # Using the internal method because this way we can reformat the JSON js = json_format . MessageToDict ( protoObject , False ) return json . dumps ( js , indent = indent )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns angle between vec_a and vec_b in range [ 0 PI ] . This does not distinguish if a is left of or right of b . [CODESPLIT] def angle_v2_rad ( vec_a , vec_b ) : # cos(x) = A * B / |A| * |B| return math . acos ( vec_a . dot ( vec_b ) / ( vec_a . length ( ) * vec_b . length ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a value to list of ints if possible . [CODESPLIT] def toListInt ( value ) : if TypeConverters . _can_convert_to_list ( value ) : value = TypeConverters . toList ( value ) if all ( map ( lambda v : TypeConverters . _is_integer ( v ) , value ) ) : return [ int ( v ) for v in value ] raise TypeError ( \"Could not convert %s to list of ints\" % value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Step over the next statement [CODESPLIT] def do_next ( self , args ) : self . _do_print_from_last_cmd = True self . _interp . step_over ( ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform a reverse lookup of a given IP address . [CODESPLIT] def cmd_dns_lookup_reverse ( ip_address , verbose ) : if verbose : logging . basicConfig ( level = logging . INFO , format = '%(message)s' ) print ( \"Looking up %s...\" % ip_address , file = sys . stderr ) answer = lookup_reverse ( ip_address ) if answer : print ( json . dumps ( answer , indent = 4 ) ) else : print ( \"[X] %s is not valid IPv4/IPV6 address\" % ip_address ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Stops the child process . [CODESPLIT] def stop_process ( self ) : self . _process . terminate ( ) if not self . _process . waitForFinished ( 100 ) : self . _process . kill ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update inplace widgets position when doing vertical scroll [CODESPLIT] def yview ( self , * args ) : self . after_idle ( self . __updateWnds ) ttk . Treeview . yview ( self , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Stop this server so that the calling process can exit [CODESPLIT] def stop ( self ) : # unsetup_fuse() self . fuse_process . teardown ( ) for uuid in self . processes : self . processes [ uuid ] . terminate ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the top - level element of a document sub - tree containing the YAML serialization of a Python object . [CODESPLIT] def yaml_to_param ( obj , name ) : return from_pyvalue ( u\"yaml:%s\" % name , unicode ( yaml . dump ( obj ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the names of all callable attributes of an object [CODESPLIT] def get_methods ( * objs ) : return set ( attr for obj in objs for attr in dir ( obj ) if not attr . startswith ( '_' ) and callable ( getattr ( obj , attr ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Move the turtle forward . [CODESPLIT] def forward ( self , step ) : x = self . pos_x + math . cos ( math . radians ( self . rotation ) ) * step y = self . pos_y + math . sin ( math . radians ( self . rotation ) ) * step prev_brush_state = self . brush_on self . brush_on = True self . move ( x , y ) self . brush_on = prev_brush_state", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The l2 norm of an array is is defined as : sqrt ( ||x|| ) where ||x|| is the dot product of the vector . [CODESPLIT] def l2_norm ( arr ) : arr = np . asarray ( arr ) return np . sqrt ( np . dot ( arr . ravel ( ) . squeeze ( ) , arr . ravel ( ) . squeeze ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets the default string length for lstring and ilwd : char if they are treated as strings . Default is 50 . [CODESPLIT] def default_strlen ( strlen = None ) : if strlen is not None : _default_types_status [ 'default_strlen' ] = strlen # update the typeDicts as needed lstring_as_obj ( _default_types_status [ 'lstring_as_obj' ] ) ilwd_as_int ( _default_types_status [ 'ilwd_as_int' ] ) return _default_types_status [ 'default_strlen' ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds passed value to node s globals [CODESPLIT] def set_global ( node : Node , key : str , value : Any ) : node . node_globals [ key ] = value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate new UUID [CODESPLIT] def generate_id ( ) : # TODO: Use six.string_type to Py3 compat try : return unicode ( uuid1 ( ) ) . replace ( u\"-\" , u\"\" ) except NameError : return str ( uuid1 ( ) ) . replace ( u\"-\" , u\"\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the 1 - based index of the last object on this page relative to total objects found ( hits ) . [CODESPLIT] def end_index ( self ) : return ( ( self . number - 1 ) * self . paginator . per_page + len ( self . object_list ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform underscore separated string to pascal case [CODESPLIT] def to_pascal_case ( s ) : return re . sub ( r'(?!^)_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , s . capitalize ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "left button down : report x y coords start zooming mode [CODESPLIT] def onLeftDown ( self , event = None ) : if event is None : return self . cursor_mode_action ( 'leftdown' , event = event ) self . ForwardEvent ( event = event . guiEvent )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "recursively hash unhashable objects [CODESPLIT] def omnihash ( obj ) : if isinstance ( obj , set ) : return hash ( frozenset ( omnihash ( e ) for e in obj ) ) elif isinstance ( obj , ( tuple , list ) ) : return hash ( tuple ( omnihash ( e ) for e in obj ) ) elif isinstance ( obj , dict ) : return hash ( frozenset ( ( k , omnihash ( v ) ) for k , v in obj . items ( ) ) ) else : return hash ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize the length of a vector to one [CODESPLIT] def norm_vec ( vector ) : assert len ( vector ) == 3 v = np . array ( vector ) return v / np . sqrt ( np . sum ( v ** 2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the tests . [CODESPLIT] def test ( ctx , all = False , verbose = False ) : cmd = 'tox' if all else 'py.test' if verbose : cmd += ' -v' return ctx . run ( cmd , pty = True ) . return_code", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterate through lines of file . [CODESPLIT] def txt_line_iterator ( path ) : with tf . gfile . Open ( path ) as f : for line in f : yield line . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the final coverage report . This outputs the coverage report aggregating coverage from the unit test runs ( not system test runs ) and then erases coverage data . [CODESPLIT] def cover ( session ) : session . interpreter = 'python3.6' session . install ( 'coverage' , 'pytest-cov' ) session . run ( 'coverage' , 'report' , '--show-missing' , '--fail-under=100' ) session . run ( 'coverage' , 'erase' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "regexp search with one value to return . [CODESPLIT] def find_one ( line , lookup ) : match = re . search ( lookup , line ) if match : if match . group ( 1 ) : return match . group ( 1 ) return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tears down the Django test [CODESPLIT] def teardown_test ( self , context ) : context . test . tearDownClass ( ) context . test . _post_teardown ( run = True ) del context . test", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generalised logarithm [CODESPLIT] def glog ( x , l = 2 ) : return np . log ( ( x + np . sqrt ( x ** 2 + l ** 2 ) ) / 2 ) / np . log ( l )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Accepts a NumberGenerator operand an operator and optional arguments to be provided to the operator when calling it on the operand . [CODESPLIT] def __init__ ( self , operand , operator , * * args ) : # Note that it's currently not possible to set # parameters in the superclass when creating an instance, # because **args is used by this class itself. super ( UnaryOperator , self ) . __init__ ( ) self . operand = operand self . operator = operator self . args = args", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call ioctl () with given parameters . [CODESPLIT] def _ioctl ( self , func , args ) : import fcntl return fcntl . ioctl ( self . sockfd . fileno ( ) , func , args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like dict . update but does not overwrite items [CODESPLIT] def dict_update_newkeys ( dict_ , dict2 ) : for key , val in six . iteritems ( dict2 ) : if key not in dict_ : dict_ [ key ] = val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes object obj from the index . [CODESPLIT] def _remove_from_index ( index , obj ) : try : index . value_map [ indexed_value ( index , obj ) ] . remove ( obj . id ) except KeyError : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list of keys in the database [CODESPLIT] def keys ( self , index = None ) : with self . _lmdb . begin ( ) as txn : return [ key . decode ( ) for key , _ in txn . cursor ( ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "read an image from file - PIL doesnt close nicely [CODESPLIT] def load_image ( fname ) : with open ( fname , \"rb\" ) as f : i = Image . open ( fname ) #i.load() return i", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the number of bytes that the multipart / form - data encoding of params will be . [CODESPLIT] def get_body_size ( params , boundary ) : size = sum ( p . get_size ( boundary ) for p in MultipartParam . from_params ( params ) ) return size + len ( boundary ) + 6", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Constructs a FastbootCommands instance . [CODESPLIT] def __init__ ( self , usb ) : self . _usb = usb self . _protocol = self . protocol_handler ( usb )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Receive the content of url parse it as JSON and return the object . [CODESPLIT] def get_jsonparsed_data ( url ) : response = urlopen ( url ) data = response . read ( ) . decode ( 'utf-8' ) return json . loads ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns one value if the condition evaluates to TRUE and another value if it evaluates to FALSE [CODESPLIT] def _if ( ctx , logical_test , value_if_true = 0 , value_if_false = False ) : return value_if_true if conversions . to_boolean ( logical_test , ctx ) else value_if_false", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return index of sub_string in string . [CODESPLIT] def _find ( string , sub_string , start_index ) : result = string . find ( sub_string , start_index ) if result == - 1 : raise TokenError ( \"expected '{0}'\" . format ( sub_string ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "bytes to unicode [CODESPLIT] def b2u ( string ) : if ( isinstance ( string , bytes ) or ( PY2 and isinstance ( string , str ) ) ) : return string . decode ( 'utf-8' ) return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a good UUID for using as a human readable string . [CODESPLIT] def human_uuid ( ) : return base64 . b32encode ( hashlib . sha1 ( uuid . uuid4 ( ) . bytes ) . digest ( ) ) . lower ( ) . strip ( '=' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Natural log of scipy norm function truncated at zero [CODESPLIT] def ln_norm ( x , mu , sigma = 1.0 ) : return np . log ( stats . norm ( loc = mu , scale = sigma ) . pdf ( x ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns int () of val if val is not convertable to int use default instead [CODESPLIT] def safe_int ( val , default = None ) : try : val = int ( val ) except ( ValueError , TypeError ) : val = default return val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The unnormalized log posterior components for mean - field normal family ( the quantity we want to approximate ) RAO - BLACKWELLIZED! [CODESPLIT] def normal_log_q ( self , z ) : means , scale = self . get_means_and_scales ( ) return ss . norm . logpdf ( z , loc = means , scale = scale )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Logs the basic endpoint requested [CODESPLIT] def process_request ( self , request , response ) : self . logger . info ( 'Requested: {0} {1} {2}' . format ( request . method , request . relative_uri , request . content_type ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert axis coordinate to bin index . [CODESPLIT] def val_to_bin ( edges , x ) : ibin = np . digitize ( np . array ( x , ndmin = 1 ) , edges ) - 1 return ibin", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Logarithmic loss with non - necessarily - binary labels . [CODESPLIT] def log_loss ( preds , labels ) : log_likelihood = np . sum ( labels * np . log ( preds ) ) / len ( preds ) return - log_likelihood", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the dotproduct of two vectors . [CODESPLIT] def dot_v3 ( v , w ) : return sum ( [ x * y for x , y in zip ( v , w ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalizes the given vector . The vector given may have any number of dimensions . [CODESPLIT] def v_normalize ( v ) : vmag = v_magnitude ( v ) return [ v [ i ] / vmag for i in range ( len ( v ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalizes the given vector . The vector given may have any number of dimensions . [CODESPLIT] def v_normalize ( v ) : vmag = v_magnitude ( v ) return [ v [ i ] / vmag for i in range ( len ( v ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterable - first replacement of Python s built - in map () function . [CODESPLIT] def map ( cls , iterable , func , * a , * * kw ) : return cls ( func ( x , * a , * * kw ) for x in iterable )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Toggles the video status between play and hold [CODESPLIT] def OnTogglePlay ( self , event ) : if self . player . get_state ( ) == vlc . State . Playing : self . player . pause ( ) else : self . player . play ( ) event . Skip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "set nan and inf rows from x to zero [CODESPLIT] def clean_with_zeros ( self , x ) : x [ ~ np . any ( np . isnan ( x ) | np . isinf ( x ) , axis = 1 ) ] = 0 return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates the moving average ( rolling mean ) of an array of a certain window size . [CODESPLIT] def movingaverage ( arr , window ) : m = np . ones ( int ( window ) ) / int ( window ) return scipy . ndimage . convolve1d ( arr , m , axis = 0 , mode = 'reflect' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Inputs [ a b c ] returns { a : 0 b : 1 c : 2 } . [CODESPLIT] def list_string_to_dict ( string ) : dictionary = { } for idx , c in enumerate ( string ) : dictionary . update ( { c : idx } ) return dictionary", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def get_process_handle ( self ) : # The handle doesn't need to be closed. # See http://msdn.microsoft.com/en-us/library/ms681423(VS.85).aspx hProcess = self . raw . u . CreateProcessInfo . hProcess if hProcess in ( 0 , win32 . NULL , win32 . INVALID_HANDLE_VALUE ) : hProcess = None else : hProcess = ProcessHandle ( hProcess , False , win32 . PROCESS_ALL_ACCESS ) return hProcess", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the current xy coordinates of the mouse cursor as a two - integer tuple by calling the GetCursorPos () win32 function . [CODESPLIT] def _position ( ) : cursor = POINT ( ) ctypes . windll . user32 . GetCursorPos ( ctypes . byref ( cursor ) ) return ( cursor . x , cursor . y )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write DOT comment . [CODESPLIT] def comment ( self , s , * * args ) : self . write ( u\"// \" ) self . writeln ( s = s , * * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find and kill child processes of a process . [CODESPLIT] def kill_process_children ( pid ) : if sys . platform == \"darwin\" : kill_process_children_osx ( pid ) elif sys . platform == \"linux\" : kill_process_children_unix ( pid ) else : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Closes this response . [CODESPLIT] def close ( self ) : if self . _connection : self . _connection . close ( ) self . _response . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a callable func trap the indicated exceptions for up to retries times invoking cleanup on the exception . On the final attempt allow any exceptions to propagate . [CODESPLIT] def retry_call ( func , cleanup = lambda : None , retries = 0 , trap = ( ) ) : attempts = count ( ) if retries == float ( 'inf' ) else range ( retries ) for attempt in attempts : try : return func ( ) except trap : cleanup ( ) return func ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reduce a JSON object [CODESPLIT] def reduce_json ( data ) : return reduce ( lambda x , y : int ( x ) + int ( y ) , data . values ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Chop a sequence into chunks of the given size . [CODESPLIT] def chop ( seq , size ) : chunk = lambda i : seq [ i : i + size ] return map ( chunk , xrange ( 0 , len ( seq ) , size ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "writes a string to file [CODESPLIT] def write_str2file ( pathname , astr ) : fname = pathname fhandle = open ( fname , 'wb' ) fhandle . write ( astr ) fhandle . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "searchs a value in a dicionary and returns the key of the first occurrence [CODESPLIT] def get_key_by_value ( dictionary , search_value ) : for key , value in dictionary . iteritems ( ) : if value == search_value : return ugettext ( key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return matrix as csv data . [CODESPLIT] def csv_matrix_print ( classes , table ) : result = \"\" classes . sort ( ) for i in classes : for j in classes : result += str ( table [ i ] [ j ] ) + \",\" result = result [ : - 1 ] + \"\\n\" return result [ : - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Matrix inversion op . [CODESPLIT] def MatrixInverse ( a , adj ) : return np . linalg . inv ( a if not adj else _adjoint ( a ) ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Colorize text with given color . [CODESPLIT] def _write_color_ansi ( fp , text , color ) : fp . write ( esc_ansicolor ( color ) ) fp . write ( text ) fp . write ( AnsiReset )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the indent size in spaces at the start of a line of text . [CODESPLIT] def indentsize ( line ) : expline = string . expandtabs ( line ) return len ( expline ) - len ( string . lstrip ( expline ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "decorator for showing tracebacks in IPython [CODESPLIT] def _show_traceback ( method ) : def m ( self , * args , * * kwargs ) : try : return ( method ( self , * args , * * kwargs ) ) except Exception as e : ip = get_ipython ( ) if ip is None : self . log . warning ( \"Exception in widget method %s: %s\" , method , e , exc_info = True ) else : ip . showtraceback ( ) return m", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write file with current process ID . [CODESPLIT] def _write_pidfile ( pidfile ) : pid = str ( os . getpid ( ) ) handle = open ( pidfile , 'w' ) try : handle . write ( \"%s\\n\" % pid ) finally : handle . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Communicate with the child process without closing stdin . [CODESPLIT] def correspond ( text ) : subproc . stdin . write ( text ) subproc . stdin . flush ( ) return drain ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Segmented min op . [CODESPLIT] def SegmentMin ( a , ids ) : func = lambda idxs : np . amin ( a [ idxs ] , axis = 0 ) return seg_map ( func , a , ids ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Saves a representation of the case in the Graphviz DOT language . [CODESPLIT] def save_dot ( self , fd ) : from pylon . io import DotWriter DotWriter ( self ) . write ( fd )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Establish tunnel connection early because otherwise httplib would improperly set Host : header to proxy s IP : port . [CODESPLIT] def _prepare_proxy ( self , conn ) : conn . set_tunnel ( self . _proxy_host , self . port , self . proxy_headers ) conn . connect ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Mocked decorator needed in the case we need to mock a decorator [CODESPLIT] def mock_decorator ( * args , * * kwargs ) : def _called_decorator ( dec_func ) : @ wraps ( dec_func ) def _decorator ( * args , * * kwargs ) : return dec_func ( ) return _decorator return _called_decorator", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the text for the given root node ( xml . dom . minidom ) . [CODESPLIT] def __get_xml_text ( root ) : txt = \"\" for e in root . childNodes : if ( e . nodeType == e . TEXT_NODE ) : txt += e . data return txt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Categorical accuracy [CODESPLIT] def cat_acc ( y_true , y_pred ) : return np . mean ( y_true . argmax ( axis = 1 ) == y_pred . argmax ( axis = 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate n values between start and end . [CODESPLIT] def _xxrange ( self , start , end , step_count ) : _step = ( end - start ) / float ( step_count ) return ( start + ( i * _step ) for i in xrange ( int ( step_count ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like a bulk : meth : forceput . [CODESPLIT] def forceupdate ( self , * args , * * kw ) : self . _update ( False , self . _ON_DUP_OVERWRITE , * args , * * kw )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a new datetime . datetime object with values that represent a start of a month . : param val : Date to ... : type val : datetime . datetime | datetime . date : rtype : datetime . datetime [CODESPLIT] def start_of_month ( val ) : if type ( val ) == date : val = datetime . fromordinal ( val . toordinal ( ) ) return start_of_day ( val ) . replace ( day = 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield successive n - sized chunks from an iterable . [CODESPLIT] def chunks ( iterable , chunk ) : for i in range ( 0 , len ( iterable ) , chunk ) : yield iterable [ i : i + chunk ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wanted functionality from Counters ( new in Python 2 . 7 ) . [CODESPLIT] def most_common ( items ) : counts = { } for i in items : counts . setdefault ( i , 0 ) counts [ i ] += 1 return max ( six . iteritems ( counts ) , key = operator . itemgetter ( 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run asyncio ( should be called in a thread ) and close the loop and the zmq context when the thread ends : param loop : : param zmq_context : : return : [CODESPLIT] def _run_asyncio ( loop , zmq_context ) : try : asyncio . set_event_loop ( loop ) loop . run_forever ( ) except : pass finally : loop . close ( ) zmq_context . destroy ( 1000 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wanted functionality from Counters ( new in Python 2 . 7 ) . [CODESPLIT] def most_common ( items ) : counts = { } for i in items : counts . setdefault ( i , 0 ) counts [ i ] += 1 return max ( six . iteritems ( counts ) , key = operator . itemgetter ( 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if an item is iterable ( list tuple generator ) but not string [CODESPLIT] def _is_iterable ( item ) : return isinstance ( item , collections . Iterable ) and not isinstance ( item , six . string_types )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the current xy coordinates of the mouse cursor as a two - integer tuple by calling the GetCursorPos () win32 function . [CODESPLIT] def _position ( ) : cursor = POINT ( ) ctypes . windll . user32 . GetCursorPos ( ctypes . byref ( cursor ) ) return ( cursor . x , cursor . y )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "helper function for parsing FRED date string into datetime [CODESPLIT] def _parse ( self , date_str , format = '%Y-%m-%d' ) : rv = pd . to_datetime ( date_str , format = format ) if hasattr ( rv , 'to_pydatetime' ) : rv = rv . to_pydatetime ( ) return rv", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap the text on the given line length . [CODESPLIT] def normalize_text ( text , line_len = 80 , indent = \"\" ) : return \"\\n\" . join ( textwrap . wrap ( text , width = line_len , initial_indent = indent , subsequent_indent = indent ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Current thread ident . If current thread is main thread then it returns None . [CODESPLIT] def threadid ( self ) : current = self . thread . ident main = get_main_thread ( ) if main is None : return current else : return current if current != main . ident else None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format the given vars in the form : flag = value [CODESPLIT] def format_vars ( args ) : variables = [ ] for key , value in args . items ( ) : if value : variables += [ '{0}={1}' . format ( key , value ) ] return variables", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove arduino / examples / all directory . [CODESPLIT] def remove_examples_all ( ) : d = examples_all_dir ( ) if d . exists ( ) : log . debug ( 'remove %s' , d ) d . rmtree ( ) else : log . debug ( 'nothing to remove: %s' , d )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transforation matrix from rotation matrix and translation vector . [CODESPLIT] def transform_from_rot_trans ( R , t ) : R = R . reshape ( 3 , 3 ) t = t . reshape ( 3 , 1 ) return np . vstack ( ( np . hstack ( [ R , t ] ) , [ 0 , 0 , 0 , 1 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "test if object is a list or tuple [CODESPLIT] def is_iter_non_string ( obj ) : if isinstance ( obj , list ) or isinstance ( obj , tuple ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Scipy norm function [CODESPLIT] def norm ( x , mu , sigma = 1.0 ) : return stats . norm ( loc = mu , scale = sigma ) . pdf ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a vtk matrix to a numpy . ndarray [CODESPLIT] def trans_from_matrix ( matrix ) : t = np . zeros ( ( 4 , 4 ) ) for i in range ( 4 ) : for j in range ( 4 ) : t [ i , j ] = matrix . GetElement ( i , j ) return t", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param sequence : Any sequence whose elements can be evaluated as booleans . : returns : true if all elements of the sequence satisfy True and x . [CODESPLIT] def All ( sequence ) : return bool ( reduce ( lambda x , y : x and y , sequence , True ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return cuda device information and nvcc / cuda setup [CODESPLIT] def inspect_cuda ( ) : nvcc_settings = nvcc_compiler_settings ( ) sysconfig . get_config_vars ( ) nvcc_compiler = ccompiler . new_compiler ( ) sysconfig . customize_compiler ( nvcc_compiler ) customize_compiler_for_nvcc ( nvcc_compiler , nvcc_settings ) output = inspect_cuda_version_and_devices ( nvcc_compiler , nvcc_settings ) return json . loads ( output ) , nvcc_settings", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterate over dict items . [CODESPLIT] def iteritems ( data , * * kwargs ) : return iter ( data . items ( * * kwargs ) ) if IS_PY3 else data . iteritems ( * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Serializes a numpy array to a compressed base64 string [CODESPLIT] def _array2cstr ( arr ) : out = StringIO ( ) np . save ( out , arr ) return b64encode ( out . getvalue ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the path to the javascript bundle [CODESPLIT] def default_static_path ( ) : fdir = os . path . dirname ( __file__ ) return os . path . abspath ( os . path . join ( fdir , '../assets/' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def list_add_capitalize ( l ) : nl = [ ] for i in l : nl . append ( i ) if hasattr ( i , \"capitalize\" ) : nl . append ( i . capitalize ( ) ) return list ( set ( nl ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generates a random string of given size from the given chars . [CODESPLIT] def random_id ( size = 8 , chars = string . ascii_letters + string . digits ) : return '' . join ( random . choice ( chars ) for _ in range ( size ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Natural log of scipy norm function truncated at zero [CODESPLIT] def ln_norm ( x , mu , sigma = 1.0 ) : return np . log ( stats . norm ( loc = mu , scale = sigma ) . pdf ( x ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Current thread ident . If current thread is main thread then it returns None . [CODESPLIT] def threadid ( self ) : current = self . thread . ident main = get_main_thread ( ) if main is None : return current else : return current if current != main . ident else None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Natural log of scipy norm function truncated at zero [CODESPLIT] def ln_norm ( x , mu , sigma = 1.0 ) : return np . log ( stats . norm ( loc = mu , scale = sigma ) . pdf ( x ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the default stream encoding if not found . [CODESPLIT] def get_best_encoding ( stream ) : rv = getattr ( stream , 'encoding' , None ) or sys . getdefaultencoding ( ) if is_ascii_encoding ( rv ) : return 'utf-8' return rv", "target": 1, "target_options": ["no_match", "match"]}
{"input": "equivalent to scipy . preprocessing . normalize on sparse matrices but lets avoid another depedency just for a small utility function [CODESPLIT] def normalize ( X ) : X = coo_matrix ( X ) X . data = X . data / sqrt ( bincount ( X . row , X . data ** 2 ) ) [ X . row ] return X", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator to make sure that user is root . [CODESPLIT] def require_root ( fn ) : @ wraps ( fn ) def xex ( * args , * * kwargs ) : assert os . geteuid ( ) == 0 , \"You have to be root to run function '%s'.\" % fn . __name__ return fn ( * args , * * kwargs ) return xex", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print out memory usage at this point in time [CODESPLIT] def m ( name = '' , * * kwargs ) : with Reflect . context ( * * kwargs ) as r : kwargs [ \"name\" ] = name instance = M_CLASS ( r , stream , * * kwargs ) instance ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a normalized version of a DataFrame or Series Parameters : df - DataFrame or Series The data to normalize style - function or string default mean The style to use when computing the norms . Takes mean or minmax to do mean or min - max normalization respectively . User - defined functions that take a pandas Series as input and return a normalized pandas Series are also accepted [CODESPLIT] def normalize ( df , style = 'mean' ) : if style == 'mean' : df_mean , df_std = df . mean ( ) , df . std ( ) return ( df - df_mean ) / df_std elif style == 'minmax' : col_min , col_max = df . min ( ) , df . max ( ) return ( df - col_min ) / ( col_max - col_min ) else : return style ( df )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an instance of QApplication . Creates one if neccessary . [CODESPLIT] def get_qapp ( ) : global app app = QtGui . QApplication . instance ( ) if app is None : app = QtGui . QApplication ( [ ] , QtGui . QApplication . GuiClient ) return app", "target": 1, "target_options": ["no_match", "match"]}
{"input": "equivalent to scipy . preprocessing . normalize on sparse matrices but lets avoid another depedency just for a small utility function [CODESPLIT] def normalize ( X ) : X = coo_matrix ( X ) X . data = X . data / sqrt ( bincount ( X . row , X . data ** 2 ) ) [ X . row ] return X", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return a normalized version of abmn [CODESPLIT] def _normalize_abmn ( abmn ) : abmn_2d = np . atleast_2d ( abmn ) abmn_normalized = np . hstack ( ( np . sort ( abmn_2d [ : , 0 : 2 ] , axis = 1 ) , np . sort ( abmn_2d [ : , 2 : 4 ] , axis = 1 ) , ) ) return abmn_normalized", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Executes self . function to convert LazyString instance to a real str . [CODESPLIT] def __str__ ( self ) : if not hasattr ( self , '_str' ) : self . _str = self . function ( * self . args , * * self . kwargs ) return self . _str", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the total size of all elements in objects . [CODESPLIT] def get_size ( objects ) : res = 0 for o in objects : try : res += _getsizeof ( o ) except AttributeError : print ( \"IGNORING: type=%s; o=%s\" % ( str ( type ( o ) ) , str ( o ) ) ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Accept unicode ( py2 ) or bytes ( py3 ) [CODESPLIT] def to_string ( s , encoding = 'utf-8' ) : if six . PY2 : return s . encode ( encoding ) if isinstance ( s , bytes ) : return s . decode ( encoding ) return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Formats a list of elements using the given line style [CODESPLIT] def format_line ( data , linestyle ) : return linestyle . begin + linestyle . sep . join ( data ) + linestyle . end", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a tweepy auth object [CODESPLIT] def get_tweepy_auth ( twitter_api_key , twitter_api_secret , twitter_access_token , twitter_access_token_secret ) : auth = tweepy . OAuthHandler ( twitter_api_key , twitter_api_secret ) auth . set_access_token ( twitter_access_token , twitter_access_token_secret ) return auth", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts query strings into native Python objects [CODESPLIT] def urlencoded ( body , charset = 'ascii' , * * kwargs ) : return parse_query_string ( text ( body , charset = charset ) , False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts HTML5 from Aloha to a more structured HTML5 [CODESPLIT] def aloha_to_html ( html_source ) : xml = aloha_to_etree ( html_source ) return etree . tostring ( xml , pretty_print = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handle interactive exit . [CODESPLIT] def exit ( self ) : if self . confirm_exit : if self . ask_yes_no ( 'Do you really want to exit ([y]/n)?' , 'y' ) : self . ask_exit ( ) else : self . ask_exit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes input from user . Works for Python 2 and 3 . [CODESPLIT] def _stdin_ ( p ) : _v = sys . version [ 0 ] return input ( p ) if _v is '3' else raw_input ( p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cleanup the session if it was created here [CODESPLIT] def __del__ ( self ) : if self . _cleanup_session : self . _session . loop . run_until_complete ( self . _session . close ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses just date from date - time [CODESPLIT] def get_just_date ( self ) : return datetime . datetime ( self . date_time . year , self . date_time . month , self . date_time . day )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format a string for screen printing . [CODESPLIT] def format_screen ( strng ) : # Paragraph continue par_re = re . compile ( r'\\\\$' , re . MULTILINE ) strng = par_re . sub ( '' , strng ) return strng", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return opened file with a specific encoding . [CODESPLIT] def open_with_encoding ( filename , encoding , mode = 'r' ) : return io . open ( filename , mode = mode , encoding = encoding , newline = '' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts snake_cased_names to CamelCaseNames . [CODESPLIT] def to_camel_case ( snake_case_name ) : bits = snake_case_name . split ( '_' ) return '' . join ( [ bit . capitalize ( ) for bit in bits ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the serial port e . g . : / dev / tty . usbserial - A4001ib8 [CODESPLIT] def do_serial ( self , p ) : try : self . serial . port = p self . serial . open ( ) print 'Opening serial port: %s' % p except Exception , e : print 'Unable to open serial port: %s' % p", "target": 1, "target_options": ["no_match", "match"]}
{"input": "last row or column of square A [CODESPLIT] def other_ind ( self ) : return np . full ( self . n_min , self . size - 1 , dtype = np . int )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Centre and normalize a given array . [CODESPLIT] def min_max_normalize ( img ) : min_img = img . min ( ) max_img = img . max ( ) return ( img - min_img ) / ( max_img - min_img )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a new PRDD of elements from that key . [CODESPLIT] def __getitem__ ( self , key ) : return self . from_rdd ( self . _rdd . map ( lambda x : x [ key ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Centre and normalize a given array . [CODESPLIT] def min_max_normalize ( img ) : min_img = img . min ( ) max_img = img . max ( ) return ( img - min_img ) / ( max_img - min_img )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Loads the content of a file into a base64 string . [CODESPLIT] def load_file_to_base64_str ( f_path ) : path = abs_path ( f_path ) with io . open ( path , 'rb' ) as f : f_bytes = f . read ( ) base64_str = base64 . b64encode ( f_bytes ) . decode ( \"utf-8\" ) return base64_str", "target": 1, "target_options": ["no_match", "match"]}
{"input": "download the image convert it to a NumPy array and then read it into OpenCV format [CODESPLIT] def url_to_image ( url , flag = cv2 . IMREAD_COLOR ) : resp = urlopen ( url ) image = np . asarray ( bytearray ( resp . read ( ) ) , dtype = \"uint8\" ) image = cv2 . imdecode ( image , flag ) return image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculated like in the official client . Returns ( top_left bottom_right ) . [CODESPLIT] def visible_area ( self ) : # looks like zeach has a nice big screen half_viewport = Vec ( 1920 , 1080 ) / 2 / self . scale top_left = self . world . center - half_viewport bottom_right = self . world . center + half_viewport return top_left , bottom_right", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read tag data from file and return as numpy array . [CODESPLIT] def read_numpy ( fd , byte_order , dtype , count ) : return numpy . fromfile ( fd , byte_order + dtype [ - 1 ] , count )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "read a simple text file from a private location to get username and password [CODESPLIT] def read_credentials ( fname ) : with open ( fname , 'r' ) as f : username = f . readline ( ) . strip ( '\\n' ) password = f . readline ( ) . strip ( '\\n' ) return username , password", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fit a Gaussian to the data [CODESPLIT] def fit_gaussian ( x , y , yerr , p0 ) : try : popt , pcov = curve_fit ( gaussian , x , y , sigma = yerr , p0 = p0 , absolute_sigma = True ) except RuntimeError : return [ 0 ] , [ 0 ] return popt , pcov", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the last object in file . [CODESPLIT] def last ( self ) : # End of file self . __file . seek ( 0 , 2 ) # Get the last struct data = self . get ( self . length - 1 ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Crops and / or pads an image to a target width and height . [CODESPLIT] def resize_image_with_crop_or_pad ( img , target_height , target_width ) : h , w = target_height , target_width max_h , max_w , c = img . shape # crop img = crop_center ( img , min ( max_h , h ) , min ( max_w , w ) ) # pad padded_img = np . zeros ( shape = ( h , w , c ) , dtype = img . dtype ) padded_img [ : img . shape [ 0 ] , : img . shape [ 1 ] , : img . shape [ 2 ] ] = img return padded_img", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read and reconstruct the data from a JSON file . [CODESPLIT] def load_from_file ( cls , file_path : str ) : with open ( file_path , \"r\" ) as f : data = json . load ( f ) item = cls . decode ( data = data ) return item", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Args : img ( PIL Image ) : Image to be padded . [CODESPLIT] def __call__ ( self , img ) : return F . pad ( img , self . padding , self . fill , self . padding_mode )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the next non - blank line in an ASCII file . [CODESPLIT] def rAsciiLine ( ifile ) : _line = ifile . readline ( ) . strip ( ) while len ( _line ) == 0 : _line = ifile . readline ( ) . strip ( ) return _line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Filters given query with the below regex and returns lists of quoted and unquoted strings [CODESPLIT] def filter_query ( s ) : matches = re . findall ( r'(?:\"([^\"]*)\")|([^\"]*)' , s ) result_quoted = [ t [ 0 ] . strip ( ) for t in matches if t [ 0 ] ] result_unquoted = [ t [ 1 ] . strip ( ) for t in matches if t [ 1 ] ] return result_quoted , result_unquoted", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a python file and returns a awslambda . Code object : param python_file : : return : [CODESPLIT] def lambda_from_file ( python_file ) : lambda_function = [ ] with open ( python_file , 'r' ) as f : lambda_function . extend ( f . read ( ) . splitlines ( ) ) return awslambda . Code ( ZipFile = ( Join ( '\\n' , lambda_function ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format list . [CODESPLIT] def list_formatter ( handler , item , value ) : return u', ' . join ( str ( v ) for v in value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if end - of - file is reached for file fd . [CODESPLIT] def eof ( fd ) : b = fd . read ( 1 ) end = len ( b ) == 0 if not end : curpos = fd . tell ( ) fd . seek ( curpos - 1 ) return end", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A helper to create a proxy method in a class . [CODESPLIT] def Proxy ( f ) : def Wrapped ( self , * args ) : return getattr ( self , f ) ( * args ) return Wrapped", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a n - bits long integer value . [CODESPLIT] def read_large_int ( self , bits , signed = True ) : return int . from_bytes ( self . read ( bits // 8 ) , byteorder = 'little' , signed = signed )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return default argument value as given by argparse s add_argument () . [CODESPLIT] def arg_default ( * args , * * kwargs ) : parser = argparse . ArgumentParser ( ) parser . add_argument ( * args , * * kwargs ) args = vars ( parser . parse_args ( [ ] ) ) _ , default = args . popitem ( ) return default", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a WAV file and returns the data and sample rate [CODESPLIT] def readwav ( filename ) : from scipy . io . wavfile import read as readwav samplerate , signal = readwav ( filename ) return signal , samplerate", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pull a form value from the request . [CODESPLIT] def parse_form ( self , req , name , field ) : return get_value ( req . body_arguments , name , field )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param filename : File to open and get the first little chunk of . : param length : Number of bytes to read default 1024 . : returns : Starting chunk of bytes . [CODESPLIT] def get_starting_chunk ( filename , length = 1024 ) : # Ensure we open the file in binary mode with open ( filename , 'rb' ) as f : chunk = f . read ( length ) return chunk", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a password is valid [CODESPLIT] def is_password_valid ( password ) : pattern = re . compile ( r\"^.{4,75}$\" ) return bool ( pattern . match ( password ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generator that yields lines from standard input . [CODESPLIT] def standard_input ( ) : with click . get_text_stream ( \"stdin\" ) as stdin : while stdin . readable ( ) : line = stdin . readline ( ) if line : yield line . strip ( ) . encode ( \"utf-8\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a password is valid [CODESPLIT] def is_password_valid ( password ) : pattern = re . compile ( r\"^.{4,75}$\" ) return bool ( pattern . match ( password ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve contents of each page of PDF [CODESPLIT] def resources ( self ) : return [ self . pdf . getPage ( i ) for i in range ( self . pdf . getNumPages ( ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Forward mouse cursor position events to the example [CODESPLIT] def mouse_move_event ( self , event ) : self . example . mouse_position_event ( event . x ( ) , event . y ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function flatten given nested list . Argument : nested list Returns : flat list [CODESPLIT] def flat_list ( lst ) : if isinstance ( lst , list ) : for item in lst : for i in flat_list ( item ) : yield i else : yield lst", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the log of the magnitude spectrum of frames [CODESPLIT] def log_magnitude_spectrum ( frames ) : return N . log ( N . abs ( N . fft . rfft ( frames ) ) . clip ( 1e-5 , N . inf ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a connection back to the pool [CODESPLIT] def _ReturnConnection ( self ) : if self . conn is not None : if self . connInfo . commitOnEnd is True or self . commitOnEnd is True : self . conn . Commit ( ) Pool ( ) . returnConnection ( self . conn ) self . conn = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "pops multiple keys off a dict like object [CODESPLIT] def multi_pop ( d , * args ) : retval = { } for key in args : if key in d : retval [ key ] = d . pop ( key ) return retval", "target": 1, "target_options": ["no_match", "match"]}
{"input": "stupid windows . converts the backslash to forwardslash for consistency [CODESPLIT] def __unixify ( self , s ) : return os . path . normpath ( s ) . replace ( os . sep , \"/\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "image resize function used by quite a few image problems . [CODESPLIT] def resize_by_area ( img , size ) : return tf . to_int64 ( tf . image . resize_images ( img , [ size , size ] , tf . image . ResizeMethod . AREA ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Dumps the stream from an OrderedDict . Taken from [CODESPLIT] def ordered_yaml_dump ( data , stream = None , Dumper = None , * * kwds ) : Dumper = Dumper or yaml . Dumper class OrderedDumper ( Dumper ) : pass def _dict_representer ( dumper , data ) : return dumper . represent_mapping ( yaml . resolver . BaseResolver . DEFAULT_MAPPING_TAG , data . items ( ) ) OrderedDumper . add_representer ( OrderedDict , _dict_representer ) return yaml . dump ( data , stream , OrderedDumper , * * kwds )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove comments and empty lines [CODESPLIT] def lines ( input ) : for raw_line in input : line = raw_line . strip ( ) if line and not line . startswith ( '#' ) : yield strip_comments ( line )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "shows JSON indented representation of d [CODESPLIT] def pretty_dict_str ( d , indent = 2 ) : b = StringIO ( ) write_pretty_dict_str ( b , d , indent = indent ) return b . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Serialize representation of the table for local caching . [CODESPLIT] def to_dict ( self ) : return { 'schema' : self . schema , 'name' : self . name , 'columns' : [ col . to_dict ( ) for col in self . _columns ] , 'foreign_keys' : self . foreign_keys . to_dict ( ) , 'ref_keys' : self . ref_keys . to_dict ( ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sys . out replacer by default with stderr . [CODESPLIT] def replace_print ( fileobj = sys . stderr ) : printer = _Printer ( fileobj ) previous_stdout = sys . stdout sys . stdout = printer try : yield printer finally : sys . stdout = previous_stdout", "target": 1, "target_options": ["no_match", "match"]}
{"input": "shows structured information of a object list tuple etc [CODESPLIT] def var_dump ( * obs ) : i = 0 for x in obs : str = var_dump_output ( x , 0 , '  ' , '\\n' , True ) print ( str . strip ( ) ) #dump(x, 0, i, '', object) i += 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert camelcase names to underscore [CODESPLIT] def camelcase_underscore ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the first value of a series . [CODESPLIT] def first ( series , order_by = None ) : if order_by is not None : series = order_series_by ( series , order_by ) first_s = series . iloc [ 0 ] return first_s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove all unwanted characters from text . [CODESPLIT] def clean ( self , text ) : return '' . join ( [ c for c in text if c in self . alphabet ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a lowercase string with punctuation and bad chars removed : param s : string to clean [CODESPLIT] def _clean_str ( self , s ) : return s . translate ( str . maketrans ( '' , '' , punctuation ) ) . replace ( '\\u200b' , \" \" ) . strip ( ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print in color . [CODESPLIT] def printc ( cls , txt , color = colors . red ) : print ( cls . color_txt ( txt , color ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call tf . Print . [CODESPLIT] def Print ( x , data , message , * * kwargs ) : # pylint: disable=invalid-name return PrintOperation ( x , data , message , * * kwargs ) . outputs [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove duplicates from a sequence preserving order [CODESPLIT] def remove_dups ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty print a CSV file . [CODESPLIT] def csvpretty ( csvfile : csvfile = sys . stdin ) : shellish . tabulate ( csv . reader ( csvfile ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes all . py files . [CODESPLIT] def clean_py_files ( path ) : for dirname , subdirlist , filelist in os . walk ( path ) : for f in filelist : if f . endswith ( 'py' ) : os . remove ( os . path . join ( dirname , f ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deserialize b ( instance of bytes ) to a Python object . [CODESPLIT] def loadb ( b ) : assert isinstance ( b , ( bytes , bytearray ) ) return std_json . loads ( b . decode ( 'utf-8' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove any consecutive whitespace characters from the statement text . [CODESPLIT] def clean_whitespace ( statement ) : import re # Replace linebreaks and tabs with spaces statement . text = statement . text . replace ( '\\n' , ' ' ) . replace ( '\\r' , ' ' ) . replace ( '\\t' , ' ' ) # Remove any leeding or trailing whitespace statement . text = statement . text . strip ( ) # Remove consecutive spaces statement . text = re . sub ( ' +' , ' ' , statement . text ) return statement", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a Message value to a Model instance ( entity ) . [CODESPLIT] def _to_base_type ( self , msg ) : ent = _message_to_entity ( msg , self . _modelclass ) ent . blob_ = self . _protocol_impl . encode_message ( msg ) return ent", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove and return the item at index . [CODESPLIT] def pop ( self , index = - 1 ) : value = self . _list . pop ( index ) del self . _dict [ value ] return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Serialises a protobuf object as json [CODESPLIT] def toJson ( protoObject , indent = None ) : # Using the internal method because this way we can reformat the JSON js = json_format . MessageToDict ( protoObject , False ) return json . dumps ( js , indent = indent )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if created today . [CODESPLIT] def created_today ( self ) : if self . datetime . date ( ) == datetime . today ( ) . date ( ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a lowercase string with punctuation and bad chars removed : param s : string to clean [CODESPLIT] def _clean_str ( self , s ) : return s . translate ( str . maketrans ( '' , '' , punctuation ) ) . replace ( '\\u200b' , \" \" ) . strip ( ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Unified rounding in all python versions . [CODESPLIT] def py3round ( number ) : if abs ( round ( number ) - number ) == 0.5 : return int ( 2.0 * round ( number / 2.0 ) ) return int ( round ( number ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes trailing whitespace on each line . [CODESPLIT] def clean ( s ) : lines = [ l . rstrip ( ) for l in s . split ( '\\n' ) ] return '\\n' . join ( lines )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like dict but does not hold any null values . [CODESPLIT] def nonull_dict ( self ) : return { k : v for k , v in six . iteritems ( self . dict ) if v and k != '_codes' }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes tags from objects [CODESPLIT] def _removeTags ( tags , objects ) : for t in tags : for o in objects : o . tags . remove ( t ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "call a func with args and kwargs print name of func and how long it took . [CODESPLIT] def time_func ( func , name , * args , * * kwargs ) : tic = time . time ( ) out = func ( * args , * * kwargs ) toc = time . time ( ) print ( '%s took %0.2f seconds' % ( name , toc - tic ) ) return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def get_unique_indices ( df , axis = 1 ) : return dict ( zip ( df . columns . names , dif . columns . levels ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Instantiate the given extension class and register as a public attribute of the given base . [CODESPLIT] def register_extension_class ( ext , base , * args , * * kwargs ) : ext_instance = ext . plugin ( base , * args , * * kwargs ) setattr ( base , ext . name . lstrip ( '_' ) , ext_instance )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert to lowercase and strip spaces [CODESPLIT] def lowstrip ( term ) : term = re . sub ( '\\s+' , ' ' , term ) term = term . lower ( ) return term", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates that value is an instance of basestring for Python 2 or str for Python 3 . [CODESPLIT] def validate_string ( option , value ) : if isinstance ( value , string_type ) : return value raise TypeError ( \"Wrong type for %s, value must be \" \"an instance of %s\" % ( option , string_type . __name__ ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clear only any cached global data . [CODESPLIT] def clear_global ( self ) : vname = self . varname logger . debug ( f'global clearning {vname}' ) if vname in globals ( ) : logger . debug ( 'removing global instance var: {}' . format ( vname ) ) del globals ( ) [ vname ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes input from user . Works for Python 2 and 3 . [CODESPLIT] def _stdin_ ( p ) : _v = sys . version [ 0 ] return input ( p ) if _v is '3' else raw_input ( p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def save_image ( pdf_path , img_path , page_num ) : pdf_img = Image ( filename = \"{}[{}]\" . format ( pdf_path , page_num ) ) with pdf_img . convert ( \"png\" ) as converted : # Set white background. converted . background_color = Color ( \"white\" ) converted . alpha_channel = \"remove\" converted . save ( filename = img_path )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Allow \\ n . join ( ... ) statements to work in Py2 and Py3 . : param sep : : param joinable : : return : [CODESPLIT] def _py2_and_3_joiner ( sep , joinable ) : if ISPY3 : sep = bytes ( sep , DEFAULT_ENCODING ) joined = sep . join ( joinable ) return joined . decode ( DEFAULT_ENCODING ) if ISPY3 else joined", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a string with punctuation removed . [CODESPLIT] def remove_punctuation ( text , exceptions = [ ] ) : all_but = [ r'\\w' , r'\\s' ] all_but . extend ( exceptions ) pattern = '[^{}]' . format ( '' . join ( all_but ) ) return re . sub ( pattern , '' , text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a Listbox with a vertical scrollbar . [CODESPLIT] def __init__ ( self , master = None , compound = tk . RIGHT , autohidescrollbar = True , * * kwargs ) : ttk . Frame . __init__ ( self , master ) self . columnconfigure ( 1 , weight = 1 ) self . rowconfigure ( 0 , weight = 1 ) self . listbox = tk . Listbox ( self , * * kwargs ) if autohidescrollbar : self . scrollbar = AutoHideScrollbar ( self , orient = tk . VERTICAL , command = self . listbox . yview ) else : self . scrollbar = ttk . Scrollbar ( self , orient = tk . VERTICAL , command = self . listbox . yview ) self . config_listbox ( yscrollcommand = self . scrollbar . set ) if compound is not tk . LEFT and compound is not tk . RIGHT : raise ValueError ( \"Invalid compound value passed: {0}\" . format ( compound ) ) self . __compound = compound self . _grid_widgets ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Process a matplotlib image object and call renderer . draw_image [CODESPLIT] def draw_image ( self , ax , image ) : self . renderer . draw_image ( imdata = utils . image_to_base64 ( image ) , extent = image . get_extent ( ) , coordinates = \"data\" , style = { \"alpha\" : image . get_alpha ( ) , \"zorder\" : image . get_zorder ( ) } , mplobj = image )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clean a pandas dataframe by : 1 . Filling empty values with Nan 2 . Dropping columns with all empty values [CODESPLIT] def clean_df ( df , fill_nan = True , drop_empty_columns = True ) : if fill_nan : df = df . fillna ( value = np . nan ) if drop_empty_columns : df = df . dropna ( axis = 1 , how = 'all' ) return df . sort_index ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "NON - BLOCKING POP ALL IN QUEUE IF ANY [CODESPLIT] def pop_all ( self ) : with self . lock : output = list ( self . queue ) self . queue . clear ( ) return output", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Merge all the strings . Put space between them . [CODESPLIT] def join ( mapping , bind , values ) : return [ ' ' . join ( [ six . text_type ( v ) for v in values if v is not None ] ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Process NumPy - like function docstrings . [CODESPLIT] def _replace_docstring_header ( paragraph ) : # Replace Markdown headers in docstrings with light headers in bold. paragraph = re . sub ( _docstring_header_pattern , r'*\\1*' , paragraph , ) paragraph = re . sub ( _docstring_parameters_pattern , r'\\n* `\\1` (\\2)\\n' , paragraph , ) return paragraph", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a lowercased string with non alphabetic chars removed . [CODESPLIT] def _to_lower_alpha_only ( s ) : s = re . sub ( r'\\n' , ' ' , s . lower ( ) ) return re . sub ( r'[^a-z\\s]' , '' , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raise ( or re - raises ) an exception . [CODESPLIT] def raise_ ( exception = ABSENT , * args , * * kwargs ) : if exception is ABSENT : raise else : if inspect . isclass ( exception ) : raise exception ( * args , * * kwargs ) else : if args or kwargs : raise TypeError ( \"can't pass arguments along with \" \"exception object to raise_()\" ) raise exception", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts text that may be camelcased into an underscored format [CODESPLIT] def underscore ( text ) : return UNDERSCORE [ 1 ] . sub ( r'\\1_\\2' , UNDERSCORE [ 0 ] . sub ( r'\\1_\\2' , text ) ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Construct a Bytecode from the given traceback [CODESPLIT] def from_traceback ( cls , tb ) : while tb . tb_next : tb = tb . tb_next return cls ( tb . tb_frame . f_code , current_offset = tb . tb_lasti )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert camelcase to lowercase and underscore . [CODESPLIT] def camel_to_underscore ( string ) : string = FIRST_CAP_RE . sub ( r'\\1_\\2' , string ) return ALL_CAP_RE . sub ( r'\\1_\\2' , string ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Callable function for the multiprocessing pool . [CODESPLIT] def compute ( args ) : x , y , params = args return x , y , mandelbrot ( x , y , params )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator which adds correct MIME type for python source to the decorated bottle API function . [CODESPLIT] def python_mime ( fn ) : @ wraps ( fn ) def python_mime_decorator ( * args , * * kwargs ) : response . content_type = \"text/x-python\" return fn ( * args , * * kwargs ) return python_mime_decorator", "target": 1, "target_options": ["no_match", "match"]}
{"input": "position in 3d space [CODESPLIT] def list ( self ) : return [ self . _pos3d . x , self . _pos3d . y , self . _pos3d . z ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns the shape after scaling ( should be the same as ndimage . zoom [CODESPLIT] def _scale_shape ( dshape , scale = ( 1 , 1 , 1 ) ) : nshape = np . round ( np . array ( dshape ) * np . array ( scale ) ) return tuple ( nshape . astype ( np . int ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for pulling a keyed value off various types of objects [CODESPLIT] def get_value ( key , obj , default = missing ) : if isinstance ( key , int ) : return _get_value_for_key ( key , obj , default ) return _get_value_for_keys ( key . split ( '.' ) , obj , default )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the smallest index of the row ( s ) with this column equal to value . [CODESPLIT] def index ( self , value ) : for i in xrange ( len ( self . parentNode ) ) : if getattr ( self . parentNode [ i ] , self . Name ) == value : return i raise ValueError ( value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Weeks start are fixes at Monday for now . [CODESPLIT] def weekly ( date = datetime . date . today ( ) ) : return date - datetime . timedelta ( days = date . weekday ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets the PyPI information for a given package . [CODESPLIT] def get_package_info ( package ) : url = 'https://pypi.python.org/pypi/{}/json' . format ( package ) r = requests . get ( url ) r . raise_for_status ( ) return r . json ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set an object s field to default if it doesn t have a value [CODESPLIT] def setdefault ( obj , field , default ) : setattr ( obj , field , getattr ( obj , field , default ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string of a calculation energy e . g . - 1 . 2345 eV to a float . [CODESPLIT] def energy_string_to_float ( string ) : energy_re = re . compile ( \"(-?\\d+\\.\\d+)\" ) return float ( energy_re . match ( string ) . group ( 0 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a child ( variable ) to this object . [CODESPLIT] def _add ( self , codeobj ) : assert isinstance ( codeobj , CodeVariable ) self . variables . append ( codeobj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a spec to a mock . spec can either be an object or a list of strings . Only attributes on the spec can be fetched as attributes from the mock . [CODESPLIT] def mock_add_spec ( self , spec , spec_set = False ) : self . _mock_add_spec ( spec , spec_set ) self . _mock_set_magics ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Construct a unique hashable immutable key for an observer . [CODESPLIT] def make_key ( observer ) : if hasattr ( observer , \"__self__\" ) : inst = observer . __self__ method_name = observer . __name__ key = ( id ( inst ) , method_name ) else : key = id ( observer ) return key", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update dict with fields from obj . attributes . [CODESPLIT] def update_dict ( obj , dict , attributes ) : for attribute in attributes : if hasattr ( obj , attribute ) and getattr ( obj , attribute ) is not None : dict [ attribute ] = getattr ( obj , attribute )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the number of characters at the beginning of text that are whitespace . [CODESPLIT] def _count_leading_whitespace ( text ) : idx = 0 for idx , char in enumerate ( text ) : if not char . isspace ( ) : return idx return idx + 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get attribute from the target object [CODESPLIT] def get_attr ( self , method_name ) : return self . attrs . get ( method_name ) or self . get_callable_attr ( method_name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a blank row with only an index value to self . df . This is done inplace . [CODESPLIT] def add_blank_row ( self , label ) : col_labels = self . df . columns blank_item = pd . Series ( { } , index = col_labels , name = label ) # use .loc to add in place (append won't do that) self . df . loc [ blank_item . name ] = blank_item return self . df", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the attribute name identifier [CODESPLIT] def get_attribute_name_id ( attr ) : return attr . value . id if isinstance ( attr . value , ast . Name ) else None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update only one property in the dict [CODESPLIT] def set_property ( self , key , value ) : self . properties [ key ] = value self . sync_properties ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the tensor shape of the matrix operator [CODESPLIT] def _shape ( self ) : return tuple ( reversed ( self . output_dims ( ) ) ) + tuple ( reversed ( self . input_dims ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a ctypes double pointer array to a numpy array . [CODESPLIT] def cfloat64_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_double ) ) : return np . fromiter ( cptr , dtype = np . float64 , count = length ) else : raise RuntimeError ( 'Expected double pointer' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add subparser [CODESPLIT] def sub ( name , func , * * kwarg ) : sp = subparsers . add_parser ( name , * * kwarg ) sp . set_defaults ( func = func ) sp . arg = sp . add_argument return sp", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert an image by adding text [CODESPLIT] def add_text_to_image ( fname , txt , opFilename ) : ft = ImageFont . load ( \"T://user//dev//src//python//_AS_LIB//timR24.pil\" ) #wh = ft.getsize(txt) print ( \"Adding text \" , txt , \" to \" , fname , \" pixels wide to file \" , opFilename ) im = Image . open ( fname ) draw = ImageDraw . Draw ( im ) draw . text ( ( 0 , 0 ) , txt , fill = ( 0 , 0 , 0 ) , font = ft ) del draw im . save ( opFilename )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert datetime / str to date : param arg : : return : [CODESPLIT] def _datetime_to_date ( arg ) : _arg = parse ( arg ) if isinstance ( _arg , datetime . datetime ) : _arg = _arg . date ( ) return _arg", "target": 1, "target_options": ["no_match", "match"]}
{"input": "rotates a 2d array to a multiple of 90 deg . 0 = default 1 = 90 deg . cw 2 = 180 deg . 3 = 90 deg . ccw [CODESPLIT] def rotateImage ( image , angle ) : image = [ list ( row ) for row in image ] for n in range ( angle % 4 ) : image = list ( zip ( * image [ : : - 1 ] ) ) return image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate angle between two vectors [CODESPLIT] def vec_angle ( a , b ) : cosang = np . dot ( a , b ) sinang = fast_norm ( np . cross ( a , b ) ) return np . arctan2 ( sinang , cosang )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "R x M x R^ - 1 [CODESPLIT] def similarity_transformation ( rot , mat ) : return np . dot ( rot , np . dot ( mat , np . linalg . inv ( rot ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an enumerable that iterates through a multi - page API request [CODESPLIT] def _iter_response ( self , url , params = None ) : if params is None : params = { } params [ 'page_number' ] = 1 # Last page lists itself as next page while True : response = self . _request ( url , params ) for item in response [ 'result_data' ] : yield item # Last page lists itself as next page if response [ 'service_meta' ] [ 'next_page_number' ] == params [ 'page_number' ] : break params [ 'page_number' ] += 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exchange a code ( and state token ) for a bearer token [CODESPLIT] def fetch_token ( self , * * kwargs ) : return super ( AsanaOAuth2Session , self ) . fetch_token ( self . token_url , client_secret = self . client_secret , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run lint checks using flake8 . [CODESPLIT] def lint ( args ) : application = get_current_application ( ) if not args : args = [ application . name , 'tests' ] args = [ 'flake8' ] + list ( args ) run . main ( args , standalone_mode = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A basic document feature extractor that returns a dict of words that the document contains . [CODESPLIT] def contains_extractor ( document ) : tokens = _get_document_tokens ( document ) features = dict ( ( u'contains({0})' . format ( w ) , True ) for w in tokens ) return features", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Command supervisord shell runs the interactive command shell . [CODESPLIT] def _handle_shell ( self , cfg_file , * args , * * options ) : args = ( \"--interactive\" , ) + args return supervisorctl . main ( ( \"-c\" , cfg_file ) + args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convenience function to interpolate all values in the given field using the fmt string . [CODESPLIT] def interpolate ( table , field , fmt , * * kwargs ) : conv = lambda v : fmt % v return convert ( table , field , conv , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply a function in parallel to each element of the input [CODESPLIT] def apply ( f , obj , * args , * * kwargs ) : return vectorize ( f ) ( obj , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs a bash script in the local directory [CODESPLIT] def bash ( filename ) : sys . stdout . flush ( ) subprocess . call ( \"bash {}\" . format ( filename ) , shell = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Recursively convert Python collections into Lisp collections . [CODESPLIT] def to_lisp ( o , keywordize_keys : bool = True ) : if not isinstance ( o , ( dict , frozenset , list , set , tuple ) ) : return o else : # pragma: no cover return _to_lisp_backup ( o , keywordize_keys = keywordize_keys )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates the moving average ( rolling mean ) of an array of a certain window size . [CODESPLIT] def movingaverage ( arr , window ) : m = np . ones ( int ( window ) ) / int ( window ) return scipy . ndimage . convolve1d ( arr , m , axis = 0 , mode = 'reflect' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def rotateImage ( img , angle ) : imgR = scipy . ndimage . rotate ( img , angle , reshape = False ) return imgR", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Special case of version () when the executable is a JAR file . [CODESPLIT] def version_jar ( self ) : cmd = config . get_command ( 'java' ) cmd . append ( '-jar' ) cmd += self . cmd self . version ( cmd = cmd , path = self . cmd [ 0 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run unit tests . [CODESPLIT] def test ( * args ) : subprocess . call ( [ \"py.test-2.7\" ] + list ( args ) ) subprocess . call ( [ \"py.test-3.4\" ] + list ( args ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run unit tests . [CODESPLIT] def test ( * args ) : subprocess . call ( [ \"py.test-2.7\" ] + list ( args ) ) subprocess . call ( [ \"py.test-3.4\" ] + list ( args ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "An argparse type representing an email address . [CODESPLIT] def email_type ( arg ) : if not is_valid_email_address ( arg ) : raise argparse . ArgumentTypeError ( \"{0} is not a valid email address\" . format ( repr ( arg ) ) ) return arg", "target": 1, "target_options": ["no_match", "match"]}
{"input": "adds arguments for the swap urls command [CODESPLIT] def add_arguments ( parser ) : parser . add_argument ( '-o' , '--old-environment' , help = 'Old environment name' , required = True ) parser . add_argument ( '-n' , '--new-environment' , help = 'New environment name' , required = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adapts a Numpy array into an ARRAY string to put into the database . [CODESPLIT] def adapt_array ( arr ) : out = io . BytesIO ( ) np . save ( out , arr ) , out . seek ( 0 ) return buffer ( out . read ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "main entry point for the jardiff CLI [CODESPLIT] def main ( args = sys . argv ) : parser = create_optparser ( args [ 0 ] ) return cli ( parser . parse_args ( args [ 1 : ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Saves the dictionary in json format : param fname : file to save to [CODESPLIT] def save ( self , fname ) : with open ( fname , 'wb' ) as f : json . dump ( self , f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets args and kwargs that are passed when creating a subparsers group in an argparse . ArgumentParser i . e . when calling argparser . ArgumentParser . add_subparsers [CODESPLIT] def set_subparsers_args ( self , * args , * * kwargs ) : self . subparsers_args = args self . subparsers_kwargs = kwargs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Saves the dictionary in json format : param fname : file to save to [CODESPLIT] def save ( self , fname ) : with open ( fname , 'wb' ) as f : json . dump ( self , f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wraps scalars or string types as a list or returns the iterable instance . [CODESPLIT] def ensure_iterable ( inst ) : if isinstance ( inst , string_types ) : return [ inst ] elif not isinstance ( inst , collections . Iterable ) : return [ inst ] else : return inst", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get an SArray that contains the last n elements in the SArray . [CODESPLIT] def tail ( self , n = 10 ) : with cython_context ( ) : return SArray ( _proxy = self . __proxy__ . tail ( n ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Put an object into a ftps URL . [CODESPLIT] def write ( url , content , * * args ) : with FTPSResource ( url , * * args ) as resource : resource . write ( content )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "numpy . ndarray dumper . [CODESPLIT] def dump_nparray ( self , obj , class_name = numpy_ndarray_class_name ) : return { \"$\" + class_name : self . _json_convert ( obj . tolist ( ) ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the name of the newest file given an iterable of file names . [CODESPLIT] def newest_file ( file_iterable ) : return max ( file_iterable , key = lambda fname : os . path . getmtime ( fname ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the number of seconds until the next day ( utc midnight ) . This is the long - term rate limit used by Strava . : param now : A ( utc ) timestamp : type now : arrow . arrow . Arrow : return : the number of seconds until next day as int [CODESPLIT] def get_seconds_until_next_day ( now = None ) : if now is None : now = arrow . utcnow ( ) return ( now . ceil ( 'day' ) - now ) . seconds", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the i - th unfolding of a tensor . [CODESPLIT] def unfolding ( tens , i ) : return reshape ( tens . full ( ) , ( np . prod ( tens . n [ 0 : ( i + 1 ) ] ) , - 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "\\ Asserts that two iterables contain the same values . [CODESPLIT] def expect_all ( a , b ) : assert all ( _a == _b for _a , _b in zip_longest ( a , b ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "\\ kills the child and exits [CODESPLIT] def cli_command_quit ( self , msg ) : if self . state == State . RUNNING and self . sprocess and self . sprocess . proc : self . sprocess . proc . kill ( ) else : sys . exit ( 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This method asserts that only one value of the provided list is True . [CODESPLIT] def assert_exactly_one_true ( bool_list ) : assert isinstance ( bool_list , list ) counter = 0 for item in bool_list : if item : counter += 1 return counter == 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raises an AssertionError if expected is actual . [CODESPLIT] def assert_is_not ( expected , actual , message = None , extra = None ) : assert expected is not actual , _assert_fail_message ( message , expected , actual , \"is\" , extra )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Repeats a message multiple times . [CODESPLIT] async def repeat ( ctx , times : int , content = 'repeating...' ) : for i in range ( times ) : await ctx . send ( content )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "\\ Asserts that two iterables contain the same values . [CODESPLIT] def expect_all ( a , b ) : assert all ( _a == _b for _a , _b in zip_longest ( a , b ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Digits needed to comforatbly display values in [ minval maxval ] [CODESPLIT] def _digits ( minval , maxval ) : if minval == maxval : return 3 else : return min ( 10 , max ( 2 , int ( 1 + abs ( np . log10 ( maxval - minval ) ) ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wait until all task are executed . [CODESPLIT] async def wait_and_quit ( loop ) : from pylp . lib . tasks import running if running : await asyncio . wait ( map ( lambda runner : runner . future , running ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns dicts with header - keys and psm statistic values [CODESPLIT] def generate_split_tsv_lines ( fn , header ) : for line in generate_tsv_psms_line ( fn ) : yield { x : y for ( x , y ) in zip ( header , line . strip ( ) . split ( '\\t' ) ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs the function asynchronously taking care of exceptions . [CODESPLIT] def asynchronous ( function , event ) : thread = Thread ( target = synchronous , args = ( function , event ) ) thread . daemon = True thread . start ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns system clipboard contents . [CODESPLIT] def paste ( xsel = False ) : selection = \"primary\" if xsel else \"clipboard\" try : return subprocess . Popen ( [ \"xclip\" , \"-selection\" , selection , \"-o\" ] , stdout = subprocess . PIPE ) . communicate ( ) [ 0 ] . decode ( \"utf-8\" ) except OSError as why : raise XclipNotFound", "target": 1, "target_options": ["no_match", "match"]}
{"input": "StringIO constructor shim for the async wrapper . [CODESPLIT] def StringIO ( * args , * * kwargs ) : raw = sync_io . StringIO ( * args , * * kwargs ) return AsyncStringIOWrapper ( raw )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r A function to support exiting from exit hooks . [CODESPLIT] def exit ( exit_code = 0 ) : core . processExitHooks ( ) if state . isExitHooked and not hasattr ( sys , 'exitfunc' ) : # The function is called from the exit hook sys . stderr . flush ( ) sys . stdout . flush ( ) os . _exit ( exit_code ) #pylint: disable=W0212 sys . exit ( exit_code )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add the element * value * to the set . [CODESPLIT] def add ( self , value ) : if value not in self . _set : self . _set . add ( value ) self . _list . add ( value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clears globals and reloads modules [CODESPLIT] def clear_globals_reload_modules ( self ) : self . code_array . clear_globals ( ) self . code_array . reload_modules ( ) # Clear result cache self . code_array . result_cache . clear ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Symmetrical logarithmic scale . [CODESPLIT] def filter_symlog ( y , base = 10.0 ) : log_base = np . log ( base ) sign = np . sign ( y ) logs = np . log ( np . abs ( y ) / log_base ) return sign * logs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prefill form with data . [CODESPLIT] def fill_form ( form , data ) : for ( key , value ) in data . items ( ) : if hasattr ( form , key ) : if isinstance ( value , dict ) : fill_form ( getattr ( form , key ) , value ) else : getattr ( form , key ) . data = value return form", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Constructor . See class docstring for parameter details . [CODESPLIT] def __init__ ( self , interval , key ) : self . interval = interval self . key = key", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Use openpyxl to read an Excel file . [CODESPLIT] def _openpyxl_read_xl ( xl_path : str ) : try : wb = load_workbook ( filename = xl_path , read_only = True ) except : raise else : return wb", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function is called when a return trap is set here . [CODESPLIT] def user_return ( self , frame , return_value ) : pdb . Pdb . user_return ( self , frame , return_value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the terminal window size of the child tty . [CODESPLIT] def setwinsize ( self , rows , cols ) : self . _winsize = ( rows , cols ) self . pty . set_size ( cols , rows )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete DNSSEC key . [CODESPLIT] def delete ( gandi , resource ) : result = gandi . dnssec . delete ( resource ) gandi . echo ( 'Delete successful.' ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse Config File from yaml file . [CODESPLIT] def _parse_config ( config_file_path ) : config_file = open ( config_file_path , 'r' ) config = yaml . load ( config_file ) config_file . close ( ) return config", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates an AWS Chalice project for deployment to AWS Lambda . [CODESPLIT] def create_aws_lambda ( ctx , bucket , region_name , aws_access_key_id , aws_secret_access_key ) : from canari . commands . create_aws_lambda import create_aws_lambda create_aws_lambda ( ctx . project , bucket , region_name , aws_access_key_id , aws_secret_access_key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Confusion matrix plot [CODESPLIT] def confusion_matrix ( self ) : return plot . confusion_matrix ( self . y_true , self . y_pred , self . target_names , ax = _gen_ax ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "String to binary . [CODESPLIT] def s2b ( s ) : ret = [ ] for c in s : ret . append ( bin ( ord ( c ) ) [ 2 : ] . zfill ( 8 ) ) return \"\" . join ( ret )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show the probabilities rounded and sorted by key for the sake of portable doctests . [CODESPLIT] def show_approx ( self , numfmt = '%.3g' ) : return ', ' . join ( [ ( '%s: ' + numfmt ) % ( v , p ) for ( v , p ) in sorted ( self . prob . items ( ) ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make bars in horizontal bar chart thinner [CODESPLIT] def _change_height ( self , ax , new_value ) : for patch in ax . patches : current_height = patch . get_height ( ) diff = current_height - new_value # we change the bar height patch . set_height ( new_value ) # we recenter the bar patch . set_y ( patch . get_y ( ) + diff * .5 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform triple index into a 1 - D numpy array . [CODESPLIT] def _transform_triple_numpy ( x ) : return np . array ( [ x . head , x . relation , x . tail ] , dtype = np . int64 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the text of a BeautifulSoup element [CODESPLIT] def text ( el , strip = True ) : if not el : return \"\" text = el . text if strip : text = text . strip ( ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts text that may be camelcased into an underscored format [CODESPLIT] def underscore ( text ) : return UNDERSCORE [ 1 ] . sub ( r'\\1_\\2' , UNDERSCORE [ 0 ] . sub ( r'\\1_\\2' , text ) ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a boto3 session . [CODESPLIT] def get_boto_session ( region , aws_access_key_id = None , aws_secret_access_key = None , aws_session_token = None ) : return boto3 . session . Session ( region_name = region , aws_secret_access_key = aws_secret_access_key , aws_access_key_id = aws_access_key_id , aws_session_token = aws_session_token )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Singleton definition . [CODESPLIT] def singleton ( class_ ) : instances = { } def get_instance ( * args , * * kwargs ) : if class_ not in instances : instances [ class_ ] = class_ ( * args , * * kwargs ) return instances [ class_ ] return get_instance", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Starts the web server . [CODESPLIT] def start ( ) : global app bottle . run ( app , host = conf . WebHost , port = conf . WebPort , debug = conf . WebAutoReload , reloader = conf . WebAutoReload , quiet = conf . WebQuiet )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove comments and empty lines [CODESPLIT] def lines ( input ) : for raw_line in input : line = raw_line . strip ( ) if line and not line . startswith ( '#' ) : yield strip_comments ( line )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return an iterator that returns a chunk of a string every time it is called . notice that even though bufsize_type might be line buffered we re not doing any line buffering here . that s because our StreamBufferer handles all buffering . we just need to return a reasonable - sized chunk . [CODESPLIT] def get_iter_string_reader ( stdin ) : bufsize = 1024 iter_str = ( stdin [ i : i + bufsize ] for i in range ( 0 , len ( stdin ) , bufsize ) ) return get_iter_chunk_reader ( iter_str )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to easily create the proper json formated string from a list of strs : param cmd_list : list of strings : return : str json formatted [CODESPLIT] def _make_cmd_list ( cmd_list ) : cmd = '' for i in cmd_list : cmd = cmd + '\"' + i + '\",' cmd = cmd [ : - 1 ] return cmd", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield a series of batches from iterable each size elements long . [CODESPLIT] def ibatch ( iterable , size ) : source = iter ( iterable ) while True : batch = itertools . islice ( source , size ) yield itertools . chain ( [ next ( batch ) ] , batch )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a filtered image after applying the Fourier - space filters [CODESPLIT] def filtered_image ( self , im ) : q = np . fft . fftn ( im ) for k , v in self . filters : q [ k ] -= v return np . real ( np . fft . ifftn ( q ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sort list elements by name . [CODESPLIT] def sort_by_name ( self ) : super ( JSSObjectList , self ) . sort ( key = lambda k : k . name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sort data rows and order columns [CODESPLIT] def sort_data ( data , cols ) : return data . sort_values ( cols ) [ cols + [ 'value' ] ] . reset_index ( drop = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": meth : WCacheStorage . get_cache method implementation [CODESPLIT] def get_cache ( self , decorated_function , * args , * * kwargs ) : has_value = self . has ( decorated_function , * args , * * kwargs ) cached_value = None if has_value is True : cached_value = self . get_result ( decorated_function , * args , * * kwargs ) return WCacheStorage . CacheEntry ( has_value = has_value , cached_value = cached_value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Upermutate 1 - D data that is sorted by indices_of_increasing . [CODESPLIT] def unsort_vector ( data , indices_of_increasing ) : return numpy . array ( [ data [ indices_of_increasing . index ( i ) ] for i in range ( len ( data ) ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates the distance between two points on earth . [CODESPLIT] def _calculate_distance ( latlon1 , latlon2 ) : lat1 , lon1 = latlon1 lat2 , lon2 = latlon2 dlon = lon2 - lon1 dlat = lat2 - lat1 R = 6371 # radius of the earth in kilometers a = np . sin ( dlat / 2 ) ** 2 + np . cos ( lat1 ) * np . cos ( lat2 ) * ( np . sin ( dlon / 2 ) ) ** 2 c = 2 * np . pi * R * np . arctan2 ( np . sqrt ( a ) , np . sqrt ( 1 - a ) ) / 180 return c", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coroutine called by MapAsync . It s wrapping the call of run_in_executor to run the synchronous function as thread [CODESPLIT] async def _thread_coro ( self , * args ) : return await self . _loop . run_in_executor ( self . _executor , self . _function , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator which adds correct MIME type for python source to the decorated bottle API function . [CODESPLIT] def python_mime ( fn ) : @ wraps ( fn ) def python_mime_decorator ( * args , * * kwargs ) : response . content_type = \"text/x-python\" return fn ( * args , * * kwargs ) return python_mime_decorator", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Invoke pytest replacing argv . Return result code . [CODESPLIT] def run_tests ( self ) : with _save_argv ( _sys . argv [ : 1 ] + self . addopts ) : result_code = __import__ ( 'pytest' ) . main ( ) if result_code : raise SystemExit ( result_code )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fast way to swap the priority level of two items in the pqdict . Raises KeyError if either key does not exist . [CODESPLIT] def swap_priority ( self , key1 , key2 ) : heap = self . _heap position = self . _position if key1 not in self or key2 not in self : raise KeyError pos1 , pos2 = position [ key1 ] , position [ key2 ] heap [ pos1 ] . key , heap [ pos2 ] . key = key2 , key1 position [ key1 ] , position [ key2 ] = pos2 , pos1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Trick sphinx into displaying the desired module in these objects documentation . [CODESPLIT] def _set_module_names_for_sphinx ( modules : List , new_name : str ) : for obj in modules : obj . __module__ = new_name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Splits a list into chunks [CODESPLIT] def chunks ( arr , size ) : for i in _range ( 0 , len ( arr ) , size ) : yield arr [ i : i + size ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run once should be called only from loop () [CODESPLIT] def _run_once ( self ) : try : self . do_wait ( ) self . _execute_wakeup_tasks ( ) self . _trigger_timers ( ) except Exception as e : Log . error ( \"Error occured during _run_once(): \" + str ( e ) ) Log . error ( traceback . format_exc ( ) ) self . should_exit = True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts CamelCase to camel / case [CODESPLIT] def camelcase_to_slash ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1/\\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1/\\2' , s1 ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates sql datetime2 object from Python datetime object ignoring timezone [CODESPLIT] def from_pydatetime ( cls , pydatetime ) : return cls ( date = Date . from_pydate ( pydatetime . date ) , time = Time . from_pytime ( pydatetime . time ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if string could be a valid python identifier [CODESPLIT] def is_identifier ( string ) : matched = PYTHON_IDENTIFIER_RE . match ( string ) return bool ( matched ) and not keyword . iskeyword ( string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates sql datetime2 object from Python datetime object ignoring timezone [CODESPLIT] def from_pydatetime ( cls , pydatetime ) : return cls ( date = Date . from_pydate ( pydatetime . date ) , time = Time . from_pytime ( pydatetime . time ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the scroll region on the canvas [CODESPLIT] def set_scrollregion ( self , event = None ) : self . canvas . configure ( scrollregion = self . canvas . bbox ( 'all' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Will test whether the ACS service is up and alive . [CODESPLIT] def is_alive ( self ) : response = self . get_monitoring_heartbeat ( ) if response . status_code == 200 and response . content == 'alive' : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string from snake case to camel case with the first letter capitalized . For example some_var would become SomeVar . [CODESPLIT] def to_capitalized_camel_case ( snake_case_string ) : parts = snake_case_string . split ( '_' ) return '' . join ( [ i . title ( ) for i in parts ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if all classes are subclassed from base . [CODESPLIT] def _subclassed ( base , * classes ) : return all ( map ( lambda obj : isinstance ( obj , base ) , classes ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Use the port 0 trick to find a port not in use . [CODESPLIT] def _port_not_in_use ( ) : s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) port = 0 s . bind ( ( '' , port ) ) _ , port = s . getsockname ( ) return port", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Copy an array to the shared memory . [CODESPLIT] def copy ( a ) : shared = anonymousmemmap ( a . shape , dtype = a . dtype ) shared [ : ] = a [ : ] return shared", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert datetime / str to date : param arg : : return : [CODESPLIT] def _datetime_to_date ( arg ) : _arg = parse ( arg ) if isinstance ( _arg , datetime . datetime ) : _arg = _arg . date ( ) return _arg", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Appends a PDF to a pyPDF writer . Legacy interface . [CODESPLIT] def append_pdf ( input_pdf : bytes , output_writer : PdfFileWriter ) : append_memory_pdf_to_writer ( input_pdf = input_pdf , writer = output_writer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Loads and returns foreign library . [CODESPLIT] def load ( self , name ) : name = ctypes . util . find_library ( name ) return ctypes . cdll . LoadLibrary ( name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coerce to a categorical if a series is given . [CODESPLIT] def _maybe_to_categorical ( array ) : if isinstance ( array , ( ABCSeries , ABCCategoricalIndex ) ) : return array . _values elif isinstance ( array , np . ndarray ) : return Categorical ( array ) return array", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Circular standard deviation [CODESPLIT] def circstd ( dts , axis = 2 ) : R = np . abs ( np . exp ( 1.0j * dts ) . mean ( axis = axis ) ) return np . sqrt ( - 2.0 * np . log ( R ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Called when a new DropDownItem gets selected . [CODESPLIT] def onchange ( self , value ) : log . debug ( 'combo box. selected %s' % value ) self . select_by_value ( value ) return ( value , )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets the label for a specified object . [CODESPLIT] def set_label ( self , object , label ) : label_name = self . label if label_name [ : 1 ] != '=' : xsetattr ( object , label_name , label )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add executable permissions to the file [CODESPLIT] def add_exec_permission_to ( target_file ) : mode = os . stat ( target_file ) . st_mode os . chmod ( target_file , mode | stat . S_IXUSR )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is to support iterators over a file - like object . [CODESPLIT] def next ( self ) : # File-like object. result = self . readline ( ) if result == self . _empty_buffer : raise StopIteration return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function for conversion of various data types into numeric representation . [CODESPLIT] def _to_numeric ( val ) : if isinstance ( val , ( int , float , datetime . datetime , datetime . timedelta ) ) : return val return float ( val )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format a duration in seconds . [CODESPLIT] def fmt_duration ( secs ) : return ' ' . join ( fmt . human_duration ( secs , 0 , precision = 2 , short = True ) . strip ( ) . split ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a US format date and return epoch . [CODESPLIT] def AmericanDateToEpoch ( self , date_str ) : try : epoch = time . strptime ( date_str , \"%m/%d/%Y\" ) return int ( calendar . timegm ( epoch ) ) * 1000000 except ValueError : return 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if contents of the files are the same [CODESPLIT] def cmp_contents ( filename1 , filename2 ) : with open_readable ( filename1 , 'rb' ) as fobj : contents1 = fobj . read ( ) with open_readable ( filename2 , 'rb' ) as fobj : contents2 = fobj . read ( ) return contents1 == contents2", "target": 1, "target_options": ["no_match", "match"]}
{"input": "helper function for parsing FRED date string into datetime [CODESPLIT] def _parse ( self , date_str , format = '%Y-%m-%d' ) : rv = pd . to_datetime ( date_str , format = format ) if hasattr ( rv , 'to_pydatetime' ) : rv = rv . to_pydatetime ( ) return rv", "target": 1, "target_options": ["no_match", "match"]}
{"input": "detect if a model has a given field has [CODESPLIT] def has_field ( mc , field_name ) : try : mc . _meta . get_field ( field_name ) except FieldDoesNotExist : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Callback for is_valid_api_url . [CODESPLIT] def _is_valid_api_url ( self , url ) : # Check response is a JSON with ok: 1 data = { } try : r = requests . get ( url , proxies = self . proxy_servers ) content = to_text_string ( r . content , encoding = 'utf-8' ) data = json . loads ( content ) except Exception as error : logger . error ( str ( error ) ) return data . get ( 'ok' , 0 ) == 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print a formatted straight line . [CODESPLIT] def straight_line_show ( title , length = 100 , linestyle = \"=\" , pad = 0 ) : print ( StrTemplate . straight_line ( title = title , length = length , linestyle = linestyle , pad = pad ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs command and returns the output as string . [CODESPLIT] def check_output ( args ) : log . debug ( 'run: %s' , args ) out = subprocess . check_output ( args = args ) . decode ( 'utf-8' ) log . debug ( 'out: %r' , out ) return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether the provided value is a valid enum constant . [CODESPLIT] def check ( self , var ) : if not isinstance ( var , _str_type ) : return False return _enum_mangle ( var ) in self . _consts", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether the provided value is a valid enum constant . [CODESPLIT] def check ( self , var ) : if not isinstance ( var , _str_type ) : return False return _enum_mangle ( var ) in self . _consts", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sum reduction op . [CODESPLIT] def Sum ( a , axis , keep_dims ) : return np . sum ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Python2 accumulate implementation taken from https : // docs . python . org / 3 / library / itertools . html#itertools . accumulate [CODESPLIT] def _accumulate ( sequence , func ) : iterator = iter ( sequence ) total = next ( iterator ) yield total for element in iterator : total = func ( total , element ) yield total", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether the current folder is a Git repo . [CODESPLIT] def is_git_repo ( ) : cmd = \"git\" , \"rev-parse\" , \"--git-dir\" try : subprocess . run ( cmd , stdout = subprocess . DEVNULL , check = True ) return True except subprocess . CalledProcessError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sum reduction op . [CODESPLIT] def Sum ( a , axis , keep_dims ) : return np . sum ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return True if the current distribution is running on debian like OS . [CODESPLIT] def is_archlinux ( ) : if platform . system ( ) . lower ( ) == 'linux' : if platform . linux_distribution ( ) == ( '' , '' , '' ) : # undefined distribution. Fixed in python 3. if os . path . exists ( '/etc/arch-release' ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts camel - case identifiers to snake - case . [CODESPLIT] def to_snake_case ( s ) : return re . sub ( '([^_A-Z])([A-Z])' , lambda m : m . group ( 1 ) + '_' + m . group ( 2 ) . lower ( ) , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a group exists [CODESPLIT] def group_exists ( groupname ) : try : grp . getgrnam ( groupname ) group_exists = True except KeyError : group_exists = False return group_exists", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Swap i and j rows [CODESPLIT] def _swap_rows ( self , i , j ) : L = np . eye ( 3 , dtype = 'intc' ) L [ i , i ] = 0 L [ j , j ] = 0 L [ i , j ] = 1 L [ j , i ] = 1 self . _L . append ( L . copy ( ) ) self . _A = np . dot ( L , self . _A )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "checks to see if list is equal everywhere [CODESPLIT] def allsame ( list_ , strict = True ) : if len ( list_ ) == 0 : return True first_item = list_ [ 0 ] return list_all_eq_to ( list_ , first_item , strict )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Same as lazy_binmap except the parameters are flipped for the binary function [CODESPLIT] def lazy_reverse_binmap ( f , xs ) : return ( f ( y , x ) for x , y in zip ( xs , xs [ 1 : ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a boolean list where each elements is whether that element in the column is in the compare_list . [CODESPLIT] def isin ( self , column , compare_list ) : return [ x in compare_list for x in self . _data [ self . _columns . index ( column ) ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns json format for symbol [CODESPLIT] def jsonify ( symbol ) : try : # all symbols have a toJson method, try it return json . dumps ( symbol . toJson ( ) , indent = '  ' ) except AttributeError : pass return json . dumps ( symbol , indent = '  ' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if an http server runs on a given port . [CODESPLIT] def is_http_running_on ( port ) : try : conn = httplib . HTTPConnection ( '127.0.0.1:' + str ( port ) ) conn . connect ( ) conn . close ( ) return True except Exception : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the width of the table including padding and borders . [CODESPLIT] def table_width ( self ) : outer_widths = max_dimensions ( self . table_data , self . padding_left , self . padding_right ) [ 2 ] outer_border = 2 if self . outer_border else 0 inner_border = 1 if self . inner_column_border else 0 return table_width ( outer_widths , outer_border , inner_border )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check lowercase key item . [CODESPLIT] def __contains__ ( self , key ) : assert isinstance ( key , basestring ) return dict . __contains__ ( self , key . lower ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Open saved html file in an virtual browser and save a screen shot to PNG format . [CODESPLIT] def save_as_png ( self , filename , width = 300 , height = 250 , render_time = 1 ) : self . driver . set_window_size ( width , height ) self . driver . get ( 'file://{path}/{filename}' . format ( path = os . getcwd ( ) , filename = filename + \".html\" ) ) time . sleep ( render_time ) self . driver . save_screenshot ( filename + \".png\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns numpy array of natural logarithms of values . [CODESPLIT] def to_distribution_values ( self , values ) : with warnings . catch_warnings ( ) : warnings . simplefilter ( \"ignore\" ) # avoid RuntimeWarning: divide by zero encountered in log return numpy . log ( values )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check configuration file type is JSON Return a boolean indicating wheather the file is JSON format or not [CODESPLIT] def is_json_file ( filename , show_warnings = False ) : try : config_dict = load_config ( filename , file_type = \"json\" ) is_json = True except : is_json = False return ( is_json )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns numpy array of natural logarithms of values . [CODESPLIT] def to_distribution_values ( self , values ) : with warnings . catch_warnings ( ) : warnings . simplefilter ( \"ignore\" ) # avoid RuntimeWarning: divide by zero encountered in log return numpy . log ( values )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if something quacks like a list . [CODESPLIT] def is_listish ( obj ) : if isinstance ( obj , ( list , tuple , set ) ) : return True return is_sequence ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Applies the sofplus activation function element - wise to the input . [CODESPLIT] def softplus ( attrs , inputs , proto_obj ) : new_attrs = translation_utils . _add_extra_attributes ( attrs , { 'act_type' : 'softrelu' } ) return 'Activation' , new_attrs , inputs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates data is a timestamp [CODESPLIT] def is_timestamp ( instance ) : if not isinstance ( instance , ( int , str ) ) : return True return datetime . fromtimestamp ( int ( instance ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get dimension of an array getting the number of rows and the max num of columns . [CODESPLIT] def get_dimension_array ( array ) : if all ( isinstance ( el , list ) for el in array ) : result = [ len ( array ) , len ( max ( [ x for x in array ] , key = len , ) ) ] # elif array and isinstance(array, list): else : result = [ len ( array ) , 1 ] return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if the given thing represents a date [CODESPLIT] def is_date ( thing ) : # known date types date_types = ( datetime . datetime , datetime . date , DateTime ) return isinstance ( thing , date_types )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Implements the === operator . [CODESPLIT] def hard_equals ( a , b ) : if type ( a ) != type ( b ) : return False return a == b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the line number parsed from the comment or 0 . [CODESPLIT] def _get_line_no_from_comments ( py_line ) : matched = LINECOL_COMMENT_RE . match ( py_line ) if matched : return int ( matched . group ( 1 ) ) else : return 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get attribute from the target object [CODESPLIT] def get_attr ( self , method_name ) : return self . attrs . get ( method_name ) or self . get_callable_attr ( method_name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Checks if l is iterable and contains only integral types [CODESPLIT] def is_iterable_of_int ( l ) : if not is_iterable ( l ) : return False return all ( is_int ( value ) for value in l )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Should we skip logging for this handler? [CODESPLIT] def should_skip_logging ( func ) : disabled = strtobool ( request . headers . get ( \"x-request-nolog\" , \"false\" ) ) return disabled or getattr ( func , SKIP_LOGGING , False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine whether or not obj is iterable but not a string ( eg a list set tuple etc ) . [CODESPLIT] def is_iterable_but_not_string ( obj ) : return hasattr ( obj , '__iter__' ) and not isinstance ( obj , str ) and not isinstance ( obj , bytes )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks whether a variable is a numpy integer array . [CODESPLIT] def is_integer_array ( val ) : return is_np_array ( val ) and issubclass ( val . dtype . type , np . integer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make sure we can route to the given endpoint or url . [CODESPLIT] def can_route ( self , endpoint , method = None , * * kwargs ) : view = flask . current_app . view_functions . get ( endpoint ) if not view : endpoint , args = flask . _request_ctx . top . match ( endpoint ) view = flask . current_app . view_functions . get ( endpoint ) if not view : return False return self . can ( 'http.' + ( method or 'GET' ) . lower ( ) , view , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determines if a system process identifer exists in process table . [CODESPLIT] def pid_exists ( pid ) : try : os . kill ( pid , 0 ) except OSError as exc : return exc . errno == errno . EPERM else : return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the element with the highest probability . [CODESPLIT] def best ( self ) : b = ( - 1e999999 , None ) for k , c in iteritems ( self . counts ) : b = max ( b , ( c , k ) ) return b [ 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if given filename is an image . [CODESPLIT] def is_image ( filename ) : # note: isfile() also accepts symlinks return os . path . isfile ( filename ) and filename . lower ( ) . endswith ( ImageExts )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Formats the given time into HH : MM : SS [CODESPLIT] def format_time ( time ) : h , r = divmod ( time / 1000 , 3600 ) m , s = divmod ( r , 60 ) return \"%02d:%02d:%02d\" % ( h , m , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tell whether a kernel driver is active on given interface number . [CODESPLIT] def kernelDriverActive ( self , interface ) : result = libusb1 . libusb_kernel_driver_active ( self . __handle , interface ) if result == 0 : return False elif result == 1 : return True raiseUSBError ( result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if value is an instance of float . [CODESPLIT] def test_value ( self , value ) : if not isinstance ( value , float ) : raise ValueError ( 'expected float value: ' + str ( type ( value ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If value is a datetime convert to timestamp [CODESPLIT] def dt_to_ts ( value ) : if not isinstance ( value , datetime ) : return value return calendar . timegm ( value . utctimetuple ( ) ) + value . microsecond / 1000000.0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test the speed of a function . [CODESPLIT] def speedtest ( func , * args , * * kwargs ) : n = 100 start = time . time ( ) for i in range ( n ) : func ( * args , * * kwargs ) end = time . time ( ) return ( end - start ) / n", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks whether a variable is a numpy integer array . [CODESPLIT] def is_integer_array ( val ) : return is_np_array ( val ) and issubclass ( val . dtype . type , np . integer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update the column width . [CODESPLIT] def _column_resized ( self , col , old_width , new_width ) : self . dataTable . setColumnWidth ( col , new_width ) self . _update_layout ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a boolean indicating if the code is executed inside softimage . [CODESPLIT] def inside_softimage ( ) : try : import maya return False except ImportError : pass try : from win32com . client import Dispatch as disp disp ( 'XSI.Application' ) return True except : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a function that checks whether a scalar or array is of a given kind ( e . g . float int datetime timedelta ) . [CODESPLIT] def make_kind_check ( python_types , numpy_kind ) : def check ( value ) : if hasattr ( value , 'dtype' ) : return value . dtype . kind == numpy_kind return isinstance ( value , python_types ) return check", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if the given type is a builtin one . [CODESPLIT] def is_builtin_type ( tp ) : return hasattr ( __builtins__ , tp . __name__ ) and tp is getattr ( __builtins__ , tp . __name__ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the list of distinct values with preserving order . [CODESPLIT] def distinct ( xs ) : # don't use collections.OrderedDict because we do support Python 2.6 seen = set ( ) return [ x for x in xs if x not in seen and not seen . add ( x ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses data and builds an instance of this class [CODESPLIT] def from_df ( data_frame ) : labels = data_frame . keys ( ) . tolist ( ) data = data_frame . values . tolist ( ) return SqlTable ( labels , data , \"{:.3f}\" , \"\\n\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks length of value [CODESPLIT] def check_length ( value , length ) : _length = len ( value ) if _length != length : raise ValueError ( \"length must be %d, not %d\" % ( length , _length ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "transpose matrix [CODESPLIT] def transpose ( table ) : t = [ ] for i in range ( 0 , len ( table [ 0 ] ) ) : t . append ( [ row [ i ] for row in table ] ) return t", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check lowercase key item . [CODESPLIT] def __contains__ ( self , key ) : assert isinstance ( key , basestring ) return dict . __contains__ ( self , key . lower ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Empty a table by deleting all of its rows . [CODESPLIT] def truncate ( self , table ) : if isinstance ( table , ( list , set , tuple ) ) : for t in table : self . _truncate ( t ) else : self . _truncate ( table )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Only works for RSAPublic Keys [CODESPLIT] def rsa_eq ( key1 , key2 ) : pn1 = key1 . public_numbers ( ) pn2 = key2 . public_numbers ( ) # Check if two RSA keys are in fact the same if pn1 == pn2 : return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Match and yield all the tokens of the input string . [CODESPLIT] def tokenize ( string ) : for match in TOKENS_REGEX . finditer ( string ) : yield Token ( match . lastgroup , match . group ( ) . strip ( ) , match . span ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raises a requests . exceptions . HTTPError if the response has a non - 200 status code . [CODESPLIT] def raise_for_not_ok_status ( response ) : if response . code != OK : raise HTTPError ( 'Non-200 response code (%s) for url: %s' % ( response . code , uridecode ( response . request . absoluteURI ) ) ) return response", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of unique items ( similar to set functionality ) . [CODESPLIT] def unique ( input_list ) : output = [ ] for item in input_list : if item not in output : output . append ( item ) return output", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a copy of a dictionary with all keys converted to snake case . This is just calls to_snake_case on each of the keys in the dictionary and returns a new dictionary . [CODESPLIT] def keys_to_snake_case ( camel_case_dict ) : return dict ( ( to_snake_case ( key ) , value ) for ( key , value ) in camel_case_dict . items ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is the user a system administrator [CODESPLIT] def is_admin ( self ) : return self . role == self . roles . administrator . value and self . state == State . approved", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an image with the binarised version of the data of img . [CODESPLIT] def abs_img ( img ) : bool_img = np . abs ( read_img ( img ) . get_data ( ) ) return bool_img . astype ( int )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yaml either have automatically converted it to a datetime object or it is a string that will be validated later . [CODESPLIT] def is_timestamp ( obj ) : return isinstance ( obj , datetime . datetime ) or is_string ( obj ) or is_int ( obj ) or is_float ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert dict of ascii str / unicode to dict of str if necessary [CODESPLIT] def str_dict ( some_dict ) : return { str ( k ) : str ( v ) for k , v in some_dict . items ( ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert this confusion matrix into a 2x2 plain list of values . [CODESPLIT] def to_list ( self ) : return [ [ int ( self . table . cell_values [ 0 ] [ 1 ] ) , int ( self . table . cell_values [ 0 ] [ 2 ] ) ] , [ int ( self . table . cell_values [ 1 ] [ 1 ] ) , int ( self . table . cell_values [ 1 ] [ 2 ] ) ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns whether this is a complex floating point type . [CODESPLIT] def is_complex ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'is_complex' ) : return dtype . is_complex return np . issubdtype ( np . dtype ( dtype ) , np . complex )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Stop listening for output from the stenotype machine . [CODESPLIT] def stop_capture ( self ) : super ( Treal , self ) . stop_capture ( ) if self . _machine : self . _machine . close ( ) self . _stopped ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def _tableExists ( self , tableName ) : cursor = _conn . execute ( \"\"\"\n            SELECT * FROM sqlite_master WHERE name ='{0}' and type='table';\n        \"\"\" . format ( tableName ) ) exists = cursor . fetchone ( ) is not None cursor . close ( ) return exists", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Search twitter API [CODESPLIT] def search_for_tweets_about ( user_id , params ) : url = \"https://api.twitter.com/1.1/search/tweets.json\" response = make_twitter_request ( url , user_id , params ) return process_tweets ( response . json ( ) [ \"statuses\" ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if given filename is an image . [CODESPLIT] def is_image ( filename ) : # note: isfile() also accepts symlinks return os . path . isfile ( filename ) and filename . lower ( ) . endswith ( ImageExts )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert from whatever is given to a list of scalars for the lookup_field . [CODESPLIT] def coerce ( self , value ) : if isinstance ( value , dict ) : value = [ value ] if not isiterable_notstring ( value ) : value = [ value ] return [ coerce_single_instance ( self . lookup_field , v ) for v in value ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Equivalent of unix chmod + w path [CODESPLIT] def chmod_plus_w ( path ) : path_mode = os . stat ( path ) . st_mode path_mode &= int ( '777' , 8 ) path_mode |= stat . S_IWRITE os . chmod ( path , path_mode )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a sorted list of all system font names [CODESPLIT] def get_font_list ( ) : font_map = pangocairo . cairo_font_map_get_default ( ) font_list = [ f . get_name ( ) for f in font_map . list_families ( ) ] font_list . sort ( ) return font_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Autoconnect slot activated when tbSourceDir is clicked . [CODESPLIT] def on_source_directory_chooser_clicked ( self ) : title = self . tr ( 'Set the source directory for script and scenario' ) self . choose_directory ( self . source_directory , title )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield successive n - sized chunks from an iterable . [CODESPLIT] def chunks ( iterable , chunk ) : for i in range ( 0 , len ( iterable ) , chunk ) : yield iterable [ i : i + chunk ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove decoded instruction from instruction cache [CODESPLIT] def invalidate_cache ( cpu , address , size ) : cache = cpu . instruction_cache for offset in range ( size ) : if address + offset in cache : del cache [ address + offset ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a set of unique n - grams from a string . [CODESPLIT] def make_unique_ngrams ( s , n ) : return set ( s [ i : i + n ] for i in range ( len ( s ) - n + 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Must be called to print final progress label . [CODESPLIT] def finished ( self ) : self . progress_bar . set_state ( ProgressBar . STATE_DONE ) self . progress_bar . show ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def get_unique_indices ( df , axis = 1 ) : return dict ( zip ( df . columns . names , dif . columns . levels ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clears globals and reloads modules [CODESPLIT] def clear_globals_reload_modules ( self ) : self . code_array . clear_globals ( ) self . code_array . reload_modules ( ) # Clear result cache self . code_array . result_cache . clear ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Same order unique list using only a list compression . [CODESPLIT] def uniquify_list ( L ) : return [ e for i , e in enumerate ( L ) if L . index ( e ) == i ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shutdown process ( this method is also a signal handler ) [CODESPLIT] def stop ( self , dummy_signum = None , dummy_frame = None ) : logging . info ( 'Shutting down ...' ) self . socket . close ( ) sys . exit ( 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compose all given tuples together . [CODESPLIT] def compose_all ( tups ) : from . import ast # I weep for humanity return functools . reduce ( lambda x , y : x . compose ( y ) , map ( ast . make_tuple , tups ) , ast . make_tuple ( { } ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Manually shutdown the async API . [CODESPLIT] def shutdown ( ) : global handler , transport , protocol if handler is not None : handler . close ( ) transport . close ( ) handler = None transport = None protocol = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Comparsion not implemented . [CODESPLIT] def __cmp__ ( self , other ) : # Stops python 2 from allowing comparsion of arbitrary objects raise TypeError ( 'unorderable types: {}, {}' '' . format ( self . __class__ . __name__ , type ( other ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "is_valid_image_extension . [CODESPLIT] def is_valid_image_extension ( file_path ) : valid_extensions = [ '.jpeg' , '.jpg' , '.gif' , '.png' ] _ , extension = os . path . splitext ( file_path ) return extension . lower ( ) in valid_extensions", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Download and unzip from url . [CODESPLIT] def install_from_zip ( url ) : fname = 'tmp.zip' downlad_file ( url , fname ) unzip_file ( fname ) print ( \"Removing {}\" . format ( fname ) ) os . unlink ( fname )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get distance between pairs of lat - lon points [CODESPLIT] def Distance ( lat1 , lon1 , lat2 , lon2 ) : az12 , az21 , dist = wgs84_geod . inv ( lon1 , lat1 , lon2 , lat2 ) return az21 , dist", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Opens a connection to the cloudant service and closes it automatically if used as context manager . [CODESPLIT] def get_conn ( self ) : conn = self . get_connection ( self . cloudant_conn_id ) self . _validate_connection ( conn ) cloudant_session = cloudant ( user = conn . login , passwd = conn . password , account = conn . host ) return cloudant_session", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Put a new element in the queue . [CODESPLIT] def push ( self , el ) : count = next ( self . counter ) heapq . heappush ( self . _queue , ( el , count ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates progress bar for a specified target . [CODESPLIT] def update_target ( self , name , current , total ) : self . refresh ( self . _bar ( name , current , total ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check the validity of an IPv6 address [CODESPLIT] def is_valid_ipv6 ( ip_str ) : try : socket . inet_pton ( socket . AF_INET6 , ip_str ) except socket . error : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the absolute position of table top [CODESPLIT] def table_top_abs ( self ) : table_height = np . array ( [ 0 , 0 , self . table_full_size [ 2 ] ] ) return string_to_array ( self . floor . get ( \"pos\" ) ) + table_height", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A function to display sympy expression using display style LaTeX in PNG . [CODESPLIT] def print_display_png ( o ) : s = latex ( o , mode = 'plain' ) s = s . strip ( '$' ) # As matplotlib does not support display style, dvipng backend is # used here. png = latex_to_png ( '$$%s$$' % s , backend = 'dvipng' ) return png", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a comma separated string to a list [CODESPLIT] def _str_to_list ( s ) : _list = s . split ( \",\" ) return list ( map ( lambda i : i . lstrip ( ) , _list ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the distance between two points . [CODESPLIT] def dist ( x1 , x2 , axis = 0 ) : return np . linalg . norm ( x2 - x1 , axis = axis )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Build word frequency list from incoming string . [CODESPLIT] def counter_from_str ( self , string ) : string_list = [ chars for chars in string if chars not in self . punctuation ] string_joined = '' . join ( string_list ) tokens = self . punkt . word_tokenize ( string_joined ) return Counter ( tokens )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of characters in two strings that don t exactly match [CODESPLIT] def count_string_diff ( a , b ) : shortest = min ( len ( a ) , len ( b ) ) return sum ( a [ i ] != b [ i ] for i in range ( shortest ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create an index from the columns of a dataframe [CODESPLIT] def _make_index ( df , cols = META_IDX ) : return pd . MultiIndex . from_tuples ( pd . unique ( list ( zip ( * [ df [ col ] for col in cols ] ) ) ) , names = tuple ( cols ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Attempts to compile the given source first as an expression and then as a statement if the first approach fails . [CODESPLIT] def _try_compile ( source , name ) : try : c = compile ( source , name , 'eval' ) except SyntaxError : c = compile ( source , name , 'exec' ) return c", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a sort lambda function for the sortedbykey [CODESPLIT] def _sort_lambda ( sortedby = 'cpu_percent' , sortedby_secondary = 'memory_percent' ) : ret = None if sortedby == 'io_counters' : ret = _sort_io_counters elif sortedby == 'cpu_times' : ret = _sort_cpu_times return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Python2 accumulate implementation taken from https : // docs . python . org / 3 / library / itertools . html#itertools . accumulate [CODESPLIT] def _accumulate ( sequence , func ) : iterator = iter ( sequence ) total = next ( iterator ) yield total for element in iterator : total = func ( total , element ) yield total", "target": 1, "target_options": ["no_match", "match"]}
{"input": "__init__ Args : root_section ( str ) : root section in the init defaults ( dict ) : Default dictonary to load can be empty . [CODESPLIT] def __init__ ( self , root_section = 'lago' , defaults = { } ) : self . root_section = root_section self . _defaults = defaults self . _config = defaultdict ( dict ) self . _config . update ( self . load ( ) ) self . _parser = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "conv2d returns a 2d convolution layer with full stride . [CODESPLIT] def conv2d ( x_input , w_matrix ) : return tf . nn . conv2d ( x_input , w_matrix , strides = [ 1 , 1 , 1 , 1 ] , padding = 'SAME' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": return : list (( option value ) ... ) pairs of all items in the given section [CODESPLIT] def items ( self , section_name ) : return [ ( k , v ) for k , v in super ( GitConfigParser , self ) . items ( section_name ) if k != '__name__' ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Segmented min op . [CODESPLIT] def SegmentMin ( a , ids ) : func = lambda idxs : np . amin ( a [ idxs ] , axis = 0 ) return seg_map ( func , a , ids ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Connect to a redis instance . [CODESPLIT] def __connect ( ) : global redis_instance if use_tcp_socket : redis_instance = redis . StrictRedis ( host = hostname , port = port ) else : redis_instance = redis . StrictRedis ( unix_socket_path = unix_socket )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "%D . [CODESPLIT] def percent_d ( data , period ) : p_k = percent_k ( data , period ) percent_d = sma ( p_k , 3 ) return percent_d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Calculate the voxel coordinates of a straight line between the two given end points [CODESPLIT] def line_segment ( X0 , X1 ) : X0 = sp . around ( X0 ) . astype ( int ) X1 = sp . around ( X1 ) . astype ( int ) if len ( X0 ) == 3 : L = sp . amax ( sp . absolute ( [ [ X1 [ 0 ] - X0 [ 0 ] ] , [ X1 [ 1 ] - X0 [ 1 ] ] , [ X1 [ 2 ] - X0 [ 2 ] ] ] ) ) + 1 x = sp . rint ( sp . linspace ( X0 [ 0 ] , X1 [ 0 ] , L ) ) . astype ( int ) y = sp . rint ( sp . linspace ( X0 [ 1 ] , X1 [ 1 ] , L ) ) . astype ( int ) z = sp . rint ( sp . linspace ( X0 [ 2 ] , X1 [ 2 ] , L ) ) . astype ( int ) return [ x , y , z ] else : L = sp . amax ( sp . absolute ( [ [ X1 [ 0 ] - X0 [ 0 ] ] , [ X1 [ 1 ] - X0 [ 1 ] ] ] ) ) + 1 x = sp . rint ( sp . linspace ( X0 [ 0 ] , X1 [ 0 ] , L ) ) . astype ( int ) y = sp . rint ( sp . linspace ( X0 [ 1 ] , X1 [ 1 ] , L ) ) . astype ( int ) return [ x , y ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate all matches found within a string for a regex and yield each match as a string [CODESPLIT] def iter_finds ( regex_obj , s ) : if isinstance ( regex_obj , str ) : for m in re . finditer ( regex_obj , s ) : yield m . group ( ) else : for m in regex_obj . finditer ( s ) : yield m . group ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Interpolated flux at a given wavelength ( calls np . interp ) . [CODESPLIT] def get_line_flux ( line_wave , wave , flux , * * kwargs ) : return np . interp ( line_wave , wave , flux , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return data as a JSON string . [CODESPLIT] def to_json ( data ) : return json . dumps ( data , default = lambda x : x . __dict__ , sort_keys = True , indent = 4 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap a function as a method . [CODESPLIT] def method ( func ) : attr = abc . abstractmethod ( func ) attr . __imethod__ = True return attr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Spotify version information [CODESPLIT] def version ( self ) : url : str = get_url ( \"/service/version.json\" ) params = { \"service\" : \"remote\" } r = self . _request ( url = url , params = params ) return r . json ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert datetime to epoch seconds . [CODESPLIT] def _dt_to_epoch ( dt ) : try : epoch = dt . timestamp ( ) except AttributeError : # py2 epoch = ( dt - datetime ( 1970 , 1 , 1 ) ) . total_seconds ( ) return epoch", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sophisticated simulation of multiplication [CODESPLIT] def multiply ( traj ) : z = traj . x * traj . y traj . f_add_result ( 'z' , z = z , comment = 'I am the product of two reals!' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the offset between the given point and this point [CODESPLIT] def getOffset ( self , loc ) : return Location ( loc . x - self . x , loc . y - self . y )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print results straight to stdout [CODESPLIT] def stdout_display ( ) : if sys . version_info [ 0 ] == 2 : yield SmartBuffer ( sys . stdout ) else : yield SmartBuffer ( sys . stdout . buffer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return first row and also iterable with same items as original [CODESPLIT] def peekiter ( iterable ) : it = iter ( iterable ) one = next ( it ) def gen ( ) : \"\"\"Generator that returns first and proxy other items from source\"\"\" yield one while True : yield next ( it ) return ( one , gen ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A tensorflow variable tranfomed to be constrained in a L2 unit ball . [CODESPLIT] def unit_ball_L2 ( shape ) : x = tf . Variable ( tf . zeros ( shape ) ) return constrain_L2 ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate column - wise Pearson correlations using numpy . ma . corrcoef [CODESPLIT] def correlation ( df , rowvar = False ) : # Create a correlation matrix for all correlations # of the columns (filled with na for all values) df = df . copy ( ) maskv = np . ma . masked_where ( np . isnan ( df . values ) , df . values ) cdf = np . ma . corrcoef ( maskv , rowvar = False ) cdf = pd . DataFrame ( np . array ( cdf ) ) cdf . columns = df . columns cdf . index = df . columns cdf = cdf . sort_index ( level = 0 , axis = 1 ) cdf = cdf . sort_index ( level = 0 ) return cdf", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Hard assert for whether and element is present and visible in the current window / frame [CODESPLIT] def assert_visible ( self , locator , msg = None ) : e = driver . find_elements_by_locator ( locator ) if len ( e ) == 0 : raise AssertionError ( \"Element at %s was not found\" % locator ) assert e . is_displayed ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "From a given natural integer returns the prime factors and their multiplicity : param n : Natural integer : return : [CODESPLIT] def _factor_generator ( n ) : p = prime_factors ( n ) factors = { } for p1 in p : try : factors [ p1 ] += 1 except KeyError : factors [ p1 ] = 1 return factors", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Provides the color corresponding to value x in the form of a tuple ( R G B A ) with int values between 0 and 255 . [CODESPLIT] def rgba_bytes_tuple ( self , x ) : return tuple ( int ( u * 255.9999 ) for u in self . rgba_floats_tuple ( x ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove and return the item at index . [CODESPLIT] def pop ( self , index = - 1 ) : value = self . _list . pop ( index ) del self . _dict [ value ] return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Count the number of rows in 2D arrays that contain any nan values . [CODESPLIT] def count_rows_with_nans ( X ) : if X . ndim == 2 : return np . where ( np . isnan ( X ) . sum ( axis = 1 ) != 0 , 1 , 0 ) . sum ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the gradient of the current model using the training set [CODESPLIT] def compute_gradient ( self ) : delta = self . predict ( self . X ) - self . y return delta . dot ( self . X ) / len ( self . X )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the length of the indentation on the given token s line . [CODESPLIT] def _get_indent_length ( line ) : result = 0 for char in line : if char == \" \" : result += 1 elif char == \"\\t\" : result += _TAB_LENGTH else : break return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the number of characters at the beginning of text that are whitespace . [CODESPLIT] def _count_leading_whitespace ( text ) : idx = 0 for idx , char in enumerate ( text ) : if not char . isspace ( ) : return idx return idx + 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return internal state useful for testing . [CODESPLIT] def state ( self ) : return { 'c' : self . c , 's0' : self . s0 , 's1' : self . s1 , 's2' : self . s2 }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Counts the word frequences in a list of sentences . [CODESPLIT] def count ( lines ) : words = [ w for l in lines for w in l . strip ( ) . split ( ) ] return Counter ( words )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Begins an indented block . Must be used in a with code block . All calls to the logger inside of the block will be indented . [CODESPLIT] def indent ( self ) : blk = IndentBlock ( self , self . _indent ) self . _indent += 1 return blk", "target": 1, "target_options": ["no_match", "match"]}
{"input": "List the n most common elements and their counts . [CODESPLIT] def nlargest ( self , n = None ) : if n is None : return sorted ( self . counts ( ) , key = itemgetter ( 1 ) , reverse = True ) else : return heapq . nlargest ( n , self . counts ( ) , key = itemgetter ( 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Writes a file if it doesn t already exist with the same content . [CODESPLIT] def _replace_file ( path , content ) : if os . path . exists ( path ) : with open ( path , 'r' ) as f : if content == f . read ( ) : print ( \"Not overwriting {} because it is unchanged\" . format ( path ) , file = sys . stderr ) return with open ( path , 'w' ) as f : f . write ( content )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Allow \\ n . join ( ... ) statements to work in Py2 and Py3 . : param sep : : param joinable : : return : [CODESPLIT] def _py2_and_3_joiner ( sep , joinable ) : if ISPY3 : sep = bytes ( sep , DEFAULT_ENCODING ) joined = sep . join ( joinable ) return joined . decode ( DEFAULT_ENCODING ) if ISPY3 else joined", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a absolute path in the file system . [CODESPLIT] def create_path ( path ) : import os if not os . path . exists ( path ) : os . makedirs ( path )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the O_NONBLOCK flag for a file descriptor . Availability : Unix . [CODESPLIT] def setblocking ( fd , blocking ) : if not fcntl : warnings . warn ( 'setblocking() not supported on Windows' ) flags = fcntl . fcntl ( fd , fcntl . F_GETFL ) if blocking : flags |= os . O_NONBLOCK else : flags &= ~ os . O_NONBLOCK fcntl . fcntl ( fd , fcntl . F_SETFL , flags )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a vector randomly within the given rectangle . [CODESPLIT] def from_rectangle ( box ) : x = box . left + box . width * random . uniform ( 0 , 1 ) y = box . bottom + box . height * random . uniform ( 0 , 1 ) return Vector ( x , y )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns system clipboard contents . [CODESPLIT] def paste ( xsel = False ) : selection = \"primary\" if xsel else \"clipboard\" try : return subprocess . Popen ( [ \"xclip\" , \"-selection\" , selection , \"-o\" ] , stdout = subprocess . PIPE ) . communicate ( ) [ 0 ] . decode ( \"utf-8\" ) except OSError as why : raise XclipNotFound", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Send signal to process . [CODESPLIT] def process_kill ( pid , sig = None ) : sig = sig or signal . SIGTERM os . kill ( pid , sig )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if git command is available . [CODESPLIT] def check_git ( ) : try : with open ( os . devnull , \"wb\" ) as devnull : subprocess . check_call ( [ \"git\" , \"--version\" ] , stdout = devnull , stderr = devnull ) except : raise RuntimeError ( \"Please make sure git is installed and on your path.\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Builds instance from dictionary of properties . [CODESPLIT] def fromDict ( cls , _dict ) : obj = cls ( ) obj . __dict__ . update ( _dict ) return obj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the last n items in readline history . [CODESPLIT] def get_readline_tail ( self , n = 10 ) : end = self . shell . readline . get_current_history_length ( ) + 1 start = max ( end - n , 1 ) ghi = self . shell . readline . get_history_item return [ ghi ( x ) for x in range ( start , end ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return matrix as csv data . [CODESPLIT] def csv_matrix_print ( classes , table ) : result = \"\" classes . sort ( ) for i in classes : for j in classes : result += str ( table [ i ] [ j ] ) + \",\" result = result [ : - 1 ] + \"\\n\" return result [ : - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a tuple containing all elements of tup plus elem . [CODESPLIT] def _ensure_element ( tup , elem ) : try : return tup , tup . index ( elem ) except ValueError : return tuple ( chain ( tup , ( elem , ) ) ) , len ( tup )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "helpful in situations where browser / app may recognize Unicode encoding in the \\ u0b8e type syntax but not actual unicode glyph / code - point [CODESPLIT] def to_unicode_repr ( _letter ) : # Python 2-3 compatible return u\"u'\" + u\"\" . join ( [ u\"\\\\u%04x\" % ord ( l ) for l in _letter ] ) + u\"'\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a value or list of values and returns a single result joined by if necessary . [CODESPLIT] def vectorize ( values ) : if isinstance ( values , list ) : return ',' . join ( str ( v ) for v in values ) return values", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets main window icon to given wx . Bitmap [CODESPLIT] def set_icon ( self , bmp ) : _icon = wx . EmptyIcon ( ) _icon . CopyFromBitmap ( bmp ) self . SetIcon ( _icon )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates symbolic link for either operating system . http : // stackoverflow . com / questions / 6260149 / os - symlink - support - in - windows [CODESPLIT] def create_symlink ( source , link_name ) : os_symlink = getattr ( os , \"symlink\" , None ) if isinstance ( os_symlink , collections . Callable ) : os_symlink ( source , link_name ) else : import ctypes csl = ctypes . windll . kernel32 . CreateSymbolicLinkW csl . argtypes = ( ctypes . c_wchar_p , ctypes . c_wchar_p , ctypes . c_uint32 ) csl . restype = ctypes . c_ubyte flags = 1 if os . path . isdir ( source ) else 0 if csl ( link_name , source , flags ) == 0 : raise ctypes . WinError ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates background color [CODESPLIT] def _update_bordercolor ( self , bordercolor ) : border_color = wx . SystemSettings_GetColour ( wx . SYS_COLOUR_ACTIVEBORDER ) border_color . SetRGB ( bordercolor ) self . linecolor_choice . SetColour ( border_color )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Try to convert variables into datatypes . [CODESPLIT] def autoconvert ( string ) : for fn in ( boolify , int , float ) : try : return fn ( string ) except ValueError : pass return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create database connection use TraceCursor as the cursor_factory . [CODESPLIT] def connect ( * args , * * kwargs ) : kwargs [ 'cursor_factory' ] = TraceCursor conn = pg_connect ( * args , * * kwargs ) return conn", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the screen resolution of the primary screen . [CODESPLIT] def get_screen_resolution ( self ) : widget = QDesktopWidget ( ) geometry = widget . availableGeometry ( widget . primaryScreen ( ) ) return geometry . width ( ) , geometry . height ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a tuple into a range with error handling . [CODESPLIT] def from_tuple ( tup ) : if len ( tup ) not in ( 2 , 3 ) : raise ValueError ( 'tuple must contain 2 or 3 elements, not: %d (%r' % ( len ( tup ) , tup , ) , ) return range ( * tup )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Trim a PIL image and remove white space . [CODESPLIT] def _trim ( image ) : background = PIL . Image . new ( image . mode , image . size , image . getpixel ( ( 0 , 0 ) ) ) diff = PIL . ImageChops . difference ( image , background ) diff = PIL . ImageChops . add ( diff , diff , 2.0 , - 100 ) bbox = diff . getbbox ( ) if bbox : image = image . crop ( bbox ) return image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a ctypes int pointer array to a numpy array . [CODESPLIT] def cint8_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int8 ) ) : return np . fromiter ( cptr , dtype = np . int8 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Submit an operation [CODESPLIT] def submit ( self , fn , * args , * * kwargs ) : corofn = asyncio . coroutine ( lambda : fn ( * args , * * kwargs ) ) return run_coroutine_threadsafe ( corofn ( ) , self . loop )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Imports from javascript source file . globals is your globals () [CODESPLIT] def import_js ( path , lib_name , globals ) : with codecs . open ( path_as_local ( path ) , \"r\" , \"utf-8\" ) as f : js = f . read ( ) e = EvalJs ( ) e . execute ( js ) var = e . context [ 'var' ] globals [ lib_name ] = var . to_python ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns an ExpMatrix containing all pairwise sample correlations . [CODESPLIT] def sample_correlations ( self ) : C = np . corrcoef ( self . X . T ) corr_matrix = ExpMatrix ( genes = self . samples , samples = self . samples , X = C ) return corr_matrix", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generates a count of the number of times each unique item appears in a list [CODESPLIT] def count_list ( the_list ) : count = the_list . count result = [ ( item , count ( item ) ) for item in set ( the_list ) ] result . sort ( ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Maxheap version of a heappop . [CODESPLIT] def heappop_max ( heap ) : lastelt = heap . pop ( ) # raises appropriate IndexError if heap is empty if heap : returnitem = heap [ 0 ] heap [ 0 ] = lastelt _siftup_max ( heap , 0 ) return returnitem return lastelt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check code coverage quickly with the default Python [CODESPLIT] def coverage ( ) : run ( \"coverage run --source {PROJECT_NAME} -m py.test\" . format ( PROJECT_NAME = PROJECT_NAME ) ) run ( \"coverage report -m\" ) run ( \"coverage html\" ) webbrowser . open ( 'file://' + os . path . realpath ( \"htmlcov/index.html\" ) , new = 2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This class overrides this method [CODESPLIT] def action ( self ) : self . return_value = self . function ( * self . args , * * self . kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string of bytes into an integer as per X9 . 62 . [CODESPLIT] def string_to_int ( s ) : result = 0 for c in s : if not isinstance ( c , int ) : c = ord ( c ) result = 256 * result + c return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Populates the ListView with a string list . [CODESPLIT] def new_from_list ( cls , items , * * kwargs ) : obj = cls ( * * kwargs ) for item in items : obj . append ( ListItem ( item ) ) return obj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets a naive datetime from a datetime . [CODESPLIT] def get_naive ( dt ) : if not dt . tzinfo : return dt if hasattr ( dt , \"asdatetime\" ) : return dt . asdatetime ( ) return dt . replace ( tzinfo = None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Build the header [CODESPLIT] def format_op_hdr ( ) : txt = 'Base Filename' . ljust ( 36 ) + ' ' txt += 'Lines' . rjust ( 7 ) + ' ' txt += 'Words' . rjust ( 7 ) + '  ' txt += 'Unique' . ljust ( 8 ) + '' return txt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Override method to set a value to show it as 0 to 100 . [CODESPLIT] def setValue ( self , p_float ) : p_float = p_float * 100 super ( PercentageSpinBox , self ) . setValue ( p_float )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get adjacency matrix . [CODESPLIT] def get_adjacent_matrix ( self ) : edges = self . edges num_edges = len ( edges ) + 1 adj = np . zeros ( [ num_edges , num_edges ] ) for k in range ( num_edges - 1 ) : adj [ edges [ k ] . L , edges [ k ] . R ] = 1 adj [ edges [ k ] . R , edges [ k ] . L ] = 1 return adj", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param value : Some value in a dataset . : type value : varies : return : unicode representation of that value : rtype : unicode [CODESPLIT] def format_arg ( value ) : translator = repr if isinstance ( value , six . string_types ) else six . text_type return translator ( value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts from hex to hsv [CODESPLIT] def hex_to_hsv ( color ) : color = normalize ( color ) color = color [ 1 : ] # color=tuple(ord(c)/255.0 for c in color.decode('hex')) color = ( int ( color [ 0 : 2 ] , base = 16 ) / 255.0 , int ( color [ 2 : 4 ] , base = 16 ) / 255.0 , int ( color [ 4 : 6 ] , base = 16 ) / 255.0 ) return colorsys . rgb_to_hsv ( * color )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create Postgres schema script and execute it on cursor [CODESPLIT] def create_db_schema ( cls , cur , schema_name ) : create_schema_script = \"CREATE SCHEMA {0} ;\\n\" . format ( schema_name ) cur . execute ( create_schema_script )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create 2D rotation matrix [CODESPLIT] def create_rot2d ( angle ) : ca = math . cos ( angle ) sa = math . sin ( angle ) return np . array ( [ [ ca , - sa ] , [ sa , ca ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a n + 1 dim one - hot array from n dim int - categorical array . [CODESPLIT] def one_hot ( x , size , dtype = np . float32 ) : return np . array ( x [ ... , np . newaxis ] == np . arange ( size ) , dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "position in 3d space [CODESPLIT] def list ( self ) : return [ self . _pos3d . x , self . _pos3d . y , self . _pos3d . z ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generates an mxn sparse d matrix with round ( a * m * n ) nonzeros . [CODESPLIT] def sp_rand ( m , n , a ) : if m == 0 or n == 0 : return spmatrix ( [ ] , [ ] , [ ] , ( m , n ) ) nnz = min ( max ( 0 , int ( round ( a * m * n ) ) ) , m * n ) nz = matrix ( random . sample ( range ( m * n ) , nnz ) , tc = 'i' ) return spmatrix ( normal ( nnz , 1 ) , nz % m , matrix ( [ int ( ii ) for ii in nz / m ] ) , ( m , n ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a new table . [CODESPLIT] def append_table ( self , name , * * kwargs ) : self . stack . append ( Table ( name , * * kwargs ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is responsible for building the viewer s UI . It should place the UI in container . Override this to make a custom UI . [CODESPLIT] def build_gui ( self , container ) : vbox = Widgets . VBox ( ) vbox . set_border_width ( 0 ) w = Viewers . GingaViewerWidget ( viewer = self ) vbox . add_widget ( w , stretch = 1 ) # need to put this in an hbox with an expanding label or the # browser wants to resize the canvas, distorting it hbox = Widgets . HBox ( ) hbox . add_widget ( vbox , stretch = 0 ) hbox . add_widget ( Widgets . Label ( '' ) , stretch = 1 ) container . set_widget ( hbox )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return time in milliseconds from start_time [CODESPLIT] def timespan ( start_time ) : timespan = datetime . datetime . now ( ) - start_time timespan_ms = timespan . total_seconds ( ) * 1000 return timespan_ms", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add object to local and app environment storage [CODESPLIT] def add_object ( self , obj ) : if obj . top_level_object : if isinstance ( obj , DotNetNamespace ) : self . namespaces [ obj . name ] = obj self . objects [ obj . id ] = obj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print security object information for a pdf document [CODESPLIT] def security ( self ) : return { k : v for i in self . pdf . resolvedObjects . items ( ) for k , v in i [ 1 ] . items ( ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a column of the given matrix . [CODESPLIT] def get_column ( self , X , column ) : if isinstance ( X , pd . DataFrame ) : return X [ column ] . values return X [ : , column ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve the next row . [CODESPLIT] def next ( self ) : # I'm pretty sure this is the completely wrong way to go about this, but # oh well, this works. if not hasattr ( self , '_iter' ) : self . _iter = self . readrow_as_dict ( ) return self . _iter . next ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Move datetime 1 year in the chosen direction . unit is a no - op to keep the API the same as the day case [CODESPLIT] def move_datetime_year ( dt , direction , num_shifts ) : delta = relativedelta ( years = + num_shifts ) return _move_datetime ( dt , direction , delta )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Copy [CODESPLIT] def getBuffer ( x ) : b = bytes ( x ) return ( c_ubyte * len ( b ) ) . from_buffer_copy ( bytes ( x ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a ctypes int pointer array to a numpy array . [CODESPLIT] def cint8_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int8 ) ) : return np . fromiter ( cptr , dtype = np . int8 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Put curly brackets round an indented text [CODESPLIT] def dumped ( text , level , indent = 2 ) : return indented ( \"{\\n%s\\n}\" % indented ( text , level + 1 , indent ) or \"None\" , level , indent ) + \"\\n\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a ctypes float pointer array to a numpy array . [CODESPLIT] def cfloat32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_float ) ) : return np . fromiter ( cptr , dtype = np . float32 , count = length ) else : raise RuntimeError ( 'Expected float pointer' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a python string to C string . [CODESPLIT] def c_str ( string ) : if not isinstance ( string , str ) : string = string . decode ( 'ascii' ) return ctypes . c_char_p ( string . encode ( 'utf-8' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "writes the line and count newlines after the line [CODESPLIT] def write_line ( self , line , count = 1 ) : self . write ( line ) self . write_newlines ( count )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a ctypes int pointer array to a numpy array . [CODESPLIT] def cint8_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int8 ) ) : return np . fromiter ( cptr , dtype = np . int8 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Implements the context manager protocol . Specially useful for asserting exceptions [CODESPLIT] def __enter__ ( self ) : clone = self . clone ( ) self . _contexts . append ( clone ) self . reset ( ) return self", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get adjacency matrix . [CODESPLIT] def get_adjacent_matrix ( self ) : edges = self . edges num_edges = len ( edges ) + 1 adj = np . zeros ( [ num_edges , num_edges ] ) for k in range ( num_edges - 1 ) : adj [ edges [ k ] . L , edges [ k ] . R ] = 1 adj [ edges [ k ] . R , edges [ k ] . L ] = 1 return adj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return BGR image read by opencv [CODESPLIT] def imdecode ( image_path ) : import os assert os . path . exists ( image_path ) , image_path + ' not found' im = cv2 . imread ( image_path ) return im", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates col_widths in code_array [CODESPLIT] def _xls2col_widths ( self , worksheet , tab ) : for col in xrange ( worksheet . ncols ) : try : xls_width = worksheet . colinfo_map [ col ] . width pys_width = self . xls_width2pys_width ( xls_width ) self . code_array . col_widths [ col , tab ] = pys_width except KeyError : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace month strings occurrences with month number . [CODESPLIT] def replace_month_abbr_with_num ( date_str , lang = DEFAULT_DATE_LANG ) : num , abbr = get_month_from_date_str ( date_str , lang ) return re . sub ( abbr , str ( num ) , date_str , flags = re . IGNORECASE )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts Timestamp to datetime . [CODESPLIT] def ToDatetime ( self ) : return datetime . utcfromtimestamp ( self . seconds + self . nanos / float ( _NANOS_PER_SECOND ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Max reduction op . [CODESPLIT] def Max ( a , axis , keep_dims ) : return np . amax ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate angle between two vectors [CODESPLIT] def vec_angle ( a , b ) : cosang = np . dot ( a , b ) sinang = fast_norm ( np . cross ( a , b ) ) return np . arctan2 ( sinang , cosang )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "date to unix timestamp in milliseconds [CODESPLIT] def date_to_timestamp ( date ) : date_tuple = date . timetuple ( ) timestamp = calendar . timegm ( date_tuple ) * 1000 return timestamp", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap text in an ansi escape sequence [CODESPLIT] def ansi ( color , text ) : code = COLOR_CODES [ color ] return '\\033[1;{0}m{1}{2}' . format ( code , text , RESET_TERM )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert raw input value of the field . [CODESPLIT] def _converter ( self , value ) : if not isinstance ( value , datetime . date ) : raise TypeError ( '{0} is not valid date' . format ( value ) ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets a new value to map element [CODESPLIT] def set_as_object ( self , value ) : self . clear ( ) map = MapConverter . to_map ( value ) self . append ( map )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a UTC datetime to a Unix timestamp [CODESPLIT] def datetime_to_timestamp ( dt ) : delta = dt - datetime . utcfromtimestamp ( 0 ) return delta . seconds + delta . days * 24 * 3600", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a string and dictionary . replaces all occurrences of i with j [CODESPLIT] def replace_all ( text , dic ) : for i , j in dic . iteritems ( ) : text = text . replace ( i , j ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts datetimeoffset object into Python s datetime . datetime object [CODESPLIT] def to_pydatetime ( self ) : dt = datetime . datetime . combine ( self . _date . to_pydate ( ) , self . _time . to_pytime ( ) ) from . tz import FixedOffsetTimezone return dt . replace ( tzinfo = _utc ) . astimezone ( FixedOffsetTimezone ( self . _offset ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize the string according to normalization list [CODESPLIT] def normalize ( self , string ) : return '' . join ( [ self . _normalize . get ( x , x ) for x in nfd ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts python datetime to epoch microseconds . [CODESPLIT] def _DateToEpoch ( date ) : tz_zero = datetime . datetime . utcfromtimestamp ( 0 ) diff_sec = int ( ( date - tz_zero ) . total_seconds ( ) ) return diff_sec * 1000000", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Enable the download log filter . [CODESPLIT] def __enter__ ( self ) : self . logger = logging . getLogger ( 'pip.download' ) self . logger . addFilter ( self )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple function to convert naive : std : datetime . datetime object containing local time to a naive : std : datetime . datetime object with UTC time . [CODESPLIT] def datetime_local_to_utc ( local ) : timestamp = time . mktime ( local . timetuple ( ) ) return datetime . datetime . utcfromtimestamp ( timestamp )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts Timestamp to datetime . [CODESPLIT] def ToDatetime ( self ) : return datetime . utcfromtimestamp ( self . seconds + self . nanos / float ( _NANOS_PER_SECOND ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve the previous quarter for dt [CODESPLIT] def previous_quarter ( d ) : from django_toolkit . datetime_util import quarter as datetime_quarter return quarter ( ( datetime_quarter ( datetime ( d . year , d . month , d . day ) ) [ 0 ] + timedelta ( days = - 1 ) ) . date ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This will equal 124 for the V1 database . [CODESPLIT] def __len__ ( self ) : length = 0 for typ , siz , _ in self . format : length += siz return length", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string of bytes into an integer as per X9 . 62 . [CODESPLIT] def string_to_int ( s ) : result = 0 for c in s : if not isinstance ( c , int ) : c = ord ( c ) result = 256 * result + c return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if the given value is a scalar . [CODESPLIT] def is_scalar ( value ) : return np . isscalar ( value ) or ( isinstance ( value , np . ndarray ) and ( len ( np . squeeze ( value ) . shape ) == 0 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove duplicates from list while preserving order . [CODESPLIT] def purge_duplicates ( list_in ) : _list = [ ] for item in list_in : if item not in _list : _list . append ( item ) return _list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A function that works for both Python 2 . x and Python 3 . x . It asks the user for input and returns it as a string . [CODESPLIT] def input_int_default ( question = \"\" , default = 0 ) : answer = input_string ( question ) if answer == \"\" or answer == \"yes\" : return default else : return int ( answer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "manually set the default figure size of plots :: Arguments :: x ( float ) : x - axis size y ( float ) : y - axis size aspect ( float ) : aspect ratio scalar [CODESPLIT] def figsize ( x = 8 , y = 7. , aspect = 1. ) : # update rcparams with adjusted figsize params mpl . rcParams . update ( { 'figure.figsize' : ( x * aspect , y ) } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator to explicitly mark functions that are exposed in a lib . [CODESPLIT] def export ( defn ) : globals ( ) [ defn . __name__ ] = defn __all__ . append ( defn . __name__ ) return defn", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": API : public [CODESPLIT] def assert_list ( self , putative_list , expected_type = string_types , key_arg = None ) : return assert_list ( putative_list , expected_type , key_arg = key_arg , raise_type = lambda msg : TargetDefinitionException ( self , msg ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove instance from instance list [CODESPLIT] def pop ( ) : pid = os . getpid ( ) thread = threading . current_thread ( ) Wdb . _instances . pop ( ( pid , thread ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete a directory if it s present . If it s not present no - op . [CODESPLIT] def safe_rmtree ( directory ) : if os . path . exists ( directory ) : shutil . rmtree ( directory , True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to add timezone information to datetime so that datetime is comparable to other datetime objects in recent versions that now also have timezone information . [CODESPLIT] def datetime_from_timestamp ( timestamp , content ) : return set_date_tzinfo ( datetime . fromtimestamp ( timestamp ) , tz_name = content . settings . get ( 'TIMEZONE' , None ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove the value found at key from the queue [CODESPLIT] def remove ( self , key ) : item = self . item_finder . pop ( key ) item [ - 1 ] = None self . removed_count += 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transpose the columns into rows remove all of the rows that are empty after the first cell then transpose back . The result is that columns that have a header but no data in the body are removed assuming the header is the first row . [CODESPLIT] def drop_empty ( rows ) : return zip ( * [ col for col in zip ( * rows ) if bool ( filter ( bool , col [ 1 : ] ) ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a python file and returns a awslambda . Code object : param python_file : : return : [CODESPLIT] def lambda_from_file ( python_file ) : lambda_function = [ ] with open ( python_file , 'r' ) as f : lambda_function . extend ( f . read ( ) . splitlines ( ) ) return awslambda . Code ( ZipFile = ( Join ( '\\n' , lambda_function ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates requests session user - agent with the driver s user agent [CODESPLIT] def copy_user_agent_from_driver ( self ) : selenium_user_agent = self . driver . execute_script ( \"return navigator.userAgent;\" ) self . headers . update ( { \"user-agent\" : selenium_user_agent } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show the x - axis tick labels for a subplot . [CODESPLIT] def show_xticklabels ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . show_xticklabels ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Populate axis limits GUI with current plot values . [CODESPLIT] def set_xlimits_widgets ( self , set_min = True , set_max = True ) : xmin , xmax = self . tab_plot . ax . get_xlim ( ) if set_min : self . w . x_lo . set_text ( '{0}' . format ( xmin ) ) if set_max : self . w . x_hi . set_text ( '{0}' . format ( xmax ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if the socket managed by this connection is connected [CODESPLIT] def is_connected ( self ) : try : return self . socket is not None and self . socket . getsockname ( ) [ 1 ] != 0 and BaseTransport . is_connected ( self ) except socket . error : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get longitudes from cartesian coordinates . [CODESPLIT] def get_lons_from_cartesian ( x__ , y__ ) : return rad2deg ( arccos ( x__ / sqrt ( x__ ** 2 + y__ ** 2 ) ) ) * sign ( y__ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Swap i and j rows [CODESPLIT] def _swap_rows ( self , i , j ) : L = np . eye ( 3 , dtype = 'intc' ) L [ i , i ] = 0 L [ j , j ] = 0 L [ i , j ] = 1 L [ j , i ] = 1 self . _L . append ( L . copy ( ) ) self . _A = np . dot ( L , self . _A )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determines if a system process identifer exists in process table . [CODESPLIT] def pid_exists ( pid ) : try : os . kill ( pid , 0 ) except OSError as exc : return exc . errno == errno . EPERM else : return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Guess extraction method given file name ( or path ) . [CODESPLIT] def _guess_extract_method ( fname ) : for method , extensions in _EXTRACTION_METHOD_TO_EXTS : for ext in extensions : if fname . endswith ( ext ) : return method return ExtractMethod . NO_EXTRACT", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add dots . [CODESPLIT] def _dotify ( cls , data ) : return '' . join ( char if char in cls . PRINTABLE_DATA else '.' for char in data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "x is a 2D sparse matrix with it s first shape equal to 1 . [CODESPLIT] def is_sparse_vector ( x ) : return sp . issparse ( x ) and len ( x . shape ) == 2 and x . shape [ 0 ] == 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compiles to native Python bytecode and runs program returning the topmost value on the stack . [CODESPLIT] def xeval ( source , optimize = True ) : native = xcompile ( source , optimize = optimize ) return native ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether the provided value is a valid enum constant . [CODESPLIT] def check ( self , var ) : if not isinstance ( var , _str_type ) : return False return _enum_mangle ( var ) in self . _consts", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given data points data where axis 0 is considered to delineate points return an generator for sets of bootstrap indexes . This can be used as a list of bootstrap indexes ( with list ( bootstrap_indexes ( data ))) as well . [CODESPLIT] def bootstrap_indexes ( data , n_samples = 10000 ) : for _ in xrange ( n_samples ) : yield randint ( data . shape [ 0 ] , size = ( data . shape [ 0 ] , ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if all the args are functions and / or subroutines [CODESPLIT] def is_callable ( * p ) : import symbols return all ( isinstance ( x , symbols . FUNCTION ) for x in p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get all instances matching a tag . [CODESPLIT] def _aws_get_instance_by_tag ( region , name , tag , raw ) : client = boto3 . session . Session ( ) . client ( 'ec2' , region ) matching_reservations = client . describe_instances ( Filters = [ { 'Name' : tag , 'Values' : [ name ] } ] ) . get ( 'Reservations' , [ ] ) instances = [ ] [ [ instances . append ( _aws_instance_from_dict ( region , instance , raw ) ) # pylint: disable=expression-not-assigned for instance in reservation . get ( 'Instances' ) ] for reservation in matching_reservations if reservation ] return instances", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the path to the javascript bundle [CODESPLIT] def default_static_path ( ) : fdir = os . path . dirname ( __file__ ) return os . path . abspath ( os . path . join ( fdir , '../assets/' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the display length of a string . This can differ from the character length if the string contains wide characters . [CODESPLIT] def display_len ( text ) : text = unicodedata . normalize ( 'NFD' , text ) return sum ( char_width ( char ) for char in text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute boxplot for given pandas Series . [CODESPLIT] def compute_boxplot ( self , series ) : from matplotlib . cbook import boxplot_stats series = series [ series . notnull ( ) ] if len ( series . values ) == 0 : return { } elif not is_numeric_dtype ( series ) : return self . non_numeric_stats ( series ) stats = boxplot_stats ( list ( series . values ) ) [ 0 ] stats [ 'count' ] = len ( series . values ) stats [ 'fliers' ] = \"|\" . join ( map ( str , stats [ 'fliers' ] ) ) return stats", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns true if the guessed mimetyped isnt t in text group . [CODESPLIT] def IsBinary ( self , filename ) : mimetype = mimetypes . guess_type ( filename ) [ 0 ] if not mimetype : return False # e.g. README, \"real\" binaries usually have an extension # special case for text files which don't start with text/ if mimetype in TEXT_MIMETYPES : return False return not mimetype . startswith ( \"text/\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "if the value is in the list move it to the front and return it . [CODESPLIT] def list_move_to_front ( l , value = 'other' ) : l = list ( l ) if value in l : l . remove ( value ) l . insert ( 0 , value ) return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a JSSObject for the element with ID id_ [CODESPLIT] def retrieve_by_id ( self , id_ ) : items_with_id = [ item for item in self if item . id == int ( id_ ) ] if len ( items_with_id ) == 1 : return items_with_id [ 0 ] . retrieve ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove null items from a dictionary [CODESPLIT] def purge_dict ( idict ) : odict = { } for key , val in idict . items ( ) : if is_null ( val ) : continue odict [ key ] = val return odict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Install RPM Python binding . [CODESPLIT] def install_rpm_py ( ) : python_path = sys . executable cmd = '{0} install.py' . format ( python_path ) exit_status = os . system ( cmd ) if exit_status != 0 : raise Exception ( 'Command failed: {0}' . format ( cmd ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "update () extends rather than replaces existing key lists . [CODESPLIT] def update ( self , other_dict ) : for key , value in iter_multi_items ( other_dict ) : MultiDict . add ( self , key , value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert an OrderedDict containing C values to a 1D array . [CODESPLIT] def C_dict2array ( C ) : return np . hstack ( [ np . asarray ( C [ k ] ) . ravel ( ) for k in C_keys ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transforms the regular socket . socket to an ssl . SSLSocket for secure connections . Any arguments are passed to ssl . wrap_socket : http : // docs . python . org / dev / library / ssl . html#ssl . wrap_socket [CODESPLIT] def enable_ssl ( self , * args , * * kwargs ) : if self . handshake_sent : raise SSLError ( 'can only enable SSL before handshake' ) self . secure = True self . sock = ssl . wrap_socket ( self . sock , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert time into C style timeval . [CODESPLIT] def convert_timeval ( seconds_since_epoch ) : frac , whole = math . modf ( seconds_since_epoch ) microseconds = math . floor ( frac * 1000000 ) seconds = math . floor ( whole ) return seconds , microseconds", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a copy of the dictionary . [CODESPLIT] def copy ( self ) : result = NocaseDict ( ) result . _data = self . _data . copy ( ) # pylint: disable=protected-access return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Annual growth given growth from start date to end date . [CODESPLIT] def growthfromrange ( rangegrowth , startdate , enddate ) : _yrs = ( pd . Timestamp ( enddate ) - pd . Timestamp ( startdate ) ) . total_seconds ( ) / dt . timedelta ( 365.25 ) . total_seconds ( ) return yrlygrowth ( rangegrowth , _yrs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Makes the given dictionary symmetric . Values are assumed to be unique . [CODESPLIT] def make_symmetric ( dict ) : for key , value in list ( dict . items ( ) ) : dict [ value ] = key return dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Double Exponential Moving Average . [CODESPLIT] def double_exponential_moving_average ( data , period ) : catch_errors . check_for_period_error ( data , period ) dema = ( 2 * ema ( data , period ) ) - ema ( ema ( data , period ) , period ) return dema", "target": 1, "target_options": ["no_match", "match"]}
{"input": "pops multiple keys off a dict like object [CODESPLIT] def multi_pop ( d , * args ) : retval = { } for key in args : if key in d : retval [ key ] = d . pop ( key ) return retval", "target": 1, "target_options": ["no_match", "match"]}
{"input": "inverse hyperbolic sine transformation [CODESPLIT] def inh ( table ) : t = [ ] for i in table : t . append ( np . ndarray . tolist ( np . arcsinh ( i ) ) ) return t", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalizes the given vector . The vector given may have any number of dimensions . [CODESPLIT] def v_normalize ( v ) : vmag = v_magnitude ( v ) return [ v [ i ] / vmag for i in range ( len ( v ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "dict . update but which merges child dicts ( dict2 takes precedence where there s conflict ) . [CODESPLIT] def recursively_update ( d , d2 ) : for k , v in d2 . items ( ) : if k in d : if isinstance ( v , dict ) : recursively_update ( d [ k ] , v ) continue d [ k ] = v", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The number of days in the month of the given date [CODESPLIT] def _days_in_month ( date ) : if date . month == 12 : reference = type ( date ) ( date . year + 1 , 1 , 1 ) else : reference = type ( date ) ( date . year , date . month + 1 , 1 ) return ( reference - timedelta ( days = 1 ) ) . day", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Count the number of rows in 2D arrays that contain any nan values . [CODESPLIT] def count_rows_with_nans ( X ) : if X . ndim == 2 : return np . where ( np . isnan ( X ) . sum ( axis = 1 ) != 0 , 1 , 0 ) . sum ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a python string to c array . [CODESPLIT] def c_array ( ctype , values ) : if isinstance ( values , np . ndarray ) and values . dtype . itemsize == ctypes . sizeof ( ctype ) : return ( ctype * len ( values ) ) . from_buffer_copy ( values ) return ( ctype * len ( values ) ) ( * values )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the standard error of a . [CODESPLIT] def stderr ( a ) : return np . nanstd ( a ) / np . sqrt ( sum ( np . isfinite ( a ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns whether a path names an existing directory we can list and read files from . [CODESPLIT] def is_readable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . R_OK ) and os . access ( path , os . X_OK )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Imports from javascript source file . globals is your globals () [CODESPLIT] def import_js ( path , lib_name , globals ) : with codecs . open ( path_as_local ( path ) , \"r\" , \"utf-8\" ) as f : js = f . read ( ) e = EvalJs ( ) e . execute ( js ) var = e . context [ 'var' ] globals [ lib_name ] = var . to_python ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Context manager to temporarily disable certificate validation in the standard SSL library . [CODESPLIT] def disable_cert_validation ( ) : current_context = ssl . _create_default_https_context ssl . _create_default_https_context = ssl . _create_unverified_context try : yield finally : ssl . _create_default_https_context = current_context", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Context manager to temporarily disable certificate validation in the standard SSL library . [CODESPLIT] def disable_cert_validation ( ) : current_context = ssl . _create_default_https_context ssl . _create_default_https_context = ssl . _create_unverified_context try : yield finally : ssl . _create_default_https_context = current_context", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rejects the snapshot and closes the widget . [CODESPLIT] def reject ( self ) : if self . hideWindow ( ) : self . hideWindow ( ) . show ( ) self . close ( ) self . deleteLater ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse an int robustly ignoring commas and other cruft . [CODESPLIT] def robust_int ( v ) : if isinstance ( v , int ) : return v if isinstance ( v , float ) : return int ( v ) v = str ( v ) . replace ( ',' , '' ) if not v : return None return int ( v )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Send data to specified socket . [CODESPLIT] def send ( socket , data , num_bytes = 20 ) : pickled_data = pickle . dumps ( data , - 1 ) length = str ( len ( pickled_data ) ) . zfill ( num_bytes ) socket . sendall ( length . encode ( ) ) socket . sendall ( pickled_data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Separates the real and imaginary parts from the complex number and executes the _trim_zeros_float method on each of those . [CODESPLIT] def _trim_zeros_complex ( str_complexes , na_rep = 'NaN' ) : def separate_and_trim ( str_complex , na_rep ) : num_arr = str_complex . split ( '+' ) return ( _trim_zeros_float ( [ num_arr [ 0 ] ] , na_rep ) + [ '+' ] + _trim_zeros_float ( [ num_arr [ 1 ] [ : - 1 ] ] , na_rep ) + [ 'j' ] ) return [ '' . join ( separate_and_trim ( x , na_rep ) ) for x in str_complexes ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "create a graphviz graph from text [CODESPLIT] def _text_to_graphiz ( self , text ) : dot = Source ( text , format = 'svg' ) return dot . pipe ( ) . decode ( 'utf-8' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert snake_case to camel_case . [CODESPLIT] def to_identifier ( s ) : if s . startswith ( 'GPS' ) : s = 'Gps' + s [ 3 : ] return '' . join ( [ i . capitalize ( ) for i in s . split ( '_' ) ] ) if '_' in s else s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get screen width and height [CODESPLIT] def display ( self ) : w , h = self . session . window_size ( ) return Display ( w * self . scale , h * self . scale )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert snake case string to camel case . [CODESPLIT] def _snake_to_camel_case ( value ) : words = value . split ( \"_\" ) return words [ 0 ] + \"\" . join ( map ( str . capitalize , words [ 1 : ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "consider the distance between two mapPoints ignoring all terrain pathing issues [CODESPLIT] def direct2dDistance ( self , point ) : if not isinstance ( point , MapPoint ) : return 0.0 return ( ( self . x - point . x ) ** 2 + ( self . y - point . y ) ** 2 ) ** ( 0.5 ) # simple distance formula", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert snake case string to camel case . [CODESPLIT] def _snake_to_camel_case ( value ) : words = value . split ( \"_\" ) return words [ 0 ] + \"\" . join ( map ( str . capitalize , words [ 1 : ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convenience method for deleting a model ( automatically commits the delete to the database and returns with an HTTP 204 status code ) [CODESPLIT] def deleted ( self , instance ) : self . session_manager . delete ( instance , commit = True ) return '' , HTTPStatus . NO_CONTENT", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert snake_case to camel_case . [CODESPLIT] def to_identifier ( s ) : if s . startswith ( 'GPS' ) : s = 'Gps' + s [ 3 : ] return '' . join ( [ i . capitalize ( ) for i in s . split ( '_' ) ] ) if '_' in s else s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show image ( item is a PIL image ) [CODESPLIT] def show_image ( self , key ) : data = self . model . get_data ( ) data [ key ] . show ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs command and returns the output as string . [CODESPLIT] def check_output ( args ) : log . debug ( 'run: %s' , args ) out = subprocess . check_output ( args = args ) . decode ( 'utf-8' ) log . debug ( 'out: %r' , out ) return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check that the page title matches the given one . [CODESPLIT] def page_title ( step , title ) : with AssertContextManager ( step ) : assert_equals ( world . browser . title , title )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Hacked run function which installs the trace . [CODESPLIT] def __run ( self ) : sys . settrace ( self . globaltrace ) self . __run_backup ( ) self . run = self . __run_backup", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse the command line and run : func : migrate . [CODESPLIT] def main ( ) : parser = get_args_parser ( ) args = parser . parse_args ( ) config = Config . from_parse_args ( args ) migrate ( config )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The function compares strings ignoring case [CODESPLIT] def is_equal_strings_ignore_case ( first , second ) : if first and second : return first . upper ( ) == second . upper ( ) else : return not ( first or second )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Requests - mock requests . post wrapper . [CODESPLIT] def requests_post ( url , data = None , json = None , * * kwargs ) : return requests_request ( 'post' , url , data = data , json = json , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Merge migrations into one . [CODESPLIT] def merge ( database = None , directory = None , verbose = None ) : router = get_router ( directory , database , verbose ) router . merge ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deserializes string to date . [CODESPLIT] def deserialize_date ( string ) : try : from dateutil . parser import parse return parse ( string ) . date ( ) except ImportError : return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add params to doc string [CODESPLIT] def _add_params_docstring ( params ) : p_string = \"\\nAccepts the following paramters: \\n\" for param in params : p_string += \"name: %s, required: %s, description: %s \\n\" % ( param [ 'name' ] , param [ 'required' ] , param [ 'description' ] ) return p_string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simply logs a warning if the desired enum value is not found . [CODESPLIT] def from_string ( cls , string ) : # find enum value for attr in dir ( cls ) : value = getattr ( cls , attr ) if value == string : return value # if not found, log warning and return the value passed in logger . warning ( \"{} is not a valid enum value for {}.\" . format ( string , cls . __name__ ) ) return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a section a subsection and some text to the document . [CODESPLIT] def fill_document ( doc ) : with doc . create ( Section ( 'A section' ) ) : doc . append ( 'Some regular text and some ' ) doc . append ( italic ( 'italic text. ' ) ) with doc . create ( Subsection ( 'A subsection' ) ) : doc . append ( 'Also some crazy characters: $&#{}' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print a dictionary of attributes in the DOT format [CODESPLIT] def _attrprint ( d , delimiter = ', ' ) : return delimiter . join ( ( '\"%s\"=\"%s\"' % item ) for item in sorted ( d . items ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call Java Function [CODESPLIT] def callJavaFunc ( func , * args ) : gateway = _get_gateway ( ) args = [ _py2java ( gateway , a ) for a in args ] result = func ( * args ) return _java2py ( gateway , result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts text that may be camelcased into an underscored format [CODESPLIT] def underscore ( text ) : return UNDERSCORE [ 1 ] . sub ( r'\\1_\\2' , UNDERSCORE [ 0 ] . sub ( r'\\1_\\2' , text ) ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Attempts to convert given object to a string object [CODESPLIT] def to_str ( obj ) : if not isinstance ( obj , str ) and PY3 and isinstance ( obj , bytes ) : obj = obj . decode ( 'utf-8' ) return obj if isinstance ( obj , string_types ) else str ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator to ensure the given snake_case method is also written in UpperCamelCase in the given namespace . That was mainly written to avoid confusion when using wxPython and its UpperCamelCaseMethods . [CODESPLIT] def ucamel_method ( func ) : frame_locals = inspect . currentframe ( ) . f_back . f_locals frame_locals [ snake2ucamel ( func . __name__ ) ] = func return func", "target": 1, "target_options": ["no_match", "match"]}
{"input": "sets the aspect ratio of the current zoom level of the imshow image [CODESPLIT] def image_set_aspect ( aspect = 1.0 , axes = \"gca\" ) : if axes is \"gca\" : axes = _pylab . gca ( ) e = axes . get_images ( ) [ 0 ] . get_extent ( ) axes . set_aspect ( abs ( ( e [ 1 ] - e [ 0 ] ) / ( e [ 3 ] - e [ 2 ] ) ) / aspect )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The minimal ~photutils . aperture . BoundingBox for the cutout region with respect to the original ( large ) image . [CODESPLIT] def bbox ( self ) : return BoundingBox ( self . slices [ 1 ] . start , self . slices [ 1 ] . stop , self . slices [ 0 ] . start , self . slices [ 0 ] . stop )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a string composed of elements in inlist with each element separated by delimiter . Used by function writedelimited . Use \\ t for tab - delimiting . [CODESPLIT] def linedelimited ( inlist , delimiter ) : outstr = '' for item in inlist : if type ( item ) != StringType : item = str ( item ) outstr = outstr + item + delimiter outstr = outstr [ 0 : - 1 ] return outstr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wraps a function to run in a given directory . [CODESPLIT] def change_dir ( directory ) : def cd_decorator ( func ) : @ wraps ( func ) def wrapper ( * args , * * kwargs ) : org_path = os . getcwd ( ) os . chdir ( directory ) func ( * args , * * kwargs ) os . chdir ( org_path ) return wrapper return cd_decorator", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove all non - MagIC columns from all tables . [CODESPLIT] def remove_non_magic_cols ( self ) : for table_name in self . tables : table = self . tables [ table_name ] table . remove_non_magic_cols_from_table ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Forces a parameter value to be text [CODESPLIT] def TextWidget ( * args , * * kw ) : kw [ 'value' ] = str ( kw [ 'value' ] ) kw . pop ( 'options' , None ) return TextInput ( * args , * * kw )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert an array from 0 .. 1 to dtype scaling up linearly [CODESPLIT] def scale_dtype ( arr , dtype ) : max_int = np . iinfo ( dtype ) . max return ( arr * max_int ) . astype ( dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator to explicitly mark functions that are exposed in a lib . [CODESPLIT] def export ( defn ) : globals ( ) [ defn . __name__ ] = defn __all__ . append ( defn . __name__ ) return defn", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shape a list of lists into the appropriate shape and data type [CODESPLIT] def shape_list ( l , shape , dtype ) : return np . array ( l , dtype = dtype ) . reshape ( shape )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tries to encode images with ffmpeg to check if it works . [CODESPLIT] def ffmpeg_works ( ) : images = np . zeros ( ( 2 , 32 , 32 , 3 ) , dtype = np . uint8 ) try : _encode_gif ( images , 2 ) return True except ( IOError , OSError ) : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "When converting Spark SQL records to Pandas DataFrame the inferred data type may be wrong . This method gets the corrected data type for Pandas if that type may be inferred uncorrectly . [CODESPLIT] def _to_corrected_pandas_type ( dt ) : import numpy as np if type ( dt ) == ByteType : return np . int8 elif type ( dt ) == ShortType : return np . int16 elif type ( dt ) == IntegerType : return np . int32 elif type ( dt ) == FloatType : return np . float32 else : return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Searches for a single document in the given index on the name field . Performs a case - insensitive search by utilizing Elasticsearch s match_phrase query . Args : index : str . The name of an Elasticsearch index ( i . e . biosamples ) . name : str . The value of a document s name key to search for . Returns : dict containing the document that was indexed into Elasticsearch . Raises : MultipleHitsException : More than 1 hit is returned . [CODESPLIT] def get_record_by_name ( self , index , name ) : result = self . ES . search ( index = index , body = { \"query\" : { \"match_phrase\" : { \"name\" : name , } } } ) hits = result [ \"hits\" ] [ \"hits\" ] if not hits : return { } elif len ( hits ) == 1 : return hits [ 0 ] [ \"_source\" ] else : # Mult. records found with same prefix. See if a single record whose name attr matches # the match phrase exactly (in a lower-case comparison).   for h in hits : source = h [ \"_source\" ] record_name = source [ \"name\" ] if record_name . lower ( ) . strip ( ) == name . lower ( ) . strip ( ) : return source msg = \"match_phrase search found multiple records matching query '{}' for index '{}'.\" . format ( name , index ) raise MultipleHitsException ( msg )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add an additional DATETIME column with standar datetime format . [CODESPLIT] def add_datetime ( dataframe , timestamp_key = 'UNIXTIME' ) : def convert_data ( timestamp ) : return datetime . fromtimestamp ( float ( timestamp ) / 1e3 , UTC_TZ ) try : log . debug ( \"Adding DATETIME column to the data\" ) converted = dataframe [ timestamp_key ] . apply ( convert_data ) dataframe [ 'DATETIME' ] = converted except KeyError : log . warning ( \"Could not add DATETIME column\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clear all indexes in the es core [CODESPLIT] def clear_es ( ) : # TODO: should receive a catalog slug. ESHypermap . es . indices . delete ( ESHypermap . index_name , ignore = [ 400 , 404 ] ) LOGGER . debug ( 'Elasticsearch: Index cleared' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates requests session user - agent with the driver s user agent [CODESPLIT] def copy_user_agent_from_driver ( self ) : selenium_user_agent = self . driver . execute_script ( \"return navigator.userAgent;\" ) self . headers . update ( { \"user-agent\" : selenium_user_agent } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return ids of all indexed documents . [CODESPLIT] def keys ( self ) : result = [ ] if self . fresh_index is not None : result += self . fresh_index . keys ( ) if self . opt_index is not None : result += self . opt_index . keys ( ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Move datetime 1 year in the chosen direction . unit is a no - op to keep the API the same as the day case [CODESPLIT] def move_datetime_year ( dt , direction , num_shifts ) : delta = relativedelta ( years = + num_shifts ) return _move_datetime ( dt , direction , delta )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get all documents from the given index . [CODESPLIT] def all_documents ( index = INDEX_NAME ) : query = { 'query' : { 'match_all' : { } } } for result in raw_query ( query , index = index ) : yield result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get element by name [CODESPLIT] def get_by ( self , name ) : return next ( ( item for item in self if item . name == name ) , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Softsign op . [CODESPLIT] def Softsign ( a ) : return np . divide ( a , np . add ( np . abs ( a ) , 1 ) ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets the title of the console window . [CODESPLIT] def title ( msg ) : if sys . platform . startswith ( \"win\" ) : ctypes . windll . kernel32 . SetConsoleTitleW ( tounicode ( msg ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If the value is true / false / null replace with Python equivalent . [CODESPLIT] def _extract_value ( self , value ) : return ModelEndpoint . _value_map . get ( smart_str ( value ) . lower ( ) , value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve attr from current active etree implementation [CODESPLIT] def __getattribute__ ( self , attr ) : if ( attr not in object . __getattribute__ ( self , '__dict__' ) and attr not in Etree . __dict__ ) : return object . __getattribute__ ( self . _etree , attr ) return object . __getattribute__ ( self , attr )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decode string encoded by unicode_string [CODESPLIT] def decode_unicode_string ( string ) : if string . startswith ( '[BASE64-DATA]' ) and string . endswith ( '[/BASE64-DATA]' ) : return base64 . b64decode ( string [ len ( '[BASE64-DATA]' ) : - len ( '[/BASE64-DATA]' ) ] ) return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the topmost parent of the current category . [CODESPLIT] def root_parent ( self , category = None ) : return next ( filter ( lambda c : c . is_root , self . hierarchy ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set text value of an etree . Element of tag appending a new element with given tag if it doesn t exist . [CODESPLIT] def add_element_to_doc ( doc , tag , value ) : element = doc . find ( \".//%s\" % tag ) if element is None : element = etree . SubElement ( doc , tag ) element . text = value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check that value is in values [CODESPLIT] def isin ( value , values ) : for i , v in enumerate ( value ) : if v not in np . array ( values ) [ : , i ] : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read helper method [CODESPLIT] def read_from_file ( file_path , encoding = \"utf-8\" ) : with codecs . open ( file_path , \"r\" , encoding ) as f : return f . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if obj is a sequence but not a string or bytes . [CODESPLIT] def is_sequence ( obj ) : return isinstance ( obj , Sequence ) and not ( isinstance ( obj , str ) or BinaryClass . is_valid_type ( obj ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a lowercased string with non alphabetic chars removed . [CODESPLIT] def _to_lower_alpha_only ( s ) : s = re . sub ( r'\\n' , ' ' , s . lower ( ) ) return re . sub ( r'[^a-z\\s]' , '' , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check that value is in values [CODESPLIT] def isin ( value , values ) : for i , v in enumerate ( value ) : if v not in np . array ( values ) [ : , i ] : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "An enum is encoded by a int representing the zero - based position of the symbol in the schema . [CODESPLIT] def write_enum ( fo , datum , schema ) : index = schema [ 'symbols' ] . index ( datum ) write_int ( fo , index )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute a python code object in the given environment . [CODESPLIT] def exec_function ( ast , globals_map ) : locals_map = globals_map exec ast in globals_map , locals_map return locals_map", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if the json_element passed is present for the task specified . [CODESPLIT] def task_property_present_predicate ( service , task , prop ) : try : response = get_service_task ( service , task ) except Exception as e : pass return ( response is not None ) and ( prop in response )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit without garbage collection this speeds up exit by about 10ms for things like bash completion . [CODESPLIT] def fast_exit ( code ) : sys . stdout . flush ( ) sys . stderr . flush ( ) os . _exit ( code )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks whether a variable is a numpy float array . [CODESPLIT] def is_float_array ( val ) : return is_np_array ( val ) and issubclass ( val . dtype . type , np . floating )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prepares given parameters to be used in querystring . [CODESPLIT] def prepare_query_params ( * * kwargs ) : return [ ( sub_key , sub_value ) for key , value in kwargs . items ( ) for sub_key , sub_value in expand ( value , key ) if sub_value is not None ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Expands all environment variables in a settings dictionary . [CODESPLIT] def expandvars_dict ( settings ) : return dict ( ( key , os . path . expandvars ( value ) ) for key , value in settings . iteritems ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get indent of text . https : // stackoverflow . com / questions / 2268532 / grab - a - lines - whitespace - indention - with - python [CODESPLIT] def get_indent ( text ) : indent = '' ret = re . match ( r'(\\s*)' , text ) if ret : indent = ret . group ( 1 ) return indent", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if the given thing represents a date [CODESPLIT] def is_date ( thing ) : # known date types date_types = ( datetime . datetime , datetime . date , DateTime ) return isinstance ( thing , date_types )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return True if callback is a vanilla plain jane function [CODESPLIT] def is_function ( self ) : if self . is_instance ( ) or self . is_class ( ) : return False return isinstance ( self . callback , ( Callable , classmethod ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test whether the current python environment is the correct lore env . [CODESPLIT] def launched ( ) : if not PREFIX : return False return os . path . realpath ( sys . prefix ) == os . path . realpath ( PREFIX )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the available ffmpeg version [CODESPLIT] def ffmpeg_version ( ) : cmd = [ 'ffmpeg' , '-version' ] output = sp . check_output ( cmd ) aac_codecs = [ x for x in output . splitlines ( ) if \"ffmpeg version \" in str ( x ) ] [ 0 ] hay = aac_codecs . decode ( 'ascii' ) match = re . findall ( r'ffmpeg version (\\d+\\.)?(\\d+\\.)?(\\*|\\d+)' , hay ) if match : return \"\" . join ( match [ 0 ] ) else : return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check configuration file type is JSON Return a boolean indicating wheather the file is JSON format or not [CODESPLIT] def is_json_file ( filename , show_warnings = False ) : try : config_dict = load_config ( filename , file_type = \"json\" ) is_json = True except : is_json = False return ( is_json )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return frequencies for DFT [CODESPLIT] def fft_freqs ( n_fft , fs ) : return np . arange ( 0 , ( n_fft // 2 + 1 ) ) / float ( n_fft ) * float ( fs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return frequencies for DFT [CODESPLIT] def fft_freqs ( n_fft , fs ) : return np . arange ( 0 , ( n_fft // 2 + 1 ) ) / float ( n_fft ) * float ( fs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Checks if l is iterable and contains only integral types [CODESPLIT] def is_iterable_of_int ( l ) : if not is_iterable ( l ) : return False return all ( is_int ( value ) for value in l )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a file and close it . Returns the file source . [CODESPLIT] def file_read ( filename ) : fobj = open ( filename , 'r' ) source = fobj . read ( ) fobj . close ( ) return source", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve the column definition statement for a column from a table . [CODESPLIT] def get_column_definition ( self , table , column ) : # Parse column definitions for match for col in self . get_column_definition_all ( table ) : if col . strip ( '`' ) . startswith ( column ) : return col . strip ( ',' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if the string is a palindrome ( https : // en . wikipedia . org / wiki / Palindrome ) . [CODESPLIT] def is_palindrome ( string , strict = True ) : if is_full_string ( string ) : if strict : return reverse ( string ) == string return is_palindrome ( SPACES_RE . sub ( '' , string ) ) return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Filter the dict * d * to remove keys not in * keys * . [CODESPLIT] def filter_dict_by_key ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return array - like containing only true / non - NaN values possibly empty . [CODESPLIT] def remove_na_arraylike ( arr ) : if is_extension_array_dtype ( arr ) : return arr [ notna ( arr ) ] else : return arr [ notna ( lib . values_from_object ( arr ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if value is an instance of float . [CODESPLIT] def test_value ( self , value ) : if not isinstance ( value , float ) : raise ValueError ( 'expected float value: ' + str ( type ( value ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns whether the provided name is a valid variable name in Python [CODESPLIT] def is_valid_variable_name ( string_to_check ) : try : parse ( '{} = None' . format ( string_to_check ) ) return True except ( SyntaxError , ValueError , TypeError ) : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "From a given natural integer returns the prime factors and their multiplicity : param n : Natural integer : return : [CODESPLIT] def _factor_generator ( n ) : p = prime_factors ( n ) factors = { } for p1 in p : try : factors [ p1 ] += 1 except KeyError : factors [ p1 ] = 1 return factors", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether the passed variable is a tuple with two floats or integers [CODESPLIT] def contains_geometric_info ( var ) : return isinstance ( var , tuple ) and len ( var ) == 2 and all ( isinstance ( val , ( int , float ) ) for val in var )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return first occurrence matching f otherwise None [CODESPLIT] def findfirst ( f , coll ) : result = list ( dropwhile ( f , coll ) ) return result [ 0 ] if result else None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check features data are not empty [CODESPLIT] def contains_empty ( features ) : if not features : return True for feature in features : if feature . shape [ 0 ] == 0 : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns whether the provided name is a valid variable name in Python [CODESPLIT] def is_valid_variable_name ( string_to_check ) : try : parse ( '{} = None' . format ( string_to_check ) ) return True except ( SyntaxError , ValueError , TypeError ) : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns whether * obj * is iterable lazily such as generators range objects etc . [CODESPLIT] def is_lazy_iterable ( obj ) : return isinstance ( obj , ( types . GeneratorType , collections . MappingView , six . moves . range , enumerate ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialize an API . [CODESPLIT] def initialize_api ( flask_app ) : if not flask_restplus : return api = flask_restplus . Api ( version = \"1.0\" , title = \"My Example API\" ) api . add_resource ( HelloWorld , \"/hello\" ) blueprint = flask . Blueprint ( \"api\" , __name__ , url_prefix = \"/api\" ) api . init_app ( blueprint ) flask_app . register_blueprint ( blueprint )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check lowercase key item . [CODESPLIT] def __contains__ ( self , key ) : assert isinstance ( key , basestring ) return dict . __contains__ ( self , key . lower ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialize Flask application . [CODESPLIT] def init_app ( self , app ) : app . config . from_pyfile ( '{0}.cfg' . format ( app . name ) , silent = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check for convergence by determining if matrix1 and matrix2 are approximately equal . : param matrix1 : The matrix to compare with matrix2 : param matrix2 : The matrix to compare with matrix1 : returns : True if matrix1 and matrix2 approximately equal [CODESPLIT] def converged ( matrix1 , matrix2 ) : if isspmatrix ( matrix1 ) or isspmatrix ( matrix2 ) : return sparse_allclose ( matrix1 , matrix2 ) return np . allclose ( matrix1 , matrix2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks whether the re module can compile the given regular expression . [CODESPLIT] def is_valid_regex ( string ) : try : re . compile ( string ) is_valid = True except re . error : is_valid = False return is_valid", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Render a template into a response . [CODESPLIT] def render_template ( template_name , * * context ) : tmpl = jinja_env . get_template ( template_name ) context [ \"url_for\" ] = url_for return Response ( tmpl . render ( context ) , mimetype = \"text/html\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a Flask response object for the specified data and HTTP status . [CODESPLIT] def getFlaskResponse ( responseString , httpStatus = 200 ) : return flask . Response ( responseString , status = httpStatus , mimetype = MIMETYPE )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turns response into a properly formatted json or text object [CODESPLIT] async def json_or_text ( response ) : text = await response . text ( ) if response . headers [ 'Content-Type' ] == 'application/json; charset=utf-8' : return json . loads ( text ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Same as : meth : random . choice but also supports : class : set type to be passed as sequence . [CODESPLIT] def random_choice ( sequence ) : return random . choice ( tuple ( sequence ) if isinstance ( sequence , set ) else sequence )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flatten a nested list . [CODESPLIT] def flatten ( l ) : return sum ( map ( flatten , l ) , [ ] ) if isinstance ( l , list ) or isinstance ( l , tuple ) else [ l ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the index of the closest in xarr to value val [CODESPLIT] def closest ( xarr , val ) : idx_closest = np . argmin ( np . abs ( np . array ( xarr ) - val ) ) return idx_closest", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a multi - dimensional array and returns a 1 dimensional array with the same contents . [CODESPLIT] def flatten_array ( grid ) : grid = [ grid [ i ] [ j ] for i in range ( len ( grid ) ) for j in range ( len ( grid [ i ] ) ) ] while type ( grid [ 0 ] ) is list : grid = flatten_array ( grid ) return grid", "target": 1, "target_options": ["no_match", "match"]}
{"input": "function to fetch links equal to limit [CODESPLIT] def get_duckduckgo_links ( limit , params , headers ) : resp = s . get ( 'https://duckduckgo.com/html' , params = params , headers = headers ) links = scrape_links ( resp . content , engine = 'd' ) return links [ : limit ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format a byte sized value . [CODESPLIT] def fmt_sz ( intval ) : try : return fmt . human_size ( intval ) except ( ValueError , TypeError ) : return \"N/A\" . rjust ( len ( fmt . human_size ( 0 ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read tag data from file and return as unicode string . [CODESPLIT] def read_utf8 ( fh , byteorder , dtype , count , offsetsize ) : return fh . read ( count ) . decode ( 'utf-8' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Skip the specified number of elements in the list . [CODESPLIT] def skip ( self , n ) : try : self . _iter_object . skip ( n ) except AttributeError : for i in range ( 0 , n ) : self . next ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read tag data from file and return as unicode string . [CODESPLIT] def read_utf8 ( fh , byteorder , dtype , count , offsetsize ) : return fh . read ( count ) . decode ( 'utf-8' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update a dict or list in place to replace none string values with Python None . [CODESPLIT] def replace_nones ( dict_or_list ) : def replace_none_in_value ( value ) : if isinstance ( value , basestring ) and value . lower ( ) == \"none\" : return None return value items = dict_or_list . iteritems ( ) if isinstance ( dict_or_list , dict ) else enumerate ( dict_or_list ) for accessor , value in items : if isinstance ( value , ( dict , list ) ) : replace_nones ( value ) else : dict_or_list [ accessor ] = replace_none_in_value ( value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Encodes Unicode strings to byte strings if necessary . [CODESPLIT] def b ( s ) : return s if isinstance ( s , bytes ) else s . encode ( locale . getpreferredencoding ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pad the text . [CODESPLIT] def _pad ( self , text ) : top_bottom = ( \"\\n\" * self . _padding ) + \" \" right_left = \" \" * self . _padding * self . PAD_WIDTH return top_bottom + right_left + text + right_left + top_bottom", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write the given colored string to standard out . [CODESPLIT] def write_color ( string , name , style = 'normal' , when = 'auto' ) : write ( color ( string , name , style , when ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if the path refers to an existing directory . [CODESPLIT] def isdir ( self , path ) : result = True try : self . sftp_client . lstat ( path ) except FileNotFoundError : result = False return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a structured NumPy array into a Table . [CODESPLIT] def from_array ( cls , arr ) : return cls ( ) . with_columns ( [ ( f , arr [ f ] ) for f in arr . dtype . names ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "merge two Mapping objects keeping the type of the first mapping [CODESPLIT] def _merge_maps ( m1 , m2 ) : return type ( m1 ) ( chain ( m1 . items ( ) , m2 . items ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "turns a dict of lists into a list of dicts that represents the cartesian product of the initial lists [CODESPLIT] def cartesian_lists ( d ) : return [ { k : v for k , v in zip ( d . keys ( ) , args ) } for args in itertools . product ( * d . values ( ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Copy docstring from existing object to the decorated callable . [CODESPLIT] def see_doc ( obj_with_doc ) : def decorator ( fn ) : fn . __doc__ = obj_with_doc . __doc__ return fn return decorator", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if the given value is a scalar . [CODESPLIT] def is_scalar ( value ) : return np . isscalar ( value ) or ( isinstance ( value , np . ndarray ) and ( len ( np . squeeze ( value ) . shape ) == 0 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A specialized version of the reference WSGI - CGI server to adapt to Microsoft IIS quirks . This is not a production quality interface and will behave badly under load . [CODESPLIT] def iiscgi ( application ) : try : from wsgiref . handlers import IISCGIHandler except ImportError : print ( \"Python 3.2 or newer is required.\" ) if not __debug__ : warnings . warn ( \"Interactive debugging and other persistence-based processes will not work.\" ) IISCGIHandler ( ) . run ( application )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate the arguments dictionary provided to : py : meth : generate_name and : py : meth : calculate_total_steps . [CODESPLIT] def arguments_as_dict ( cls , * args , * * kwargs ) : all_args = ( None , ) + args return inspect . getcallargs ( cls . run , * all_args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if a string is an integer . If the string value is an integer return True otherwise return False . Args : string : a string to test . [CODESPLIT] def is_int ( string ) : try : a = float ( string ) b = int ( a ) except ValueError : return False else : return a == b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates or updates a property for the instance for each parameter . [CODESPLIT] def update ( self , * * kwargs ) : for key , value in kwargs . items ( ) : setattr ( self , key , value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if contents of the files are the same [CODESPLIT] def cmp_contents ( filename1 , filename2 ) : with open_readable ( filename1 , 'rb' ) as fobj : contents1 = fobj . read ( ) with open_readable ( filename2 , 'rb' ) as fobj : contents2 = fobj . read ( ) return contents1 == contents2", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is a compatibility function that takes a C { float } and converts it to an C { int } if the values are equal . [CODESPLIT] def _check_for_int ( x ) : try : y = int ( x ) except ( OverflowError , ValueError ) : pass else : # There is no way in AMF0 to distinguish between integers and floats if x == x and y == x : return y return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return folder / drive free space ( in bytes ) [CODESPLIT] def get_free_mb ( folder ) : if platform . system ( ) == 'Windows' : free_bytes = ctypes . c_ulonglong ( 0 ) ctypes . windll . kernel32 . GetDiskFreeSpaceExW ( ctypes . c_wchar_p ( folder ) , None , None , ctypes . pointer ( free_bytes ) ) return free_bytes . value / 1024 / 1024 else : st = os . statvfs ( folder ) return st . f_bavail * st . f_frsize / 1024 / 1024", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator which dynamically binds static methods to the model for later use . [CODESPLIT] def static_method ( cls , f ) : setattr ( cls , f . __name__ , staticmethod ( f ) ) return f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is builtin in python2 but we have to roll our own on py3 . [CODESPLIT] def execfile ( fname , variables ) : with open ( fname ) as f : code = compile ( f . read ( ) , fname , 'exec' ) exec ( code , variables )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cumulative distribution function . [CODESPLIT] def _cdf ( self , xloc , dist , cache ) : return evaluation . evaluate_forward ( dist , numpy . e ** xloc , cache = cache )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Equal to Minowski distance with : math : p = 1 . See also -------- minowski [CODESPLIT] def manhattan ( h1 , h2 ) : # # 7 us @array, 31 us @list \\w 100 bins h1 , h2 = __prepare_histogram ( h1 , h2 ) return scipy . sum ( scipy . absolute ( h1 - h2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Scrapes data from techshop . ws . [CODESPLIT] def data_from_techshop_ws ( tws_url ) : r = requests . get ( tws_url ) if r . status_code == 200 : data = BeautifulSoup ( r . text , \"lxml\" ) else : data = \"There was an error while accessing data on techshop.ws.\" return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Whitespace normalization : [CODESPLIT] def text_remove_empty_lines ( text ) : lines = [ line . rstrip ( ) for line in text . splitlines ( ) if line . strip ( ) ] return \"\\n\" . join ( lines )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute average gradient norm of an image [CODESPLIT] def average_gradient ( data , * kwargs ) : return np . average ( np . array ( np . gradient ( data ) ) ** 2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract a ZIP archive to a directory [CODESPLIT] def unzip_file_to_dir ( path_to_zip , output_directory ) : z = ZipFile ( path_to_zip , 'r' ) z . extractall ( output_directory ) z . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the mean absolute error . [CODESPLIT] def _mean_absolute_error ( y , y_pred , w ) : return np . average ( np . abs ( y_pred - y ) , weights = w )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Complex non - optimized Discrete Fourier Transform [CODESPLIT] def dft ( blk , freqs , normalize = True ) : dft_data = ( sum ( xn * cexp ( - 1j * n * f ) for n , xn in enumerate ( blk ) ) for f in freqs ) if normalize : lblk = len ( blk ) return [ v / lblk for v in dft_data ] return list ( dft_data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Stable implementation of the softmax function . [CODESPLIT] def softmax ( xs ) : ys = xs - np . max ( xs ) exps = np . exp ( ys ) return exps / exps . sum ( axis = 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generates a random ID of given length [CODESPLIT] def random_id ( length ) : def char ( ) : \"\"\"Generate single random char\"\"\" return random . choice ( string . ascii_letters + string . digits ) return \"\" . join ( char ( ) for _ in range ( length ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transforms the regular socket . socket to an ssl . SSLSocket for secure connections . Any arguments are passed to ssl . wrap_socket : http : // docs . python . org / dev / library / ssl . html#ssl . wrap_socket [CODESPLIT] def enable_ssl ( self , * args , * * kwargs ) : if self . handshake_sent : raise SSLError ( 'can only enable SSL before handshake' ) self . secure = True self . sock = ssl . wrap_socket ( self . sock , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create an array . Keyword arguments as per : func : zarr . creation . zeros . [CODESPLIT] def zeros ( self , name , * * kwargs ) : return self . _write_op ( self . _zeros_nosync , name , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform auth request for token . [CODESPLIT] def auth_request ( self , url , headers , body ) : return self . req . post ( url , headers , body = body )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a temporary filename based on filename . [CODESPLIT] def get_incomplete_path ( filename ) : random_suffix = \"\" . join ( random . choice ( string . ascii_uppercase + string . digits ) for _ in range ( 6 ) ) return filename + \".incomplete\" + random_suffix", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Construct the adjacency matrix of the tree : param tree : : return : [CODESPLIT] def adjacency ( tree ) : dd = ids ( tree ) N = len ( dd ) A = np . zeros ( ( N , N ) ) def _adj ( node ) : if np . isscalar ( node ) : return elif isinstance ( node , tuple ) and len ( node ) == 2 : A [ dd [ node ] , dd [ node [ 0 ] ] ] = 1 A [ dd [ node [ 0 ] ] , dd [ node ] ] = 1 _adj ( node [ 0 ] ) A [ dd [ node ] , dd [ node [ 1 ] ] ] = 1 A [ dd [ node [ 1 ] ] , dd [ node ] ] = 1 _adj ( node [ 1 ] ) _adj ( tree ) return A", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate random id numbers . [CODESPLIT] def generate_random_id ( size = 6 , chars = string . ascii_uppercase + string . digits ) : return \"\" . join ( random . choice ( chars ) for x in range ( size ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Use tensorflows nest function if available otherwise just wrap object in an array [CODESPLIT] def nest ( thing ) : tfutil = util . get_module ( 'tensorflow.python.util' ) if tfutil : return tfutil . nest . flatten ( thing ) else : return [ thing ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Method to create a dictionary containing a JSON reference to the schema in the spec [CODESPLIT] def get_ref_dict ( self , schema ) : schema_key = make_schema_key ( schema ) ref_schema = build_reference ( \"schema\" , self . openapi_version . major , self . refs [ schema_key ] ) if getattr ( schema , \"many\" , False ) : return { \"type\" : \"array\" , \"items\" : ref_schema } return ref_schema", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an enumerable that iterates through a multi - page API request [CODESPLIT] def _iter_response ( self , url , params = None ) : if params is None : params = { } params [ 'page_number' ] = 1 # Last page lists itself as next page while True : response = self . _request ( url , params ) for item in response [ 'result_data' ] : yield item # Last page lists itself as next page if response [ 'service_meta' ] [ 'next_page_number' ] == params [ 'page_number' ] : break params [ 'page_number' ] += 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Emit a sine wave at the given frequency . [CODESPLIT] def sine_wave ( frequency ) : xs = tf . reshape ( tf . range ( _samples ( ) , dtype = tf . float32 ) , [ 1 , _samples ( ) , 1 ] ) ts = xs / FLAGS . sample_rate return tf . sin ( 2 * math . pi * frequency * ts )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "shortcut to return simple plain / text messages in the response . [CODESPLIT] def text_response ( self , contents , code = 200 , headers = { } ) : return Response ( contents , status = code , headers = { 'Content-Type' : 'text/plain' } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function that returns the name of estimator or the given string if a string is given [CODESPLIT] def make_name ( estimator ) : if estimator is not None : if isinstance ( estimator , six . string_types ) : estimator_name = estimator else : estimator_name = estimator . __class__ . __name__ else : estimator_name = None return estimator_name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Context menu event handler [CODESPLIT] def OnContextMenu ( self , event ) : self . grid . PopupMenu ( self . grid . contextmenu ) event . Skip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns all files in a given directory [CODESPLIT] def list_files ( directory ) : return [ f for f in pathlib . Path ( directory ) . iterdir ( ) if f . is_file ( ) and not f . name . startswith ( '.' ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Main window move event [CODESPLIT] def OnMove ( self , event ) : # Store window position in config position = self . main_window . GetScreenPositionTuple ( ) config [ \"window_position\" ] = repr ( position )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns all files in a given directory [CODESPLIT] def list_files ( directory ) : return [ f for f in pathlib . Path ( directory ) . iterdir ( ) if f . is_file ( ) and not f . name . startswith ( '.' ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a version of the query string with the _e _k and _s values removed . [CODESPLIT] def filter_query_string ( query ) : return '&' . join ( [ q for q in query . split ( '&' ) if not ( q . startswith ( '_k=' ) or q . startswith ( '_e=' ) or q . startswith ( '_s' ) ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the unique items from iterable * seq * ( in order ) . [CODESPLIT] def unique_items ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create palette . [CODESPLIT] def adjust ( cols , light ) : raw_colors = [ cols [ 0 ] , * cols , \"#FFFFFF\" , \"#000000\" , * cols , \"#FFFFFF\" ] return colors . generic_adjust ( raw_colors , light )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calcuate median datetime from datetime list [CODESPLIT] def median_date ( dt_list ) : #dt_list_sort = sorted(dt_list) idx = len ( dt_list ) / 2 if len ( dt_list ) % 2 == 0 : md = mean_date ( [ dt_list [ idx - 1 ] , dt_list [ idx ] ] ) else : md = dt_list [ idx ] return md", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a square grid with values of the distance from the centre of the grid to each gridpoint [CODESPLIT] def RadiusGrid ( gridSize ) : x , y = np . mgrid [ 0 : gridSize , 0 : gridSize ] x = x - ( gridSize - 1.0 ) / 2.0 y = y - ( gridSize - 1.0 ) / 2.0 return np . abs ( x + 1j * y )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the autocorrelation coefficient . [CODESPLIT] def autocorr_coeff ( x , t , tau1 , tau2 ) : return corr_coeff ( x , x , t , tau1 , tau2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The url of this window [CODESPLIT] def url ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . url", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the indent size in spaces at the start of a line of text . [CODESPLIT] def indentsize ( line ) : expline = string . expandtabs ( line ) return len ( expline ) - len ( string . lstrip ( expline ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the month start date a nd end date [CODESPLIT] def get_month_start_end_day ( ) : t = date . today ( ) n = mdays [ t . month ] return ( date ( t . year , t . month , 1 ) , date ( t . year , t . month , n ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Count the number of non - NA in this array along the given axis or axes [CODESPLIT] def count ( data , axis = None ) : return np . sum ( np . logical_not ( isnull ( data ) ) , axis = axis )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the circular permutation for a given list of items . [CODESPLIT] def circ_permutation ( items ) : permutations = [ ] for i in range ( len ( items ) ) : permutations . append ( items [ i : ] + items [ : i ] ) return permutations", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transforma una string con elementos separados por sep en una lista . [CODESPLIT] def string_to_list ( string , sep = \",\" , filter_empty = False ) : return [ value . strip ( ) for value in string . split ( sep ) if ( not filter_empty or value ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the absolute path to the directory containing the package data . [CODESPLIT] def data_directory ( ) : package_directory = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( package_directory , \"data\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Go to the end of the current line and create a new line [CODESPLIT] def go_to_new_line ( self ) : self . stdkey_end ( False , False ) self . insert_text ( self . get_line_separator ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the RMS of the audio [CODESPLIT] def calc_volume ( self , sample : np . ndarray ) : return sqrt ( np . mean ( np . square ( sample ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a set of unique n - grams from a string . [CODESPLIT] def make_unique_ngrams ( s , n ) : return set ( s [ i : i + n ] for i in range ( len ( s ) - n + 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a string from a file - like object . [CODESPLIT] def read_string ( buff , byteorder = 'big' ) : length = read_numeric ( USHORT , buff , byteorder ) return buff . read ( length ) . decode ( 'utf-8' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a conda environment inside the current sandbox for the given list of dependencies and options . [CODESPLIT] def create_conda_env ( sandbox_dir , env_name , dependencies , options = ( ) ) : env_dir = os . path . join ( sandbox_dir , env_name ) cmdline = [ \"conda\" , \"create\" , \"--yes\" , \"--copy\" , \"--quiet\" , \"-p\" , env_dir ] + list ( options ) + dependencies log . info ( \"Creating conda environment: \" ) log . info ( \"  command line: %s\" , cmdline ) subprocess . check_call ( cmdline , stderr = subprocess . PIPE , stdout = subprocess . PIPE ) log . debug ( \"Environment created\" ) return env_dir , env_name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a sparse ( n 3 ) list of integer indexes of filled cells turn it into a dense ( m o p ) matrix . [CODESPLIT] def sparse_to_matrix ( sparse ) : sparse = np . asanyarray ( sparse , dtype = np . int ) if not util . is_shape ( sparse , ( - 1 , 3 ) ) : raise ValueError ( 'sparse must be (n,3)!' ) shape = sparse . max ( axis = 0 ) + 1 matrix = np . zeros ( np . product ( shape ) , dtype = np . bool ) multiplier = np . array ( [ np . product ( shape [ 1 : ] ) , shape [ 2 ] , 1 ] ) index = ( sparse * multiplier ) . sum ( axis = 1 ) matrix [ index ] = True dense = matrix . reshape ( shape ) return dense", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Se asegura de que un directorio exista . [CODESPLIT] def ensure_dir_exists ( directory ) : if directory and not os . path . exists ( directory ) : os . makedirs ( directory )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write a single property to the file in Java properties format . [CODESPLIT] def write_property ( fh , key , value ) : if key is COMMENT : write_comment ( fh , value ) return _require_string ( key , 'keys' ) _require_string ( value , 'values' ) fh . write ( _escape_key ( key ) ) fh . write ( b'=' ) fh . write ( _escape_value ( value ) ) fh . write ( b'\\n' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the current branch [CODESPLIT] def get_current_branch ( ) : cmd = [ \"git\" , \"rev-parse\" , \"--abbrev-ref\" , \"HEAD\" ] output = subprocess . check_output ( cmd , stderr = subprocess . STDOUT ) return output . strip ( ) . decode ( \"utf-8\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads the date from a string in the format YYYY / MM / DD and returns : class : datetime . date [CODESPLIT] def _read_date_from_string ( str1 ) : full_date = [ int ( x ) for x in str1 . split ( '/' ) ] return datetime . date ( full_date [ 0 ] , full_date [ 1 ] , full_date [ 2 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return n size lists from a given list l [CODESPLIT] def chunk_list ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a C array using the given string . [CODESPLIT] def bytes_to_c_array ( data ) : chars = [ \"'{}'\" . format ( encode_escape ( i ) ) for i in decode_escape ( data ) ] return ', ' . join ( chars ) + ', 0'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This turns off stdout buffering so that outputs are immediately materialized and log messages show up before the program exits [CODESPLIT] def disable_stdout_buffering ( ) : stdout_orig = sys . stdout sys . stdout = os . fdopen ( sys . stdout . fileno ( ) , 'w' , 0 ) # NOTE(brandyn): This removes the original stdout return stdout_orig", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a ctypes void pointer to the memory mapped region . [CODESPLIT] def pointer ( self ) : return ctypes . cast ( ctypes . pointer ( ctypes . c_uint8 . from_buffer ( self . mapping , 0 ) ) , ctypes . c_void_p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a nested list and returns the size of each dimension followed by the element type in the list [CODESPLIT] def get_list_dimensions ( _list ) : if isinstance ( _list , list ) or isinstance ( _list , tuple ) : return [ len ( _list ) ] + get_list_dimensions ( _list [ 0 ] ) return [ ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Loads and returns foreign library . [CODESPLIT] def load ( self , name ) : name = ctypes . util . find_library ( name ) return ctypes . cdll . LoadLibrary ( name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Integer dots per inch for the width of this image . Defaults to 72 when not present in the file as is often the case . [CODESPLIT] def horz_dpi ( self ) : pHYs = self . _chunks . pHYs if pHYs is None : return 72 return self . _dpi ( pHYs . units_specifier , pHYs . horz_px_per_unit )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the name of the newest file given an iterable of file names . [CODESPLIT] def newest_file ( file_iterable ) : return max ( file_iterable , key = lambda fname : os . path . getmtime ( fname ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ajoute la target au plot [CODESPLIT] def plot_target ( target , ax ) : ax . scatter ( target [ 0 ] , target [ 1 ] , target [ 2 ] , c = \"red\" , s = 80 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes the extension from a filename [CODESPLIT] def remove_ext ( fname ) : bn = os . path . basename ( fname ) return os . path . splitext ( bn ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a list a certain size [CODESPLIT] def _crop_list_to_size ( l , size ) : for x in range ( size - len ( l ) ) : l . append ( False ) for x in range ( len ( l ) - size ) : l . pop ( ) return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the first day of the given month . [CODESPLIT] def get_month_start ( day = None ) : day = add_timezone ( day or datetime . date . today ( ) ) return day . replace ( day = 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Scale the image to uint8 [CODESPLIT] def uint8sc ( im ) : im = np . asarray ( im ) immin = im . min ( ) immax = im . max ( ) imrange = immax - immin return cv2 . convertScaleAbs ( im - immin , alpha = 255 / imrange )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Full name of a class including the module . Like qualified_class_name but when you already have a class [CODESPLIT] def qualified_name_import ( cls ) : parts = qualified_name ( cls ) . split ( '.' ) return \"from {} import {}\" . format ( '.' . join ( parts [ : - 1 ] ) , parts [ - 1 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the value of a local variable somewhere in the call stack . [CODESPLIT] def getvariable ( name ) : import inspect fr = inspect . currentframe ( ) try : while fr : fr = fr . f_back vars = fr . f_locals if name in vars : return vars [ name ] except : pass return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a copy of the list without duplicates . [CODESPLIT] def unique ( list ) : unique = [ ] [ unique . append ( x ) for x in list if x not in unique ] return unique", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the size of remote files [CODESPLIT] def server ( self ) : try : tar = urllib2 . urlopen ( self . registry ) meta = tar . info ( ) return int ( meta . getheaders ( \"Content-Length\" ) [ 0 ] ) except ( urllib2 . URLError , IndexError ) : return \" \"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decision Tree [CODESPLIT] def cric__decision_tree ( ) : model = sklearn . tree . DecisionTreeClassifier ( random_state = 0 , max_depth = 4 ) # we want to explain the raw probability outputs of the trees model . predict = lambda X : model . predict_proba ( X ) [ : , 1 ] return model", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compiles to native Python bytecode and runs program returning the topmost value on the stack . [CODESPLIT] def xeval ( source , optimize = True ) : native = xcompile ( source , optimize = optimize ) return native ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load an object from a module by name [CODESPLIT] def load_object_by_name ( object_name ) : mod_name , attr = object_name . rsplit ( '.' , 1 ) mod = import_module ( mod_name ) return getattr ( mod , attr )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the item at the given index . [CODESPLIT] def __getitem__ ( self , index ) : row , col = index return self . rows [ row ] [ col ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Destroy self since closures cannot be called again . [CODESPLIT] def _release ( self ) : del self . funcs del self . variables del self . variable_values del self . satisfied", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an iterator over the values of a dictionary . [CODESPLIT] def itervalues ( d , * * kw ) : if not PY2 : return iter ( d . values ( * * kw ) ) return d . itervalues ( * * kw )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete a directory if it s present . If it s not present no - op . [CODESPLIT] def safe_rmtree ( directory ) : if os . path . exists ( directory ) : shutil . rmtree ( directory , True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete a label by name . [CODESPLIT] def del_label ( self , name ) : labels_tag = self . root [ 0 ] labels_tag . remove ( self . _find_label ( name ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get all properties of the MessageFlags class . [CODESPLIT] def get_properties ( cls ) : property_names = [ p for p in dir ( cls ) if isinstance ( getattr ( cls , p ) , property ) ] return property_names", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieves a person s coordinates by full name [CODESPLIT] def get_coordinates_by_full_name ( self , name ) : person = self . get_person_by_full_name ( name ) if not person : return '' , '' return person . latitude , person . longitude", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove the value found at key from the queue [CODESPLIT] def remove ( self , key ) : item = self . item_finder . pop ( key ) item [ - 1 ] = None self . removed_count += 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets the median of a list of values Returns a float / int [CODESPLIT] def getMedian ( numericValues ) : theValues = sorted ( numericValues ) if len ( theValues ) % 2 == 1 : return theValues [ ( len ( theValues ) + 1 ) / 2 - 1 ] else : lower = theValues [ len ( theValues ) / 2 - 1 ] upper = theValues [ len ( theValues ) / 2 ] return ( float ( lower + upper ) ) / 2", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a model s verbose name to the model class . This allows us to use the models verbose name in steps . [CODESPLIT] def get_model ( name ) : model = MODELS . get ( name . lower ( ) , None ) assert model , \"Could not locate model by name '%s'\" % name return model", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform check_array ( X ) after removing infinite values ( numpy . inf ) from the given distance matrix . [CODESPLIT] def check_precomputed_distance_matrix ( X ) : tmp = X . copy ( ) tmp [ np . isinf ( tmp ) ] = 1 check_array ( tmp )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get an SArray that contains the last n elements in the SArray . [CODESPLIT] def tail ( self , n = 10 ) : with cython_context ( ) : return SArray ( _proxy = self . __proxy__ . tail ( n ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a boolean indicating if the code is executed inside softimage . [CODESPLIT] def inside_softimage ( ) : try : import maya return False except ImportError : pass try : from win32com . client import Dispatch as disp disp ( 'XSI.Application' ) return True except : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the type of obj as a string . More descriptive and specific than type ( obj ) and safe for any object unlike __class__ . [CODESPLIT] def typename ( obj ) : if hasattr ( obj , '__class__' ) : return getattr ( obj , '__class__' ) . __name__ else : return type ( obj ) . __name__", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the first day of the current month [CODESPLIT] def get_month_start_date ( self ) : now = timezone . now ( ) return timezone . datetime ( day = 1 , month = now . month , year = now . year , tzinfo = now . tzinfo )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "When converting Spark SQL records to Pandas DataFrame the inferred data type may be wrong . This method gets the corrected data type for Pandas if that type may be inferred uncorrectly . [CODESPLIT] def _to_corrected_pandas_type ( dt ) : import numpy as np if type ( dt ) == ByteType : return np . int8 elif type ( dt ) == ShortType : return np . int16 elif type ( dt ) == IntegerType : return np . int32 elif type ( dt ) == FloatType : return np . float32 else : return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates the distance between two points on earth . [CODESPLIT] def _calculate_distance ( latlon1 , latlon2 ) : lat1 , lon1 = latlon1 lat2 , lon2 = latlon2 dlon = lon2 - lon1 dlat = lat2 - lat1 R = 6371 # radius of the earth in kilometers a = np . sin ( dlat / 2 ) ** 2 + np . cos ( lat1 ) * np . cos ( lat2 ) * ( np . sin ( dlon / 2 ) ) ** 2 c = 2 * np . pi * R * np . arctan2 ( np . sqrt ( a ) , np . sqrt ( 1 - a ) ) / 180 return c", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a property by name [CODESPLIT] def get_property_by_name ( pif , name ) : return next ( ( x for x in pif . properties if x . name == name ) , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get dimension of an array getting the number of rows and the max num of columns . [CODESPLIT] def get_dimension_array ( array ) : if all ( isinstance ( el , list ) for el in array ) : result = [ len ( array ) , len ( max ( [ x for x in array ] , key = len , ) ) ] # elif array and isinstance(array, list): else : result = [ len ( array ) , 1 ] return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a property by name [CODESPLIT] def get_propety_by_name ( pif , name ) : warn ( \"This method has been deprecated in favor of get_property_by_name\" ) return next ( ( x for x in pif . properties if x . name == name ) , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get a set of keys from redis [CODESPLIT] def get ( self , key ) : res = self . connection . get ( key ) print ( res ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update the dev_info data from a dictionary . [CODESPLIT] def update ( self , params ) : dev_info = self . json_state . get ( 'deviceInfo' ) dev_info . update ( { k : params [ k ] for k in params if dev_info . get ( k ) } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return byte - size of a memoryview or buffer . [CODESPLIT] def _nbytes ( buf ) : if isinstance ( buf , memoryview ) : if PY3 : # py3 introduces nbytes attribute return buf . nbytes else : # compute nbytes on py2 size = buf . itemsize for dim in buf . shape : size *= dim return size else : # not a memoryview, raw bytes/ py2 buffer return len ( buf )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compare differencs from two dicts [CODESPLIT] def compare_dict ( da , db ) : sa = set ( da . items ( ) ) sb = set ( db . items ( ) ) diff = sa & sb return dict ( sa - diff ) , dict ( sb - diff )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the latest modification time of all files / subdirectories in a directory [CODESPLIT] def dir_modtime ( dpath ) : return max ( os . path . getmtime ( d ) for d , _ , _ in os . walk ( dpath ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raise the open file handles permitted by the Dusty daemon process and its child processes . The number we choose here needs to be within the OS X default kernel hard limit which is 10240 . [CODESPLIT] def _increase_file_handle_limit ( ) : logging . info ( 'Increasing file handle limit to {}' . format ( constants . FILE_HANDLE_LIMIT ) ) resource . setrlimit ( resource . RLIMIT_NOFILE , ( constants . FILE_HANDLE_LIMIT , resource . RLIM_INFINITY ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve a User object by ID . [CODESPLIT] def get_user_by_id ( self , id ) : return self . db_adapter . get_object ( self . UserClass , id = id )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a datetime . timedelta object return the delta in milliseconds [CODESPLIT] def datetime_delta_to_ms ( delta ) : delta_ms = delta . days * 24 * 60 * 60 * 1000 delta_ms += delta . seconds * 1000 delta_ms += delta . microseconds / 1000 delta_ms = int ( delta_ms ) return delta_ms", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fetch an image from url and convert it into a Pillow Image object [CODESPLIT] def url_to_image ( url ) : r = requests . get ( url ) image = StringIO ( r . content ) return image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prints the values and freqs / probs in ascending order . [CODESPLIT] def Print ( self ) : for val , prob in sorted ( self . d . iteritems ( ) ) : print ( val , prob )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert version like string to a tuple of integers . [CODESPLIT] def ver_to_tuple ( value ) : return tuple ( int ( _f ) for _f in re . split ( r'\\D+' , value ) if _f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Used for generating thumbnails . Does not include overlaid graphics . [CODESPLIT] def get_plain_image_as_widget ( self ) : arr = self . getwin_array ( order = self . rgb_order ) image = self . _get_qimage ( arr , self . qimg_fmt ) return image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a unique ID that is somewhat guaranteed to be unique among all instances running at the same time . [CODESPLIT] def generate_unique_host_id ( ) : host = \".\" . join ( reversed ( socket . gethostname ( ) . split ( \".\" ) ) ) pid = os . getpid ( ) return \"%s.%d\" % ( host , pid )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse an environment variable string [CODESPLIT] def parse_env_var ( s ) : parts = s . split ( '=' , 1 ) if len ( parts ) == 2 : k , v = parts return ( k , v ) k = parts [ 0 ] return ( k , os . getenv ( k , '' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses the get - all - user - accounts Portals API to retrieve the user - id by supplying an email . [CODESPLIT] def get_user_id_from_email ( self , email ) : accts = self . get_all_user_accounts ( ) for acct in accts : if acct [ 'email' ] == email : return acct [ 'id' ] return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the folder exisits . If not create the folder [CODESPLIT] def check_create_folder ( filename ) : os . makedirs ( os . path . dirname ( filename ) , exist_ok = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the MachineGuid from HKEY_LOCAL_MACHINE \\ Software \\ Microsoft \\ Cryptography \\ MachineGuid [CODESPLIT] def get_nt_system_uid ( ) : try : import _winreg as winreg except ImportError : import winreg lm = winreg . ConnectRegistry ( None , winreg . HKEY_LOCAL_MACHINE ) try : key = winreg . OpenKey ( lm , r\"Software\\Microsoft\\Cryptography\" ) try : return winreg . QueryValueEx ( key , \"MachineGuid\" ) [ 0 ] finally : key . Close ( ) finally : lm . Close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of all parsed comments in a file . Mostly for testing & interactive use . [CODESPLIT] def parse_comments_for_file ( filename ) : return [ parse_comment ( strip_stars ( comment ) , next_line ) for comment , next_line in get_doc_comments ( read_file ( filename ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raw print to sys . __stdout__ otherwise identical interface to print () . [CODESPLIT] def raw_print ( * args , * * kw ) : print ( * args , sep = kw . get ( 'sep' , ' ' ) , end = kw . get ( 'end' , '\\n' ) , file = sys . __stdout__ ) sys . __stdout__ . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine True / False from argument [CODESPLIT] def process_bool_arg ( arg ) : if isinstance ( arg , bool ) : return arg elif isinstance ( arg , basestring ) : if arg . lower ( ) in [ \"true\" , \"1\" ] : return True elif arg . lower ( ) in [ \"false\" , \"0\" ] : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load graph as defined by a DOT file . The file is assumed to be in DOT format . It will be loaded parsed and a Dot class will be returned representing the graph . [CODESPLIT] def graph_from_dot_file ( path ) : fd = file ( path , 'rb' ) data = fd . read ( ) fd . close ( ) return graph_from_dot_data ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a attribut [CODESPLIT] def getAttributeData ( self , name , channel = None ) : return self . _getNodeData ( name , self . _ATTRIBUTENODE , channel )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the dotproduct between self and another vector . [CODESPLIT] def dot ( self , w ) : return sum ( [ x * y for x , y in zip ( self , w ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the logger for this object . [CODESPLIT] def __getLogger ( cls ) : if cls . __logger is None : cls . __logger = opf_utils . initLogger ( cls ) return cls . __logger", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert the dependency graph ( DepGraph class ) to dot source code . [CODESPLIT] def depgraph_to_dotsrc ( dep_graph , show_cycles , nodot , reverse ) : if show_cycles : dotsrc = cycles2dot ( dep_graph , reverse = reverse ) elif not nodot : dotsrc = dep2dot ( dep_graph , reverse = reverse ) else : dotsrc = None return dotsrc", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Commit any changes optionally staging all changes beforehand . [CODESPLIT] def commit ( self , message = None , amend = False , stage = True ) : return git_commit ( self . repo_dir , message = message , amend = amend , stage = stage )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Draw a horizontal line up to a given length . [CODESPLIT] def hline ( self , x , y , width , color ) : self . rect ( x , y , width , 1 , color , fill = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get image as a buffer in ( format ) . Format should be jpeg png etc . [CODESPLIT] def get_buffer ( self , data_np , header , format , output = None ) : if not have_pil : raise Exception ( \"Install PIL to use this method\" ) image = PILimage . fromarray ( data_np ) buf = output if buf is None : buf = BytesIO ( ) image . save ( buf , format ) return buf", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deletes all the unnamed columns [CODESPLIT] def del_Unnamed ( df ) : cols_del = [ c for c in df . columns if 'Unnamed' in c ] return df . drop ( cols_del , axis = 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "abstract method [CODESPLIT] def poke_array ( self , store , name , elemtype , elements , container , visited , _stack ) : raise NotImplementedError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap a single paragraph of text returning a list of wrapped lines . [CODESPLIT] def wrap ( text , width = 70 , * * kwargs ) : w = TextWrapper ( width = width , * * kwargs ) return w . wrap ( text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return array - like containing only true / non - NaN values possibly empty . [CODESPLIT] def remove_na_arraylike ( arr ) : if is_extension_array_dtype ( arr ) : return arr [ notna ( arr ) ] else : return arr [ notna ( lib . values_from_object ( arr ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap itertools . groupby to make life easier . [CODESPLIT] def group_by ( iterable , key_func ) : groups = ( list ( sub ) for key , sub in groupby ( iterable , key_func ) ) return zip ( groups , groups )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize path slashes . [CODESPLIT] def norm_slash ( name ) : if isinstance ( name , str ) : return name . replace ( '/' , \"\\\\\" ) if not is_case_sensitive ( ) else name else : return name . replace ( b'/' , b\"\\\\\" ) if not is_case_sensitive ( ) else name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple abstraction on top of the : meth : ~elasticsearch . Elasticsearch . scroll api - a simple iterator that yields all hits as returned by underlining scroll requests . By default scan does not return results in any pre - determined order . To have a standard order in the returned documents ( either by score or explicit sort definition ) when scrolling use preserve_order = True . This may be an expensive operation and will negate the performance benefits of using scan . : arg client : instance of : class : ~elasticsearch . Elasticsearch to use : arg query : body for the : meth : ~elasticsearch . Elasticsearch . search api : arg scroll : Specify how long a consistent view of the index should be maintained for scrolled search : arg raise_on_error : raises an exception ( ScanError ) if an error is encountered ( some shards fail to execute ) . By default we raise . : arg preserve_order : don t set the search_type to scan - this will cause the scroll to paginate with preserving the order . Note that this can be an extremely expensive operation and can easily lead to unpredictable results use with caution . : arg size : size ( per shard ) of the batch send at each iteration . Any additional keyword arguments will be passed to the initial : meth : ~elasticsearch . Elasticsearch . search call :: scan ( es query = { query : { match : { title : python }}} index = orders - * doc_type = books ) [CODESPLIT] def scan ( client , query = None , scroll = '5m' , raise_on_error = True , preserve_order = False , size = 1000 , * * kwargs ) : if not preserve_order : kwargs [ 'search_type' ] = 'scan' # initial search resp = client . search ( body = query , scroll = scroll , size = size , * * kwargs ) scroll_id = resp . get ( '_scroll_id' ) if scroll_id is None : return first_run = True while True : # if we didn't set search_type to scan initial search contains data if preserve_order and first_run : first_run = False else : resp = client . scroll ( scroll_id , scroll = scroll ) for hit in resp [ 'hits' ] [ 'hits' ] : yield hit # check if we have any errrors if resp [ \"_shards\" ] [ \"failed\" ] : logger . warning ( 'Scroll request has failed on %d shards out of %d.' , resp [ '_shards' ] [ 'failed' ] , resp [ '_shards' ] [ 'total' ] ) if raise_on_error : raise ScanError ( 'Scroll request has failed on %d shards out of %d.' % ( resp [ '_shards' ] [ 'failed' ] , resp [ '_shards' ] [ 'total' ] ) ) scroll_id = resp . get ( '_scroll_id' ) # end of scroll if scroll_id is None or not resp [ 'hits' ] [ 'hits' ] : break", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if git command is available . [CODESPLIT] def check_git ( ) : try : with open ( os . devnull , \"wb\" ) as devnull : subprocess . check_call ( [ \"git\" , \"--version\" ] , stdout = devnull , stderr = devnull ) except : raise RuntimeError ( \"Please make sure git is installed and on your path.\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A standard compound hash . [CODESPLIT] def double_sha256 ( data ) : return bytes_as_revhex ( hashlib . sha256 ( hashlib . sha256 ( data ) . digest ( ) ) . digest ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return group content . [CODESPLIT] def _read_group_h5 ( filename , groupname ) : with h5py . File ( filename , 'r' ) as h5f : data = h5f [ groupname ] [ ( ) ] return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the value coresponding to the given enum name . [CODESPLIT] def Value ( self , name ) : if name in self . _enum_type . values_by_name : return self . _enum_type . values_by_name [ name ] . number raise ValueError ( 'Enum %s has no value defined for name %s' % ( self . _enum_type . name , name ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check for Python 3 . 6 async comprehension . [CODESPLIT] def async_comp_check ( self , original , loc , tokens ) : return self . check_py ( \"36\" , \"async comprehension\" , original , loc , tokens )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns the rows columns of terminal [CODESPLIT] def _size_36 ( ) : from shutil import get_terminal_size dim = get_terminal_size ( ) if isinstance ( dim , list ) : return dim [ 0 ] , dim [ 1 ] return dim . lines , dim . columns", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Executes self . function to convert LazyString instance to a real str . [CODESPLIT] def __str__ ( self ) : if not hasattr ( self , '_str' ) : self . _str = self . function ( * self . args , * * self . kwargs ) return self . _str", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute average gradient norm of an image [CODESPLIT] def average_gradient ( data , * kwargs ) : return np . average ( np . array ( np . gradient ( data ) ) ** 2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Performs a join using the union join function . [CODESPLIT] def merge ( left , right , how = 'inner' , key = None , left_key = None , right_key = None , left_as = 'left' , right_as = 'right' ) : return join ( left , right , how , key , left_key , right_key , join_fn = make_union_join ( left_as , right_as ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a histogram for the data to the axes . [CODESPLIT] def _histplot_op ( ax , data , * * kwargs ) : bins = get_bins ( data ) ax . hist ( data , bins = bins , align = \"left\" , density = True , * * kwargs ) return ax", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the final coverage report . This outputs the coverage report aggregating coverage from the unit test runs ( not system test runs ) and then erases coverage data . [CODESPLIT] def cover ( session ) : session . interpreter = 'python3.6' session . install ( 'coverage' , 'pytest-cov' ) session . run ( 'coverage' , 'report' , '--show-missing' , '--fail-under=100' ) session . run ( 'coverage' , 'erase' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete a directory if it s present . If it s not present no - op . [CODESPLIT] def safe_rmtree ( directory ) : if os . path . exists ( directory ) : shutil . rmtree ( directory , True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prints the specified message and exits the program with the specified exit status . [CODESPLIT] def fail ( message = None , exit_status = None ) : print ( 'Error:' , message , file = sys . stderr ) sys . exit ( exit_status or 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get string from file . [CODESPLIT] def get_file_string ( filepath ) : with open ( os . path . abspath ( filepath ) ) as f : return f . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a list of dict like objects and uses champ_id field as Id [CODESPLIT] def _from_list_dict ( cls , list_dic ) : return cls ( { _convert_id ( dic [ cls . CHAMP_ID ] ) : dict ( dic ) for dic in list_dic } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Export the specified context to be capable context transferring [CODESPLIT] def export_context ( cls , context ) : if context is None : return result = [ ( x . context_name ( ) , x . context_value ( ) ) for x in context ] result . reverse ( ) return tuple ( result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the filesize of the PDF [CODESPLIT] def get_filesize ( self , pdf ) : try : filesize = float ( pdf . get_size ( ) ) return filesize / 1024 except ( POSKeyError , TypeError ) : return 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dictionary of key / values from os . environ . [CODESPLIT] def _get_os_environ_dict ( keys ) : return { k : os . environ . get ( k , _UNDEFINED ) for k in keys }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse ASDL from the given file and return a Module node describing it . [CODESPLIT] def parse ( filename ) : with open ( filename ) as f : parser = ASDLParser ( ) return parser . parse ( f . read ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Defines the time after which Exscript fails if it does not receive a prompt from the remote host . [CODESPLIT] def set_timeout ( scope , timeout ) : conn = scope . get ( '__connection__' ) conn . set_timeout ( int ( timeout [ 0 ] ) ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Upload a local file on the remote host . [CODESPLIT] def send_file ( self , local_path , remote_path , user = 'root' , unix_mode = None ) : self . enable_user ( user ) return self . ssh_pool . send_file ( user , local_path , remote_path , unix_mode = unix_mode )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rewrite a file adding a line to its beginning . [CODESPLIT] def prepend_line ( filepath , line ) : with open ( filepath ) as f : lines = f . readlines ( ) lines . insert ( 0 , line ) with open ( filepath , 'w' ) as f : f . writelines ( lines )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fill an array from a list [CODESPLIT] def _fill_array_from_list ( the_list , the_array ) : for i , val in enumerate ( the_list ) : the_array [ i ] = val return the_array", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Assign x and y to an object that has properties x and y . [CODESPLIT] def assign_to ( self , obj ) : obj . x = self . x obj . y = self . y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Composes the passed filters into an and - joined filter . [CODESPLIT] def BROADCAST_FILTER_NOT ( func ) : return lambda u , command , * args , * * kwargs : not func ( u , command , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a datetime from the Amazon - provided datetime string [CODESPLIT] def clean_time ( time_string ) : # Get a timezone-aware datetime object from the string time = dateutil . parser . parse ( time_string ) if not settings . USE_TZ : # If timezone support is not active, convert the time to UTC and # remove the timezone field time = time . astimezone ( timezone . utc ) . replace ( tzinfo = None ) return time", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Populates an object s attributes using the provided dict [CODESPLIT] def populate_obj ( obj , attrs ) : for k , v in attrs . iteritems ( ) : setattr ( obj , k , v )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Populates an object s attributes using the provided dict [CODESPLIT] def populate_obj ( obj , attrs ) : for k , v in attrs . iteritems ( ) : setattr ( obj , k , v )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove missing values according to Baloo s convention . [CODESPLIT] def dropna ( self , subset = None ) : subset = check_and_obtain_subset_columns ( subset , self ) not_nas = [ v . notna ( ) for v in self [ subset ] . _iter ( ) ] and_filter = reduce ( lambda x , y : x & y , not_nas ) return self [ and_filter ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Underline the input [CODESPLIT] def underline ( self , msg ) : return click . style ( msg , underline = True ) if self . colorize else msg", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the list of registered filters ( as a list of strings ) . [CODESPLIT] def registered_filters_list ( self ) : return [ filter_name for filter_name in self . __jinja2_environment . filters . keys ( ) if filter_name not in self . __jinja2_predefined_filters ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Begins an indented block . Must be used in a with code block . All calls to the logger inside of the block will be indented . [CODESPLIT] def indent ( self ) : blk = IndentBlock ( self , self . _indent ) self . _indent += 1 return blk", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if arg is a valid file that already exists on the file system . [CODESPLIT] def is_valid_file ( parser , arg ) : arg = os . path . abspath ( arg ) if not os . path . exists ( arg ) : parser . error ( \"The file %s does not exist!\" % arg ) else : return arg", "target": 1, "target_options": ["no_match", "match"]}
{"input": "expects a _n . array returns the global minimum of ( value - array ) ^2 [CODESPLIT] def index_nearest ( value , array ) : a = ( array - value ) ** 2 return index ( a . min ( ) , a )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the leftmost index of an element in a list using binary search . [CODESPLIT] def bisect_index ( a , x ) : i = bisect . bisect_left ( a , x ) if i != len ( a ) and a [ i ] == x : return i raise ValueError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if the given thing represents a date [CODESPLIT] def is_date ( thing ) : # known date types date_types = ( datetime . datetime , datetime . date , DateTime ) return isinstance ( thing , date_types )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "in comparison to argrelmax () more simple and reliable peak finder [CODESPLIT] def findMax ( arr ) : out = np . zeros ( shape = arr . shape , dtype = bool ) _calcMax ( arr , out ) return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a member from an object by ( string ) name [CODESPLIT] def get_member ( thing_obj , member_string ) : mems = { x [ 0 ] : x [ 1 ] for x in inspect . getmembers ( thing_obj ) } if member_string in mems : return mems [ member_string ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of characters in two strings that don t exactly match [CODESPLIT] def count_string_diff ( a , b ) : shortest = min ( len ( a ) , len ( b ) ) return sum ( a [ i ] != b [ i ] for i in range ( shortest ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get amount of months between dates http : // stackoverflow . com / a / 4040338 [CODESPLIT] def get_months_apart ( d1 , d2 ) : return ( d1 . year - d2 . year ) * 12 + d1 . month - d2 . month", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if the given type is a builtin one . [CODESPLIT] def is_builtin_type ( tp ) : return hasattr ( __builtins__ , tp . __name__ ) and tp is getattr ( __builtins__ , tp . __name__ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create : class : PNG from raw bytes . : arg bytes b : The raw bytes of the PNG file . : rtype : : class : PNG [CODESPLIT] def from_bytes ( cls , b ) : im = cls ( ) im . chunks = list ( parse_chunks ( b ) ) im . init ( ) return im", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rounds a float value off to the desired precision [CODESPLIT] def _saferound ( value , decimal_places ) : try : f = float ( value ) except ValueError : return '' format = '%%.%df' % decimal_places return format % f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gaussian peak [CODESPLIT] def Gaussian ( x , a , x0 , sigma , y0 ) : return a * np . exp ( - ( x - x0 ) ** 2 / ( 2 * sigma ** 2 ) ) + y0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Move the slider only by increment given by resolution . [CODESPLIT] def _increment ( self , * args ) : value = self . _var . get ( ) if self . _resolution : value = self . _start + int ( round ( ( value - self . _start ) / self . _resolution ) ) * self . _resolution self . _var . set ( value ) self . display_value ( value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Render a jinja template [CODESPLIT] def render_template ( env , filename , values = None ) : if not values : values = { } tmpl = env . get_template ( filename ) return tmpl . render ( values )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes two clicks and returns the slope . [CODESPLIT] def click_estimate_slope ( ) : c1 = _pylab . ginput ( ) if len ( c1 ) == 0 : return None c2 = _pylab . ginput ( ) if len ( c2 ) == 0 : return None return ( c1 [ 0 ] [ 1 ] - c2 [ 0 ] [ 1 ] ) / ( c1 [ 0 ] [ 0 ] - c2 [ 0 ] [ 0 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert any array into a 2d numpy array . [CODESPLIT] def make_2d ( ary ) : dim_0 ,  * _ = np . atleast_1d ( ary ) . shape return ary . reshape ( dim_0 , - 1 , order = \"F\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flatten a nested list . [CODESPLIT] def flatten ( l ) : return sum ( map ( flatten , l ) , [ ] ) if isinstance ( l , list ) or isinstance ( l , tuple ) else [ l ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns whether a path names an existing executable file . [CODESPLIT] def is_executable ( path ) : return os . path . isfile ( path ) and os . access ( path , os . X_OK )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Horizontally flip the given PIL Image . [CODESPLIT] def hflip ( img ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) return img . transpose ( Image . FLIP_LEFT_RIGHT )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handle keyboard interrupt and other errors . [CODESPLIT] def run ( self ) : try : self . run_checked ( ) except KeyboardInterrupt : thread . interrupt_main ( ) except Exception : self . internal_error ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Horizontally flip the given PIL Image . [CODESPLIT] def hflip ( img ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) return img . transpose ( Image . FLIP_LEFT_RIGHT )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wait until all the threads are finished . [CODESPLIT] def wait_until_exit ( self ) : [ t . join ( ) for t in self . threads ] self . threads = list ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fill file at [CODESPLIT] def file_writelines_flush_sync ( path , lines ) : fp = open ( path , 'w' ) try : fp . writelines ( lines ) flush_sync_file_object ( fp ) finally : fp . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sends a file via FTP . [CODESPLIT] def _send_file ( self , filename ) : # pylint: disable=E1101 ftp = ftplib . FTP ( host = self . host ) ftp . login ( user = self . user , passwd = self . password ) ftp . set_pasv ( True ) ftp . storbinary ( \"STOR %s\" % os . path . basename ( filename ) , file ( filename , 'rb' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clean up processes after SIGTERM or SIGINT is received . [CODESPLIT] def cleanup_storage ( * args ) : ShardedClusters ( ) . cleanup ( ) ReplicaSets ( ) . cleanup ( ) Servers ( ) . cleanup ( ) sys . exit ( 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert exception info into a string suitable for display . [CODESPLIT] def exception_format ( ) : return \"\" . join ( traceback . format_exception ( sys . exc_info ( ) [ 0 ] , sys . exc_info ( ) [ 1 ] , sys . exc_info ( ) [ 2 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how long you should cache results for cacheable queries [CODESPLIT] def ttl ( self ) : ret = 3600 cn = self . get_process ( ) if \"ttl\" in cn : ret = cn [ \"ttl\" ] return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns : a triple of integers from a version tag [CODESPLIT] def version_triple ( tag ) : groups = re . match ( r'v?(\\d+)\\.(\\d+)\\.(\\d+)' , tag ) . groups ( ) return tuple ( int ( n ) for n in groups )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If called after an update the sprite can move back [CODESPLIT] def move_back ( self , dt ) : self . _position = self . _old_position self . rect . topleft = self . _position self . feet . midbottom = self . rect . midbottom", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Counts the word frequences in a list of sentences . [CODESPLIT] def count ( lines ) : words = [ w for l in lines for w in l . strip ( ) . split ( ) ] return Counter ( words )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a vector randomly within the given rectangle . [CODESPLIT] def from_rectangle ( box ) : x = box . left + box . width * random . uniform ( 0 , 1 ) y = box . bottom + box . height * random . uniform ( 0 , 1 ) return Vector ( x , y )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "searchs a value in a dicionary and returns the key of the first occurrence [CODESPLIT] def get_key_by_value ( dictionary , search_value ) : for key , value in dictionary . iteritems ( ) : if value == search_value : return ugettext ( key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a hdf5 file into a dictionary [CODESPLIT] def h5ToDict ( h5 , readH5pyDataset = True ) : h = h5py . File ( h5 , \"r\" ) ret = unwrapArray ( h , recursive = True , readH5pyDataset = readH5pyDataset ) if readH5pyDataset : h . close ( ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "insert_slash insert / every 2 char [CODESPLIT] def insert_slash ( string , every = 2 ) : return os . path . join ( string [ i : i + every ] for i in xrange ( 0 , len ( string ) , every ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalized Gaussian [CODESPLIT] def gauss_pdf ( x , mu , sigma ) : return 1 / np . sqrt ( 2 * np . pi ) / sigma * np . exp ( - ( x - mu ) ** 2 / 2. / sigma ** 2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A magic method to implement shallow copy behavior . [CODESPLIT] def __copy__ ( self ) : return self . __class__ . load ( self . dump ( ) , context = self . context )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "callback function for key down [CODESPLIT] def _get_history_next ( self ) : if self . _has_history : ret = self . _input_history . return_history ( 1 ) self . string = ret self . _curs_pos = len ( ret )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize a field to a ( min max ) exposure range default is ( 0 255 ) . ( min max ) exposure values . Invert the image if requested . [CODESPLIT] def normalize ( im , invert = False , scale = None , dtype = np . float64 ) : if dtype not in { np . float16 , np . float32 , np . float64 } : raise ValueError ( 'dtype must be numpy.float16, float32, or float64.' ) out = im . astype ( 'float' ) . copy ( ) scale = scale or ( 0.0 , 255.0 ) l , u = ( float ( i ) for i in scale ) out = ( out - l ) / ( u - l ) if invert : out = - out + ( out . max ( ) + out . min ( ) ) return out . astype ( dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a 3 - dimensional rotation matrix . [CODESPLIT] def R_rot_3d ( th ) : sx , sy , sz = np . sin ( th ) . T cx , cy , cz = np . cos ( th ) . T R = np . empty ( ( len ( th ) , 3 , 3 ) , dtype = np . float ) R [ : , 0 , 0 ] = cy * cz R [ : , 0 , 1 ] = - cy * sz R [ : , 0 , 2 ] = sy R [ : , 1 , 0 ] = sx * sy * cz + cx * sz R [ : , 1 , 1 ] = - sx * sy * sz + cx * cz R [ : , 1 , 2 ] = - sx * cy R [ : , 2 , 0 ] = - cx * sy * cz + sx * sz R [ : , 2 , 1 ] = cx * sy * sz + sx * cz R [ : , 2 , 2 ] = cx * cy return R", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fill all null values with NaN values in a column . Null values are None or en empty string [CODESPLIT] def fill_nulls ( self , col : str ) : n = [ None , \"\" ] try : self . df [ col ] = self . df [ col ] . replace ( n , nan ) except Exception as e : self . err ( e )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the percentile of a list of values . [CODESPLIT] def percentile ( values , k ) : if not values : return None values . sort ( ) index = ( len ( values ) * ( float ( k ) / 100 ) ) - 1 return values [ int ( math . ceil ( index ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform relative pathnames into absolute pathnames . [CODESPLIT] def get_absolute_path ( * args ) : directory = os . path . dirname ( os . path . abspath ( __file__ ) ) return os . path . join ( directory , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the percentile of a list of values . [CODESPLIT] def percentile ( values , k ) : if not values : return None values . sort ( ) index = ( len ( values ) * ( float ( k ) / 100 ) ) - 1 return values [ int ( math . ceil ( index ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the names of all callable attributes of an object [CODESPLIT] def get_methods ( * objs ) : return set ( attr for obj in objs for attr in dir ( obj ) if not attr . startswith ( '_' ) and callable ( getattr ( obj , attr ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a object into dictionary with all of its readable attributes . [CODESPLIT] def dict_from_object ( obj : object ) : # If object is a dict instance, no need to convert. return ( obj if isinstance ( obj , dict ) else { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( '_' ) } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Internal function to read an XML file [CODESPLIT] def xmltreefromfile ( filename ) : try : return ElementTree . parse ( filename , ElementTree . XMLParser ( collect_ids = False ) ) except TypeError : return ElementTree . parse ( filename , ElementTree . XMLParser ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Redirect standard out to file . [CODESPLIT] def redirect_output ( fileobj ) : old = sys . stdout sys . stdout = fileobj try : yield fileobj finally : sys . stdout = old", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return pinyin of string the string must be unicode [CODESPLIT] def get ( s , delimiter = '' , format = \"diacritical\" ) : return delimiter . join ( _pinyin_generator ( u ( s ) , format = format ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes the extension from a filename [CODESPLIT] def remove_ext ( fname ) : bn = os . path . basename ( fname ) return os . path . splitext ( bn ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "calculates a rough guess of runtime based on product of parameters [CODESPLIT] def estimate_complexity ( self , x , y , z , n ) : num_calculations = x * y * z * n run_time = num_calculations / 100000 # a 2014 PC does about 100k calcs in a second (guess based on prior logs) return self . show_time_as_short_string ( run_time )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "rewind [CODESPLIT] def do_rewind ( self , line ) : self . print_response ( \"Rewinding from frame %s to 0\" % self . bot . _frame ) self . bot . _frame = 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Lookup country for IP address . [CODESPLIT] def get_geoip ( ip ) : reader = geolite2 . reader ( ) ip_data = reader . get ( ip ) or { } return ip_data . get ( 'country' , { } ) . get ( 'iso_code' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the coordinates from position in meters [CODESPLIT] def unproject ( self , xy ) : ( x , y ) = xy lng = x / EARTH_RADIUS * RAD_TO_DEG lat = 2 * atan ( exp ( y / EARTH_RADIUS ) ) - pi / 2 * RAD_TO_DEG return ( lng , lat )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the len ( a & b ) / len ( a ) [CODESPLIT] def _cosine ( a , b ) : return 1. * len ( a & b ) / ( math . sqrt ( len ( a ) ) * math . sqrt ( len ( b ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Called from the fit method this method gets all the words from the corpus and their corresponding frequency counts . [CODESPLIT] def count ( self , X ) : # Sum on axis 0 (by columns), each column is a word # Convert the matrix to an array # Squeeze to remove the 1 dimension objects (like ravel) return np . squeeze ( np . asarray ( X . sum ( axis = 0 ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return current threads prepared for further processing . [CODESPLIT] def get_current_frames ( ) : return dict ( ( thread_id , { 'frame' : thread2list ( frame ) , 'time' : None } ) for thread_id , frame in sys . _current_frames ( ) . items ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace all None values in a dict with none [CODESPLIT] def _replace_none ( self , aDict ) : for k , v in aDict . items ( ) : if v is None : aDict [ k ] = 'none'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute timestamp from a datetime object that could be timezone aware or unaware . [CODESPLIT] def timestamp_from_datetime ( dt ) : try : utc_dt = dt . astimezone ( pytz . utc ) except ValueError : utc_dt = dt . replace ( tzinfo = pytz . utc ) return timegm ( utc_dt . timetuple ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list with no repeated elements . [CODESPLIT] def get_uniques ( l ) : result = [ ] for i in l : if i not in result : result . append ( i ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the list of distinct values with preserving order . [CODESPLIT] def distinct ( xs ) : # don't use collections.OrderedDict because we do support Python 2.6 seen = set ( ) return [ x for x in xs if x not in seen and not seen . add ( x ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Whether this path is a symbolic link . [CODESPLIT] def is_symlink ( self ) : try : return S_ISLNK ( self . lstat ( ) . st_mode ) except OSError as e : if e . errno != ENOENT : raise # Path doesn't exist return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The Euclidean distance between two vectors . [CODESPLIT] def vector_distance ( a , b ) : a = np . array ( a ) b = np . array ( b ) return np . linalg . norm ( a - b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns ( module locals ) of the funciton depth frames away from the caller [CODESPLIT] def extract_module_locals ( depth = 0 ) : f = sys . _getframe ( depth + 1 ) global_ns = f . f_globals module = sys . modules [ global_ns [ '__name__' ] ] return ( module , f . f_locals )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if the file is binary [CODESPLIT] def is_binary ( filename ) : with open ( filename , 'rb' ) as fp : data = fp . read ( 1024 ) if not data : return False if b'\\0' in data : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function prints the given String immediately and flushes the output . [CODESPLIT] def printOut ( value , end = '\\n' ) : sys . stdout . write ( value ) sys . stdout . write ( end ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a tuple of ( start end ) indices of an item from its index . [CODESPLIT] def _get_item_position ( self , idx ) : start = 0 if idx == 0 else self . _index [ idx - 1 ] + 1 end = self . _index [ idx ] return start , end", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ajout d un message de log de type WARN [CODESPLIT] def warn ( self , text ) : self . logger . warn ( \"{}{}\" . format ( self . message_prefix , text ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the list of properties specified for a model in an index . [CODESPLIT] def get_model_index_properties ( instance , index ) : mapping = get_index_mapping ( index ) doc_type = instance . _meta . model_name . lower ( ) return list ( mapping [ \"mappings\" ] [ doc_type ] [ \"properties\" ] . keys ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a copy of this list with each element copied to new memory [CODESPLIT] def copy ( self ) : out = type ( self ) ( ) for series in self : out . append ( series . copy ( ) ) return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns json contents as string [CODESPLIT] def open_json ( file_name ) : with open ( file_name , \"r\" ) as json_data : data = json . load ( json_data ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts markdown to text . [CODESPLIT] def markdown_to_text ( body ) : # Turn our input into HTML md = markdown . markdown ( body , extensions = [ 'markdown.extensions.extra' ] ) # Safely parse HTML so that we don't have to parse it ourselves soup = BeautifulSoup ( md , 'html.parser' ) # Return just the text of the parsed HTML return soup . get_text ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Last modified timestamp as a UTC datetime [CODESPLIT] def last_modified_date ( filename ) : mtime = os . path . getmtime ( filename ) dt = datetime . datetime . utcfromtimestamp ( mtime ) return dt . replace ( tzinfo = pytz . utc )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "HTTP response for not - authorized access ( status code 403 ) [CODESPLIT] def HttpResponse401 ( request , template = KEY_AUTH_401_TEMPLATE , content = KEY_AUTH_401_CONTENT , content_type = KEY_AUTH_401_CONTENT_TYPE ) : return AccessFailedResponse ( request , template , content , content_type , status = 401 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract the boundaries from a list of indexes [CODESPLIT] def get_idx_rect ( index_list ) : rows , cols = list ( zip ( * [ ( i . row ( ) , i . column ( ) ) for i in index_list ] ) ) return ( min ( rows ) , max ( rows ) , min ( cols ) , max ( cols ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the SQL typename required to store the given FieldDefinition [CODESPLIT] def _getTypename ( self , defn ) : return 'REAL' if defn . type . float or 'TIME' in defn . type . name or defn . dntoeu else 'INTEGER'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Obtain a real address as an integer from an objectproxy . [CODESPLIT] def objectproxy_realaddress ( obj ) : voidp = QROOT . TPython . ObjectProxy_AsVoidPtr ( obj ) return C . addressof ( C . c_char . from_buffer ( voidp ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the size of remote files [CODESPLIT] def server ( self ) : try : tar = urllib2 . urlopen ( self . registry ) meta = tar . info ( ) return int ( meta . getheaders ( \"Content-Length\" ) [ 0 ] ) except ( urllib2 . URLError , IndexError ) : return \" \"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the current mouse location ( coordinates and screen number ) . [CODESPLIT] def get_mouse_location ( self ) : x = ctypes . c_int ( 0 ) y = ctypes . c_int ( 0 ) screen_num = ctypes . c_int ( 0 ) _libxdo . xdo_get_mouse_location ( self . _xdo , ctypes . byref ( x ) , ctypes . byref ( y ) , ctypes . byref ( screen_num ) ) return mouse_location ( x . value , y . value , screen_num . value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if the json_element passed is present for the task specified . [CODESPLIT] def task_property_present_predicate ( service , task , prop ) : try : response = get_service_task ( service , task ) except Exception as e : pass return ( response is not None ) and ( prop in response )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "List all the filesystems mounted on the system . [CODESPLIT] def GetMountpoints ( ) : devices = { } for filesys in GetFileSystems ( ) : devices [ filesys . f_mntonname ] = ( filesys . f_mntfromname , filesys . f_fstypename ) return devices", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the file - like object is readable . [CODESPLIT] def is_readable ( fp , size = 1 ) : read_size = len ( fp . read ( size ) ) fp . seek ( - read_size , 1 ) return read_size == size", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of active CPUs on a Darwin system . [CODESPLIT] def _num_cpus_darwin ( ) : p = subprocess . Popen ( [ 'sysctl' , '-n' , 'hw.ncpu' ] , stdout = subprocess . PIPE ) return p . stdout . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs command and returns the output as string . [CODESPLIT] def check_output ( args ) : log . debug ( 'run: %s' , args ) out = subprocess . check_output ( args = args ) . decode ( 'utf-8' ) log . debug ( 'out: %r' , out ) return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if there s something to read on stdin ( posix version ) . [CODESPLIT] def _stdin_ready_posix ( ) : infds , outfds , erfds = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return bool ( infds )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Username of document creator [CODESPLIT] def owner ( self ) : if self . _owner : return self . _owner elif not self . abstract : return self . read_meta ( ) . _owner raise EmptyDocumentException ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a object into dictionary with all of its readable attributes . [CODESPLIT] def dict_from_object ( obj : object ) : # If object is a dict instance, no need to convert. return ( obj if isinstance ( obj , dict ) else { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( '_' ) } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a copy of the list without duplicates . [CODESPLIT] def unique ( list ) : unique = [ ] [ unique . append ( x ) for x in list if x not in unique ] return unique", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Just check if raw_image is completely white . http : // stackoverflow . com / questions / 14041562 / python - pil - detect - if - an - image - is - completely - black - or - white [CODESPLIT] def check_color ( cls , raw_image ) : # sum(img.convert(\"L\").getextrema()) in (0, 2)\n extrema = raw_image . convert ( \"L\" ) . getextrema ( ) if extrema == ( 255 , 255 ) : # all white\n raise cls . MonoImageException", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get rid of all axis ticks lines etc . [CODESPLIT] def axes_off ( ax ) : ax . set_frame_on ( False ) ax . axes . get_yaxis ( ) . set_visible ( False ) ax . axes . get_xaxis ( ) . set_visible ( False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "in comparison to argrelmax () more simple and reliable peak finder [CODESPLIT] def findMin ( arr ) : out = np . zeros ( shape = arr . shape , dtype = bool ) _calcMin ( arr , out ) return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets up the python include paths to include src [CODESPLIT] def setup_path ( ) : import os . path import sys if sys . argv [ 0 ] : top_dir = os . path . dirname ( os . path . abspath ( sys . argv [ 0 ] ) ) sys . path = [ os . path . join ( top_dir , \"src\" ) ] + sys . path pass return", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return unix SECOND timestamp of num mondays ago [CODESPLIT] def prevmonday ( num ) : today = get_today ( ) lastmonday = today - timedelta ( days = today . weekday ( ) , weeks = num ) return lastmonday", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Performs a join using the union join function . [CODESPLIT] def merge ( left , right , how = 'inner' , key = None , left_key = None , right_key = None , left_as = 'left' , right_as = 'right' ) : return join ( left , right , how , key , left_key , right_key , join_fn = make_union_join ( left_as , right_as ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the 1 - based index of the last object on this page relative to total objects found ( hits ) . [CODESPLIT] def end_index ( self ) : return ( ( self . number - 1 ) * self . paginator . per_page + len ( self . object_list ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Python s input () is blocking which means the event loop we set above can t be running while we re blocking there . This method will let the loop run while we wait for input . [CODESPLIT] async def async_input ( prompt ) : print ( prompt , end = '' , flush = True ) return ( await loop . run_in_executor ( None , sys . stdin . readline ) ) . rstrip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a property s value . [CODESPLIT] def get_property ( self , property_name ) : prop = self . find_property ( property_name ) if prop : return prop . get_value ( ) return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Copy a file whole from input to output . [CODESPLIT] def copyFile ( input , output , replace = None ) : _found = findFile ( output ) if not _found or ( _found and replace ) : shutil . copy2 ( input , output )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the ASCII int value of a character in a string . [CODESPLIT] def byte2int ( s , index = 0 ) : if six . PY2 : return ord ( s [ index ] ) return s [ index ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Indents a string by the given amount of characters . [CODESPLIT] def indent ( text , amount , ch = ' ' ) : padding = amount * ch return '' . join ( padding + line for line in text . splitlines ( True ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Weeks start are fixes at Monday for now . [CODESPLIT] def weekly ( date = datetime . date . today ( ) ) : return date - datetime . timedelta ( days = date . weekday ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get user name provide by operating system [CODESPLIT] def get_user_name ( ) : if sys . platform == 'win32' : #user = os.getenv('USERPROFILE') user = os . getenv ( 'USERNAME' ) else : user = os . getenv ( 'LOGNAME' ) return user", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse an int robustly ignoring commas and other cruft . [CODESPLIT] def robust_int ( v ) : if isinstance ( v , int ) : return v if isinstance ( v , float ) : return int ( v ) v = str ( v ) . replace ( ',' , '' ) if not v : return None return int ( v )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get a value from a tag ( if it exists ) [CODESPLIT] def _get_minidom_tag_value ( station , tag_name ) : tag = station . getElementsByTagName ( tag_name ) [ 0 ] . firstChild if tag : return tag . nodeValue return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Interpolate the given slice of the larger array . [CODESPLIT] def interpolate_slice ( slice_rows , slice_cols , interpolator ) : fine_rows = np . arange ( slice_rows . start , slice_rows . stop , slice_rows . step ) fine_cols = np . arange ( slice_cols . start , slice_cols . stop , slice_cols . step ) return interpolator ( fine_cols , fine_rows )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resample spectrum onto desired grid [CODESPLIT] def resample ( grid , wl , flux ) : flux_rs = ( interpolate . interp1d ( wl , flux ) ) ( grid ) return flux_rs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a Python - friendly id [CODESPLIT] def pythonise ( id , encoding = 'ascii' ) : replace = { '-' : '_' , ':' : '_' , '/' : '_' } func = lambda id , pair : id . replace ( pair [ 0 ] , pair [ 1 ] ) id = reduce ( func , replace . iteritems ( ) , id ) id = '_%s' % id if id [ 0 ] in string . digits else id return id . encode ( encoding )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns the name of an EVREvent enum value [CODESPLIT] def getEventTypeNameFromEnum ( self , eType ) : fn = self . function_table . getEventTypeNameFromEnum result = fn ( eType ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Lookup country for IP address . [CODESPLIT] def get_geoip ( ip ) : reader = geolite2 . reader ( ) ip_data = reader . get ( ip ) or { } return ip_data . get ( 'country' , { } ) . get ( 'iso_code' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if git command is available . [CODESPLIT] def check_git ( ) : try : with open ( os . devnull , \"wb\" ) as devnull : subprocess . check_call ( [ \"git\" , \"--version\" ] , stdout = devnull , stderr = devnull ) except : raise RuntimeError ( \"Please make sure git is installed and on your path.\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if the string is a palindrome ( https : // en . wikipedia . org / wiki / Palindrome ) . [CODESPLIT] def is_palindrome ( string , strict = True ) : if is_full_string ( string ) : if strict : return reverse ( string ) == string return is_palindrome ( SPACES_RE . sub ( '' , string ) ) return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert bytes and non - string into Python 3 str [CODESPLIT] def to_str ( s ) : if isinstance ( s , bytes ) : s = s . decode ( 'utf-8' ) elif not isinstance ( s , str ) : s = str ( s ) return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the bounding box around nonzero elements in the given array [CODESPLIT] def bbox ( img ) : rows = np . any ( img , axis = 1 ) cols = np . any ( img , axis = 0 ) rmin , rmax = np . where ( rows ) [ 0 ] [ [ 0 , - 1 ] ] cmin , cmax = np . where ( cols ) [ 0 ] [ [ 0 , - 1 ] ] return rmin , rmax , cmin , cmax", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Splits a list into chunks [CODESPLIT] def chunks ( arr , size ) : for i in _range ( 0 , len ( arr ) , size ) : yield arr [ i : i + size ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute a stored procedure . Returns the first row of the result set or None . [CODESPLIT] def query_proc_row ( procname , args = ( ) , factory = None ) : for row in query_proc ( procname , args , factory ) : return row return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Similar to #itertools . chain . from_iterable () . [CODESPLIT] def concat ( cls , iterables ) : def generator ( ) : for it in iterables : for element in it : yield element return cls ( generator ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Same as lazy_binmap except the parameters are flipped for the binary function [CODESPLIT] def lazy_reverse_binmap ( f , xs ) : return ( f ( y , x ) for x , y in zip ( xs , xs [ 1 : ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pop the head off the iterator and return it . [CODESPLIT] def __next__ ( self ) : res = self . _head self . _fill ( ) if res is None : raise StopIteration ( ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "why is this not in heapq [CODESPLIT] def _heappush_max ( heap , item ) : heap . append ( item ) heapq . _siftdown_max ( heap , 0 , len ( heap ) - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert iterable object into numpy array [CODESPLIT] def A ( * a ) : return np . array ( a [ 0 ] ) if len ( a ) == 1 else [ np . array ( o ) for o in a ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": type root : TreeNode : rtype : int [CODESPLIT] def min_depth ( self , root ) : if root is None : return 0 if root . left is not None or root . right is not None : return max ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1 return min ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterates through each image in the given directory . ( not recursive ) : param dir_path : Directory path where images files are present : return : Iterator to iterate through image files [CODESPLIT] def each_img ( dir_path ) : for fname in os . listdir ( dir_path ) : if fname . endswith ( '.jpg' ) or fname . endswith ( '.png' ) or fname . endswith ( '.bmp' ) : yield fname", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Hex encode a binary string [CODESPLIT] def hex_escape ( bin_str ) : printable = string . ascii_letters + string . digits + string . punctuation + ' ' return '' . join ( ch if ch in printable else r'0x{0:02x}' . format ( ord ( ch ) ) for ch in bin_str )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple directory walker [CODESPLIT] def get_files ( dir_name ) : return [ ( os . path . join ( '.' , d ) , [ os . path . join ( d , f ) for f in files ] ) for d , _ , files in os . walk ( dir_name ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If pygments are available on the system then returned output is colored . Otherwise unchanged content is returned . [CODESPLIT] def get_highlighted_code ( name , code , type = 'terminal' ) : import logging try : import pygments pygments except ImportError : return code from pygments import highlight from pygments . lexers import guess_lexer_for_filename , ClassNotFound from pygments . formatters import TerminalFormatter try : lexer = guess_lexer_for_filename ( name , code ) formatter = TerminalFormatter ( ) content = highlight ( code , lexer , formatter ) except ClassNotFound : logging . debug ( \"Couldn't guess Lexer, will not use pygments.\" ) content = code return content", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Internal helper to return the values of a dictionary sorted by key . [CODESPLIT] def _dict_values_sorted_by_key ( dictionary ) : # This should be a yield from instead. for _ , value in sorted ( dictionary . iteritems ( ) , key = operator . itemgetter ( 0 ) ) : yield value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of all parsed comments in a file . Mostly for testing & interactive use . [CODESPLIT] def parse_comments_for_file ( filename ) : return [ parse_comment ( strip_stars ( comment ) , next_line ) for comment , next_line in get_doc_comments ( read_file ( filename ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterate through all elements . [CODESPLIT] def __iter__ ( self ) : for value , count in self . counts ( ) : for _ in range ( count ) : yield value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the value of each QuerySet but also add the # property to each return item . [CODESPLIT] def _unordered_iterator ( self ) : for i , qs in zip ( self . _queryset_idxs , self . _querysets ) : for item in qs : setattr ( item , '#' , i ) yield item", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a pretty formated xml [CODESPLIT] def pretty_xml ( data ) : parsed_string = minidom . parseString ( data . decode ( 'utf-8' ) ) return parsed_string . toprettyxml ( indent = '\\t' , encoding = 'utf-8' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns an iterator over chunk_len chunks of source [CODESPLIT] def get_chunks ( source , chunk_len ) : return ( source [ i : i + chunk_len ] for i in range ( 0 , len ( source ) , chunk_len ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the index of elem in the reversed iterator . [CODESPLIT] def index ( self , elem ) : return _coconut . len ( self . _iter ) - self . _iter . index ( elem ) - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "* Get the root path for this python package - used in unit testing code * [CODESPLIT] def getpackagepath ( ) : moduleDirectory = os . path . dirname ( __file__ ) packagePath = os . path . dirname ( __file__ ) + \"/../\" return packagePath", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the last object in file . [CODESPLIT] def last ( self ) : # End of file self . __file . seek ( 0 , 2 ) # Get the last struct data = self . get ( self . length - 1 ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a list of tuples describing a table into a HTML string [CODESPLIT] def html ( header_rows ) : name = 'table%d' % next ( tablecounter ) return HtmlTable ( [ map ( str , row ) for row in header_rows ] , name ) . render ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Authenticates account using soap method . [CODESPLIT] def authenticate ( self , transport , account_name , password = None ) : Authenticator . authenticate ( self , transport , account_name , password ) if password == None : return self . pre_auth ( transport , account_name ) else : return self . auth ( transport , account_name , password )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Render a template into a response . [CODESPLIT] def render_template ( template_name , * * context ) : tmpl = jinja_env . get_template ( template_name ) context [ \"url_for\" ] = url_for return Response ( tmpl . render ( context ) , mimetype = \"text/html\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert numbers to floats whether the decimal point is . or [CODESPLIT] def comma_converter ( float_string ) : trans_table = maketrans ( b',' , b'.' ) return float ( float_string . translate ( trans_table ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Render our pages as a jinja template for fancy templating goodness . [CODESPLIT] def rstjinja ( app , docname , source ) : # Make sure we're outputting HTML if app . builder . format != 'html' : return src = source [ 0 ] rendered = app . builder . templates . render_string ( src , app . config . html_context ) source [ 0 ] = rendered", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Allow \\ n . join ( ... ) statements to work in Py2 and Py3 . : param sep : : param joinable : : return : [CODESPLIT] def _py2_and_3_joiner ( sep , joinable ) : if ISPY3 : sep = bytes ( sep , DEFAULT_ENCODING ) joined = sep . join ( joinable ) return joined . decode ( DEFAULT_ENCODING ) if ISPY3 else joined", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterate through all elements . [CODESPLIT] def __iter__ ( self ) : for value , count in self . counts ( ) : for _ in range ( count ) : yield value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Path join helper method Join paths if list passed [CODESPLIT] def prepare_path ( path ) : if type ( path ) == list : return os . path . join ( * path ) return path", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if data is JSON serializable . [CODESPLIT] def is_valid_data ( obj ) : if obj : try : tmp = json . dumps ( obj , default = datetime_encoder ) del tmp except ( TypeError , UnicodeDecodeError ) : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "utility to set a floating value useful for converting from strings [CODESPLIT] def set_float ( val ) : out = None if not val in ( None , '' ) : try : out = float ( val ) except ValueError : return None if numpy . isnan ( out ) : out = default return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse a list of JSON objects into a result set of model instances . [CODESPLIT] def parse_list ( cls , api , json_list ) : results = [ ] for json_obj in json_list : if json_obj : obj = cls . parse ( api , json_obj ) results . append ( obj ) return results", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test program for telnetlib . [CODESPLIT] def test ( ) : debuglevel = 0 while sys . argv [ 1 : ] and sys . argv [ 1 ] == '-d' : debuglevel = debuglevel + 1 del sys . argv [ 1 ] host = 'localhost' if sys . argv [ 1 : ] : host = sys . argv [ 1 ] port = 0 if sys . argv [ 2 : ] : portstr = sys . argv [ 2 ] try : port = int ( portstr ) except ValueError : port = socket . getservbyname ( portstr , 'tcp' ) tn = Telnet ( ) tn . set_debuglevel ( debuglevel ) tn . open ( host , port ) tn . interact ( ) tn . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit without garbage collection this speeds up exit by about 10ms for things like bash completion . [CODESPLIT] def fast_exit ( code ) : sys . stdout . flush ( ) sys . stderr . flush ( ) os . _exit ( code )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a json string representing the python object obj . [CODESPLIT] def to_json ( obj ) : i = StringIO . StringIO ( ) w = Writer ( i , encoding = 'UTF-8' ) w . write_value ( obj ) return i . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets multiple headers on the request and returns the request itself . [CODESPLIT] def with_headers ( self , headers ) : for key , value in headers . items ( ) : self . with_header ( key , value ) return self", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return info about an object s members as JSON [CODESPLIT] def as_tree ( context ) : tree = _build_tree ( context , 2 , 1 ) if type ( tree ) == dict : tree = [ tree ] return Response ( content_type = 'application/json' , body = json . dumps ( tree ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fold all values of the matrix into [ 0 1 ] . [CODESPLIT] def normalize_matrix ( matrix ) : abs_matrix = np . abs ( matrix . copy ( ) ) return abs_matrix / abs_matrix . max ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert value from json to a python object [CODESPLIT] def process_result_value ( self , value , dialect ) : if value is not None : value = simplejson . loads ( value ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "HParams for training languagemodel_lm1b32k_packed . 880M Params . [CODESPLIT] def lmx_h1k_f64k ( ) : hparams = lmx_base ( ) hparams . hidden_size = 1024 hparams . filter_size = 65536 hparams . batch_size = 2048 return hparams", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator to explicitly mark functions that are exposed in a lib . [CODESPLIT] def export ( defn ) : globals ( ) [ defn . __name__ ] = defn __all__ . append ( defn . __name__ ) return defn", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Send signal to process . [CODESPLIT] def process_kill ( pid , sig = None ) : sig = sig or signal . SIGTERM os . kill ( pid , sig )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Implements the === operator . [CODESPLIT] def hard_equals ( a , b ) : if type ( a ) != type ( b ) : return False return a == b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap an AST Call node to lambda expression node . call : ast . Call node [CODESPLIT] def make_lambda ( call ) : empty_args = ast . arguments ( args = [ ] , vararg = None , kwarg = None , defaults = [ ] ) return ast . Lambda ( args = empty_args , body = call )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "prints a date - object [CODESPLIT] def print_datetime_object ( dt ) : print ( dt ) print ( 'ctime  :' , dt . ctime ( ) ) print ( 'tuple  :' , dt . timetuple ( ) ) print ( 'ordinal:' , dt . toordinal ( ) ) print ( 'Year   :' , dt . year ) print ( 'Mon    :' , dt . month ) print ( 'Day    :' , dt . day )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retries function until it doesn t raise an EINTR error [CODESPLIT] def retry_on_signal ( function ) : while True : try : return function ( ) except EnvironmentError , e : if e . errno != errno . EINTR : raise", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a lowercase string with punctuation and bad chars removed : param s : string to clean [CODESPLIT] def _clean_str ( self , s ) : return s . translate ( str . maketrans ( '' , '' , punctuation ) ) . replace ( '\\u200b' , \" \" ) . strip ( ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pad the text . [CODESPLIT] def _pad ( self , text ) : top_bottom = ( \"\\n\" * self . _padding ) + \" \" right_left = \" \" * self . _padding * self . PAD_WIDTH return top_bottom + right_left + text + right_left + top_bottom", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap the text on the given line length . [CODESPLIT] def normalize_text ( text , line_len = 80 , indent = \"\" ) : return \"\\n\" . join ( textwrap . wrap ( text , width = line_len , initial_indent = indent , subsequent_indent = indent ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add plots to an existing plot [CODESPLIT] def add_plot ( x , y , xl , yl , fig , ax , LATEX = False , linestyle = None , * * kwargs ) : if LATEX : xl_data = xl [ 1 ] # NOQA yl_data = yl [ 1 ] else : xl_data = xl [ 0 ] # NOQA yl_data = yl [ 0 ] for idx in range ( len ( y ) ) : ax . plot ( x , y [ idx ] , label = yl_data [ idx ] , linestyle = linestyle ) ax . legend ( loc = 'upper right' ) ax . set_ylim ( auto = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to easily create the proper json formated string from a list of strs : param cmd_list : list of strings : return : str json formatted [CODESPLIT] def _make_cmd_list ( cmd_list ) : cmd = '' for i in cmd_list : cmd = cmd + '\"' + i + '\",' cmd = cmd [ : - 1 ] return cmd", "target": 1, "target_options": ["no_match", "match"]}
{"input": "inverse hyperbolic sine transformation [CODESPLIT] def inh ( table ) : t = [ ] for i in table : t . append ( np . ndarray . tolist ( np . arcsinh ( i ) ) ) return t", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if an element from a list is in a string . [CODESPLIT] def isin ( elems , line ) : found = False for e in elems : if e in line . lower ( ) : found = True break return found", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the names of all callable attributes of an object [CODESPLIT] def get_methods ( * objs ) : return set ( attr for obj in objs for attr in dir ( obj ) if not attr . startswith ( '_' ) and callable ( getattr ( obj , attr ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Quick way to read a file content . [CODESPLIT] def read ( fname ) : content = None with open ( os . path . join ( here , fname ) ) as f : content = f . read ( ) return content", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks to see if a 2D list is a valid 2D matrix [CODESPLIT] def _rectangular ( n ) : for i in n : if len ( i ) != len ( n [ 0 ] ) : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove duplicates from a sequence preserving order [CODESPLIT] def remove_dups ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "abstract method [CODESPLIT] def poke_array ( self , store , name , elemtype , elements , container , visited , _stack ) : raise NotImplementedError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns first and last element of numpy array or sparse matrix . [CODESPLIT] def _first_and_last_element ( arr ) : if isinstance ( arr , np . ndarray ) or hasattr ( arr , 'data' ) : # numpy array or sparse matrix with .data attribute data = arr . data if sparse . issparse ( arr ) else arr return data . flat [ 0 ] , data . flat [ - 1 ] else : # Sparse matrices without .data attribute. Only dok_matrix at # the time of writing, in this case indexing is fast return arr [ 0 , 0 ] , arr [ - 1 , - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a ctypes double pointer array to a numpy array . [CODESPLIT] def cfloat64_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_double ) ) : return np . fromiter ( cptr , dtype = np . float64 , count = length ) else : raise RuntimeError ( 'Expected double pointer' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert iterable object into numpy array [CODESPLIT] def A ( * a ) : return np . array ( a [ 0 ] ) if len ( a ) == 1 else [ np . array ( o ) for o in a ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last n rows in the table [CODESPLIT] def get_last_row ( dbconn , tablename , n = 1 , uuid = None ) : return fetch ( dbconn , tablename , n , uuid , end = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets the median of a list of values Returns a float / int [CODESPLIT] def getMedian ( numericValues ) : theValues = sorted ( numericValues ) if len ( theValues ) % 2 == 1 : return theValues [ ( len ( theValues ) + 1 ) / 2 - 1 ] else : lower = theValues [ len ( theValues ) / 2 - 1 ] upper = theValues [ len ( theValues ) / 2 ] return ( float ( lower + upper ) ) / 2", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Loads the dictionary from json file : param fname : file to load from : return : loaded dictionary [CODESPLIT] def load ( cls , fname ) : with open ( fname ) as f : return Config ( * * json . load ( f ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shows the given correlation matrix as image [CODESPLIT] def show_correlation_matrix ( self , correlation_matrix ) : cr_plot . create_correlation_matrix_plot ( correlation_matrix , self . title , self . headers_to_test ) pyplot . show ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Loads and returns foreign library . [CODESPLIT] def load ( self , name ) : name = ctypes . util . find_library ( name ) return ctypes . cdll . LoadLibrary ( name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Undo the effects of patch ( func obj name ) [CODESPLIT] def unpatch ( obj , name ) : setattr ( obj , name , getattr ( obj , name ) . original )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the height of the given line . ( The height that it would take if this line became visible . ) [CODESPLIT] def get_height_for_line ( self , lineno ) : if self . wrap_lines : return self . ui_content . get_height_for_line ( lineno , self . window_width ) else : return 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load a pickled obj from the filesystem . [CODESPLIT] def load ( filename ) : if not os . path . exists ( filename ) : LOG . error ( \"load object - File '%s' does not exist.\" , filename ) return None obj = None with open ( filename , 'rb' ) as obj_file : obj = dill . load ( obj_file ) return obj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple function to add two numbers [CODESPLIT] def generic_add ( a , b ) : logger . debug ( 'Called generic_add({}, {})' . format ( a , b ) ) return a + b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load graph as defined by a DOT file . The file is assumed to be in DOT format . It will be loaded parsed and a Dot class will be returned representing the graph . [CODESPLIT] def graph_from_dot_file ( path ) : fd = file ( path , 'rb' ) data = fd . read ( ) fd . close ( ) return graph_from_dot_data ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Toggles document word wrap . [CODESPLIT] def toggle_word_wrap ( self ) : self . setWordWrapMode ( not self . wordWrapMode ( ) and QTextOption . WordWrap or QTextOption . NoWrap ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Loads UTF8 string : param reader : : return : [CODESPLIT] async def load_unicode ( reader ) : ivalue = await load_uvarint ( reader ) fvalue = bytearray ( ivalue ) await reader . areadinto ( fvalue ) return str ( fvalue , 'utf8' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Use this function to store data in a JSON file . [CODESPLIT] def store_data ( data ) : with open ( url_json_path ) as json_file : try : json_file_data = load ( json_file ) json_file_data . update ( data ) except ( AttributeError , JSONDecodeError ) : json_file_data = data with open ( url_json_path , 'w' ) as json_file : dump ( json_file_data , json_file , indent = 4 , sort_keys = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses numpy . load to open the underlying file [CODESPLIT] def _openResources ( self ) : arr = np . load ( self . _fileName , allow_pickle = ALLOW_PICKLE ) check_is_an_array ( arr ) self . _array = arr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load the pickled model weights . [CODESPLIT] def load ( self , path ) : with io . open ( path , 'rb' ) as fin : self . weights = pickle . load ( fin )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Loads a model from specified file [CODESPLIT] def Load ( file ) : with open ( file , 'rb' ) as file : model = dill . load ( file ) return model", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the indices of elements whose field first satisfies the given values [CODESPLIT] def elem_find ( self , field , value ) : if isinstance ( value , ( int , float , str ) ) : value = [ value ] f = list ( self . __dict__ [ field ] ) uid = np . vectorize ( f . index ) ( value ) return self . get_idx ( uid )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert snake case to camel case [CODESPLIT] def camel_case ( self , snake_case ) : components = snake_case . split ( '_' ) return components [ 0 ] + \"\" . join ( x . title ( ) for x in components [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple memoization for functions without keyword arguments . [CODESPLIT] def simple_memoize ( callable_object ) : cache = dict ( ) def wrapper ( * rest ) : if rest not in cache : cache [ rest ] = callable_object ( * rest ) return cache [ rest ] return wrapper", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Releases the specified mouse button . [CODESPLIT] def buttonUp ( self , button = mouse . LEFT ) : self . _lock . acquire ( ) mouse . release ( button ) self . _lock . release ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the log of the magnitude spectrum of frames [CODESPLIT] def log_magnitude_spectrum ( frames ) : return N . log ( N . abs ( N . fft . rfft ( frames ) ) . clip ( 1e-5 , N . inf ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Attempts to convert given object to a string object [CODESPLIT] def to_str ( obj ) : if not isinstance ( obj , str ) and PY3 and isinstance ( obj , bytes ) : obj = obj . decode ( 'utf-8' ) return obj if isinstance ( obj , string_types ) else str ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Logarithmic loss with non - necessarily - binary labels . [CODESPLIT] def log_loss ( preds , labels ) : log_likelihood = np . sum ( labels * np . log ( preds ) ) / len ( preds ) return - log_likelihood", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load logger config from file Keyword arguments : filename -- configuration filename ( Default : logging . ini ) * args -- options passed to fileConfig ** kwargs -- options passed to fileConfigg [CODESPLIT] def load_config ( filename = \"logging.ini\" , * args , * * kwargs ) : logging . config . fileConfig ( filename , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create the stream handler . Used for console / debug output . [CODESPLIT] def make_stream_handler ( graph , formatter ) : return { \"class\" : graph . config . logging . stream_handler . class_ , \"formatter\" : formatter , \"level\" : graph . config . logging . level , \"stream\" : graph . config . logging . stream_handler . stream , }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handle logging . [CODESPLIT] def logger ( message , level = 10 ) : logging . getLogger ( __name__ ) . log ( level , str ( message ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert an integer list into a string list . [CODESPLIT] def list_i2str ( ilist ) : slist = [ ] for el in ilist : slist . append ( str ( el ) ) return slist", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Search for and return the file and line number from the log collector . [CODESPLIT] def GetLoggingLocation ( ) : frame = inspect . currentframe ( ) this_file = frame . f_code . co_filename frame = frame . f_back while frame : if this_file == frame . f_code . co_filename : if 'cdbg_logging_location' in frame . f_locals : ret = frame . f_locals [ 'cdbg_logging_location' ] if len ( ret ) != 3 : return ( None , None , None ) return ret frame = frame . f_back return ( None , None , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Integer to two bytes [CODESPLIT] def intToBin ( i ) : # devide in two parts (bytes) i1 = i % 256 i2 = int ( i / 256 ) # make string (little endian) return chr ( i1 ) + chr ( i2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ajout d un message de log de type DEBUG [CODESPLIT] def debug ( self , text ) : self . logger . debug ( \"{}{}\" . format ( self . message_prefix , text ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace accentuated chars in string by their non accentuated equivalent . [CODESPLIT] def unaccentuate ( s ) : return \"\" . join ( c for c in unicodedata . normalize ( \"NFKD\" , s ) if not unicodedata . combining ( c ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "print the message to the predefined log file without newline [CODESPLIT] def log_no_newline ( self , msg ) : self . print2file ( self . logfile , False , False , msg )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param dt : pythone datetime . datetime : return : 1999 - 02 - 01 string type [CODESPLIT] def QA_util_datetime_to_strdate ( dt ) : strdate = \"%04d-%02d-%02d\" % ( dt . year , dt . month , dt . day ) return strdate", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A Bark logging handler logging output to a named file . At intervals specified by the when the file will be rotated under control of backupCount . [CODESPLIT] def timed_rotating_file_handler ( name , logname , filename , when = 'h' , interval = 1 , backupCount = 0 , encoding = None , delay = False , utc = False ) : return wrap_log_handler ( logging . handlers . TimedRotatingFileHandler ( filename , when = when , interval = interval , backupCount = backupCount , encoding = encoding , delay = delay , utc = utc ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Private method for setting axis limits . [CODESPLIT] def _set_axis_limits ( self , which , lims , d , scale , reverse = False ) : setattr ( self . limits , which + 'lims' , lims ) setattr ( self . limits , 'd' + which , d ) setattr ( self . limits , which + 'scale' , scale ) if reverse : setattr ( self . limits , 'reverse_' + which + '_axis' , True ) return", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the length of the longest consecutive run of True values . [CODESPLIT] def longest_run ( da , dim = 'time' ) : d = rle ( da , dim = dim ) rl_long = d . max ( dim = dim ) return rl_long", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of all parsed comments in a file . Mostly for testing & interactive use . [CODESPLIT] def parse_comments_for_file ( filename ) : return [ parse_comment ( strip_stars ( comment ) , next_line ) for comment , next_line in get_doc_comments ( read_file ( filename ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Skip the specified number of elements in the list . [CODESPLIT] def skip ( self , n ) : try : self . _iter_object . skip ( n ) except AttributeError : for i in range ( 0 , n ) : self . next ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Encodes Unicode strings to byte strings if necessary . [CODESPLIT] def b ( s ) : return s if isinstance ( s , bytes ) else s . encode ( locale . getpreferredencoding ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like pretty but print to stdout . [CODESPLIT] def pprint ( obj , verbose = False , max_width = 79 , newline = '\\n' ) : printer = RepresentationPrinter ( sys . stdout , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) sys . stdout . write ( newline ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a spec to a mock . spec can either be an object or a list of strings . Only attributes on the spec can be fetched as attributes from the mock . [CODESPLIT] def mock_add_spec ( self , spec , spec_set = False ) : self . _mock_add_spec ( spec , spec_set ) self . _mock_set_magics ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Inputs [ a b c ] returns { a : 0 b : 1 c : 2 } . [CODESPLIT] def list_string_to_dict ( string ) : dictionary = { } for idx , c in enumerate ( string ) : dictionary . update ( { c : idx } ) return dictionary", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Does openat read - only then does fdopen to get a file object [CODESPLIT] def fopenat ( base_fd , path ) : return os . fdopen ( openat ( base_fd , path , os . O_RDONLY ) , 'rb' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Implements string formatting along with color specified in colorama . Fore [CODESPLIT] def colorize ( string , color , * args , * * kwargs ) : string = string . format ( * args , * * kwargs ) return color + string + colorama . Fore . RESET", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the exectuable bit on the given filename [CODESPLIT] def set_executable ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Does a string replace with a list of search and replacements [CODESPLIT] def multi_replace ( instr , search_list = [ ] , repl_list = None ) : repl_list = [ '' ] * len ( search_list ) if repl_list is None else repl_list for ser , repl in zip ( search_list , repl_list ) : instr = instr . replace ( ser , repl ) return instr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Changes a column name in a DataFrame Parameters : df - DataFrame DataFrame to operate on col_name - string Name of column to change new_col_name - string New name of column [CODESPLIT] def col_rename ( df , col_name , new_col_name ) : col_list = list ( df . columns ) for index , value in enumerate ( col_list ) : if value == col_name : col_list [ index ] = new_col_name break df . columns = col_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a string representing a numpy array of 0 s and 1 s [CODESPLIT] def bitsToString ( arr ) : s = array ( 'c' , '.' * len ( arr ) ) for i in xrange ( len ( arr ) ) : if arr [ i ] == 1 : s [ i ] = '*' return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generates ( urlencoded ) query string from stored key - values tuples [CODESPLIT] def create_search_url ( self ) : url = '?' for key , value in self . arguments . items ( ) : url += '%s=%s&' % ( quote_plus ( key ) , quote_plus ( value ) ) self . url = url [ : - 1 ] return self . url", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Append text to the User - Agent header for the request . [CODESPLIT] def append_user_agent ( self , user_agent ) : old_ua = self . session . headers . get ( 'User-Agent' , '' ) ua = old_ua + ' ' + user_agent self . session . headers [ 'User-Agent' ] = ua . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create directories if they do not exist otherwise do nothing . [CODESPLIT] def makedirs ( path ) : if not os . path . isdir ( path ) : os . makedirs ( path ) return path", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Will make any functions return an iterable objects by wrapping its result in a list . [CODESPLIT] def force_iterable ( f ) : def wrapper ( * args , * * kwargs ) : r = f ( * args , * * kwargs ) if hasattr ( r , '__iter__' ) : return r else : return [ r ] return wrapper", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Do all elements of x have a type from types? [CODESPLIT] def _valid_other_type ( x , types ) : return all ( any ( isinstance ( el , t ) for t in types ) for el in np . ravel ( x ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates the returned positional object [CODESPLIT] def _validate_pos ( df ) : assert isinstance ( df , pd . DataFrame ) assert [ \"seqname\" , \"position\" , \"strand\" ] == df . columns . tolist ( ) assert df . position . dtype == np . dtype ( \"int64\" ) assert df . strand . dtype == np . dtype ( \"O\" ) assert df . seqname . dtype == np . dtype ( \"O\" ) return df", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Start the Django dev server . [CODESPLIT] def server ( port ) : args = [ 'python' , 'manage.py' , 'runserver' ] if port : args . append ( port ) run . main ( args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if required dependency is installed [CODESPLIT] def check ( modname ) : for dependency in DEPENDENCIES : if dependency . modname == modname : return dependency . check ( ) else : raise RuntimeError ( \"Unkwown dependency %s\" % modname )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Build dumpdata commands [CODESPLIT] def generate_dumper ( self , mapfile , names ) : return self . build_template ( mapfile , names , self . _dumpdata_template )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses head object to make sure the file exists in S3 . [CODESPLIT] def health_check ( self ) : logger . debug ( 'Health Check on S3 file for: {namespace}' . format ( namespace = self . namespace ) ) try : self . client . head_object ( Bucket = self . bucket_name , Key = self . data_file ) return True except ClientError as e : logger . debug ( 'Error encountered with S3.  Assume unhealthy' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a string return true if it matches the supplied list of patterns . [CODESPLIT] def match ( string , patterns ) : if patterns is None : return True else : return any ( re . match ( pattern , string ) for pattern in patterns )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Collect digits from a string [CODESPLIT] def str2int ( string_with_int ) : return int ( \"\" . join ( [ char for char in string_with_int if char in string . digits ] ) or 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check that value is in values [CODESPLIT] def isin ( value , values ) : for i , v in enumerate ( value ) : if v not in np . array ( values ) [ : , i ] : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Register all globally visible functions . [CODESPLIT] def init_checks_registry ( ) : mod = inspect . getmodule ( register_check ) for ( name , function ) in inspect . getmembers ( mod , inspect . isfunction ) : register_check ( function )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns svg from matplotlib chart [CODESPLIT] def fig2x ( figure , format ) : # Save svg to file like object svg_io io = StringIO ( ) figure . savefig ( io , format = format ) # Rewind the file like object io . seek ( 0 ) data = io . getvalue ( ) io . close ( ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if git command is available . [CODESPLIT] def check_git ( ) : try : with open ( os . devnull , \"wb\" ) as devnull : subprocess . check_call ( [ \"git\" , \"--version\" ] , stdout = devnull , stderr = devnull ) except : raise RuntimeError ( \"Please make sure git is installed and on your path.\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Used when the plot method defined does not create a figure nor calls save_plot Then the plot method has to use self . fig [CODESPLIT] def plot_and_save ( self , * * kwargs ) : self . fig = pyplot . figure ( ) self . plot ( ) self . axes = pyplot . gca ( ) self . save_plot ( self . fig , self . axes , * * kwargs ) pyplot . close ( self . fig )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if a file is located within the given directory . [CODESPLIT] def contained_in ( filename , directory ) : filename = os . path . normcase ( os . path . abspath ( filename ) ) directory = os . path . normcase ( os . path . abspath ( directory ) ) return os . path . commonprefix ( [ filename , directory ] ) == directory", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets the title on the underlying matplotlib AxesSubplot . [CODESPLIT] def set_title ( self , title , * * kwargs ) : ax = self . get_axes ( ) ax . set_title ( title , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if the filename exists under the path . [CODESPLIT] def _file_exists ( path , filename ) : return os . path . isfile ( os . path . join ( path , filename ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "checks to see if list is equal everywhere [CODESPLIT] def allsame ( list_ , strict = True ) : if len ( list_ ) == 0 : return True first_item = list_ [ 0 ] return list_all_eq_to ( list_ , first_item , strict )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return peak memory usage in MB [CODESPLIT] def peak_memory_usage ( ) : if sys . platform . startswith ( 'win' ) : p = psutil . Process ( ) return p . memory_info ( ) . peak_wset / 1024 / 1024 mem = resource . getrusage ( resource . RUSAGE_SELF ) . ru_maxrss factor_mb = 1 / 1024 if sys . platform == 'darwin' : factor_mb = 1 / ( 1024 * 1024 ) return mem * factor_mb", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take the union of a list of lists . [CODESPLIT] def listunion ( ListOfLists ) : u = [ ] for s in ListOfLists : if s != None : u . extend ( s ) return u", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Merge another stats . [CODESPLIT] def merge ( self , other ) : Stats . merge ( self , other ) self . changes += other . changes", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get a value from a tag ( if it exists ) [CODESPLIT] def _get_minidom_tag_value ( station , tag_name ) : tag = station . getElementsByTagName ( tag_name ) [ 0 ] . firstChild if tag : return tag . nodeValue return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A wrapper of os . makedirs () . [CODESPLIT] def makedirs ( path , mode = 0o777 , exist_ok = False ) : os . makedirs ( path , mode , exist_ok )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check configuration file type is JSON Return a boolean indicating wheather the file is JSON format or not [CODESPLIT] def is_json_file ( filename , show_warnings = False ) : try : config_dict = load_config ( filename , file_type = \"json\" ) is_json = True except : is_json = False return ( is_json )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coroutine called by MapAsync . It s wrapping the call of run_in_executor to run the synchronous function as thread [CODESPLIT] async def _thread_coro ( self , * args ) : return await self . _loop . run_in_executor ( self . _executor , self . _function , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Invoked when determining whether a specific key is in the dictionary using key in d . [CODESPLIT] def __contains__ ( self , key ) : k = self . _real_key ( key ) return k in self . _data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update a record of a loan report in the provided database . [CODESPLIT] def update_loan_entry ( database , entry ) : entry = clean_entry ( entry ) database . loans . update ( { 'recordID' : entry [ 'recordID' ] } , { '$set' : entry } , upsert = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "( Deprecated ) Converts a JSON object to a mongo db cursor [CODESPLIT] def json_obj_to_cursor ( self , json ) : cursor = json_util . loads ( json ) if \"id\" in json : cursor [ \"_id\" ] = ObjectId ( cursor [ \"id\" ] ) del cursor [ \"id\" ] return cursor", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the most common element in iterable . [CODESPLIT] def _most_common ( iterable ) : data = Counter ( iterable ) return max ( data , key = data . __getitem__ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the file at the given path is safe to use as a state file . [CODESPLIT] def check_permission_safety ( path ) : f_stats = os . stat ( path ) return ( f_stats . st_mode & ( stat . S_IRWXG | stat . S_IRWXO ) ) == 0 and f_stats . st_uid == os . getuid ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Move cursor to this line in the current buffer . [CODESPLIT] def _go_to_line ( editor , line ) : b = editor . application . current_buffer b . cursor_position = b . document . translate_row_col_to_index ( max ( 0 , int ( line ) - 1 ) , 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Move the cursor up a number of lines . [CODESPLIT] def move_up ( lines = 1 , file = sys . stdout ) : move . up ( lines ) . write ( file = file )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "White out the progress bar . [CODESPLIT] def erase ( self ) : with self . _at_last_line ( ) : self . stream . write ( self . _term . clear_eol ) self . stream . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets the cursor to the desired position . [CODESPLIT] def set_cursor ( self , x , y ) : curses . curs_set ( 1 ) self . screen . move ( y , x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates the moving average of an array . [CODESPLIT] def moving_average ( array , n = 3 ) : ret = _np . cumsum ( array , dtype = float ) ret [ n : ] = ret [ n : ] - ret [ : - n ] return ret [ n - 1 : ] / n", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clears the input and output buffers [CODESPLIT] def __clear_buffers ( self ) : try : self . _port . reset_input_buffer ( ) self . _port . reset_output_buffer ( ) except AttributeError : #pySerial 2.7 self . _port . flushInput ( ) self . _port . flushOutput ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "position in 3d space [CODESPLIT] def list ( self ) : return [ self . _pos3d . x , self . _pos3d . y , self . _pos3d . z ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clear the displayed image . [CODESPLIT] def clear ( self ) : self . _imgobj = None try : # See if there is an image on the canvas self . canvas . delete_object_by_tag ( self . _canvas_img_tag ) self . redraw ( ) except KeyError : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterable - first replacement of Python s built - in map () function . [CODESPLIT] def map ( cls , iterable , func , * a , * * kw ) : return cls ( func ( x , * a , * * kw ) for x in iterable )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wraps openjpeg library function cio_close . [CODESPLIT] def cio_close ( cio ) : OPENJPEG . opj_cio_close . argtypes = [ ctypes . POINTER ( CioType ) ] OPENJPEG . opj_cio_close ( cio )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "An async result aggregator that combines all the results This gets executed in unsync . loop and unsync . thread [CODESPLIT] async def result_processor ( tasks ) : output = { } for task in tasks : num , res = await task output [ num ] = res return output", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Close the db and release memory [CODESPLIT] def close ( self ) : if self . db is not None : self . db . commit ( ) self . db . close ( ) self . db = None return", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Internal function to overcome pickling problem in python2 . [CODESPLIT] def _parallel_compare_helper ( class_obj , pairs , x , x_link = None ) : return class_obj . _compute ( pairs , x , x_link )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve contents of each page of PDF [CODESPLIT] def resources ( self ) : return [ self . pdf . getPage ( i ) for i in range ( self . pdf . getNumPages ( ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Attempts to compute the partition size to evenly distribute work across processes . Defaults to 1 if the length of result cannot be determined . [CODESPLIT] def compute_partition_size ( result , processes ) : try : return max ( math . ceil ( len ( result ) / processes ) , 1 ) except TypeError : return 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Incrementally add the content of another model to this model ( + = ) . [CODESPLIT] def __iadd__ ( self , other_model ) : warn ( 'use model.merge instead' , DeprecationWarning ) return self . merge ( other_model , objective = 'sum' , inplace = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Method to validate if the value is valid for exact match type evaluation . [CODESPLIT] def is_value_type_valid_for_exact_conditions ( self , value ) : # No need to check for bool since bool is a subclass of int if isinstance ( value , string_types ) or isinstance ( value , ( numbers . Integral , float ) ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Internal function to overcome pickling problem in python2 . [CODESPLIT] def _parallel_compare_helper ( class_obj , pairs , x , x_link = None ) : return class_obj . _compute ( pairs , x , x_link )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if two objects are equal . [CODESPLIT] def __eq__ ( self , other ) : return isinstance ( other , self . __class__ ) and self . _freeze ( ) == other . _freeze ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Formats the sum of a and b . [CODESPLIT] def pair_strings_sum_formatter ( a , b ) : if b [ : 1 ] == \"-\" : return \"{0} - {1}\" . format ( a , b [ 1 : ] ) return \"{0} + {1}\" . format ( a , b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Drop all tables in the database [CODESPLIT] def drop_all_tables ( self ) : for table_name in self . table_names ( ) : self . execute_sql ( \"DROP TABLE %s\" % table_name ) self . connection . commit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retries function until it doesn t raise an EINTR error [CODESPLIT] def retry_on_signal ( function ) : while True : try : return function ( ) except EnvironmentError , e : if e . errno != errno . EINTR : raise", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform a named tuple into a dictionary [CODESPLIT] def dictify ( a_named_tuple ) : return dict ( ( s , getattr ( a_named_tuple , s ) ) for s in a_named_tuple . _fields )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator to explicitly mark functions that are exposed in a lib . [CODESPLIT] def export ( defn ) : globals ( ) [ defn . __name__ ] = defn __all__ . append ( defn . __name__ ) return defn", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns system clipboard contents . [CODESPLIT] def paste ( xsel = False ) : selection = \"primary\" if xsel else \"clipboard\" try : return subprocess . Popen ( [ \"xclip\" , \"-selection\" , selection , \"-o\" ] , stdout = subprocess . PIPE ) . communicate ( ) [ 0 ] . decode ( \"utf-8\" ) except OSError as why : raise XclipNotFound", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Inverse of the noise covariance . [CODESPLIT] def Cinv ( self ) : try : return np . linalg . inv ( self . c ) except np . linalg . linalg . LinAlgError : print ( 'Warning: non-invertible noise covariance matrix c.' ) return np . eye ( self . c . shape [ 0 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a nested set of name and id scopes and avoids repeats . [CODESPLIT] def _method_scope ( input_layer , name ) : global _in_method_scope # pylint: disable=protected-access with input_layer . g . as_default ( ) , scopes . var_and_name_scope ( None if _in_method_scope else input_layer . _scope ) , scopes . var_and_name_scope ( ( name , None ) ) as ( scope , var_scope ) : was_in_method_scope = _in_method_scope yield scope , var_scope _in_method_scope = was_in_method_scope", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reshape a multidimensional array to a vector . [CODESPLIT] def arr_to_vector ( arr ) : dim = array_dim ( arr ) tmp_arr = [ ] for n in range ( len ( dim ) - 1 ) : for inner in arr : for i in inner : tmp_arr . append ( i ) arr = tmp_arr tmp_arr = [ ] return arr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if the given object conforms to the Serializable protocol . [CODESPLIT] def is_serializable ( obj ) : if inspect . isclass ( obj ) : return Serializable . is_serializable_type ( obj ) return isinstance ( obj , Serializable ) or hasattr ( obj , '_asdict' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply the coefficients from a linear fit to an array of x y positions . [CODESPLIT] def apply_fit ( xy , coeffs ) : x_new = coeffs [ 0 ] [ 2 ] + coeffs [ 0 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 0 ] [ 1 ] * xy [ : , 1 ] y_new = coeffs [ 1 ] [ 2 ] + coeffs [ 1 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 1 ] [ 1 ] * xy [ : , 1 ] return x_new , y_new", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine the number of leaves in a tree [CODESPLIT] def num_leaves ( tree ) : if tree . is_leaf : return 1 else : return num_leaves ( tree . left_child ) + num_leaves ( tree . right_child )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the magnitude of a vector . [CODESPLIT] def mag ( z ) : if isinstance ( z [ 0 ] , np . ndarray ) : return np . array ( list ( map ( np . linalg . norm , z ) ) ) else : return np . linalg . norm ( z )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Computes the unnormalized PDF of the normal distribution . [CODESPLIT] def EvalGaussianPdf ( x , mu , sigma ) : return scipy . stats . norm . pdf ( x , mu , sigma )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get line count of file [CODESPLIT] def line_count ( fn ) : with open ( fn ) as f : for i , l in enumerate ( f ) : pass return i + 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalized Gaussian [CODESPLIT] def gauss_pdf ( x , mu , sigma ) : return 1 / np . sqrt ( 2 * np . pi ) / sigma * np . exp ( - ( x - mu ) ** 2 / 2. / sigma ** 2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generates a count of the number of times each unique item appears in a list [CODESPLIT] def count_list ( the_list ) : count = the_list . count result = [ ( item , count ( item ) ) for item in set ( the_list ) ] result . sort ( ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "rescales a numpy array so that min is 0 and max is 255 [CODESPLIT] def _normalize ( mat : np . ndarray ) : return ( ( mat - mat . min ( ) ) * ( 255 / mat . max ( ) ) ) . astype ( np . uint8 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Build a pyramid of specified base size s and height centered at pos . [CODESPLIT] def Pyramid ( pos = ( 0 , 0 , 0 ) , s = 1 , height = 1 , axis = ( 0 , 0 , 1 ) , c = \"dg\" , alpha = 1 ) : return Cone ( pos , s , height , axis , c , alpha , 4 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run application tests [CODESPLIT] def test ( nose_argsuments ) : from nose import run params = [ '__main__' , '-c' , 'nose.ini' ] params . extend ( nose_argsuments ) run ( argv = params )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs the unit test framework . Can be overridden to run anything . Returns True on passing and False on failure . [CODESPLIT] def run ( self ) : try : import nose arguments = [ sys . argv [ 0 ] ] + list ( self . test_args ) return nose . run ( argv = arguments ) except ImportError : print ( ) print ( \"*** Nose library missing. Please install it. ***\" ) print ( ) raise", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utilize wordnet ( installed with nltk ) to get synonyms for words word is the input word returns a list of unique synonyms [CODESPLIT] def get_wordnet_syns ( word ) : synonyms = [ ] regex = r\"_\" pat = re . compile ( regex ) synset = nltk . wordnet . wordnet . synsets ( word ) for ss in synset : for swords in ss . lemma_names : synonyms . append ( pat . sub ( \" \" , swords . lower ( ) ) ) synonyms = f7 ( synonyms ) return synonyms", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Logarithmic loss with non - necessarily - binary labels . [CODESPLIT] def log_loss ( preds , labels ) : log_likelihood = np . sum ( labels * np . log ( preds ) ) / len ( preds ) return - log_likelihood", "target": 1, "target_options": ["no_match", "match"]}
{"input": "From : http : // stackoverflow . com / questions / 13062300 / convert - a - dict - to - sorted - dict - in - python [CODESPLIT] def format_result ( input ) : items = list ( iteritems ( input ) ) return OrderedDict ( sorted ( items , key = lambda x : x [ 0 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of days since January 1 of the given year . [CODESPLIT] def gday_of_year ( self ) : return ( self . date - dt . date ( self . date . year , 1 , 1 ) ) . days", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of days since January 1 of the given year . [CODESPLIT] def gday_of_year ( self ) : return ( self . date - dt . date ( self . date . year , 1 , 1 ) ) . days", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the products from a query response as a Pandas DataFrame with the values in their appropriate Python types . [CODESPLIT] def to_dataframe ( products ) : try : import pandas as pd except ImportError : raise ImportError ( \"to_dataframe requires the optional dependency Pandas.\" ) return pd . DataFrame . from_dict ( products , orient = 'index' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Count the number of rows in 2D arrays that contain any nan values . [CODESPLIT] def count_rows_with_nans ( X ) : if X . ndim == 2 : return np . where ( np . isnan ( X ) . sum ( axis = 1 ) != 0 , 1 , 0 ) . sum ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create an instance from a dictionary . [CODESPLIT] def from_dict ( cls , d ) : return cls ( * * { k : v for k , v in d . items ( ) if k in cls . ENTRIES } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Count the number of non - NA in this array along the given axis or axes [CODESPLIT] def count ( data , axis = None ) : return np . sum ( np . logical_not ( isnull ( data ) ) , axis = axis )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decode an request previously encoded [CODESPLIT] def _decode_request ( self , encoded_request ) : obj = self . serializer . loads ( encoded_request ) return request_from_dict ( obj , self . spider )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "disassemble Python byte - code file ( . pyc ) [CODESPLIT] def disassemble_file ( filename , outstream = None ) : filename = check_object_path ( filename ) ( version , timestamp , magic_int , co , is_pypy , source_size ) = load_module ( filename ) if type ( co ) == list : for con in co : disco ( version , con , outstream ) else : disco ( version , co , outstream , is_pypy = is_pypy ) co = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Encode ndarray to base64 string image data Parameters ---------- arr : ndarray ( rows cols depth ) kwargs : passed directly to matplotlib . image . imsave [CODESPLIT] def img_encode ( arr , * * kwargs ) : sio = BytesIO ( ) imsave ( sio , arr , * * kwargs ) sio . seek ( 0 ) img_format = kwargs [ 'format' ] if kwargs . get ( 'format' ) else 'png' img_str = base64 . b64encode ( sio . getvalue ( ) ) . decode ( ) return 'data:image/{};base64,{}' . format ( img_format , img_str )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "ndarray containing tuples of pairwise indices . [CODESPLIT] def pairwise_indices ( self ) : return np . array ( [ sig . pairwise_indices for sig in self . values ] ) . T", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print temporarily until next print overrides it . [CODESPLIT] def printmp ( msg ) : filler = ( 80 - len ( msg ) ) * ' ' print ( msg + filler , end = '\\r' ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like netCDF4 . stringtochar but faster and more flexible . [CODESPLIT] def _numpy_bytes_to_char ( arr ) : # ensure the array is contiguous arr = np . array ( arr , copy = False , order = 'C' , dtype = np . string_ ) return arr . reshape ( arr . shape + ( 1 , ) ) . view ( 'S1' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete a track value [CODESPLIT] def delete ( self , row ) : i = self . _get_key_index ( row ) del self . keys [ i ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete an image . [CODESPLIT] def cli ( env , identifier ) : image_mgr = SoftLayer . ImageManager ( env . client ) image_id = helpers . resolve_id ( image_mgr . resolve_ids , identifier , 'image' ) image_mgr . delete_image ( image_id )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if array is an array of real numbers . [CODESPLIT] def contains_all ( self , array ) : dtype = getattr ( array , 'dtype' , None ) if dtype is None : dtype = np . result_type ( * array ) return is_real_dtype ( dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A deprecation warning emmiter as a decorator . [CODESPLIT] def deprecate ( func ) : @ wraps ( func ) def wrapper ( * args , * * kwargs ) : warn ( \"Deprecated, this will be removed in the future\" , DeprecationWarning ) return func ( * args , * * kwargs ) wrapper . __doc__ = \"Deprecated.\\n\" + ( wrapper . __doc__ or \"\" ) return wrapper", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Checks if l is a numpy array of integers [CODESPLIT] def is_int_vector ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 1 and ( l . dtype . kind == 'i' or l . dtype . kind == 'u' ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a numpy dtype determines whether it is a string . Returns True if the dtype is string or unicode . [CODESPLIT] def _isstring ( dtype ) : return dtype . type == numpy . unicode_ or dtype . type == numpy . string_", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert numpy s datetime64 to datetime [CODESPLIT] def datetime64_to_datetime ( dt ) : dt64 = np . datetime64 ( dt ) ts = ( dt64 - np . datetime64 ( '1970-01-01T00:00:00' ) ) / np . timedelta64 ( 1 , 's' ) return datetime . datetime . utcfromtimestamp ( ts )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A small helper function to convert a string to a numeric value if appropriate [CODESPLIT] def _convert_to_float_if_possible ( s ) : try : ret = float ( s ) except ( ValueError , TypeError ) : ret = s return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "L2 Normalize along specified axes . [CODESPLIT] def normalize ( v , axis = None , eps = 1e-10 ) : return v / max ( anorm ( v , axis = axis , keepdims = True ) , eps )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the first location in our array that is not empty [CODESPLIT] def find_start_point ( self ) : for i , row in enumerate ( self . data ) : for j , _ in enumerate ( row ) : if self . data [ i , j ] != 0 : # or not np.isfinite(self.data[i,j]): return i , j", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate HTML to display map . [CODESPLIT] def as_html ( self ) : if not self . _folium_map : self . draw ( ) return self . _inline_map ( self . _folium_map , self . _width , self . _height )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns true if the guessed mimetyped isnt t in text group . [CODESPLIT] def IsBinary ( self , filename ) : mimetype = mimetypes . guess_type ( filename ) [ 0 ] if not mimetype : return False # e.g. README, \"real\" binaries usually have an extension # special case for text files which don't start with text/ if mimetype in TEXT_MIMETYPES : return False return not mimetype . startswith ( \"text/\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read tag data from file and return as numpy array . [CODESPLIT] def read_numpy ( fd , byte_order , dtype , count ) : return numpy . fromfile ( fd , byte_order + dtype [ - 1 ] , count )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the minimum of an array ignoring any NaNs . [CODESPLIT] def fn_min ( self , a , axis = None ) : return numpy . nanmin ( self . _to_ndarray ( a ) , axis = axis )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shuffle the data . [CODESPLIT] def _shuffle ( data , idx ) : shuffle_data = [ ] for idx_k , idx_v in data : shuffle_data . append ( ( idx_k , mx . ndarray . array ( idx_v . asnumpy ( ) [ idx ] , idx_v . context ) ) ) return shuffle_data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns numpy array of natural logarithms of values . [CODESPLIT] def to_distribution_values ( self , values ) : with warnings . catch_warnings ( ) : warnings . simplefilter ( \"ignore\" ) # avoid RuntimeWarning: divide by zero encountered in log return numpy . log ( values )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Match and yield all the tokens of the input string . [CODESPLIT] def tokenize ( string ) : for match in TOKENS_REGEX . finditer ( string ) : yield Token ( match . lastgroup , match . group ( ) . strip ( ) , match . span ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A unique name for this scraper . [CODESPLIT] def name ( self ) : return '' . join ( '_%s' % c if c . isupper ( ) else c for c in self . __class__ . __name__ ) . strip ( '_' ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Match and yield all the tokens of the input string . [CODESPLIT] def tokenize ( string ) : for match in TOKENS_REGEX . finditer ( string ) : yield Token ( match . lastgroup , match . group ( ) . strip ( ) , match . span ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A magic method to implement shallow copy behavior . [CODESPLIT] def __copy__ ( self ) : return self . __class__ . load ( self . dump ( ) , context = self . context )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a lowercased string with non alphabetic chars removed . [CODESPLIT] def _to_lower_alpha_only ( s ) : s = re . sub ( r'\\n' , ' ' , s . lower ( ) ) return re . sub ( r'[^a-z\\s]' , '' , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Synthesize white noise [CODESPLIT] def synthesize ( self , duration ) : sr = self . samplerate . samples_per_second seconds = duration / Seconds ( 1 ) samples = np . random . uniform ( low = - 1. , high = 1. , size = int ( sr * seconds ) ) return AudioSamples ( samples , self . samplerate )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Private method for determining if a data record is of type DATE . [CODESPLIT] def _is_date_data ( self , data_type ) : dt = DATA_TYPES [ data_type ] if isinstance ( self . data , dt [ 'type' ] ) : self . type = data_type . upper ( ) self . len = None return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Go to the end of the current line and create a new line [CODESPLIT] def go_to_new_line ( self ) : self . stdkey_end ( False , False ) self . insert_text ( self . get_line_separator ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Get the real or imaginary part of a complex number . [CODESPLIT] def part ( z , s ) : if sage_included : if s == 1 : return np . real ( z ) elif s == - 1 : return np . imag ( z ) elif s == 0 : return z else : if s == 1 : return z . real elif s == - 1 : return z . imag elif s == 0 : return z", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Filter any sequences who s seq does not match the filter . Ignore case . [CODESPLIT] def seq_include ( records , filter_regex ) : regex = re . compile ( filter_regex ) for record in records : if regex . search ( str ( record . seq ) ) : yield record", "target": 1, "target_options": ["no_match", "match"]}
{"input": "execute jobs in processes using N threads [CODESPLIT] def parallel ( processes , threads ) : pool = multithread ( threads ) pool . map ( run_process , processes ) pool . close ( ) pool . join ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load graph as defined by a DOT file . The file is assumed to be in DOT format . It will be loaded parsed and a Dot class will be returned representing the graph . [CODESPLIT] def graph_from_dot_file ( path ) : fd = file ( path , 'rb' ) data = fd . read ( ) fd . close ( ) return graph_from_dot_data ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return opened file with a specific encoding . [CODESPLIT] def open_with_encoding ( filename , encoding , mode = 'r' ) : return io . open ( filename , mode = mode , encoding = encoding , newline = '' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Saves a representation of the case in the Graphviz DOT language . [CODESPLIT] def save_dot ( self , fd ) : from pylon . io import DotWriter DotWriter ( self ) . write ( fd )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Does openat read - only then does fdopen to get a file object [CODESPLIT] def fopenat ( base_fd , path ) : return os . fdopen ( openat ( base_fd , path , os . O_RDONLY ) , 'rb' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert an integer list into a string list . [CODESPLIT] def list_i2str ( ilist ) : slist = [ ] for el in ilist : slist . append ( str ( el ) ) return slist", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a file - like object loads it up into a PIL . Image object and returns it . [CODESPLIT] def get_image ( self , source ) : buf = StringIO ( source . read ( ) ) return Image . open ( buf )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fit a Gaussian to the data [CODESPLIT] def fit_gaussian ( x , y , yerr , p0 ) : try : popt , pcov = curve_fit ( gaussian , x , y , sigma = yerr , p0 = p0 , absolute_sigma = True ) except RuntimeError : return [ 0 ] , [ 0 ] return popt , pcov", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flatten a nested list . [CODESPLIT] def flatten ( l ) : return sum ( map ( flatten , l ) , [ ] ) if isinstance ( l , list ) or isinstance ( l , tuple ) else [ l ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Zoom the center of image x by a factor of z + 1 while retaining the original image size and proportion . [CODESPLIT] def zoom_cv ( x , z ) : if z == 0 : return x r , c ,  * _ = x . shape M = cv2 . getRotationMatrix2D ( ( c / 2 , r / 2 ) , 0 , z + 1. ) return cv2 . warpAffine ( x , M , ( c , r ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function to warp input image given an estimated 2D linear transformation [CODESPLIT] def warp ( self , warp_matrix , img , iflag = cv2 . INTER_NEAREST ) : height , width = img . shape [ : 2 ] warped_img = np . zeros_like ( img , dtype = img . dtype ) # Check if image to warp is 2D or 3D. If 3D need to loop over channels if ( self . interpolation_type == InterpolationType . LINEAR ) or img . ndim == 2 : warped_img = cv2 . warpAffine ( img . astype ( np . float32 ) , warp_matrix , ( width , height ) , flags = iflag ) . astype ( img . dtype ) elif img . ndim == 3 : for idx in range ( img . shape [ - 1 ] ) : warped_img [ ... , idx ] = cv2 . warpAffine ( img [ ... , idx ] . astype ( np . float32 ) , warp_matrix , ( width , height ) , flags = iflag ) . astype ( img . dtype ) else : raise ValueError ( 'Image has incorrect number of dimensions: {}' . format ( img . ndim ) ) return warped_img", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like many_until but must consume at least one of these . [CODESPLIT] def many_until1 ( these , term ) : first = [ these ( ) ] these_results , term_result = many_until ( these , term ) return ( first + these_results , term_result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert snake case to camel case [CODESPLIT] def camel_case ( self , snake_case ) : components = snake_case . split ( '_' ) return components [ 0 ] + \"\" . join ( x . title ( ) for x in components [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return the usage string for available options [CODESPLIT] def help ( self , level = 0 ) : self . cmdline_parser . formatter . output_level = level with _patch_optparse ( ) : return self . cmdline_parser . format_help ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a legal python name for the given name for use as a unit key . [CODESPLIT] def unit_key_from_name ( name ) : result = name for old , new in six . iteritems ( UNIT_KEY_REPLACEMENTS ) : result = result . replace ( old , new ) # Collapse redundant underscores and convert to uppercase. result = re . sub ( r'_+' , '_' , result . upper ( ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "An iterable of column names for a particular table or view . [CODESPLIT] def column_names ( self , table ) : table_info = self . execute ( u'PRAGMA table_info(%s)' % quote ( table ) ) return ( column [ 'name' ] for column in table_info )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets a naive datetime from a datetime . [CODESPLIT] def get_naive ( dt ) : if not dt . tzinfo : return dt if hasattr ( dt , \"asdatetime\" ) : return dt . asdatetime ( ) return dt . replace ( tzinfo = None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract all useful infos from the given table [CODESPLIT] def get_table_metadata ( engine , table ) : metadata = MetaData ( ) metadata . reflect ( bind = engine , only = [ table ] ) table_metadata = Table ( table , metadata , autoload = True ) return table_metadata", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a str of decimal with two digits after a decimal mark . [CODESPLIT] def money ( min = 0 , max = 10 ) : value = random . choice ( range ( min * 100 , max * 100 ) ) return \"%1.2f\" % ( float ( value ) / 100 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Empty a table by deleting all of its rows . [CODESPLIT] def truncate ( self , table ) : if isinstance ( table , ( list , set , tuple ) ) : for t in table : self . _truncate ( t ) else : self . _truncate ( table )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the output shape from an array . [CODESPLIT] def out_shape_from_array ( arr ) : arr = np . asarray ( arr ) if arr . ndim == 1 : return arr . shape else : return ( arr . shape [ 1 ] , )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A messy way to import library - specific classes . TODO : I should really make a factory class or something but I m lazy . Plus factories remind me a lot of java ... [CODESPLIT] def _import ( module , cls ) : global Scanner try : cls = str ( cls ) mod = __import__ ( str ( module ) , globals ( ) , locals ( ) , [ cls ] , 1 ) Scanner = getattr ( mod , cls ) except ImportError : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Redirect standard out to file . [CODESPLIT] def redirect_output ( fileobj ) : old = sys . stdout sys . stdout = fileobj try : yield fileobj finally : sys . stdout = old", "target": 1, "target_options": ["no_match", "match"]}
{"input": "variance of the values must have 2 or more entries . [CODESPLIT] def variance ( arr ) : avg = average ( arr ) return sum ( [ ( float ( x ) - avg ) ** 2 for x in arr ] ) / float ( len ( arr ) - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Requests - mock requests . request wrapper . [CODESPLIT] def requests_request ( method , url , * * kwargs ) : session = local_sessions . session response = session . request ( method = method , url = url , * * kwargs ) session . close ( ) return response", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterate through results from all pages . [CODESPLIT] def autopage ( self ) : while self . items : yield from self . items self . items = self . fetch_next ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns an ExpMatrix containing all pairwise sample correlations . [CODESPLIT] def sample_correlations ( self ) : C = np . corrcoef ( self . X . T ) corr_matrix = ExpMatrix ( genes = self . samples , samples = self . samples , X = C ) return corr_matrix", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the command usage . [CODESPLIT] def find ( command , on ) : output_lines = parse_man_page ( command , on ) click . echo ( '' . join ( output_lines ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse a bool from a string . [CODESPLIT] def FromString ( self , string ) : if string . lower ( ) in ( \"false\" , \"no\" , \"n\" ) : return False if string . lower ( ) in ( \"true\" , \"yes\" , \"y\" ) : return True raise TypeValueError ( \"%s is not recognized as a boolean value.\" % string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function that gets relative path to the filename [CODESPLIT] def rel_path ( filename ) : return os . path . join ( os . getcwd ( ) , os . path . dirname ( __file__ ) , filename )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the integer word id of a word string . [CODESPLIT] def word_to_id ( self , word ) : if word in self . vocab : return self . vocab [ word ] else : return self . unk_id", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Primary entry point to turn kwargs into properties [CODESPLIT] def updateFromKwargs ( self , properties , kwargs , collector , * * unused ) : properties [ self . name ] = self . getFromKwargs ( kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses dynamic programming to infer the location of spaces in a string without spaces . [CODESPLIT] def split ( s ) : l = [ _split ( x ) for x in _SPLIT_RE . split ( s ) ] return [ item for sublist in l for item in sublist ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reload the cached localzone . You need to call this if the timezone has changed . [CODESPLIT] def reload_localzone ( ) : global _cache_tz _cache_tz = pytz . timezone ( get_localzone_name ( ) ) utils . assert_tz_offset ( _cache_tz ) return _cache_tz", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clipboard paste as event handler [CODESPLIT] def OnPasteAs ( self , event ) : data = self . main_window . clipboard . get_clipboard ( ) key = self . main_window . grid . actions . cursor with undo . group ( _ ( \"Paste As...\" ) ) : self . main_window . actions . paste_as ( key , data ) self . main_window . grid . ForceRefresh ( ) event . Skip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a datetime to a millisecond accuracy timestamp [CODESPLIT] def datetime_to_ms ( dt ) : seconds = calendar . timegm ( dt . utctimetuple ( ) ) return seconds * 1000 + int ( dt . microsecond / 1000 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pause the music [CODESPLIT] def pause ( self ) : mixer . music . pause ( ) self . pause_time = self . get_time ( ) self . paused = True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Start a Pdb instance at the calling frame with stdout routed to sys . __stdout__ . [CODESPLIT] def set_trace ( ) : # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py pdb . Pdb ( stdout = sys . __stdout__ ) . set_trace ( sys . _getframe ( ) . f_back )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the shape of the dataset as ( rows cols ) . [CODESPLIT] def shape ( self ) : if not self . data : return ( 0 , 0 ) return ( len ( self . data ) , len ( self . dimensions ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get width and height of a PDF [CODESPLIT] def dimensions ( self ) : size = self . pdf . getPage ( 0 ) . mediaBox return { 'w' : float ( size [ 2 ] ) , 'h' : float ( size [ 3 ] ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of active CPUs on a Darwin system . [CODESPLIT] def _num_cpus_darwin ( ) : p = subprocess . Popen ( [ 'sysctl' , '-n' , 'hw.ncpu' ] , stdout = subprocess . PIPE ) return p . stdout . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete an object from the redis table [CODESPLIT] def delete_entry ( self , key ) : pipe = self . client . pipeline ( ) pipe . srem ( self . keys_container , key ) pipe . delete ( key ) pipe . execute ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the number of rows of the main dataframe [CODESPLIT] def count_ ( self ) : try : num = len ( self . df . index ) except Exception as e : self . err ( e , \"Can not count data\" ) return return num", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the circular permutation for a given list of items . [CODESPLIT] def circ_permutation ( items ) : permutations = [ ] for i in range ( len ( items ) ) : permutations . append ( items [ i : ] + items [ : i ] ) return permutations", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run a command and return its stdout / stderr as a string . [CODESPLIT] def getoutput_pexpect ( self , cmd ) : try : return pexpect . run ( self . sh , args = [ '-c' , cmd ] ) . replace ( '\\r\\n' , '\\n' ) except KeyboardInterrupt : print ( '^C' , file = sys . stderr , end = '' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list of names of columns that are string type . [CODESPLIT] def _get_str_columns ( sf ) : return [ name for name in sf . column_names ( ) if sf [ name ] . dtype == str ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Unpickle a python object from the given path . [CODESPLIT] def unpickle ( pickle_file ) : pickle = None with open ( pickle_file , \"rb\" ) as pickle_f : pickle = dill . load ( pickle_f ) if not pickle : LOG . error ( \"Could not load python object from file\" ) return pickle", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the angle between two points . [CODESPLIT] def angle ( x0 , y0 , x1 , y1 ) : return degrees ( atan2 ( y1 - y0 , x1 - x0 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Highlight a region on the chart between the specified start and end x - co - ordinates . param pyplot plt : matplotlibk pyplot which contains the charts to be highlighted param string start_x : epoch time millis param string end_x : epoch time millis [CODESPLIT] def highlight_region ( plt , start_x , end_x ) : start_x = convert_to_mdate ( start_x ) end_x = convert_to_mdate ( end_x ) plt . axvspan ( start_x , end_x , color = CONSTANTS . HIGHLIGHT_COLOR , alpha = CONSTANTS . HIGHLIGHT_ALPHA )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Google AppEngine Helper to convert a data type into a string . [CODESPLIT] def datatype ( dbtype , description , cursor ) : dt = cursor . db . introspection . get_field_type ( dbtype , description ) if type ( dt ) is tuple : return dt [ 0 ] else : return dt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ajoute la target au plot [CODESPLIT] def plot_target ( target , ax ) : ax . scatter ( target [ 0 ] , target [ 1 ] , target [ 2 ] , c = \"red\" , s = 80 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns nr of first entry parseable to float in ll None otherwise [CODESPLIT] def find_first_number ( ll ) : for nr , entry in enumerate ( ll ) : try : float ( entry ) except ( ValueError , TypeError ) as e : pass else : return nr return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run a function that uses blocking IO . [CODESPLIT] def blocking ( func , * args , * * kwargs ) : pool = get_io_pool ( ) fut = pool . submit ( func , * args , * * kwargs ) return fut . result ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find longest ORF from the given list of ORFs . [CODESPLIT] def get_longest_orf ( orfs ) : sorted_orf = sorted ( orfs , key = lambda x : len ( x [ 'sequence' ] ) , reverse = True ) [ 0 ] return sorted_orf", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call a system command in the background disown it and hide it s output . [CODESPLIT] def disown ( cmd ) : subprocess . Popen ( cmd , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Increment _token to the next token and return it . [CODESPLIT] def _next_token ( self , skipws = True ) : self . _token = next ( self . _tokens ) . group ( 0 ) return self . _next_token ( ) if skipws and self . _token . isspace ( ) else self . _token", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call a system command in the background disown it and hide it s output . [CODESPLIT] def disown ( cmd ) : subprocess . Popen ( cmd , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the number of rows of the main dataframe [CODESPLIT] def count_ ( self ) : try : num = len ( self . df . index ) except Exception as e : self . err ( e , \"Can not count data\" ) return return num", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Drops and re - creates the SQL schema [CODESPLIT] def init_db ( ) : db . drop_all ( ) db . configure_mappers ( ) db . create_all ( ) db . session . commit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return relevant twitter timeline [CODESPLIT] def twitter_timeline ( screen_name , since_id = None ) : consumer_key = twitter_credential ( 'consumer_key' ) consumer_secret = twitter_credential ( 'consumer_secret' ) access_token = twitter_credential ( 'access_token' ) access_token_secret = twitter_credential ( 'access_secret' ) auth = tweepy . OAuthHandler ( consumer_key , consumer_secret ) auth . set_access_token ( access_token , access_token_secret ) api = tweepy . API ( auth ) return get_all_tweets ( screen_name , api , since_id )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get a value from a tag ( if it exists ) [CODESPLIT] def _get_minidom_tag_value ( station , tag_name ) : tag = station . getElementsByTagName ( tag_name ) [ 0 ] . firstChild if tag : return tag . nodeValue return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print the values of all this object s Parameters . [CODESPLIT] def print_param_values ( self_ ) : self = self_ . self for name , val in self . param . get_param_values ( ) : print ( '%s.%s = %s' % ( self . name , name , val ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the given code line by line with printing as list of lines and return variable ans . [CODESPLIT] def runcode ( code ) : for line in code : print ( '# ' + line ) exec ( line , globals ( ) ) print ( '# return ans' ) return ans", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if created today . [CODESPLIT] def created_today ( self ) : if self . datetime . date ( ) == datetime . today ( ) . date ( ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print the current iteration . [CODESPLIT] def __call__ ( self , _ ) : if self . iter % self . step == 0 : print ( self . fmt . format ( self . iter ) , * * self . kwargs ) self . iter += 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a ( probably ) unique ID to identify a system . Used to differentiate votes . [CODESPLIT] def get_system_uid ( ) : try : if os . name == 'nt' : return get_nt_system_uid ( ) if sys . platform == 'darwin' : return get_osx_system_uid ( ) except Exception : return get_mac_uid ( ) else : return get_mac_uid ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prints the values and freqs / probs in ascending order . [CODESPLIT] def Print ( self ) : for val , prob in sorted ( self . d . iteritems ( ) ) : print ( val , prob )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "generate a CamelCase string from an underscore_string . [CODESPLIT] def camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = '' for component in components : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raw print to sys . __stdout__ otherwise identical interface to print () . [CODESPLIT] def raw_print ( * args , * * kw ) : print ( * args , sep = kw . get ( 'sep' , ' ' ) , end = kw . get ( 'end' , '\\n' ) , file = sys . __stdout__ ) sys . __stdout__ . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine with width in pixels of string . [CODESPLIT] def text_width ( string , font_name , font_size ) : return stringWidth ( string , fontName = font_name , fontSize = font_size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print a formatted indented text . [CODESPLIT] def indented_show ( text , howmany = 1 ) : print ( StrTemplate . pad_indent ( text = text , howmany = howmany ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Assign x and y to an object that has properties x and y . [CODESPLIT] def assign_to ( self , obj ) : obj . x = self . x obj . y = self . y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "print a binary tree [CODESPLIT] def print_bintree ( tree , indent = '  ' ) : for n in sorted ( tree . keys ( ) ) : print \"%s%s\" % ( indent * depth ( n , tree ) , n )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ajoute la target au plot [CODESPLIT] def plot_target ( target , ax ) : ax . scatter ( target [ 0 ] , target [ 1 ] , target [ 2 ] , c = \"red\" , s = 80 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Saves a representation of the case in the Graphviz DOT language . [CODESPLIT] def save_dot ( self , fd ) : from pylon . io import DotWriter DotWriter ( self ) . write ( fd )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "launch layouts display [CODESPLIT] def _display ( self , layout ) : print ( file = self . out ) TextWriter ( ) . format ( layout , self . out )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pull the value from the cookiejar . [CODESPLIT] def parse_cookies ( self , req , name , field ) : return core . get_value ( req . COOKIES , name , field )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Process command line arguments and walk inputs . [CODESPLIT] def run ( args ) : raw_arguments = get_arguments ( args [ 1 : ] ) process_arguments ( raw_arguments ) walk . run ( ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Implements the === operator . [CODESPLIT] def hard_equals ( a , b ) : if type ( a ) != type ( b ) : return False return a == b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return string as a comment [CODESPLIT] def _comment ( string ) : lines = [ line . strip ( ) for line in string . splitlines ( ) ] return \"# \" + ( \"%s# \" % linesep ) . join ( lines )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return current free memory on the machine for windows . [CODESPLIT] def get_free_memory_win ( ) : stat = MEMORYSTATUSEX ( ) ctypes . windll . kernel32 . GlobalMemoryStatusEx ( ctypes . byref ( stat ) ) return int ( stat . ullAvailPhys / 1024 / 1024 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cycle through all windows . [CODESPLIT] def cycle_focus ( self ) : windows = self . windows ( ) new_index = ( windows . index ( self . active_window ) + 1 ) % len ( windows ) self . active_window = windows [ new_index ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update the progressbar . [CODESPLIT] def __call__ ( self , _ ) : if self . iter % self . step == 0 : self . pbar . update ( self . step ) self . iter += 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Value of property . [CODESPLIT] def value ( self ) : if self . _prop . fget is None : raise AttributeError ( 'Unable to read attribute' ) return self . _prop . fget ( self . _obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A small helper function to convert a string to a numeric value if appropriate [CODESPLIT] def _convert_to_float_if_possible ( s ) : try : ret = float ( s ) except ( ValueError , TypeError ) : ret = s return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Processor time when the alarm was acknowledged . [CODESPLIT] def acknowledge_time ( self ) : if ( self . is_acknowledged and self . _proto . acknowledgeInfo . HasField ( 'acknowledgeTime' ) ) : return parse_isostring ( self . _proto . acknowledgeInfo . acknowledgeTime ) return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Establish tunnel connection early because otherwise httplib would improperly set Host : header to proxy s IP : port . [CODESPLIT] def _prepare_proxy ( self , conn ) : conn . set_tunnel ( self . _proxy_host , self . port , self . proxy_headers ) conn . connect ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Makes a package name [CODESPLIT] def packagenameify ( s ) : return '' . join ( w if w in ACRONYMS else w . title ( ) for w in s . split ( '.' ) [ - 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call a system command in the background disown it and hide it s output . [CODESPLIT] def disown ( cmd ) : subprocess . Popen ( cmd , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Construct a single page PDF from the provided page in memory [CODESPLIT] def _single_page_pdf ( page ) : pdf = Pdf . new ( ) pdf . pages . append ( page ) bio = BytesIO ( ) pdf . save ( bio ) bio . seek ( 0 ) return bio . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Hides the main window of the terminal and sets the visible flag to False . [CODESPLIT] def hide ( self ) : if not HidePrevention ( self . window ) . may_hide ( ) : return self . hidden = True self . get_widget ( 'window-root' ) . unstick ( ) self . window . hide ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set y - axis limits of a subplot . [CODESPLIT] def set_ylimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_ylimits ( min , max )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if text at given position is a block comment . [CODESPLIT] def isBlockComment ( self , line , column ) : return self . _highlighter is not None and self . _highlighter . isBlockComment ( self . document ( ) . findBlockByNumber ( line ) , column )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Qt / Python2 / 3 compatibility helper . [CODESPLIT] def handle_qbytearray ( obj , encoding ) : if isinstance ( obj , QByteArray ) : obj = obj . data ( ) return to_text_string ( obj , encoding = encoding )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the line number parsed from the comment or 0 . [CODESPLIT] def _get_line_no_from_comments ( py_line ) : matched = LINECOL_COMMENT_RE . match ( py_line ) if matched : return int ( matched . group ( 1 ) ) else : return 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a dict to a querystring suitable to be appended to a URL . [CODESPLIT] def dict_to_querystring ( dictionary ) : s = u\"\" for d in dictionary . keys ( ) : s = unicode . format ( u\"{0}{1}={2}&\" , s , d , dictionary [ d ] ) return s [ : - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update the progressbar . [CODESPLIT] def __call__ ( self , _ ) : if self . iter % self . step == 0 : self . pbar . update ( self . step ) self . iter += 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if list contains either values of type vtype or None . [CODESPLIT] def is_nullable_list ( val , vtype ) : return ( isinstance ( val , list ) and any ( isinstance ( v , vtype ) for v in val ) and all ( ( isinstance ( v , vtype ) or v is None ) for v in val ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convenience method for just changing font size . [CODESPLIT] def set_font_size ( self , size ) : if self . font . font_size == size : pass else : self . font . _set_size ( size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Intersect dictionaries d1 and d2 by key * and * value . [CODESPLIT] def intersect ( d1 , d2 ) : return dict ( ( k , d1 [ k ] ) for k in d1 if k in d2 and d1 [ k ] == d2 [ k ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield directory file names . [CODESPLIT] def directory_files ( path ) : for entry in os . scandir ( path ) : if not entry . name . startswith ( '.' ) and entry . is_file ( ) : yield entry . name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a RangeMap for the range start to stop . [CODESPLIT] def get_range ( self , start = None , stop = None ) : return self . from_iterable ( self . ranges ( start , stop ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "exit without breaking pipes . [CODESPLIT] def safe_exit ( output ) : try : sys . stdout . write ( output ) sys . stdout . flush ( ) except IOError : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Linspace op . [CODESPLIT] def LinSpace ( start , stop , num ) : return np . linspace ( start , stop , num = num , dtype = np . float32 ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ensure the cursor is within horizontal screen bounds . [CODESPLIT] def ensure_hbounds ( self ) : self . cursor . x = min ( max ( 0 , self . cursor . x ) , self . columns - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get mnist dataset with features and label as ndarray . Data would be downloaded automatically if it doesn t present at the specific location . [CODESPLIT] def get_mnist ( data_type = \"train\" , location = \"/tmp/mnist\" ) : X , Y = mnist . read_data_sets ( location , data_type ) return X , Y + 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the next non - blank line in an ASCII file . [CODESPLIT] def rAsciiLine ( ifile ) : _line = ifile . readline ( ) . strip ( ) while len ( _line ) == 0 : _line = ifile . readline ( ) . strip ( ) return _line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a n - bits long integer value . [CODESPLIT] def read_large_int ( self , bits , signed = True ) : return int . from_bytes ( self . read ( bits // 8 ) , byteorder = 'little' , signed = signed )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resizes an image preserving the aspect ratio . [CODESPLIT] def scale_image ( image , new_width ) : ( original_width , original_height ) = image . size aspect_ratio = original_height / float ( original_width ) new_height = int ( aspect_ratio * new_width ) # This scales it wider than tall, since characters are biased new_image = image . resize ( ( new_width * 2 , new_height ) ) return new_image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Try converting the README to an RST document . Return it as is on failure . [CODESPLIT] def readme ( ) : try : import pypandoc readme_content = pypandoc . convert ( 'README.md' , 'rst' ) except ( IOError , ImportError ) : print ( \"Warning: no pypandoc module found.\" ) try : readme_content = open ( 'README.md' ) . read ( ) except IOError : readme_content = '' return readme_content", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pad the text . [CODESPLIT] def _pad ( self , text ) : top_bottom = ( \"\\n\" * self . _padding ) + \" \" right_left = \" \" * self . _padding * self . PAD_WIDTH return top_bottom + right_left + text + right_left + top_bottom", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function for fast reading from sensor files . [CODESPLIT] def _fast_read ( self , infile ) : infile . seek ( 0 ) return ( int ( infile . read ( ) . decode ( ) . strip ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print a formatted indented text . [CODESPLIT] def indented_show ( text , howmany = 1 ) : print ( StrTemplate . pad_indent ( text = text , howmany = howmany ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to read JSON file as OrderedDict [CODESPLIT] def _read_json_file ( self , json_file ) : self . log . debug ( \"Reading '%s' JSON file...\" % json_file ) with open ( json_file , 'r' ) as f : return json . load ( f , object_pairs_hook = OrderedDict )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "read the lines from a file into a list [CODESPLIT] def get_list_from_file ( file_name ) : with open ( file_name , mode = 'r' , encoding = 'utf-8' ) as f1 : lst = f1 . readlines ( ) return lst", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Send a KICK command . [CODESPLIT] def kick ( self , channel , nick , comment = \"\" ) : self . send_items ( 'KICK' , channel , nick , comment and ':' + comment )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generator that yields lines from standard input . [CODESPLIT] def standard_input ( ) : with click . get_text_stream ( \"stdin\" ) as stdin : while stdin . readable ( ) : line = stdin . readline ( ) if line : yield line . strip ( ) . encode ( \"utf-8\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return n size lists from a given list l [CODESPLIT] def chunk_list ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Directly reads text data from url [CODESPLIT] def url_read_text ( url , verbose = True ) : data = url_read ( url , verbose ) text = data . decode ( 'utf8' ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap itertools . groupby to make life easier . [CODESPLIT] def group_by ( iterable , key_func ) : groups = ( list ( sub ) for key , sub in groupby ( iterable , key_func ) ) return zip ( groups , groups )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to read bytes until a certain end byte is hit [CODESPLIT] def _readuntil ( f , end = _TYPE_END ) : buf = bytearray ( ) byte = f . read ( 1 ) while byte != end : if byte == b'' : raise ValueError ( 'File ended unexpectedly. Expected end byte {}.' . format ( end ) ) buf += byte byte = f . read ( 1 ) return buf", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Random normal variates . [CODESPLIT] def rnormal ( mu , tau , size = None ) : return np . random . normal ( mu , 1. / np . sqrt ( tau ) , size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Build word frequency list from incoming string . [CODESPLIT] def counter_from_str ( self , string ) : string_list = [ chars for chars in string if chars not in self . punctuation ] string_joined = '' . join ( string_list ) tokens = self . punkt . word_tokenize ( string_joined ) return Counter ( tokens )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "exit without breaking pipes . [CODESPLIT] def safe_exit ( output ) : try : sys . stdout . write ( output ) sys . stdout . flush ( ) except IOError : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Visible width of a potentially multiline content . [CODESPLIT] def _multiline_width ( multiline_s , line_width_fn = len ) : return max ( map ( line_width_fn , re . split ( \"[\\r\\n]\" , multiline_s ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Request that the Outstation perform a cold restart . Command syntax is : restart [CODESPLIT] def do_restart ( self , line ) : self . application . master . Restart ( opendnp3 . RestartType . COLD , restart_callback )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": see :: meth : RedisMap . __setitem__ [CODESPLIT] def __setitem__ ( self , field , value ) : return self . _client . hset ( self . key_prefix , field , self . _dumps ( value ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper parse action to convert tokens to lower case . [CODESPLIT] def downcaseTokens ( s , l , t ) : return [ tt . lower ( ) for tt in map ( _ustr , t ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": see :: meth : RedisMap . __setitem__ [CODESPLIT] def __setitem__ ( self , field , value ) : return self . _client . hset ( self . key_prefix , field , self . _dumps ( value ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "mono - exponential curve . [CODESPLIT] def algo_exp ( x , m , t , b ) : return m * np . exp ( - t * x ) + b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of bytes stored in the value of key within hash name [CODESPLIT] def hstrlen ( self , name , key ) : with self . pipe as pipe : return pipe . hstrlen ( self . redis_key ( name ) , key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "dynamically build autocomplete options based on an external file [CODESPLIT] def get_default_preds ( ) : g = ontospy . Ontospy ( rdfsschema , text = True , verbose = False , hide_base_schemas = False ) classes = [ ( x . qname , x . bestDescription ( ) ) for x in g . all_classes ] properties = [ ( x . qname , x . bestDescription ( ) ) for x in g . all_properties ] commands = [ ( 'exit' , 'exits the terminal' ) , ( 'show' , 'show current buffer' ) ] return rdfschema + owlschema + classes + properties + commands", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Closes the connection [CODESPLIT] def exit ( self ) : self . pubsub . unsubscribe ( ) self . client . connection_pool . disconnect ( ) logger . info ( \"Connection to Redis closed\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns dict of fields that changed since save ( with old values ) [CODESPLIT] def changed ( self ) : return dict ( ( field , self . previous ( field ) ) for field in self . fields if self . has_changed ( field ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return info dict from specified Redis instance [CODESPLIT] def _get_info ( self , host , port , unix_socket , auth ) : client = self . _client ( host , port , unix_socket , auth ) if client is None : return None info = client . info ( ) del client return info", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pure - Python implementation of itertools . combinations ( l 2 ) . [CODESPLIT] def combinations ( l ) : result = [ ] for x in xrange ( len ( l ) - 1 ) : ls = l [ x + 1 : ] for y in ls : result . append ( ( l [ x ] , y ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Appends a PDF to a pyPDF writer . Legacy interface . [CODESPLIT] def append_pdf ( input_pdf : bytes , output_writer : PdfFileWriter ) : append_memory_pdf_to_writer ( input_pdf = input_pdf , writer = output_writer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the index rank according to Bertran s notation . [CODESPLIT] def rank ( idx , dim ) : idxm = multi_index ( idx , dim ) out = 0 while idxm [ - 1 : ] == ( 0 , ) : out += 1 idxm = idxm [ : - 1 ] return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract table names from an SQL query . [CODESPLIT] def extract_table_names ( query ) : # a good old fashioned regex. turns out this worked better than actually parsing the code tables_blocks = re . findall ( r'(?:FROM|JOIN)\\s+(\\w+(?:\\s*,\\s*\\w+)*)' , query , re . IGNORECASE ) tables = [ tbl for block in tables_blocks for tbl in re . findall ( r'\\w+' , block ) ] return set ( tables )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper for iterating numpy array [CODESPLIT] def _npiter ( arr ) : for a in np . nditer ( arr , flags = [ \"refs_ok\" ] ) : c = a . item ( ) if c is not None : yield c", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get pages reloading the site if needed . [CODESPLIT] def pages ( self ) : rev = self . db . get ( 'site:rev' ) if int ( rev ) != self . revision : self . reload_site ( ) return self . _pages", "target": 1, "target_options": ["no_match", "match"]}
{"input": "logx linear [CODESPLIT] def logx_linear ( x , a , b ) : x = np . log ( x ) return a * x + b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if the given thing represents a date [CODESPLIT] def is_date ( thing ) : # known date types date_types = ( datetime . datetime , datetime . date , DateTime ) return isinstance ( thing , date_types )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip accents to prepare for slugification . [CODESPLIT] def strip_accents ( s ) : nfkd = unicodedata . normalize ( 'NFKD' , unicode ( s ) ) return u'' . join ( ch for ch in nfkd if not unicodedata . combining ( ch ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return possible range for min function . [CODESPLIT] def min_values ( args ) : return Interval ( min ( x . low for x in args ) , min ( x . high for x in args ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove punctuation from string s . [CODESPLIT] def unpunctuate ( s , * , char_blacklist = string . punctuation ) : # remove punctuation s = \"\" . join ( c for c in s if c not in char_blacklist ) # remove consecutive spaces return \" \" . join ( filter ( None , s . split ( \" \" ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ensure the cursor is within horizontal screen bounds . [CODESPLIT] def ensure_hbounds ( self ) : self . cursor . x = min ( max ( 0 , self . cursor . x ) , self . columns - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove legend for axes or gca . [CODESPLIT] def remove_legend ( ax = None ) : from pylab import gca , draw if ax is None : ax = gca ( ) ax . legend_ = None draw ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Makes a classname [CODESPLIT] def classnameify ( s ) : return '' . join ( w if w in ACRONYMS else w . title ( ) for w in s . split ( '_' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a Vector as the product of the vector and a real number . [CODESPLIT] def multiply ( self , number ) : return self . from_list ( [ x * number for x in self . to_list ( ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load the named cube from the current registered CubeManager . [CODESPLIT] def get_cube ( name ) : manager = get_manager ( ) if not manager . has_cube ( name ) : raise NotFound ( 'No such cube: %r' % name ) return manager . get_cube ( name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove duplicates from a sequence preserving order [CODESPLIT] def remove_dups ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return array - like containing only true / non - NaN values possibly empty . [CODESPLIT] def remove_na_arraylike ( arr ) : if is_extension_array_dtype ( arr ) : return arr [ notna ( arr ) ] else : return arr [ notna ( lib . values_from_object ( arr ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove key from dict and return value . [CODESPLIT] def pop ( self , key ) : if key in self . _keys : self . _keys . remove ( key ) super ( ListDict , self ) . pop ( key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove a file from an AWS S3 bucket . [CODESPLIT] def remove_file_from_s3 ( awsclient , bucket , key ) : client_s3 = awsclient . get_client ( 's3' ) response = client_s3 . delete_object ( Bucket = bucket , Key = key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return evidence codes in order shown in code2name . [CODESPLIT] def get_order ( self , codes ) : return sorted ( codes , key = lambda e : [ self . ev2idx . get ( e ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete a file or directory path only if it exists . [CODESPLIT] def remover ( file_path ) : if os . path . isfile ( file_path ) : os . remove ( file_path ) return True elif os . path . isdir ( file_path ) : shutil . rmtree ( file_path ) return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return data as a JSON string . [CODESPLIT] def to_json ( data ) : return json . dumps ( data , default = lambda x : x . __dict__ , sort_keys = True , indent = 4 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reimplement Qt method to send focus change notification [CODESPLIT] def focusInEvent ( self , event ) : self . focus_changed . emit ( ) return super ( ControlWidget , self ) . focusInEvent ( event )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns json format for symbol [CODESPLIT] def jsonify ( symbol ) : try : # all symbols have a toJson method, try it return json . dumps ( symbol . toJson ( ) , indent = '  ' ) except AttributeError : pass return json . dumps ( symbol , indent = '  ' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve contents of each page of PDF [CODESPLIT] def resources ( self ) : return [ self . pdf . getPage ( i ) for i in range ( self . pdf . getNumPages ( ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handle conversion of pymongo cursor into a JSON object formatted for UI consumption [CODESPLIT] def _obj_cursor_to_dictionary ( self , cursor ) : if not cursor : return cursor cursor = json . loads ( json . dumps ( cursor , cls = BSONEncoder ) ) if cursor . get ( \"_id\" ) : cursor [ \"id\" ] = cursor . get ( \"_id\" ) del cursor [ \"_id\" ] return cursor", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove all unwanted characters from text . [CODESPLIT] def clean ( self , text ) : return '' . join ( [ c for c in text if c in self . alphabet ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove commas from a float [CODESPLIT] def clean_float ( v ) : if v is None or not str ( v ) . strip ( ) : return None return float ( str ( v ) . replace ( ',' , '' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return line ending . [CODESPLIT] def get_line_ending ( line ) : non_whitespace_index = len ( line . rstrip ( ) ) - len ( line ) if not non_whitespace_index : return '' else : return line [ non_whitespace_index : ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Serialize obj as a JSON formatted stream to fp [CODESPLIT] def _serialize_json ( obj , fp ) : json . dump ( obj , fp , indent = 4 , default = serialize )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes tags from objects [CODESPLIT] def _removeTags ( tags , objects ) : for t in tags : for o in objects : o . tags . remove ( t ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clips a prefix from the beginning of a string if it exists . [CODESPLIT] def _clip ( sid , prefix ) : return sid [ len ( prefix ) : ] if sid . startswith ( prefix ) else sid", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pause the music [CODESPLIT] def pause ( self ) : mixer . music . pause ( ) self . pause_time = self . get_time ( ) self . paused = True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format a string for screen printing . [CODESPLIT] def format_screen ( strng ) : # Paragraph continue par_re = re . compile ( r'\\\\$' , re . MULTILINE ) strng = par_re . sub ( '' , strng ) return strng", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Appends tzinfo and assumes UTC if datetime object has no tzinfo already . [CODESPLIT] def make_aware ( dt ) : return dt if dt . tzinfo else dt . replace ( tzinfo = timezone . utc )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Categorical accuracy [CODESPLIT] def cat_acc ( y_true , y_pred ) : return np . mean ( y_true . argmax ( axis = 1 ) == y_pred . argmax ( axis = 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove the value found at key from the queue [CODESPLIT] def remove ( self , key ) : item = self . item_finder . pop ( key ) item [ - 1 ] = None self . removed_count += 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Closes the stream . Performs cleanup . [CODESPLIT] def close_stream ( self ) : self . keep_listening = False self . stream . stop ( ) self . stream . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print an error in red text . Parameters error ( HTTPError ) Error object to print . [CODESPLIT] def fail_print ( error ) : print ( COLORS . fail , error . message , COLORS . end ) print ( COLORS . fail , error . errors , COLORS . end )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple function to add two numbers [CODESPLIT] def generic_add ( a , b ) : print logger . info ( 'Called generic_add({}, {})' . format ( a , b ) ) return a + b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A non - optimal implementation of a regex filter [CODESPLIT] def subn_filter ( s , find , replace , count = 0 ) : return re . gsub ( find , replace , count , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty print a CSV file . [CODESPLIT] def csvpretty ( csvfile : csvfile = sys . stdin ) : shellish . tabulate ( csv . reader ( csvfile ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper to print a prepared query . Useful to debug a POST query . [CODESPLIT] def pretty_print_post ( req ) : print ( ( '{}\\n{}\\n{}\\n\\n{}' . format ( '-----------START-----------' , req . method + ' ' + req . url , '\\n' . join ( '{}: {}' . format ( k , v ) for k , v in list ( req . headers . items ( ) ) ) , req . body , ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert camelcase names to underscore [CODESPLIT] def camelcase_underscore ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pull a querystring value from the request . [CODESPLIT] def parse_querystring ( self , req , name , field ) : return core . get_value ( req . args , name , field )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function returns a pretty table used to display the port results . [CODESPLIT] def get_table ( ports ) : table = PrettyTable ( [ \"Name\" , \"Port\" , \"Protocol\" , \"Description\" ] ) table . align [ \"Name\" ] = \"l\" table . align [ \"Description\" ] = \"l\" table . padding_width = 1 for port in ports : table . add_row ( port ) return table", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Gets the string representation of the given type . [CODESPLIT] def getTypeStr ( _type ) : if isinstance ( _type , CustomType ) : return str ( _type ) if hasattr ( _type , '__name__' ) : return _type . __name__ return ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "HEAD request wrapper for : func : request () [CODESPLIT] def head ( self , path , query = None , data = None , redirects = True ) : return self . request ( 'HEAD' , path , query , None , redirects )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get max for queryset . [CODESPLIT] def get_max ( qs , field ) : max_field = '%s__max' % field num = qs . aggregate ( Max ( field ) ) [ max_field ] return num if num else 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A context manager for this client s session . [CODESPLIT] def session ( self ) : self . _session = requests . session ( ) yield self . _session . close ( ) self . _session = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exponential function [CODESPLIT] def Exponential ( x , a , tau , y0 ) : return np . exp ( x / tau ) * a + y0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Send a POST request [CODESPLIT] def send_post ( self , url , data , remove_header = None ) : return self . send_request ( method = \"post\" , url = url , data = data , remove_header = remove_header )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "sample data from given histogram and min max values within range [CODESPLIT] def inverseHistogram ( hist , bin_range ) : data = hist . astype ( float ) / np . min ( hist [ np . nonzero ( hist ) ] ) new_data = np . empty ( shape = np . sum ( data , dtype = int ) ) i = 0 xvals = np . linspace ( bin_range [ 0 ] , bin_range [ 1 ] , len ( data ) ) for d , x in zip ( data , xvals ) : new_data [ i : i + d ] = x i += int ( d ) return new_data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "See get_http_proxy . [CODESPLIT] async def set_http_proxy ( cls , url : typing . Optional [ str ] ) : await cls . set_config ( \"http_proxy\" , \"\" if url is None else url )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print list of strings to the predefined stdout . [CODESPLIT] def print_out ( self , * lst ) : self . print2file ( self . stdout , True , True , * lst )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pull the value from the cookiejar . [CODESPLIT] def parse_cookies ( self , req , name , field ) : return core . get_value ( req . COOKIES , name , field )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param session : actually it is a sqlalchemy session : return : version number [CODESPLIT] def get_db_version ( session ) : value = session . query ( ProgramInformation . value ) . filter ( ProgramInformation . name == \"db_version\" ) . scalar ( ) return int ( value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resize and image to fit the passed in width keeping the aspect ratio the same [CODESPLIT] def resize_image_to_fit_width ( image , dest_w ) : scale_factor = dest_w / image . size [ 0 ] dest_h = image . size [ 1 ] * scale_factor scaled_image = image . resize ( ( int ( dest_w ) , int ( dest_h ) ) , PIL . Image . ANTIALIAS ) return scaled_image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fetch a subset of randomzied GUIDs from the whitelist [CODESPLIT] def get_randomized_guid_sample ( self , item_count ) : dataset = self . get_whitelist ( ) random . shuffle ( dataset ) return dataset [ : item_count ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "For attributes not found in self redirect to the properties dictionary [CODESPLIT] def __getattr__ ( self , name ) : try : return self . __dict__ [ name ] except KeyError : if hasattr ( self . _properties , name ) : return getattr ( self . _properties , name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract from the given iterable of lines the list of words . [CODESPLIT] def extract_words ( lines ) : for line in lines : for word in re . findall ( r\"\\w+\" , line ) : yield word", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a new raw REST interface to stats resources [CODESPLIT] def stats ( self ) : import ns1 . rest . stats return ns1 . rest . stats . Stats ( self . config )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return an iterator that returns a chunk of a string every time it is called . notice that even though bufsize_type might be line buffered we re not doing any line buffering here . that s because our StreamBufferer handles all buffering . we just need to return a reasonable - sized chunk . [CODESPLIT] def get_iter_string_reader ( stdin ) : bufsize = 1024 iter_str = ( stdin [ i : i + bufsize ] for i in range ( 0 , len ( stdin ) , bufsize ) ) return get_iter_chunk_reader ( iter_str )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Restore settings to default values . [CODESPLIT] def restore_default_settings ( ) : global __DEFAULTS __DEFAULTS . CACHE_DIR = defaults . CACHE_DIR __DEFAULTS . SET_SEED = defaults . SET_SEED __DEFAULTS . SEED = defaults . SEED logging . info ( 'Settings reverted to their default values.' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Receive the content of url parse it as JSON and return the object . [CODESPLIT] def get_jsonparsed_data ( url ) : response = urlopen ( url ) data = response . read ( ) . decode ( 'utf-8' ) return json . loads ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the memory per process in megabytes [CODESPLIT] def set_mem_per_proc ( self , mem_mb ) : super ( ) . set_mem_per_proc ( mem_mb ) self . qparams [ \"mem_per_cpu\" ] = self . mem_per_proc", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Log out the active user [CODESPLIT] def logout ( ) : flogin . logout_user ( ) next = flask . request . args . get ( 'next' ) return flask . redirect ( next or flask . url_for ( \"user\" ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dictionary only with keys found in allowed_keys [CODESPLIT] def dict_pick ( dictionary , allowed_keys ) : return { key : value for key , value in viewitems ( dictionary ) if key in allowed_keys }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fold all values of the matrix into [ 0 1 ] . [CODESPLIT] def normalize_matrix ( matrix ) : abs_matrix = np . abs ( matrix . copy ( ) ) return abs_matrix / abs_matrix . max ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Click the element [CODESPLIT] def click ( self ) : try : self . wait_until_clickable ( ) . web_element . click ( ) except StaleElementReferenceException : # Retry if element has changed self . web_element . click ( ) return self", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return a standard name by following rules : 1 . find all regular expression partners (( IDs ) | ( ID ) | ( [ A - Z ] [ a - z ] + ) | ( [ A - Z ] { 2 } )) 2 . lower very part and join again with _ This method is only used if values in table [ model ] [ columns ] are str [CODESPLIT] def standard_db_name ( file_column_name ) : found = id_re . findall ( file_column_name ) if not found : return file_column_name return '_' . join ( x [ 0 ] . lower ( ) for x in found )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the indices of all the val in m [CODESPLIT] def index ( m , val ) : mm = np . array ( m ) idx_tuple = np . where ( mm == val ) idx = idx_tuple [ 0 ] . tolist ( ) return idx", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove text nodes containing only whitespace [CODESPLIT] def cleanup_nodes ( doc ) : for node in doc . documentElement . childNodes : if node . nodeType == Node . TEXT_NODE and node . nodeValue . isspace ( ) : doc . documentElement . removeChild ( node ) return doc", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove unwanted list indices . First argument is the list of indices to remove . Other elements are the lists to trim . [CODESPLIT] def rm_empty_indices ( * args ) : rm_inds = args [ 0 ] if not rm_inds : return args [ 1 : ] keep_inds = [ i for i in range ( len ( args [ 1 ] ) ) if i not in rm_inds ] return [ [ a [ i ] for i in keep_inds ] for a in args [ 1 : ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the total size of all elements in objects . [CODESPLIT] def get_size ( objects ) : res = 0 for o in objects : try : res += _getsizeof ( o ) except AttributeError : print ( \"IGNORING: type=%s; o=%s\" % ( str ( type ( o ) ) , str ( o ) ) ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a copy of dct without keys keys [CODESPLIT] def _delete_keys ( dct , keys ) : c = deepcopy ( dct ) assert isinstance ( keys , list ) for k in keys : c . pop ( k ) return c", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If pair is in search_list return the index . Otherwise return - 1 [CODESPLIT] def is_in ( self , search_list , pair ) : index = - 1 for nr , i in enumerate ( search_list ) : if ( np . all ( i == pair ) ) : return nr return index", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a generic success response . [CODESPLIT] def success_response ( * * data ) : data_out = { } data_out [ \"status\" ] = \"success\" data_out . update ( data ) js = dumps ( data_out , default = date_handler ) return Response ( js , status = 200 , mimetype = \"application/json\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a string with punctuation removed . [CODESPLIT] def remove_punctuation ( text , exceptions = [ ] ) : all_but = [ r'\\w' , r'\\s' ] all_but . extend ( exceptions ) pattern = '[^{}]' . format ( '' . join ( all_but ) ) return re . sub ( pattern , '' , text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the index of the closest in xarr to value val [CODESPLIT] def closest ( xarr , val ) : idx_closest = np . argmin ( np . abs ( np . array ( xarr ) - val ) ) return idx_closest", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a list of words given text removing punctuation . [CODESPLIT] def wordify ( text ) : stopset = set ( nltk . corpus . stopwords . words ( 'english' ) ) tokens = nltk . WordPunctTokenizer ( ) . tokenize ( text ) return [ w for w in tokens if w not in stopset ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Copy file - like object to temp file and return path . [CODESPLIT] def copy_to_temp ( object ) : temp_file = NamedTemporaryFile ( delete = False ) _copy_and_close ( object , temp_file ) return temp_file . name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove non - alphanumerical characters from metric word . And trim excessive underscores . [CODESPLIT] def sanitize_word ( s ) : s = re . sub ( '[^\\w-]+' , '_' , s ) s = re . sub ( '__+' , '_' , s ) return s . strip ( '_' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Temporary helper function to link to the API routes [CODESPLIT] def home ( ) : return dict ( links = dict ( api = '{}{}' . format ( request . url , PREFIX [ 1 : ] ) ) ) , HTTPStatus . OK", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns short version of topic url ( without page number ) [CODESPLIT] def get_short_url ( self ) : return reverse ( 'post_short_url' , args = ( self . forum . slug , self . slug , self . id ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "in string astr replace all occurences of thefind with thereplace [CODESPLIT] def myreplace ( astr , thefind , thereplace ) : alist = astr . split ( thefind ) new_s = alist . split ( thereplace ) return new_s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a 3 - dimensional rotation matrix . [CODESPLIT] def R_rot_3d ( th ) : sx , sy , sz = np . sin ( th ) . T cx , cy , cz = np . cos ( th ) . T R = np . empty ( ( len ( th ) , 3 , 3 ) , dtype = np . float ) R [ : , 0 , 0 ] = cy * cz R [ : , 0 , 1 ] = - cy * sz R [ : , 0 , 2 ] = sy R [ : , 1 , 0 ] = sx * sy * cz + cx * sz R [ : , 1 , 1 ] = - sx * sy * sz + cx * cz R [ : , 1 , 2 ] = - sx * cy R [ : , 2 , 0 ] = - cx * sy * cz + sx * sz R [ : , 2 , 1 ] = cx * sy * sz + sx * cz R [ : , 2 , 2 ] = cx * cy return R", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace multiple values in a string [CODESPLIT] def replace ( s , replace ) : for r in replace : s = s . replace ( * r ) return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns x rounded to n significant figures . [CODESPLIT] def round_figures ( x , n ) : return round ( x , int ( n - math . ceil ( math . log10 ( abs ( x ) ) ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert CamelCase to underscore [CODESPLIT] def convert ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is an object iterable like a list ( and not a string ) ? [CODESPLIT] def listlike ( obj ) : return hasattr ( obj , \"__iter__\" ) and not issubclass ( type ( obj ) , str ) and not issubclass ( type ( obj ) , unicode )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run manage . py using this component s specific Django settings [CODESPLIT] def managepy ( cmd , extra = None ) : extra = extra . split ( ) if extra else [ ] run_django_cli ( [ 'invoke' , cmd ] + extra )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns nr of first entry parseable to float in ll None otherwise [CODESPLIT] def find_first_number ( ll ) : for nr , entry in enumerate ( ll ) : try : float ( entry ) except ( ValueError , TypeError ) as e : pass else : return nr return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a background thread for httpd and serve forever [CODESPLIT] def start ( self ) : self . _process = threading . Thread ( target = self . _background_runner ) self . _process . start ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return file contents as string . [CODESPLIT] def str_from_file ( path ) : with open ( path ) as f : s = f . read ( ) . strip ( ) return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the unique items from iterable * seq * ( in order ) . [CODESPLIT] def unique_items ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Stop receiving connections wait for all tasks to end and then terminate the server . [CODESPLIT] def stop_server ( self ) : self . stop = True while self . task_count : time . sleep ( END_RESP ) self . terminate = True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sort the given list in the way that humans expect . [CODESPLIT] def sort_nicely ( l ) : convert = lambda text : int ( text ) if text . isdigit ( ) else text alphanum_key = lambda key : [ convert ( c ) for c in re . split ( '([0-9]+)' , key ) ] l . sort ( key = alphanum_key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Round to sig figs [CODESPLIT] def round_to_n ( x , n ) : return round ( x , - int ( np . floor ( np . log10 ( x ) ) ) + ( n - 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove commas from a float [CODESPLIT] def clean_float ( v ) : if v is None or not str ( v ) . strip ( ) : return None return float ( str ( v ) . replace ( ',' , '' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write content back to file . [CODESPLIT] def write ( self ) : with open ( self . path , 'w' ) as file_ : file_ . write ( self . content )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the name of the function f s keyword argument parameter if it exists otherwise None [CODESPLIT] def get_func_posargs_name ( f ) : sigparams = inspect . signature ( f ) . parameters for p in sigparams : if sigparams [ p ] . kind == inspect . Parameter . VAR_POSITIONAL : return sigparams [ p ] . name return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a random ( i . e . unique ) string identifier [CODESPLIT] def _get_random_id ( ) : symbols = string . ascii_uppercase + string . ascii_lowercase + string . digits return '' . join ( random . choice ( symbols ) for _ in range ( 15 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run a HgPushlog etl process [CODESPLIT] def fetch_hg_push_log ( repo_name , repo_url ) : newrelic . agent . add_custom_parameter ( \"repo_name\" , repo_name ) process = HgPushlogProcess ( ) process . run ( repo_url + '/json-pushes/?full=1&version=2' , repo_name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Commandline interface to average parameters . [CODESPLIT] def main ( ) : setup_main_logger ( console = True , file_logging = False ) params = argparse . ArgumentParser ( description = \"Averages parameters from multiple models.\" ) arguments . add_average_args ( params ) args = params . parse_args ( ) average_parameters ( args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update cursor position . [CODESPLIT] def update_cursor_position ( self , line , index ) : value = 'Line {}, Col {}' . format ( line + 1 , index + 1 ) self . set_value ( value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Populates an object s attributes using the provided dict [CODESPLIT] def populate_obj ( obj , attrs ) : for k , v in attrs . iteritems ( ) : setattr ( obj , k , v )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Scroll element into view [CODESPLIT] def scroll_element_into_view ( self ) : x = self . web_element . location [ 'x' ] y = self . web_element . location [ 'y' ] self . driver . execute_script ( 'window.scrollTo({0}, {1})' . format ( x , y ) ) return self", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Because standard distinct used on the all fields are very slow and works only with PostgreSQL database this method provides alternative to the standard distinct method . : return : qs with unique objects [CODESPLIT] def fast_distinct ( self ) : return self . model . objects . filter ( pk__in = self . values_list ( 'pk' , flat = True ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Populate axis limits GUI with current plot values . [CODESPLIT] def set_xlimits_widgets ( self , set_min = True , set_max = True ) : xmin , xmax = self . tab_plot . ax . get_xlim ( ) if set_min : self . w . x_lo . set_text ( '{0}' . format ( xmin ) ) if set_max : self . w . x_hi . set_text ( '{0}' . format ( xmax ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the current xy coordinates of the mouse cursor as a two - integer tuple by calling the GetCursorPos () win32 function . [CODESPLIT] def _position ( ) : cursor = POINT ( ) ctypes . windll . user32 . GetCursorPos ( ctypes . byref ( cursor ) ) return ( cursor . x , cursor . y )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Must be called to print final progress label . [CODESPLIT] def finished ( self ) : self . progress_bar . set_state ( ProgressBar . STATE_DONE ) self . progress_bar . show ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Display both SQLAlchemy and Python help statements [CODESPLIT] def _help ( ) : statement = '%s%s' % ( shelp , phelp % ', ' . join ( cntx_ . keys ( ) ) ) print statement . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If values in a series match a specified value change them to np . nan . [CODESPLIT] def na_if ( series , * values ) : series = pd . Series ( series ) series [ series . isin ( values ) ] = np . nan return series", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shuffle the data . [CODESPLIT] def _shuffle ( data , idx ) : shuffle_data = [ ] for idx_k , idx_v in data : shuffle_data . append ( ( idx_k , mx . ndarray . array ( idx_v . asnumpy ( ) [ idx ] , idx_v . context ) ) ) return shuffle_data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Skip the specified number of elements in the list . [CODESPLIT] def skip ( self , n ) : try : self . _iter_object . skip ( n ) except AttributeError : for i in range ( 0 , n ) : self . next ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Not meant to be used directly use : meth : Instaloader . save_session_to_file . [CODESPLIT] def save_session_to_file ( self , sessionfile ) : pickle . dump ( requests . utils . dict_from_cookiejar ( self . _session . cookies ) , sessionfile )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a slice from a table column holding arrays . ( see : func : table . getcolslice ) [CODESPLIT] def getcolslice ( self , blc , trc , inc = [ ] , startrow = 0 , nrow = - 1 , rowincr = 1 ) : return self . _table . getcolslice ( self . _column , blc , trc , inc , startrow , nrow , rowincr )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set yaxis limits . [CODESPLIT] def ylim ( self , low , high , index = 1 ) : self . layout [ 'yaxis' + str ( index ) ] [ 'range' ] = [ low , high ] return self", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Grow a slice object by 1 in each direction without overreaching the list . [CODESPLIT] def grow_slice ( slc , size ) : return slice ( max ( 0 , slc . start - 1 ) , min ( size , slc . stop + 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "DEBUG FUNC modify argv to look like you ran a command [CODESPLIT] def aug_sysargv ( cmdstr ) : import shlex argv = shlex . split ( cmdstr ) sys . argv . extend ( argv )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sort the given list in the way that humans expect . [CODESPLIT] def sort_nicely ( l ) : convert = lambda text : int ( text ) if text . isdigit ( ) else text alphanum_key = lambda key : [ convert ( c ) for c in re . split ( '([0-9]+)' , key ) ] l . sort ( key = alphanum_key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the tests . [CODESPLIT] def test ( ctx , all = False , verbose = False ) : cmd = 'tox' if all else 'py.test' if verbose : cmd += ' -v' return ctx . run ( cmd , pty = True ) . return_code", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sort the data . [CODESPLIT] def sort_data ( x , y ) : xy = sorted ( zip ( x , y ) ) x , y = zip ( * xy ) return x , y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "zeros out states that should be identical [CODESPLIT] def _zerosamestates ( self , A ) : for pair in self . samestates : A [ pair [ 0 ] , pair [ 1 ] ] = 0 A [ pair [ 1 ] , pair [ 0 ] ] = 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sort data rows and order columns [CODESPLIT] def sort_data ( data , cols ) : return data . sort_values ( cols ) [ cols + [ 'value' ] ] . reset_index ( drop = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds passed value to node s globals [CODESPLIT] def set_global ( node : Node , key : str , value : Any ) : node . node_globals [ key ] = value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a histogram for the data to the axes . [CODESPLIT] def _histplot_op ( ax , data , * * kwargs ) : bins = get_bins ( data ) ax . hist ( data , bins = bins , align = \"left\" , density = True , * * kwargs ) return ax", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Hacked run function which installs the trace . [CODESPLIT] def __run ( self ) : sys . settrace ( self . globaltrace ) self . __run_backup ( ) self . run = self . __run_backup", "target": 1, "target_options": ["no_match", "match"]}
{"input": "transpose matrix [CODESPLIT] def transpose ( table ) : t = [ ] for i in range ( 0 , len ( table [ 0 ] ) ) : t . append ( [ row [ i ] for row in table ] ) return t", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Toggle linear / log scale for Y - axis . [CODESPLIT] def log_y_cb ( self , w , val ) : self . tab_plot . logy = val self . plot_two_columns ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Equivalent to numpy . split ( array_2d slices ) but avoids fancy indexing [CODESPLIT] def _split_arrs ( array_2d , slices ) : if len ( array_2d ) == 0 : return np . empty ( 0 , dtype = np . object ) rtn = np . empty ( len ( slices ) + 1 , dtype = np . object ) start = 0 for i , s in enumerate ( slices ) : rtn [ i ] = array_2d [ start : s ] start = s rtn [ - 1 ] = array_2d [ start : ] return rtn", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fold all values of the matrix into [ 0 1 ] . [CODESPLIT] def normalize_matrix ( matrix ) : abs_matrix = np . abs ( matrix . copy ( ) ) return abs_matrix / abs_matrix . max ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Empty the range from start to stop . [CODESPLIT] def empty ( self , start = None , stop = None ) : self . set ( NOT_SET , start = start , stop = stop )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shut down a specific process . [CODESPLIT] def stop ( pid ) : if psutil . pid_exists ( pid ) : try : p = psutil . Process ( pid ) p . kill ( ) except Exception : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Store the user session for a client . [CODESPLIT] def save_session ( self , sid , session , namespace = None ) : return self . server . save_session ( sid , session , namespace = namespace or self . namespace )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove duplicates from a list preserving the order . [CODESPLIT] def dedupe_list ( l ) : result = [ ] for el in l : if el not in result : result . append ( el ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to turn a string representation of true into boolean True . [CODESPLIT] def strToBool ( val ) : if isinstance ( val , str ) : val = val . lower ( ) return val in [ 'true' , 'on' , 'yes' , True ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list copy in which each item occurs only once ( in - order ) . [CODESPLIT] def unique ( iterable ) : seen = set ( ) return [ x for x in iterable if x not in seen and not seen . add ( x ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Formats the sum of a and b . [CODESPLIT] def pair_strings_sum_formatter ( a , b ) : if b [ : 1 ] == \"-\" : return \"{0} - {1}\" . format ( a , b [ 1 : ] ) return \"{0} + {1}\" . format ( a , b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a target dct and a dict of { key : default value } pairs calls setdefault for all of those pairs . [CODESPLIT] def setdefaults ( dct , defaults ) : for key in defaults : dct . setdefault ( key , defaults [ key ] ) return dct", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a json string representing the python object obj . [CODESPLIT] def to_json ( obj ) : i = StringIO . StringIO ( ) w = Writer ( i , encoding = 'UTF-8' ) w . write_value ( obj ) return i . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Install or upgrade setuptools and EasyInstall [CODESPLIT] def main ( argv , version = DEFAULT_VERSION ) : tarball = download_setuptools ( ) _install ( tarball , _build_install_args ( argv ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a comma separated option into a list . [CODESPLIT] def split_comma_argument ( comma_sep_str ) : terms = [ ] for term in comma_sep_str . split ( ',' ) : if term : terms . append ( term ) return terms", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Swap i and j rows [CODESPLIT] def _swap_rows ( self , i , j ) : L = np . eye ( 3 , dtype = 'intc' ) L [ i , i ] = 0 L [ j , j ] = 0 L [ i , j ] = 1 L [ j , i ] = 1 self . _L . append ( L . copy ( ) ) self . _A = np . dot ( L , self . _A )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return sha1 for contents of filename . [CODESPLIT] def _sha1_for_file ( filename ) : with open ( filename , \"rb\" ) as fileobj : contents = fileobj . read ( ) return hashlib . sha1 ( contents ) . hexdigest ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a sha1 of the given string [CODESPLIT] def sha1 ( s ) : h = hashlib . new ( 'sha1' ) h . update ( s ) return h . hexdigest ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform a range of years ( two ints ) to a DateRange object . [CODESPLIT] def from_years_range ( start_year , end_year ) : start = datetime . date ( start_year , 1 , 1 ) end = datetime . date ( end_year , 12 , 31 ) return DateRange ( start , end )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns true if the virtualenv tool is installed . [CODESPLIT] def has_virtualenv ( self ) : with self . settings ( warn_only = True ) : ret = self . run_or_local ( 'which virtualenv' ) . strip ( ) return bool ( ret )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generalised logarithm [CODESPLIT] def glog ( x , l = 2 ) : return np . log ( ( x + np . sqrt ( x ** 2 + l ** 2 ) ) / 2 ) / np . log ( l )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a Django project is being managed with manage . py or django - admin scripts [CODESPLIT] def is_managed ( ) : for item in sys . argv : if re . search ( r'manage.py|django-admin|django' , item ) is not None : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Logs a function s run time [CODESPLIT] def timed_call ( func , * args , log_level = 'DEBUG' , * * kwargs ) : start = time ( ) r = func ( * args , * * kwargs ) t = time ( ) - start log ( log_level , \"Call to '{}' took {:0.6f}s\" . format ( func . __name__ , t ) ) return r", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a string containing the type and text of the exception . [CODESPLIT] def format_exception ( e ) : from . utils . printing import fill return '\\n' . join ( fill ( line ) for line in traceback . format_exception_only ( type ( e ) , e ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an appropriate positive infinity for this dtype . [CODESPLIT] def get_neg_infinity ( dtype ) : if issubclass ( dtype . type , ( np . floating , np . integer ) ) : return - np . inf if issubclass ( dtype . type , np . complexfloating ) : return - np . inf - 1j * np . inf return NINF", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Quit signal handler . [CODESPLIT] def signal_handler ( signal_name , frame ) : sys . stdout . flush ( ) print ( \"\\nSIGINT in frame signal received. Quitting...\" ) sys . stdout . flush ( ) sys . exit ( 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates one element of the collection [CODESPLIT] def update_one ( self , query , doc ) : if self . table is None : self . build_table ( ) if u\"$set\" in doc : doc = doc [ u\"$set\" ] allcond = self . parse_query ( query ) try : result = self . table . update ( doc , allcond ) except : # TODO: check table.update result # check what pymongo does in that case result = None return UpdateResult ( raw_result = result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resolve all html entities to their corresponding unicode character [CODESPLIT] def unescape_all ( string ) : def escape_single ( matchobj ) : return _unicode_for_entity_with_name ( matchobj . group ( 1 ) ) return entities . sub ( escape_single , string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update the dev_info data from a dictionary . [CODESPLIT] def update ( self , params ) : dev_info = self . json_state . get ( 'deviceInfo' ) dev_info . update ( { k : params [ k ] for k in params if dev_info . get ( k ) } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Selectively log an accepted request . [CODESPLIT] def log_request ( self , code = '-' , size = '-' ) : if self . server . logRequests : BaseHTTPServer . BaseHTTPRequestHandler . log_request ( self , code , size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update the dev_info data from a dictionary . [CODESPLIT] def update ( self , params ) : dev_info = self . json_state . get ( 'deviceInfo' ) dev_info . update ( { k : params [ k ] for k in params if dev_info . get ( k ) } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates the request payload size [CODESPLIT] def calculate_size ( name , timeout ) : data_size = 0 data_size += calculate_size_str ( name ) data_size += LONG_SIZE_IN_BYTES return data_size", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transforms the regular socket . socket to an ssl . SSLSocket for secure connections . Any arguments are passed to ssl . wrap_socket : http : // docs . python . org / dev / library / ssl . html#ssl . wrap_socket [CODESPLIT] def enable_ssl ( self , * args , * * kwargs ) : if self . handshake_sent : raise SSLError ( 'can only enable SSL before handshake' ) self . secure = True self . sock = ssl . wrap_socket ( self . sock , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function returns a pretty table used to display the port results . [CODESPLIT] def get_table ( ports ) : table = PrettyTable ( [ \"Name\" , \"Port\" , \"Protocol\" , \"Description\" ] ) table . align [ \"Name\" ] = \"l\" table . align [ \"Description\" ] = \"l\" table . padding_width = 1 for port in ports : table . add_row ( port ) return table", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Increment over newlines . [CODESPLIT] def _skip_newlines ( self ) : while self . _cur_token [ 'type' ] is TT . lbreak and not self . _finished : self . _increment ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Filter the given object through the filter chain . [CODESPLIT] def filter ( self , obj , * args , * * kwargs ) : for _ , _ , func in self . _filter_order : obj = func ( obj , * args , * * kwargs ) if obj is None : return None return obj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Skip a single frame from the trajectory [CODESPLIT] def _skip_frame ( self ) : size = self . read_size ( ) for i in range ( size + 1 ) : line = self . _f . readline ( ) if len ( line ) == 0 : raise StopIteration", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Indent given text using custom spacing default is set to 4 . [CODESPLIT] def indent ( txt , spacing = 4 ) : return prefix ( str ( txt ) , '' . join ( [ ' ' for _ in range ( spacing ) ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns are under the ROC curve [CODESPLIT] def roc_auc ( y_true , y_score ) : notnull = ~ np . isnan ( y_true ) fpr , tpr , thresholds = sklearn . metrics . roc_curve ( y_true [ notnull ] , y_score [ notnull ] ) return sklearn . metrics . auc ( fpr , tpr )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Layered feed - forward network . [CODESPLIT] def NeuralNetLearner ( dataset , sizes ) : activations = map ( lambda n : [ 0.0 for i in range ( n ) ] , sizes ) weights = [ ] def predict ( example ) : unimplemented ( ) return predict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exponential function [CODESPLIT] def Exponential ( x , a , tau , y0 ) : return np . exp ( x / tau ) * a + y0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find rightmost value less than or equal to x . [CODESPLIT] def find_le ( a , x ) : i = bs . bisect_right ( a , x ) if i : return i - 1 raise ValueError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pause for this many seconds [CODESPLIT] def seconds ( num ) : now = pytime . time ( ) end = now + num until ( end )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts html content to plain text [CODESPLIT] def html_to_text ( content ) : text = None h2t = html2text . HTML2Text ( ) h2t . ignore_links = False text = h2t . handle ( content ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "We have a full length slice . [CODESPLIT] def is_full_slice ( obj , l ) : return ( isinstance ( obj , slice ) and obj . start == 0 and obj . stop == l and obj . step is None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "splits iterables a in equal parts of size sz [CODESPLIT] def partition ( a , sz ) : return [ a [ i : i + sz ] for i in range ( 0 , len ( a ) , sz ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns : N x #class scores summed to one for each box . [CODESPLIT] def output_scores ( self , name = None ) : return tf . nn . softmax ( self . label_logits , name = name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sort list elements by name . [CODESPLIT] def sort_by_name ( self ) : super ( JSSObjectList , self ) . sort ( key = lambda k : k . name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Advance the iterator without returning the old head . [CODESPLIT] def _fill ( self ) : try : self . _head = self . _iterable . next ( ) except StopIteration : self . _head = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a vector with the elements rounded to the given number of digits . [CODESPLIT] def get_rounded ( self , digits ) : result = self . copy ( ) result . round ( digits ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of dictionaries which are sorted for only unique entries . [CODESPLIT] def unique_list_dicts ( dlist , key ) : return list ( dict ( ( val [ key ] , val ) for val in dlist ) . values ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write GML comment . [CODESPLIT] def comment ( self , s , * * args ) : self . writeln ( s = u'comment \"%s\"' % s , * * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Batches a list into a list of lists with sub - lists sized by a specified batch size . [CODESPLIT] def batch ( items , size ) : return [ items [ x : x + size ] for x in xrange ( 0 , len ( items ) , size ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "helper function used for joins builds left and right join list for join function [CODESPLIT] def get_join_cols ( by_entry ) : left_cols = [ ] right_cols = [ ] for col in by_entry : if isinstance ( col , str ) : left_cols . append ( col ) right_cols . append ( col ) else : left_cols . append ( col [ 0 ] ) right_cols . append ( col [ 1 ] ) return left_cols , right_cols", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split s by sep unless it s inside a quote . [CODESPLIT] def split_on ( s , sep = \" \" ) : pattern = '''((?:[^%s\"']|\"[^\"]*\"|'[^']*')+)''' % sep return [ _strip_speechmarks ( t ) for t in re . split ( pattern , s ) [ 1 : : 2 ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert version like string to a tuple of integers . [CODESPLIT] def ver_to_tuple ( value ) : return tuple ( int ( _f ) for _f in re . split ( r'\\D+' , value ) if _f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty output of nested dictionaries . [CODESPLIT] def pretty_dict_string ( d , indent = 0 ) : s = '' for key , value in sorted ( d . items ( ) ) : s += '    ' * indent + str ( key ) if isinstance ( value , dict ) : s += '\\n' + pretty_dict_string ( value , indent + 1 ) else : s += '=' + str ( value ) + '\\n' return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "split string * s * into list of strings no longer than * length * [CODESPLIT] def split_len ( s , length ) : return [ s [ i : i + length ] for i in range ( 0 , len ( s ) , length ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert an untyped point into an Expression point . [CODESPLIT] def upoint2exprpoint ( upoint ) : point = dict ( ) for uniqid in upoint [ 0 ] : point [ _LITS [ uniqid ] ] = 0 for uniqid in upoint [ 1 ] : point [ _LITS [ uniqid ] ] = 1 return point", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts camel - case identifiers to snake - case . [CODESPLIT] def to_snake_case ( s ) : return re . sub ( '([^_A-Z])([A-Z])' , lambda m : m . group ( 1 ) + '_' + m . group ( 2 ) . lower ( ) , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "logical_or ( t ) = self ( t ) or other ( t ) . [CODESPLIT] def logical_or ( self , other ) : return self . operation ( other , lambda x , y : int ( x or y ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "parse_query_string : very simplistic . won t do the right thing with list values [CODESPLIT] def parse_query_string ( query ) : result = { } qparts = query . split ( '&' ) for item in qparts : key , value = item . split ( '=' ) key = key . strip ( ) value = value . strip ( ) result [ key ] = unquote_plus ( value ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a random alpha - numerical id . [CODESPLIT] def get_random_id ( length ) : alphabet = string . ascii_uppercase + string . ascii_lowercase + string . digits return '' . join ( random . choice ( alphabet ) for _ in range ( length ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resolve all html entities to their corresponding unicode character [CODESPLIT] def unescape_all ( string ) : def escape_single ( matchobj ) : return _unicode_for_entity_with_name ( matchobj . group ( 1 ) ) return entities . sub ( escape_single , string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts markdown content to text [CODESPLIT] def md_to_text ( content ) : text = None html = markdown . markdown ( content ) if html : text = html_to_text ( content ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Conveinience : [CODESPLIT] def get_tablenames ( cur ) : cur . execute ( \"SELECT name FROM sqlite_master WHERE type='table'\" ) tablename_list_ = cur . fetchall ( ) tablename_list = [ str ( tablename [ 0 ] ) for tablename in tablename_list_ ] return tablename_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the SQL typename required to store the given FieldDefinition [CODESPLIT] def _getTypename ( self , defn ) : return 'REAL' if defn . type . float or 'TIME' in defn . type . name or defn . dntoeu else 'INTEGER'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the id of the last written row in table [CODESPLIT] def get_last_id ( self , cur , table = 'reaction' ) : cur . execute ( \"SELECT seq FROM sqlite_sequence WHERE name='{0}'\" . format ( table ) ) result = cur . fetchone ( ) if result is not None : id = result [ 0 ] else : id = 0 return id", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the pythonic string type . [CODESPLIT] def visit_Str ( self , node ) : self . result [ node ] = self . builder . NamedType ( pytype_to_ctype ( str ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Plot stacked serie lines and stacked secondary lines [CODESPLIT] def _plot ( self ) : for serie in self . series [ : : - 1 if self . stack_from_top else 1 ] : self . line ( serie ) for serie in self . secondary_series [ : : - 1 if self . stack_from_top else 1 ] : self . line ( serie , True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "print just one that returns what you give it instead of None [CODESPLIT] def print ( * a ) : try : _print ( * a ) return a [ 0 ] if len ( a ) == 1 else a except : _print ( * a )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Writes the string to stdout [CODESPLIT] def _stdout_raw ( self , s ) : print ( s , end = '' , file = sys . stdout ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "function to check if input query is not None and set missing arguments to default value [CODESPLIT] def validate_args ( * * args ) : if not args [ 'query' ] : print ( \"\\nMissing required query argument.\" ) sys . exit ( ) for key in DEFAULTS : if key not in args : args [ key ] = DEFAULTS [ key ] return args", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shutdown the service with a reason . [CODESPLIT] def stop ( self , reason = None ) : self . logger . info ( 'stopping' ) self . loop . stop ( pyev . EVBREAK_ALL )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates the Jaccard similarity between two sets of nodes . Called by mroc . [CODESPLIT] def jaccard ( c_1 , c_2 ) : nom = np . intersect1d ( c_1 , c_2 ) . size denom = np . union1d ( c_1 , c_2 ) . size return nom / denom", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get tuple ( actually a generator ) of indices where the max value of array x occurs . Requires that x have a max () method as x . max () ( in the case of NumPy ) is much faster than max ( x ) . For a simpler faster argmax when there is only a single maximum entry or when knowing only the first index where the maximum occurs call argmax () on a NumPy array . [CODESPLIT] def MultiArgMax ( x ) : m = x . max ( ) return ( i for i , v in enumerate ( x ) if v == m )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Encodes numpy images into gif string . [CODESPLIT] def _encode_gif ( images , fps ) : writer = WholeVideoWriter ( fps ) writer . write_multi ( images ) return writer . finish ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If a user id is stored in the session load the user object from the database into g . user . [CODESPLIT] def load_logged_in_user ( ) : user_id = session . get ( \"user_id\" ) g . user = User . query . get ( user_id ) if user_id is not None else None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a complete graph from the list of node ids . [CODESPLIT] def _create_complete_graph ( node_ids ) : g = nx . Graph ( ) g . add_nodes_from ( node_ids ) for ( i , j ) in combinations ( node_ids , 2 ) : g . add_edge ( i , j ) return g", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove key from dict and return value . [CODESPLIT] def pop ( self , key ) : if key in self . _keys : self . _keys . remove ( key ) super ( ListDict , self ) . pop ( key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create ctypes pointer to object . [CODESPLIT] def POINTER ( obj ) : p = ctypes . POINTER ( obj ) if not isinstance ( p . from_param , classmethod ) : def from_param ( cls , x ) : if x is None : return cls ( ) else : return x p . from_param = classmethod ( from_param ) return p", "target": 1, "target_options": ["no_match", "match"]}
{"input": "in string astr replace all occurences of thefind with thereplace [CODESPLIT] def myreplace ( astr , thefind , thereplace ) : alist = astr . split ( thefind ) new_s = alist . split ( thereplace ) return new_s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "in string astr replace all occurences of thefind with thereplace [CODESPLIT] def myreplace ( astr , thefind , thereplace ) : alist = astr . split ( thefind ) new_s = alist . split ( thereplace ) return new_s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Open a file . [CODESPLIT] def open_file ( file , mode ) : if hasattr ( file , \"read\" ) : return file if hasattr ( file , \"open\" ) : return file . open ( mode ) return open ( file , mode )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform an underscore_case string to a mixedCase string [CODESPLIT] def us2mc ( string ) : return re . sub ( r'_([a-z])' , lambda m : ( m . group ( 1 ) . upper ( ) ) , string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Inputs [ a b c ] returns { a : 0 b : 1 c : 2 } . [CODESPLIT] def list_string_to_dict ( string ) : dictionary = { } for idx , c in enumerate ( string ) : dictionary . update ( { c : idx } ) return dictionary", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates col_widths in code_array [CODESPLIT] def _xls2col_widths ( self , worksheet , tab ) : for col in xrange ( worksheet . ncols ) : try : xls_width = worksheet . colinfo_map [ col ] . width pys_width = self . xls_width2pys_width ( xls_width ) self . code_array . col_widths [ col , tab ] = pys_width except KeyError : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like FromFile but takes a string . [CODESPLIT] def FromString ( s , * * kwargs ) : f = StringIO . StringIO ( s ) return FromFile ( f , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like FromFile but takes a string . [CODESPLIT] def FromString ( s , * * kwargs ) : f = StringIO . StringIO ( s ) return FromFile ( f , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get tuple ( actually a generator ) of indices where the max value of array x occurs . Requires that x have a max () method as x . max () ( in the case of NumPy ) is much faster than max ( x ) . For a simpler faster argmax when there is only a single maximum entry or when knowing only the first index where the maximum occurs call argmax () on a NumPy array . [CODESPLIT] def MultiArgMax ( x ) : m = x . max ( ) return ( i for i , v in enumerate ( x ) if v == m )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a text and drops all non - printable and non - ascii characters and also any whitespace characters that aren t space . [CODESPLIT] def drop_bad_characters ( text ) : # Strip all non-ascii and non-printable characters text = '' . join ( [ c for c in text if c in ALLOWED_CHARS ] ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get zero - indexed line from an open file - like . [CODESPLIT] def get_lines ( handle , line ) : for i , l in enumerate ( handle ) : if i == line : return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a timestamp value and rounds it to a second precision . [CODESPLIT] def RoundToSeconds ( cls , timestamp ) : leftovers = timestamp % definitions . MICROSECONDS_PER_SECOND scrubbed = timestamp - leftovers rounded = round ( float ( leftovers ) / definitions . MICROSECONDS_PER_SECOND ) return int ( scrubbed + rounded * definitions . MICROSECONDS_PER_SECOND )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialize python List with capacity of 10 or user given input . Python List type is a dynamic array so we have to restrict its dynamic nature to make it work like a static array . [CODESPLIT] def __init__ ( self , capacity = 10 ) : super ( ) . __init__ ( ) self . _array = [ None ] * capacity self . _front = 0 self . _rear = 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove punctuation from string s . [CODESPLIT] def unpunctuate ( s , * , char_blacklist = string . punctuation ) : # remove punctuation s = \"\" . join ( c for c in s if c not in char_blacklist ) # remove consecutive spaces return \" \" . join ( filter ( None , s . split ( \" \" ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialise sets used for uniqueness checking . [CODESPLIT] def _init_unique_sets ( self ) : ks = dict ( ) for t in self . _unique_checks : key = t [ 0 ] ks [ key ] = set ( ) # empty set return ks", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Performs a join using the union join function . [CODESPLIT] def merge ( left , right , how = 'inner' , key = None , left_key = None , right_key = None , left_as = 'left' , right_as = 'right' ) : return join ( left , right , how , key , left_key , right_key , join_fn = make_union_join ( left_as , right_as ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clips a prefix from the beginning of a string if it exists . [CODESPLIT] def _clip ( sid , prefix ) : return sid [ len ( prefix ) : ] if sid . startswith ( prefix ) else sid", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get input from the user given an input function and an input string [CODESPLIT] def get_input ( input_func , input_str ) : val = input_func ( \"Please enter your {0}: \" . format ( input_str ) ) while not val or not len ( val . strip ( ) ) : val = input_func ( \"You didn't enter a valid {0}, please try again: \" . format ( input_str ) ) return val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Weeks start are fixes at Monday for now . [CODESPLIT] def weekly ( date = datetime . date . today ( ) ) : return date - datetime . timedelta ( days = date . weekday ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert string into camel case . [CODESPLIT] def camelcase ( string ) : string = re . sub ( r\"^[\\-_\\.]\" , '' , str ( string ) ) if not string : return string return lowercase ( string [ 0 ] ) + re . sub ( r\"[\\-_\\.\\s]([a-z])\" , lambda matched : uppercase ( matched . group ( 1 ) ) , string [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Inverse sine [CODESPLIT] def asin ( x ) : if isinstance ( x , UncertainFunction ) : mcpts = np . arcsin ( x . _mcpts ) return UncertainFunction ( mcpts ) else : return np . arcsin ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function has two purposes : [CODESPLIT] def synchronized ( obj ) : if hasattr ( obj , 'synchronizable_condition' ) : return obj . synchronizable_condition elif callable ( obj ) : @ functools . wraps ( obj ) def wrapper ( self , * args , * * kwargs ) : with self . synchronizable_condition : return obj ( self , * args , * * kwargs ) return wrapper else : raise TypeError ( 'expected Synchronizable instance or callable to decorate' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs an asynchronous function without needing to use await - useful for lambda [CODESPLIT] def runcoro ( async_function ) : future = _asyncio . run_coroutine_threadsafe ( async_function , client . loop ) result = future . result ( ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the string encoding used by the Unicode implementation . The default is ascii but if you re willing to experiment you can change this . [CODESPLIT] def setencoding ( ) : encoding = \"ascii\" # Default value set by _PyUnicode_Init() if 0 : # Enable to support locale aware default string encodings. import locale loc = locale . getdefaultlocale ( ) if loc [ 1 ] : encoding = loc [ 1 ] if 0 : # Enable to switch off string to Unicode coercion and implicit # Unicode to string conversion. encoding = \"undefined\" if encoding != \"ascii\" : # On Non-Unicode builds this will raise an AttributeError... sys . setdefaultencoding ( encoding )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Interpolate linearly variable x in rangeX onto rangeY . [CODESPLIT] def lin_interp ( x , rangeX , rangeY ) : s = ( x - rangeX [ 0 ] ) / mag ( rangeX [ 1 ] - rangeX [ 0 ] ) y = rangeY [ 0 ] * ( 1 - s ) + rangeY [ 1 ] * s return y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return password from pipe if not on TTY else False . [CODESPLIT] def pass_from_pipe ( cls ) : is_pipe = not sys . stdin . isatty ( ) return is_pipe and cls . strip_last_newline ( sys . stdin . read ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Interpolate linearly variable x in rangeX onto rangeY . [CODESPLIT] def lin_interp ( x , rangeX , rangeY ) : s = ( x - rangeX [ 0 ] ) / mag ( rangeX [ 1 ] - rangeX [ 0 ] ) y = rangeY [ 0 ] * ( 1 - s ) + rangeY [ 1 ] * s return y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Unique elements preserving order . [CODESPLIT] def unique_everseen ( iterable , filterfalse_ = itertools . filterfalse ) : # Itertools recipes:\n # https://docs.python.org/3/library/itertools.html#itertools-recipes\n seen = set ( ) seen_add = seen . add for element in filterfalse_ ( seen . __contains__ , iterable ) : seen_add ( element ) yield element", "target": 1, "target_options": ["no_match", "match"]}
{"input": "in comparison to argrelmax () more simple and reliable peak finder [CODESPLIT] def findMax ( arr ) : out = np . zeros ( shape = arr . shape , dtype = bool ) _calcMax ( arr , out ) return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raw print to sys . __stdout__ otherwise identical interface to print () . [CODESPLIT] def raw_print ( * args , * * kw ) : print ( * args , sep = kw . get ( 'sep' , ' ' ) , end = kw . get ( 'end' , '\\n' ) , file = sys . __stdout__ ) sys . __stdout__ . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a file exists [CODESPLIT] def file_found ( filename , force ) : if os . path . exists ( filename ) and not force : logger . info ( \"Found %s; skipping...\" % filename ) return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A method used to round a number in the way that UsefulUtils rounds . [CODESPLIT] def specialRound ( number , rounding ) : temp = 0 if rounding == 0 : temp = number else : temp = round ( number , rounding ) if temp % 1 == 0 : return int ( temp ) else : return float ( temp )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if exception was raised because of too many executed requests . ( This is a temporal solution and will be changed in later package versions . ) [CODESPLIT] def _request_limit_reached ( exception ) : return isinstance ( exception , requests . HTTPError ) and exception . response . status_code == requests . status_codes . codes . TOO_MANY_REQUESTS", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs a bash script in the local directory [CODESPLIT] def bash ( filename ) : sys . stdout . flush ( ) subprocess . call ( \"bash {}\" . format ( filename ) , shell = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the most common element in iterable . [CODESPLIT] def _most_common ( iterable ) : data = Counter ( iterable ) return max ( data , key = data . __getitem__ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The device of a tensor . [CODESPLIT] def get_tensor_device ( self , tensor_name ) : tensor = self . _name_to_tensor ( tensor_name ) if isinstance ( tensor , tf . Tensor ) : return tensor . device else : # mtf.Tensor return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extend the mask with the image elements where the intensity is NaN . [CODESPLIT] def mask_nonfinite ( self ) : self . mask = np . logical_and ( self . mask , ( np . isfinite ( self . intensity ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Initializes session variables . Args : sess : Session to initialize . [CODESPLIT] def sg_init ( sess ) : # initialize variables sess . run ( tf . group ( tf . global_variables_initializer ( ) , tf . local_variables_initializer ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert to timestamp . [CODESPLIT] async def iso ( self , source ) : from datetime import datetime unix_timestamp = int ( source ) return datetime . fromtimestamp ( unix_timestamp ) . isoformat ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "invoke wptools and exit safely [CODESPLIT] def main ( args ) : start = time . time ( ) output = get ( args ) _safe_exit ( start , output )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield successive n - sized chunks from iterable object . https : // stackoverflow . com / a / 312464 [CODESPLIT] def chunks ( iterable , n ) : for i in range ( 0 , len ( iterable ) , n ) : yield iterable [ i : i + n ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if something quacks like a list . [CODESPLIT] def is_listish ( obj ) : if isinstance ( obj , ( list , tuple , set ) ) : return True return is_sequence ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an iterator over the values of a dictionary . [CODESPLIT] def itervalues ( d , * * kw ) : if not PY2 : return iter ( d . values ( * * kw ) ) return d . itervalues ( * * kw )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap itertools . groupby to make life easier . [CODESPLIT] def group_by ( iterable , key_func ) : groups = ( list ( sub ) for key , sub in groupby ( iterable , key_func ) ) return zip ( groups , groups )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if an array is a square matrix . [CODESPLIT] def is_square_matrix ( mat ) : mat = np . array ( mat ) if mat . ndim != 2 : return False shape = mat . shape return shape [ 0 ] == shape [ 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether the passed variable is a tuple with two floats or integers [CODESPLIT] def contains_geometric_info ( var ) : return isinstance ( var , tuple ) and len ( var ) == 2 and all ( isinstance ( val , ( int , float ) ) for val in var )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run Python test cases against Java runtime classes . [CODESPLIT] def test_python_java_rt ( ) : sub_env = { 'PYTHONPATH' : _build_dir ( ) } log . info ( 'Executing Python unit tests (against Java runtime classes)...' ) return jpyutil . _execute_python_scripts ( python_java_rt_tests , env = sub_env )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check testcase format if valid [CODESPLIT] def _check_format ( file_path , content ) : # TODO: replace with JSON schema validation if not content : # testcase file content is empty err_msg = u\"Testcase file content is empty: {}\" . format ( file_path ) logger . log_error ( err_msg ) raise exceptions . FileFormatError ( err_msg ) elif not isinstance ( content , ( list , dict ) ) : # testcase file content does not match testcase format err_msg = u\"Testcase file content format invalid: {}\" . format ( file_path ) logger . log_error ( err_msg ) raise exceptions . FileFormatError ( err_msg )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Dump Python object as JSON string . [CODESPLIT] def dump_json ( obj ) : return simplejson . dumps ( obj , ignore_nan = True , default = json_util . default )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a copy of the string passed to the filter wrapped after 79 characters . You can override this default using the first parameter . If you set the second parameter to false Jinja will not split words apart if they are longer than width . [CODESPLIT] def do_wordwrap ( s , width = 79 , break_long_words = True ) : import textwrap return u'\\n' . join ( textwrap . wrap ( s , width = width , expand_tabs = False , replace_whitespace = False , break_long_words = break_long_words ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coerces JSON string to boolean [CODESPLIT] def from_json ( value , * * kwargs ) : if isinstance ( value , string_types ) : value = value . upper ( ) if value in ( 'TRUE' , 'Y' , 'YES' , 'ON' ) : return True if value in ( 'FALSE' , 'N' , 'NO' , 'OFF' ) : return False if isinstance ( value , int ) : return value raise ValueError ( 'Could not load boolean from JSON: {}' . format ( value ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check to see if an image is progressive . [CODESPLIT] def is_progressive ( image ) : if not isinstance ( image , Image . Image ) : # Can only check PIL images for progressive encoding. return False return ( 'progressive' in image . info ) or ( 'progression' in image . info )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Serializer for consistency [CODESPLIT] def json_dumps ( self , obj ) : return json . dumps ( obj , sort_keys = True , indent = 4 , separators = ( ',' , ': ' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the internal flag to true . [CODESPLIT] def set ( self ) : with self . __cond : self . __flag = True self . __cond . notify_all ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Outputs json with formatting edits + object handling . [CODESPLIT] def dumps ( obj ) : return json . dumps ( obj , indent = 4 , sort_keys = True , cls = CustomEncoder )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "calculates a rough guess of runtime based on product of parameters [CODESPLIT] def estimate_complexity ( self , x , y , z , n ) : num_calculations = x * y * z * n run_time = num_calculations / 100000 # a 2014 PC does about 100k calcs in a second (guess based on prior logs) return self . show_time_as_short_string ( run_time )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Open and load JSON from file . [CODESPLIT] def read_json ( location ) : location = ensure_path ( location ) with location . open ( 'r' , encoding = 'utf8' ) as f : return ujson . load ( f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a web driver if mobile . [CODESPLIT] def is_webdriver_ios ( webdriver ) : browser = webdriver . capabilities [ 'browserName' ] if ( browser == u ( 'iPhone' ) or browser == u ( 'iPad' ) ) : return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts string hh : mm : ss . ssssss as a float [CODESPLIT] def hms_to_seconds ( time_string ) : s = time_string . split ( ':' ) hours = int ( s [ 0 ] ) minutes = int ( s [ 1 ] ) secs = float ( s [ 2 ] ) return hours * 3600 + minutes * 60 + secs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a datetime object of a given timestamp ( in local tz ) . [CODESPLIT] def fromtimestamp ( cls , timestamp ) : d = cls . utcfromtimestamp ( timestamp ) return d . astimezone ( localtz ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper to uncheck a checkbox [CODESPLIT] def checkbox_uncheck ( self , force_check = False ) : if self . get_attribute ( 'checked' ) : self . click ( force_click = force_check )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Qt slot when the window is closed . [CODESPLIT] def closeEvent ( self , e ) : self . emit ( 'close_widget' ) super ( DockWidget , self ) . closeEvent ( e )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pyglet specific key press callback . Forwards and translates the events to : py : func : keyboard_event [CODESPLIT] def on_key_press ( self , symbol , modifiers ) : self . keyboard_event ( symbol , self . keys . ACTION_PRESS , modifiers )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deletes the line content after the cursor [CODESPLIT] def _end_del ( self ) : text = self . edit_text [ : self . edit_pos ] self . set_edit_text ( text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "These actions will be done after SIGTERM . [CODESPLIT] def sigterm ( self , signum , frame ) : self . logger . warning ( \"Caught signal %s. Stopping daemon.\" % signum ) sys . exit ( 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "loads widget at given position ; handling invalid arguments [CODESPLIT] def _get ( self , pos ) : res = None , None if pos is not None : try : res = self [ pos ] , pos except ( IndexError , KeyError ) : pass return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the last time filepath was accessed . [CODESPLIT] def get_access_datetime ( filepath ) : import tzlocal tz = tzlocal . get_localzone ( ) mtime = datetime . fromtimestamp ( os . path . getatime ( filepath ) ) return mtime . replace ( tzinfo = tz )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Hide the window . [CODESPLIT] def hide ( self ) : self . tk . withdraw ( ) self . _visible = False if self . _modal : self . tk . grab_release ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clear last N lines of terminal output . [CODESPLIT] def clear_last_lines ( self , n ) : self . term . stream . write ( self . term . move_up * n + self . term . clear_eos ) self . term . stream . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Callback for the Scale widget inserts an int value into the Entry . [CODESPLIT] def _on_scale ( self , event ) : self . _entry . delete ( 0 , tk . END ) self . _entry . insert ( 0 , str ( self . _variable . get ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A function to generate the latex representation of sympy expressions . [CODESPLIT] def print_latex ( o ) : if can_print_latex ( o ) : s = latex ( o , mode = 'plain' ) s = s . replace ( '\\\\dag' , '\\\\dagger' ) s = s . strip ( '$' ) return '$$%s$$' % s # Fallback to the string printer return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform underscore separated string to pascal case [CODESPLIT] def to_pascal_case ( s ) : return re . sub ( r'(?!^)_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , s . capitalize ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get distance between pairs of lat - lon points [CODESPLIT] def Distance ( lat1 , lon1 , lat2 , lon2 ) : az12 , az21 , dist = wgs84_geod . inv ( lon1 , lat1 , lon2 , lat2 ) return az21 , dist", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Merge all the PDF files in pdf_filepaths in a new PDF file out_filepath . [CODESPLIT] def merge_pdfs ( pdf_filepaths , out_filepath ) : merger = PdfFileMerger ( ) for pdf in pdf_filepaths : merger . append ( PdfFileReader ( open ( pdf , 'rb' ) ) ) merger . write ( out_filepath ) return out_filepath", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flexible writing where f can be a filename or f object if filename closed after writing [CODESPLIT] def write_to ( f , mode ) : if hasattr ( f , 'write' ) : yield f else : f = open ( f , mode ) yield f f . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get all instances matching a tag . [CODESPLIT] def _aws_get_instance_by_tag ( region , name , tag , raw ) : client = boto3 . session . Session ( ) . client ( 'ec2' , region ) matching_reservations = client . describe_instances ( Filters = [ { 'Name' : tag , 'Values' : [ name ] } ] ) . get ( 'Reservations' , [ ] ) instances = [ ] [ [ instances . append ( _aws_instance_from_dict ( region , instance , raw ) ) # pylint: disable=expression-not-assigned for instance in reservation . get ( 'Instances' ) ] for reservation in matching_reservations if reservation ] return instances", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Lemmatize all tokens in a string or a list . A string is first tokenized using punkt . Throw a type error if the input is neither a string nor a list . [CODESPLIT] def lemmatize ( self , text , best_guess = True , return_frequencies = False ) : if isinstance ( text , str ) : tokens = wordpunct_tokenize ( text ) elif isinstance ( text , list ) : tokens = text else : raise TypeError ( \"lemmatize only works with strings or lists of string tokens.\" ) return [ self . _lemmatize_token ( token , best_guess , return_frequencies ) for token in tokens ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize the length of a vector to one [CODESPLIT] def norm_vec ( vector ) : assert len ( vector ) == 3 v = np . array ( vector ) return v / np . sqrt ( np . sum ( v ** 2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run server with provided command line arguments . [CODESPLIT] def start ( args ) : application = tornado . web . Application ( [ ( r\"/run\" , run . get_handler ( args ) ) , ( r\"/status\" , run . StatusHandler ) ] ) application . runmonitor = RunMonitor ( ) application . listen ( args . port ) tornado . ioloop . IOLoop . instance ( ) . start ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turns response into a properly formatted json or text object [CODESPLIT] async def json_or_text ( response ) : text = await response . text ( ) if response . headers [ 'Content-Type' ] == 'application/json; charset=utf-8' : return json . loads ( text ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like pretty but print to stdout . [CODESPLIT] def pprint ( obj , verbose = False , max_width = 79 , newline = '\\n' ) : printer = RepresentationPrinter ( sys . stdout , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) sys . stdout . write ( newline ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raise this exception with the original traceback [CODESPLIT] def re_raise ( self ) : if self . exc_info is not None : six . reraise ( type ( self ) , self , self . exc_info [ 2 ] ) else : raise self", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generalised logarithm [CODESPLIT] def glog ( x , l = 2 ) : return np . log ( ( x + np . sqrt ( x ** 2 + l ** 2 ) ) / 2 ) / np . log ( l )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pre - order depth - first [CODESPLIT] def walk_tree ( root ) : yield root for child in root . children : for el in walk_tree ( child ) : yield el", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a Seaborn linear regression plot [CODESPLIT] def _linear_seaborn_ ( self , label = None , style = None , opts = None ) : xticks , yticks = self . _get_ticks ( opts ) try : fig = sns . lmplot ( self . x , self . y , data = self . df ) fig = self . _set_with_height ( fig , opts ) return fig except Exception as e : self . err ( e , self . linear_ , \"Can not draw linear regression chart\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Whitespace normalization : [CODESPLIT] def text_remove_empty_lines ( text ) : lines = [ line . rstrip ( ) for line in text . splitlines ( ) if line . strip ( ) ] return \"\\n\" . join ( lines )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert this confusion matrix into a 2x2 plain list of values . [CODESPLIT] def to_list ( self ) : return [ [ int ( self . table . cell_values [ 0 ] [ 1 ] ) , int ( self . table . cell_values [ 0 ] [ 2 ] ) ] , [ int ( self . table . cell_values [ 1 ] [ 1 ] ) , int ( self . table . cell_values [ 1 ] [ 2 ] ) ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an image with the binarised version of the data of img . [CODESPLIT] def abs_img ( img ) : bool_img = np . abs ( read_img ( img ) . get_data ( ) ) return bool_img . astype ( int )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of dicionaries . See set_order . [CODESPLIT] def get_order ( self ) : return [ dict ( reverse = r [ 0 ] , key = r [ 1 ] ) for r in self . get_model ( ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transparently unzip the file handle [CODESPLIT] def _unzip_handle ( handle ) : if isinstance ( handle , basestring ) : handle = _gzip_open_filename ( handle ) else : handle = _gzip_open_handle ( handle ) return handle", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if value can be part of binary / bitwise operations . [CODESPLIT] def isbinary ( * args ) : return all ( map ( lambda c : isnumber ( c ) or isbool ( c ) , args ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compose all given tuples together . [CODESPLIT] def compose_all ( tups ) : from . import ast # I weep for humanity return functools . reduce ( lambda x , y : x . compose ( y ) , map ( ast . make_tuple , tups ) , ast . make_tuple ( { } ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve contents of each page of PDF [CODESPLIT] def resources ( self ) : return [ self . pdf . getPage ( i ) for i in range ( self . pdf . getNumPages ( ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert Matrix attributes which are array - like or buffer to array . [CODESPLIT] def _convert_to_array ( array_like , dtype ) : if isinstance ( array_like , bytes ) : return np . frombuffer ( array_like , dtype = dtype ) return np . asarray ( array_like , dtype = dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a list of values from RDF triples when more than one may be present [CODESPLIT] def _get_triplet_value_list ( self , graph , identity , rdf_type ) : values = [ ] for elem in graph . objects ( identity , rdf_type ) : values . append ( elem . toPython ( ) ) return values", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Move the turtle forward . [CODESPLIT] def forward ( self , step ) : x = self . pos_x + math . cos ( math . radians ( self . rotation ) ) * step y = self . pos_y + math . sin ( math . radians ( self . rotation ) ) * step prev_brush_state = self . brush_on self . brush_on = True self . move ( x , y ) self . brush_on = prev_brush_state", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Support instance methods . [CODESPLIT] def __get__ ( self , obj , objtype ) : if not self . is_method : self . is_method = True return functools . partial ( self . __call__ , obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def parsed_args ( ) : parser = argparse . ArgumentParser ( description = \"\"\"python runtime functions\"\"\" , epilog = \"\" ) parser . add_argument ( 'command' , nargs = '*' , help = \"Name of the function to run with arguments\" ) args = parser . parse_args ( ) return ( args , parser )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load and parse a feature file . [CODESPLIT] def load_feature ( fname , language ) : fname = os . path . abspath ( fname ) feat = parse_file ( fname , language ) return feat", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raises an AssertionError if expected is actual . [CODESPLIT] def assert_is_not ( expected , actual , message = None , extra = None ) : assert expected is not actual , _assert_fail_message ( message , expected , actual , \"is\" , extra )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Search tuple array by index and value : param t : tuple array : param i : index of the value in each tuple : param v : value : return : the first tuple in the array with the specific index / value [CODESPLIT] def tuple_search ( t , i , v ) : for e in t : if e [ i ] == v : return e return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check that the page title matches the given one . [CODESPLIT] def page_title ( step , title ) : with AssertContextManager ( step ) : assert_equals ( world . browser . title , title )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Display all available logging information . [CODESPLIT] def pylog ( self , * args , * * kwargs ) : printerr ( self . name , args , kwargs , traceback . format_exc ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the length of the longest consecutive run of identical values . [CODESPLIT] def longest_run_1d ( arr ) : v , rl = rle_1d ( arr ) [ : 2 ] return np . where ( v , rl , 0 ) . max ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Search tuple array by index and value : param t : tuple array : param i : index of the value in each tuple : param v : value : return : the first tuple in the array with the specific index / value [CODESPLIT] def tuple_search ( t , i , v ) : for e in t : if e [ i ] == v : return e return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get an stacked area chart [CODESPLIT] def sarea_ ( self , col , x = None , y = None , rsum = None , rmean = None ) : try : charts = self . _multiseries ( col , x , y , \"area\" , rsum , rmean ) return hv . Area . stack ( charts ) except Exception as e : self . err ( e , self . sarea_ , \"Can not draw stacked area chart\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the modified time of a file [CODESPLIT] def set_time ( filename , mod_time ) : log . debug ( 'Setting modified time to %s' , mod_time ) mtime = calendar . timegm ( mod_time . utctimetuple ( ) ) # utctimetuple discards microseconds, so restore it (for consistency)\n mtime += mod_time . microsecond / 1000000 atime = os . stat ( filename ) . st_atime os . utime ( filename , ( atime , mtime ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print out system information ( version MAC addrs ) . [CODESPLIT] async def sysinfo ( dev : Device ) : click . echo ( await dev . get_system_info ( ) ) click . echo ( await dev . get_interface_information ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns path to packaged static files [CODESPLIT] def glr_path_static ( ) : return os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , '_static' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "In case the experiment enforces a quorum listen for notifications before creating Partipant objects . [CODESPLIT] def subscribe_to_quorum_channel ( self ) : from dallinger . experiment_server . sockets import chat_backend self . log ( \"Bot subscribing to quorum channel.\" ) chat_backend . subscribe ( self , \"quorum\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the file name from an url Parameters ---------- url : str [CODESPLIT] def get_url_file_name ( url ) : assert isinstance ( url , ( str , _oldstr ) ) return urlparse . urlparse ( url ) . path . split ( '/' ) [ - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieves the Python library directory path . [CODESPLIT] def GetPythonLibraryDirectoryPath ( ) : path = sysconfig . get_python_lib ( True ) _ , _ , path = path . rpartition ( sysconfig . PREFIX ) if path . startswith ( os . sep ) : path = path [ 1 : ] return path", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert an OrderedDict containing C values to a 1D array . [CODESPLIT] def C_dict2array ( C ) : return np . hstack ( [ np . asarray ( C [ k ] ) . ravel ( ) for k in C_keys ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Join the channel once connected to the IRC server . [CODESPLIT] def on_welcome ( self , connection , event ) : connection . join ( self . channel , key = settings . IRC_CHANNEL_KEY or \"\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether the provided value is a valid enum constant . [CODESPLIT] def check ( self , var ) : if not isinstance ( var , _str_type ) : return False return _enum_mangle ( var ) in self . _consts", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Install venv + deps . [CODESPLIT] def venv ( ) : try : import virtualenv # NOQA except ImportError : sh ( \"%s -m pip install virtualenv\" % PYTHON ) if not os . path . isdir ( \"venv\" ) : sh ( \"%s -m virtualenv venv\" % PYTHON ) sh ( \"venv\\\\Scripts\\\\pip install -r %s\" % ( REQUIREMENTS_TXT ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert special characters using %xx escape . [CODESPLIT] def url_encode ( url ) : if isinstance ( url , text_type ) : url = url . encode ( 'utf8' ) return quote ( url , ':/%?&=' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a column exists in an SFrame with error message . [CODESPLIT] def _raise_error_if_column_exists ( dataset , column_name = 'dataset' , dataset_variable_name = 'dataset' , column_name_error_message_name = 'column_name' ) : err_msg = 'The SFrame {0} must contain the column {1}.' . format ( dataset_variable_name , column_name_error_message_name ) if column_name not in dataset . column_names ( ) : raise ToolkitError ( str ( err_msg ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "if csv : import csv t = csv . writer ( sys . stdout delimiter = ; ) t . writerow ( header ) else : t = PrettyTable ( header ) t . align = r t . align [ details ] = l [CODESPLIT] def print_table ( * args , * * kwargs ) : t = format_table ( * args , * * kwargs ) click . echo ( t )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute quadratic bezier spline given start and end coordinate and two control points . [CODESPLIT] def quadratic_bezier ( start , end , c0 = ( 0 , 0 ) , c1 = ( 0 , 0 ) , steps = 50 ) : steps = np . linspace ( 0 , 1 , steps ) sx , sy = start ex , ey = end cx0 , cy0 = c0 cx1 , cy1 = c1 xs = ( ( 1 - steps ) ** 3 * sx + 3 * ( ( 1 - steps ) ** 2 ) * steps * cx0 + 3 * ( 1 - steps ) * steps ** 2 * cx1 + steps ** 3 * ex ) ys = ( ( 1 - steps ) ** 3 * sy + 3 * ( ( 1 - steps ) ** 2 ) * steps * cy0 + 3 * ( 1 - steps ) * steps ** 2 * cy1 + steps ** 3 * ey ) return np . column_stack ( [ xs , ys ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The volume of the primitive extrusion . [CODESPLIT] def volume ( self ) : volume = abs ( self . primitive . polygon . area * self . primitive . height ) return volume", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Evaluates a piece of Javascript in the context of the current page and returns its value . [CODESPLIT] def eval_script ( self , expr ) : ret = self . conn . issue_command ( \"Evaluate\" , expr ) return json . loads ( \"[%s]\" % ret ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Makes a classname [CODESPLIT] def classnameify ( s ) : return '' . join ( w if w in ACRONYMS else w . title ( ) for w in s . split ( '_' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Emit a sine wave at the given frequency . [CODESPLIT] def sine_wave ( frequency ) : xs = tf . reshape ( tf . range ( _samples ( ) , dtype = tf . float32 ) , [ 1 , _samples ( ) , 1 ] ) ts = xs / FLAGS . sample_rate return tf . sin ( 2 * math . pi * frequency * ts )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a WAV file and returns the data and sample rate [CODESPLIT] def readwav ( filename ) : from scipy . io . wavfile import read as readwav samplerate , signal = readwav ( filename ) return signal , samplerate", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get authentication . [CODESPLIT] def get_auth ( ) : import getpass user = input ( \"User Name: \" ) # noqa pswd = getpass . getpass ( 'Password: ' ) return Github ( user , pswd )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Download an HTML page using the requests session and return the final URL after following redirects . [CODESPLIT] def get_page_and_url ( session , url ) : reply = get_reply ( session , url ) return reply . text , reply . url", "target": 1, "target_options": ["no_match", "match"]}
{"input": "! [CODESPLIT] def manhattan_distance_numpy ( object1 , object2 ) : return numpy . sum ( numpy . absolute ( object1 - object2 ) , axis = 1 ) . T", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check the checkbox matching the CSS selector . [CODESPLIT] def check_by_selector ( self , selector ) : elem = find_element_by_jquery ( world . browser , selector ) if not elem . is_selected ( ) : elem . click ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add pytest unit tests to be built as part of build / test / output . [CODESPLIT] def autobuild_python_test ( path ) : env = Environment ( tools = [ ] ) target = env . Command ( [ 'build/test/output/pytest.log' ] , [ path ] , action = env . Action ( run_pytest , \"Running python unit tests\" ) ) env . AlwaysBuild ( target )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Finds multiple elements by id . [CODESPLIT] def find_elements_by_id ( self , id_ ) : return self . find_elements ( by = By . ID , value = id_ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Intersect dictionaries d1 and d2 by key * and * value . [CODESPLIT] def intersect ( d1 , d2 ) : return dict ( ( k , d1 [ k ] ) for k in d1 if k in d2 and d1 [ k ] == d2 [ k ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a tuple of ( start end ) indices of an item from its index . [CODESPLIT] def _get_item_position ( self , idx ) : start = 0 if idx == 0 else self . _index [ idx - 1 ] + 1 end = self . _index [ idx ] return start , end", "target": 1, "target_options": ["no_match", "match"]}
{"input": "add arrow to plot [CODESPLIT] def add_arrow ( self , x1 , y1 , x2 , y2 , * * kws ) : self . panel . add_arrow ( x1 , y1 , x2 , y2 , * * kws )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap standard function to easily pass into map processing . [CODESPLIT] def map_wrap ( f ) : @ functools . wraps ( f ) def wrapper ( * args , * * kwargs ) : return f ( * args , * * kwargs ) return wrapper", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This routine returns the 3x3 identity matrix . [CODESPLIT] def ident ( ) : matrix = stypes . emptyDoubleMatrix ( ) libspice . ident_c ( matrix ) return stypes . cMatrixToNumpy ( matrix )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Computes average length of words [CODESPLIT] def get_average_length_of_string ( strings ) : if not strings : return 0 return sum ( len ( word ) for word in strings ) / len ( strings )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Push item onto heap maintaining the heap invariant . [CODESPLIT] def heappush_max ( heap , item ) : heap . append ( item ) _siftdown_max ( heap , 0 , len ( heap ) - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ensure contents are written to file . [CODESPLIT] def flush ( self ) : for name in self . item_names : item = self [ name ] item . flush ( ) self . file . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Visible width of a potentially multiline content . [CODESPLIT] def _multiline_width ( multiline_s , line_width_fn = len ) : return max ( map ( line_width_fn , re . split ( \"[\\r\\n]\" , multiline_s ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "converts a base64 string to a file [CODESPLIT] def base64ToImage ( imgData , out_path , out_file ) : fh = open ( os . path . join ( out_path , out_file ) , \"wb\" ) fh . write ( imgData . decode ( 'base64' ) ) fh . close ( ) del fh return os . path . join ( out_path , out_file )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Serialize obj as a JSON formatted stream to fp [CODESPLIT] def _serialize_json ( obj , fp ) : json . dump ( obj , fp , indent = 4 , default = serialize )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine with width in pixels of string . [CODESPLIT] def text_width ( string , font_name , font_size ) : return stringWidth ( string , fontName = font_name , fontSize = font_size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Serializes a K8S resource to YAML - formatted file . [CODESPLIT] def serialize_yaml_tofile ( filename , resource ) : stream = file ( filename , \"w\" ) yaml . dump ( resource , stream , default_flow_style = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the high median of data . [CODESPLIT] def median_high ( data ) : data = sorted ( data ) n = len ( data ) if n == 0 : raise StatisticsError ( \"no median for empty data\" ) return data [ n // 2 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Obtain a real address as an integer from an objectproxy . [CODESPLIT] def objectproxy_realaddress ( obj ) : voidp = QROOT . TPython . ObjectProxy_AsVoidPtr ( obj ) return C . addressof ( C . c_char . from_buffer ( voidp ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the relative path for the given path from the current file by working around https : // bugs . python . org / issue20012 . [CODESPLIT] def _rel ( self , path ) : return os . path . relpath ( str ( path ) , self . _parent ) . replace ( os . path . sep , '/' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ends an indentation block leaving an empty line afterwards [CODESPLIT] def end_block ( self ) : self . current_indent -= 1 # If we did not add a new line automatically yet, now it's the time! if not self . auto_added_line : self . writeln ( ) self . auto_added_line = True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Merge this range object with another ( ranges need not overlap or abut ) . [CODESPLIT] def merge ( self , other ) : newstart = min ( self . _start , other . start ) newend = max ( self . _end , other . end ) return Range ( newstart , newend )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates background color [CODESPLIT] def _update_bordercolor ( self , bordercolor ) : border_color = wx . SystemSettings_GetColour ( wx . SYS_COLOUR_ACTIVEBORDER ) border_color . SetRGB ( bordercolor ) self . linecolor_choice . SetColour ( border_color )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Merge this range object with another ( ranges need not overlap or abut ) . [CODESPLIT] def merge ( self , other ) : newstart = min ( self . _start , other . start ) newend = max ( self . _end , other . end ) return Range ( newstart , newend )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the current mouse location ( coordinates and screen number ) . [CODESPLIT] def get_mouse_location ( self ) : x = ctypes . c_int ( 0 ) y = ctypes . c_int ( 0 ) screen_num = ctypes . c_int ( 0 ) _libxdo . xdo_get_mouse_location ( self . _xdo , ctypes . byref ( x ) , ctypes . byref ( y ) , ctypes . byref ( screen_num ) ) return mouse_location ( x . value , y . value , screen_num . value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take the union of a list of lists . [CODESPLIT] def listunion ( ListOfLists ) : u = [ ] for s in ListOfLists : if s != None : u . extend ( s ) return u", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Send a notice ( from bot ) message to the room . [CODESPLIT] def send_notice ( self , text ) : return self . client . api . send_notice ( self . room_id , text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get longitudes from cartesian coordinates . [CODESPLIT] def get_lons_from_cartesian ( x__ , y__ ) : return rad2deg ( arccos ( x__ / sqrt ( x__ ** 2 + y__ ** 2 ) ) ) * sign ( y__ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty print an object as YAML . [CODESPLIT] def print_yaml ( o ) : print ( yaml . dump ( o , default_flow_style = False , indent = 4 , encoding = 'utf-8' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper for pymongo . Collection . ensure_index [CODESPLIT] def ensure_index ( self , key , unique = False ) : return self . collection . ensure_index ( key , unique = unique )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract the content of the zip - file at zip_path into target_folder . [CODESPLIT] def extract_zip ( zip_path , target_folder ) : with zipfile . ZipFile ( zip_path ) as archive : archive . extractall ( target_folder )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "An alternate to sort which allows you to specify a list of fields and use a leading - ( minus ) to specify DESCENDING . [CODESPLIT] def order_by ( self , * fields ) : doc = [ ] for field in fields : if field . startswith ( '-' ) : doc . append ( ( field . strip ( '-' ) , pymongo . DESCENDING ) ) else : doc . append ( ( field , pymongo . ASCENDING ) ) return self . sort ( doc )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a leading hash # at the beginning of every line in the source . [CODESPLIT] def _add_hash ( source ) : source = '\\n' . join ( '# ' + line . rstrip ( ) for line in source . splitlines ( ) ) return source", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find rightmost value less than x . [CODESPLIT] def find_lt ( a , x ) : i = bs . bisect_left ( a , x ) if i : return i - 1 raise ValueError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator which dynamically binds static methods to the model for later use . [CODESPLIT] def static_method ( cls , f ) : setattr ( cls , f . __name__ , staticmethod ( f ) ) return f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a pandas . Series into an xarray . DataArray . [CODESPLIT] def from_series ( cls , series ) : # TODO: add a 'name' parameter name = series . name df = pd . DataFrame ( { name : series } ) ds = Dataset . from_dataframe ( df ) return ds [ name ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a result from an asyncio future . [CODESPLIT] def access ( self , accessor , timeout = None ) : if self . loop . is_running ( ) : raise RuntimeError ( \"Loop is already running\" ) coro = asyncio . wait_for ( accessor , timeout , loop = self . loop ) return self . loop . run_until_complete ( coro )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Nearest - neighbour interpolation . Calls nearnd to find the index of the closest neighbours to xi yi [CODESPLIT] def interpolate_nearest ( self , xi , yi , zdata ) : if zdata . size != self . npoints : raise ValueError ( 'zdata should be same size as mesh' ) zdata = self . _shuffle_field ( zdata ) ist = np . ones_like ( xi , dtype = np . int32 ) ist , dist = _tripack . nearnds ( xi , yi , ist , self . _x , self . _y , self . lst , self . lptr , self . lend ) return zdata [ ist - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Monkey - patch urllib3 with SecureTransport - backed SSL - support . [CODESPLIT] def inject_into_urllib3 ( ) : util . ssl_ . SSLContext = SecureTransportContext util . HAS_SNI = HAS_SNI util . ssl_ . HAS_SNI = HAS_SNI util . IS_SECURETRANSPORT = True util . ssl_ . IS_SECURETRANSPORT = True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the magnitude of a vector . [CODESPLIT] def mag ( z ) : if isinstance ( z [ 0 ] , np . ndarray ) : return np . array ( list ( map ( np . linalg . norm , z ) ) ) else : return np . linalg . norm ( z )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if the file both exists and isempty [CODESPLIT] def isemptyfile ( filepath ) : exists = os . path . exists ( safepath ( filepath ) ) if exists : filesize = os . path . getsize ( safepath ( filepath ) ) return filesize == 0 else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Scipy norm function [CODESPLIT] def norm ( x , mu , sigma = 1.0 ) : return stats . norm ( loc = mu , scale = sigma ) . pdf ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a gzipped version of a previously opened file s buffer . [CODESPLIT] def get_gzipped_contents ( input_file ) : zbuf = StringIO ( ) zfile = GzipFile ( mode = \"wb\" , compresslevel = 6 , fileobj = zbuf ) zfile . write ( input_file . read ( ) ) zfile . close ( ) return ContentFile ( zbuf . getvalue ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if the given type is an enum type . [CODESPLIT] def is_enum_type ( type_ ) : return isinstance ( type_ , type ) and issubclass ( type_ , tuple ( _get_types ( Types . ENUM ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Computes the unnormalized PDF of the normal distribution . [CODESPLIT] def EvalGaussianPdf ( x , mu , sigma ) : return scipy . stats . norm . pdf ( x , mu , sigma )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalizes the given vector . The vector given may have any number of dimensions . [CODESPLIT] def v_normalize ( v ) : vmag = v_magnitude ( v ) return [ v [ i ] / vmag for i in range ( len ( v ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shortcut to create md5 hash : param s : : return : [CODESPLIT] def md5_string ( s ) : m = hashlib . md5 ( ) m . update ( s ) return str ( m . hexdigest ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "rescales a numpy array so that min is 0 and max is 255 [CODESPLIT] def _normalize ( mat : np . ndarray ) : return ( ( mat - mat . min ( ) ) * ( 255 / mat . max ( ) ) ) . astype ( np . uint8 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if object is not a string but is iterable [CODESPLIT] def is_seq ( obj ) : if not hasattr ( obj , '__iter__' ) : return False if isinstance ( obj , basestring ) : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize a field to a ( min max ) exposure range default is ( 0 255 ) . ( min max ) exposure values . Invert the image if requested . [CODESPLIT] def normalize ( im , invert = False , scale = None , dtype = np . float64 ) : if dtype not in { np . float16 , np . float32 , np . float64 } : raise ValueError ( 'dtype must be numpy.float16, float32, or float64.' ) out = im . astype ( 'float' ) . copy ( ) scale = scale or ( 0.0 , 255.0 ) l , u = ( float ( i ) for i in scale ) out = ( out - l ) / ( u - l ) if invert : out = - out + ( out . max ( ) + out . min ( ) ) return out . astype ( dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a gzipped version of a previously opened file s buffer . [CODESPLIT] def get_gzipped_contents ( input_file ) : zbuf = StringIO ( ) zfile = GzipFile ( mode = \"wb\" , compresslevel = 6 , fileobj = zbuf ) zfile . write ( input_file . read ( ) ) zfile . close ( ) return ContentFile ( zbuf . getvalue ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if arg is a valid file that already exists on the file system . [CODESPLIT] def is_valid_folder ( parser , arg ) : arg = os . path . abspath ( arg ) if not os . path . isdir ( arg ) : parser . error ( \"The folder %s does not exist!\" % arg ) else : return arg", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of characters in two strings that don t exactly match [CODESPLIT] def count_string_diff ( a , b ) : shortest = min ( len ( a ) , len ( b ) ) return sum ( a [ i ] != b [ i ] for i in range ( shortest ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "helper to clean up an input string [CODESPLIT] def clean ( some_string , uppercase = False ) : if uppercase : return some_string . strip ( ) . upper ( ) else : return some_string . strip ( ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper to the jinja2 render method from a template file [CODESPLIT] def render ( template , context ) : path , filename = os . path . split ( template ) return jinja2 . Environment ( loader = jinja2 . FileSystemLoader ( path or './' ) ) . get_template ( filename ) . render ( context )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return unique rows [CODESPLIT] def _unique_rows_numpy ( a ) : a = np . ascontiguousarray ( a ) unique_a = np . unique ( a . view ( [ ( '' , a . dtype ) ] * a . shape [ 1 ] ) ) return unique_a . view ( a . dtype ) . reshape ( ( unique_a . shape [ 0 ] , a . shape [ 1 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert val out of numpy time for use in to_dict . Needed because of numpy bug GH#7619 [CODESPLIT] def ensure_us_time_resolution ( val ) : if np . issubdtype ( val . dtype , np . datetime64 ) : val = val . astype ( 'datetime64[us]' ) elif np . issubdtype ( val . dtype , np . timedelta64 ) : val = val . astype ( 'timedelta64[us]' ) return val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets up a requests . Session object for sharing headers across API requests . [CODESPLIT] def setup_request_sessions ( self ) : self . req_session = requests . Session ( ) self . req_session . headers . update ( self . headers )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Log - normal cumulative density function [CODESPLIT] def lognormcdf ( x , mu , tau ) : x = np . atleast_1d ( x ) return np . array ( [ 0.5 * ( 1 - flib . derf ( - ( np . sqrt ( tau / 2 ) ) * ( np . log ( y ) - mu ) ) ) for y in x ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transforms an XML string it to python - zimbra dict format [CODESPLIT] def xml_str_to_dict ( s ) : xml = minidom . parseString ( s ) return pythonzimbra . tools . xmlserializer . dom_to_dict ( xml . firstChild )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Push a new value into heap . [CODESPLIT] def push ( h , x ) : h . push ( x ) up ( h , h . size ( ) - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns first and last element of numpy array or sparse matrix . [CODESPLIT] def _first_and_last_element ( arr ) : if isinstance ( arr , np . ndarray ) or hasattr ( arr , 'data' ) : # numpy array or sparse matrix with .data attribute data = arr . data if sparse . issparse ( arr ) else arr return data . flat [ 0 ] , data . flat [ - 1 ] else : # Sparse matrices without .data attribute. Only dok_matrix at # the time of writing, in this case indexing is fast return arr [ 0 , 0 ] , arr [ - 1 , - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "consume message from channel on the consuming thread . [CODESPLIT] def run ( self ) : LOGGER . debug ( \"rabbitmq.Service.run\" ) try : self . channel . start_consuming ( ) except Exception as e : LOGGER . warn ( \"rabbitmq.Service.run - Exception raised while consuming\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return if first occurrence of the key otherwise return line . [CODESPLIT] def filter_duplicate_key ( line , message , line_number , marked_line_numbers , source , previous_line = '' ) : if marked_line_numbers and line_number == sorted ( marked_line_numbers ) [ 0 ] : return '' return line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reseed factory . fuzzy s random generator . [CODESPLIT] def reseed_random ( seed ) : r = random . Random ( seed ) random_internal_state = r . getstate ( ) set_random_state ( random_internal_state )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handle many to many relationships [CODESPLIT] def handle_m2m ( self , sender , instance , * * kwargs ) : self . handle_save ( instance . __class__ , instance )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a csv and returns a List of Dicts with keys given by header row . [CODESPLIT] def csv_to_dicts ( file , header = None ) : with open ( file ) as csvfile : return [ row for row in csv . DictReader ( csvfile , fieldnames = header ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a yaml file s contents as a dictionary [CODESPLIT] def getYamlDocument ( filePath ) : with open ( filePath ) as stream : doc = yaml . load ( stream ) return doc", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return group content . [CODESPLIT] def _read_group_h5 ( filename , groupname ) : with h5py . File ( filename , 'r' ) as h5f : data = h5f [ groupname ] [ ( ) ] return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generator that yields lines from standard input . [CODESPLIT] def standard_input ( ) : with click . get_text_stream ( \"stdin\" ) as stdin : while stdin . readable ( ) : line = stdin . readline ( ) if line : yield line . strip ( ) . encode ( \"utf-8\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a histogram for the data to the axes . [CODESPLIT] def _histplot_op ( ax , data , * * kwargs ) : bins = get_bins ( data ) ax . hist ( data , bins = bins , align = \"left\" , density = True , * * kwargs ) return ax", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Quick way to read a file content . [CODESPLIT] def read ( fname ) : content = None with open ( os . path . join ( here , fname ) ) as f : content = f . read ( ) return content", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Public function that reads a local file and generates a SHA256 hash digest for it [CODESPLIT] def generate_hash ( filepath ) : fr = FileReader ( filepath ) data = fr . read_bin ( ) return _calculate_sha256 ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "List Available REST API Versions [CODESPLIT] def versions_request ( self ) : ret = self . handle_api_exceptions ( 'GET' , '' , api_ver = '' ) return [ str_dict ( x ) for x in ret . json ( ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse string into Identity dictionary . [CODESPLIT] def string_to_identity ( identity_str ) : m = _identity_regexp . match ( identity_str ) result = m . groupdict ( ) log . debug ( 'parsed identity: %s' , result ) return { k : v for k , v in result . items ( ) if v }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Directly reads text data from url [CODESPLIT] def url_read_text ( url , verbose = True ) : data = url_read ( url , verbose ) text = data . decode ( 'utf8' ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse http raw respone into python dictionary object . : param str response : http response : returns : response dict : rtype : dict [CODESPLIT] def _parse_response ( self , response ) : response_dict = { } for line in response . splitlines ( ) : key , value = response . split ( \"=\" , 1 ) response_dict [ key ] = value return response_dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to read JSON file as OrderedDict [CODESPLIT] def _read_json_file ( self , json_file ) : self . log . debug ( \"Reading '%s' JSON file...\" % json_file ) with open ( json_file , 'r' ) as f : return json . load ( f , object_pairs_hook = OrderedDict )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a string and dictionary . replaces all occurrences of i with j [CODESPLIT] def replace_all ( text , dic ) : for i , j in dic . iteritems ( ) : text = text . replace ( i , j ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Render our pages as a jinja template for fancy templating goodness . [CODESPLIT] def rstjinja ( app , docname , source ) : # Make sure we're outputting HTML if app . builder . format != 'html' : return src = source [ 0 ] rendered = app . builder . templates . render_string ( src , app . config . html_context ) source [ 0 ] = rendered", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all filenames under recursively found in a directory [CODESPLIT] def recursively_get_files_from_directory ( directory ) : return [ os . path . join ( root , filename ) for root , directories , filenames in os . walk ( directory ) for filename in filenames ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calls the specified Trigger of another Area with the optionally given parameters . [CODESPLIT] def trigger ( self , target : str , trigger : str , parameters : Dict [ str , Any ] = { } ) : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all filenames under recursively found in a directory [CODESPLIT] def recursively_get_files_from_directory ( directory ) : return [ os . path . join ( root , filename ) for root , directories , filenames in os . walk ( directory ) for filename in filenames ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": see :: meth : RedisMap . keys [CODESPLIT] def values ( self ) : for val in self . _client . hvals ( self . key_prefix ) : yield self . _loads ( val )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "parse the domain from the url [CODESPLIT] def parse_domain ( url ) : domain_match = lib . DOMAIN_REGEX . match ( url ) if domain_match : return domain_match . group ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Banana banana [CODESPLIT] def dict_to_html_attrs ( dict_ ) : res = ' ' . join ( '%s=\"%s\"' % ( k , v ) for k , v in dict_ . items ( ) ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extracts all integers from a string an return them in a list [CODESPLIT] def get_numbers ( s ) : result = map ( int , re . findall ( r'[0-9]+' , unicode ( s ) ) ) return result + [ 1 ] * ( 2 - len ( result ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute Pearson correlation coefficient . [CODESPLIT] def cor ( y_true , y_pred ) : y_true , y_pred = _mask_nan ( y_true , y_pred ) return np . corrcoef ( y_true , y_pred ) [ 0 , 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert CamelCase to camel_case [CODESPLIT] def camel_to_ ( s ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , s ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the tests . [CODESPLIT] def test ( ctx , all = False , verbose = False ) : cmd = 'tox' if all else 'py.test' if verbose : cmd += ' -v' return ctx . run ( cmd , pty = True ) . return_code", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove comments and empty lines [CODESPLIT] def lines ( input ) : for raw_line in input : line = raw_line . strip ( ) if line and not line . startswith ( '#' ) : yield strip_comments ( line )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove duplicated elements in a list . Args : lista : List with elements to clean duplicates . [CODESPLIT] def remove_list_duplicates ( lista , unique = False ) : result = [ ] allready = [ ] for elem in lista : if elem not in result : result . append ( elem ) else : allready . append ( elem ) if unique : for elem in allready : result = list ( filter ( ( elem ) . __ne__ , result ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Confusion matrix plot [CODESPLIT] def confusion_matrix ( self ) : return plot . confusion_matrix ( self . y_true , self . y_pred , self . target_names , ax = _gen_ax ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove blank elements in val and return ret [CODESPLIT] def de_blank ( val ) : ret = list ( val ) if type ( val ) == list : for idx , item in enumerate ( val ) : if item . strip ( ) == '' : ret . remove ( item ) else : ret [ idx ] = item . strip ( ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns value of a sine wave at a given frequency and framerate for a given sample i [CODESPLIT] def sine_wave ( i , frequency = FREQUENCY , framerate = FRAMERATE , amplitude = AMPLITUDE ) : omega = 2.0 * pi * float ( frequency ) sine = sin ( omega * ( float ( i ) / float ( framerate ) ) ) return float ( amplitude ) * sine", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes non - alpha characters and converts spaces to hyphens . Useful for making file names . Source : http : // stackoverflow . com / questions / 5574042 / string - slugification - in - python [CODESPLIT] def slugify ( string ) : string = re . sub ( '[^\\w .-]' , '' , string ) string = string . replace ( \" \" , \"-\" ) return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Init a noise variable . [CODESPLIT] def normal_noise ( points ) : return np . random . rand ( 1 ) * np . random . randn ( points , 1 ) + random . sample ( [ 2 , - 2 ] , 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a list ( l ) will removing duplicates from the list preserving the original order of the list . Assumes that the list entrie are hashable . [CODESPLIT] def dedup_list ( l ) : dedup = set ( ) return [ x for x in l if not ( x in dedup or dedup . add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a matplotlib colormap . [CODESPLIT] def add_matplotlib_cmap ( cm , name = None ) : global cmaps cmap = matplotlib_to_ginga_cmap ( cm , name = name ) cmaps [ cmap . name ] = cmap", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove unwanted list indices . First argument is the list of indices to remove . Other elements are the lists to trim . [CODESPLIT] def rm_empty_indices ( * args ) : rm_inds = args [ 0 ] if not rm_inds : return args [ 1 : ] keep_inds = [ i for i in range ( len ( args [ 1 ] ) ) if i not in rm_inds ] return [ [ a [ i ] for i in keep_inds ] for a in args [ 1 : ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove problem characters from string [CODESPLIT] def remove_bad ( string ) : remove = [ ':' , ',' , '(' , ')' , ' ' , '|' , ';' , '\\'' ] for c in remove : string = string . replace ( c , '_' ) return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Implements the === operator . [CODESPLIT] def hard_equals ( a , b ) : if type ( a ) != type ( b ) : return False return a == b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list where the duplicates have been removed . [CODESPLIT] def distinct ( l ) : seen = set ( ) seen_add = seen . add return ( _ for _ in l if not ( _ in seen or seen_add ( _ ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip excess spaces from a string [CODESPLIT] def strip_spaces ( s ) : return u\" \" . join ( [ c for c in s . split ( u' ' ) if c ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip all the accents from the string [CODESPLIT] def strip_accents ( string ) : return u'' . join ( ( character for character in unicodedata . normalize ( 'NFD' , string ) if unicodedata . category ( character ) != 'Mn' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty print format some XML so it s readable . [CODESPLIT] def pp_xml ( body ) : pretty = xml . dom . minidom . parseString ( body ) return pretty . toprettyxml ( indent = \"  \" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove duplicates from an iterable preserving the order . [CODESPLIT] def delete_duplicates ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If item is not in lst add item to list at its sorted position [CODESPLIT] def insort_no_dup ( lst , item ) : import bisect ix = bisect . bisect_left ( lst , item ) if lst [ ix ] != item : lst [ ix : ix ] = [ item ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "set colouring on if STDOUT is a terminal device off otherwise [CODESPLIT] def auto ( ) : try : Style . enabled = False Style . enabled = sys . stdout . isatty ( ) except ( AttributeError , TypeError ) : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes trailing whitespace on each line . [CODESPLIT] def clean ( s ) : lines = [ l . rstrip ( ) for l in s . split ( '\\n' ) ] return '\\n' . join ( lines )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Toggles document word wrap . [CODESPLIT] def toggle_word_wrap ( self ) : self . setWordWrapMode ( not self . wordWrapMode ( ) and QTextOption . WordWrap or QTextOption . NoWrap ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strips elements of values from the beginning of sequence . [CODESPLIT] def strip_head ( sequence , values ) : values = set ( values ) return list ( itertools . dropwhile ( lambda x : x in values , sequence ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "print a binary tree [CODESPLIT] def print_bintree ( tree , indent = '  ' ) : for n in sorted ( tree . keys ( ) ) : print \"%s%s\" % ( indent * depth ( n , tree ) , n )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes a : py : class : . Series from the chart . [CODESPLIT] def remove_series ( self , series ) : if len ( self . all_series ( ) ) == 1 : raise ValueError ( \"Cannot remove last series from %s\" % str ( self ) ) self . _all_series . remove ( series ) series . _chart = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Log that this task is done . [CODESPLIT] def log_finished ( self ) : delta = time . perf_counter ( ) - self . start_time logger . log ( \"Finished '\" , logger . cyan ( self . name ) , \"' after \" , logger . magenta ( time_to_text ( delta ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove the last NoteContainer in the Bar . [CODESPLIT] def remove_last_entry ( self ) : self . current_beat -= 1.0 / self . bar [ - 1 ] [ 1 ] self . bar = self . bar [ : - 1 ] return self . current_beat", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print a formatted indented text . [CODESPLIT] def indented_show ( text , howmany = 1 ) : print ( StrTemplate . pad_indent ( text = text , howmany = howmany ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove a variable from this dataset . [CODESPLIT] def __delitem__ ( self , key ) : del self . _variables [ key ] self . _coord_names . discard ( key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a prettier version of obj [CODESPLIT] def _get_pretty_string ( obj ) : sio = StringIO ( ) pprint . pprint ( obj , stream = sio ) return sio . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clean a pandas dataframe by : 1 . Filling empty values with Nan 2 . Dropping columns with all empty values [CODESPLIT] def clean_df ( df , fill_nan = True , drop_empty_columns = True ) : if fill_nan : df = df . fillna ( value = np . nan ) if drop_empty_columns : df = df . dropna ( axis = 1 , how = 'all' ) return df . sort_index ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "quit crash [CODESPLIT] def _quit ( self , * args ) : self . logger . warn ( 'Bye!' ) sys . exit ( self . exit ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param list_of_points : : return : list_of_points with None s removed [CODESPLIT] def filter_none ( list_of_points ) : remove_elementnone = filter ( lambda p : p is not None , list_of_points ) remove_sublistnone = filter ( lambda p : not contains_none ( p ) , remove_elementnone ) return list ( remove_sublistnone )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert None values to 0 so the data works with Matplotlib : param ts : : return : a list with 0s where Nones existed [CODESPLIT] def __convert_none_to_zero ( self , ts ) : if not ts : return ts ts_clean = [ val if val else 0 for val in ts ] return ts_clean", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of qubits as ( QuantumRegister index ) pairs . [CODESPLIT] def qubits ( self ) : return [ ( v , i ) for k , v in self . qregs . items ( ) for i in range ( v . size ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a C variable name with the given prefix based on the name of obj . [CODESPLIT] def _clean_name ( self , prefix , obj ) : return '{}{}_{}' . format ( prefix , self . _uid ( ) , '' . join ( c for c in obj . name if c . isalnum ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Close an opened url connection . [CODESPLIT] def close_connection ( self ) : if self . url_connection is None : # no connection is open return try : self . url_connection . close ( ) except Exception : # ignore close errors pass self . url_connection = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove and return the item at index . [CODESPLIT] def pop ( self , index = - 1 ) : value = self . _list . pop ( index ) del self . _dict [ value ] return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A wrapper of os . makedirs () . [CODESPLIT] def makedirs ( path , mode = 0o777 , exist_ok = False ) : os . makedirs ( path , mode , exist_ok )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "I strip extra whitespace off multi - line strings if they are ready to be stripped! [CODESPLIT] def text_cleanup ( data , key , last_type ) : if key in data and last_type == STRING_TYPE : data [ key ] = data [ key ] . strip ( ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "I strip extra whitespace off multi - line strings if they are ready to be stripped! [CODESPLIT] def text_cleanup ( data , key , last_type ) : if key in data and last_type == STRING_TYPE : data [ key ] = data [ key ] . strip ( ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes input from user . Works for Python 2 and 3 . [CODESPLIT] def _stdin_ ( p ) : _v = sys . version [ 0 ] return input ( p ) if _v is '3' else raw_input ( p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validate if non empty string [CODESPLIT] def is_non_empty_string ( input_string ) : try : if not input_string . strip ( ) : raise ValueError ( ) except AttributeError as error : raise TypeError ( error ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Makes the list have unique items only and maintains the order [CODESPLIT] def unique ( _list ) : ret = [ ] for item in _list : if item not in ret : ret . append ( item ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Callback for comboboxes : notifies us that a combobox for the given item and column has changed [CODESPLIT] def _updateItemComboBoxIndex ( self , item , column , num ) : item . _combobox_current_index [ column ] = num item . _combobox_current_value [ column ] = item . _combobox_option_list [ column ] [ num ] [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transforma una string con elementos separados por sep en una lista . [CODESPLIT] def string_to_list ( string , sep = \",\" , filter_empty = False ) : return [ value . strip ( ) for value in string . split ( sep ) if ( not filter_empty or value ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace any non - word characters with a dash . [CODESPLIT] def dashrepl ( value ) : patt = re . compile ( r'\\W' , re . UNICODE ) return re . sub ( patt , '-' , value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper to convert config values to boolean as ConfigParser do . [CODESPLIT] def _cast_boolean ( value ) : _BOOLEANS = { '1' : True , 'yes' : True , 'true' : True , 'on' : True , '0' : False , 'no' : False , 'false' : False , 'off' : False , '' : False } value = str ( value ) if value . lower ( ) not in _BOOLEANS : raise ValueError ( 'Not a boolean: %s' % value ) return _BOOLEANS [ value . lower ( ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a Python 2 function as lambda ( x y ) : x + y In the Python 3 format : lambda x y : x + y [CODESPLIT] def lambda_tuple_converter ( func ) : if func is not None and func . __code__ . co_argcount == 1 : return lambda * args : func ( args [ 0 ] if len ( args ) == 1 else args ) else : return func", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace any non - word characters with a dash . [CODESPLIT] def dashrepl ( value ) : patt = re . compile ( r'\\W' , re . UNICODE ) return re . sub ( patt , '-' , value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replaces occurrences of a match string in a given list of strings and returns a list of new strings . The match string can be a regex expression . [CODESPLIT] def replace_list ( items , match , replacement ) : return [ replace ( item , match , replacement ) for item in items ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create an array . Keyword arguments as per : func : zarr . creation . zeros . [CODESPLIT] def zeros ( self , name , * * kwargs ) : return self . _write_op ( self . _zeros_nosync , name , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace month strings occurrences with month number . [CODESPLIT] def replace_month_abbr_with_num ( date_str , lang = DEFAULT_DATE_LANG ) : num , abbr = get_month_from_date_str ( date_str , lang ) return re . sub ( abbr , str ( num ) , date_str , flags = re . IGNORECASE )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "set nan and inf rows from x to zero [CODESPLIT] def clean_with_zeros ( self , x ) : x [ ~ np . any ( np . isnan ( x ) | np . isinf ( x ) , axis = 1 ) ] = 0 return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the percentile of a list of values . [CODESPLIT] def percentile ( values , k ) : if not values : return None values . sort ( ) index = ( len ( values ) * ( float ( k ) / 100 ) ) - 1 return values [ int ( math . ceil ( index ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a string and dictionary . replaces all occurrences of i with j [CODESPLIT] def replace_all ( text , dic ) : for i , j in dic . iteritems ( ) : text = text . replace ( i , j ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add 0x to string at start . [CODESPLIT] def add_0x ( string ) : if isinstance ( string , bytes ) : string = string . decode ( 'utf-8' ) return '0x' + str ( string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Submit an operation [CODESPLIT] def submit ( self , fn , * args , * * kwargs ) : corofn = asyncio . coroutine ( lambda : fn ( * args , * * kwargs ) ) return run_coroutine_threadsafe ( corofn ( ) , self . loop )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "replace nan in a by val and returns the replaced array and the nan position [CODESPLIT] def _replace_nan ( a , val ) : mask = isnull ( a ) return where_method ( val , mask , a ) , mask", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Lookup country for IP address . [CODESPLIT] def get_geoip ( ip ) : reader = geolite2 . reader ( ) ip_data = reader . get ( ip ) or { } return ip_data . get ( 'country' , { } ) . get ( 'iso_code' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve the request s User - Agent if available . [CODESPLIT] def _get_user_agent ( self ) : user_agent = request . headers . get ( 'User-Agent' ) if user_agent : user_agent = user_agent . encode ( 'utf-8' ) return user_agent or ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "swap and then flatten axes 0 and 1 [CODESPLIT] def sf01 ( arr ) : s = arr . shape return arr . swapaxes ( 0 , 1 ) . reshape ( s [ 0 ] * s [ 1 ] , * s [ 2 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Synthesize white noise [CODESPLIT] def synthesize ( self , duration ) : sr = self . samplerate . samples_per_second seconds = duration / Seconds ( 1 ) samples = np . random . uniform ( low = - 1. , high = 1. , size = int ( sr * seconds ) ) return AudioSamples ( samples , self . samplerate )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Internal function to overcome pickling problem in python2 . [CODESPLIT] def _parallel_compare_helper ( class_obj , pairs , x , x_link = None ) : return class_obj . _compute ( pairs , x , x_link )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Register a callback to be invoked when a new device appears . [CODESPLIT] def add_device_callback ( self , callback ) : _LOGGER . debug ( 'Added new callback %s ' , callback ) self . _cb_new_device . append ( callback )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns type of the data for the given FeatureType . [CODESPLIT] def type ( self ) : if self is FeatureType . TIMESTAMP : return list if self is FeatureType . BBOX : return BBox return dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Example of sending a message . [CODESPLIT] async def send_message ( ) : jar = aiohttp . CookieJar ( unsafe = True ) websession = aiohttp . ClientSession ( cookie_jar = jar ) modem = eternalegypt . Modem ( hostname = sys . argv [ 1 ] , websession = websession ) await modem . login ( password = sys . argv [ 2 ] ) await modem . sms ( phone = sys . argv [ 3 ] , message = sys . argv [ 4 ] ) await modem . logout ( ) await websession . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Opens the file and reads the value [CODESPLIT] def get_property ( self , filename ) : with open ( self . filepath ( filename ) ) as f : return f . read ( ) . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adapted from pandas . tslib . get_date_field [CODESPLIT] def get_date_field ( datetimes , field ) : return np . array ( [ getattr ( date , field ) for date in datetimes ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the bounding box around nonzero elements in the given array [CODESPLIT] def bbox ( img ) : rows = np . any ( img , axis = 1 ) cols = np . any ( img , axis = 0 ) rmin , rmax = np . where ( rows ) [ 0 ] [ [ 0 , - 1 ] ] cmin , cmax = np . where ( cols ) [ 0 ] [ [ 0 , - 1 ] ] return rmin , rmax , cmin , cmax", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate random string of given length [CODESPLIT] def generate_hash ( self , length = 30 ) : import random , string chars = string . ascii_letters + string . digits ran = random . SystemRandom ( ) . choice hash = '' . join ( ran ( chars ) for i in range ( length ) ) return hash", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wanted functionality from Counters ( new in Python 2 . 7 ) . [CODESPLIT] def most_common ( items ) : counts = { } for i in items : counts . setdefault ( i , 0 ) counts [ i ] += 1 return max ( six . iteritems ( counts ) , key = operator . itemgetter ( 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find rightmost value less than x [CODESPLIT] def find_lt ( a , x ) : i = bisect . bisect_left ( a , x ) if i : return a [ i - 1 ] raise ValueError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Step over the next statement [CODESPLIT] def do_next ( self , args ) : self . _do_print_from_last_cmd = True self . _interp . step_over ( ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts all args to set type via self . setify function . [CODESPLIT] def convert_args_to_sets ( f ) : @ wraps ( f ) def wrapper ( * args , * * kwargs ) : args = ( setify ( x ) for x in args ) return f ( * args , * * kwargs ) return wrapper", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the memory byte size of a Numpy array as an integer . [CODESPLIT] def bytesize ( arr ) : byte_size = np . prod ( arr . shape ) * np . dtype ( arr . dtype ) . itemsize return byte_size", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Merge args with kwargs . [CODESPLIT] def _merge_args_with_kwargs ( args_dict , kwargs_dict ) : ret = args_dict . copy ( ) ret . update ( kwargs_dict ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the union of two RangeSets as a new RangeSet . [CODESPLIT] def __or__ ( self , other ) : if not isinstance ( other , set ) : return NotImplemented return self . union ( other )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply a function in parallel to each element of the input [CODESPLIT] def apply ( f , obj , * args , * * kwargs ) : return vectorize ( f ) ( obj , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Gets the string representation of the given type . [CODESPLIT] def getTypeStr ( _type ) : if isinstance ( _type , CustomType ) : return str ( _type ) if hasattr ( _type , '__name__' ) : return _type . __name__ return ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Implementation of Ramda s mapObjIndexed without the final argument . This returns the original key with the mapped value . Use map_key_values to modify the keys too : param f : Called with a key and value : param dct : : return { dict } : Keyed by the original key valued by the mapped value [CODESPLIT] def map_with_obj ( f , dct ) : f_dict = { } for k , v in dct . items ( ) : f_dict [ k ] = f ( k , v ) return f_dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transforms a DataFrame in place . Computes all outputs of the DataFrame . [CODESPLIT] def transform ( self , df ) : for name , function in self . outputs : df [ name ] = function ( df )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse markdown text to html . [CODESPLIT] def parse_markdown ( markdown_content , site_settings ) : markdown_extensions = set_markdown_extensions ( site_settings ) html_content = markdown . markdown ( markdown_content , extensions = markdown_extensions , ) return html_content", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert RGB arrays from mask canvas object back to boolean mask . [CODESPLIT] def _rgbtomask ( self , obj ) : dat = obj . get_image ( ) . get_data ( ) # RGB arrays return dat . sum ( axis = 2 ) . astype ( np . bool )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine True / False from argument [CODESPLIT] def process_bool_arg ( arg ) : if isinstance ( arg , bool ) : return arg elif isinstance ( arg , basestring ) : if arg . lower ( ) in [ \"true\" , \"1\" ] : return True elif arg . lower ( ) in [ \"false\" , \"0\" ] : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create 2D rotation matrix [CODESPLIT] def create_rot2d ( angle ) : ca = math . cos ( angle ) sa = math . sin ( angle ) return np . array ( [ [ ca , - sa ] , [ sa , ca ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "An argparse type representing an email address . [CODESPLIT] def email_type ( arg ) : if not is_valid_email_address ( arg ) : raise argparse . ArgumentTypeError ( \"{0} is not a valid email address\" . format ( repr ( arg ) ) ) return arg", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Round x and y down to integers . [CODESPLIT] def floor ( self ) : return Point ( int ( math . floor ( self . x ) ) , int ( math . floor ( self . y ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "main entry point for the jardiff CLI [CODESPLIT] def main ( args = sys . argv ) : parser = create_optparser ( args [ 0 ] ) return cli ( parser . parse_args ( args [ 1 : ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns x rounded to n significant figures . [CODESPLIT] def round_figures ( x , n ) : return round ( x , int ( n - math . ceil ( math . log10 ( abs ( x ) ) ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets args and kwargs that are passed when creating a subparsers group in an argparse . ArgumentParser i . e . when calling argparser . ArgumentParser . add_subparsers [CODESPLIT] def set_subparsers_args ( self , * args , * * kwargs ) : self . subparsers_args = args self . subparsers_kwargs = kwargs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns x rounded to n significant figures . [CODESPLIT] def round_figures ( x , n ) : return round ( x , int ( n - math . ceil ( math . log10 ( abs ( x ) ) ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create an array . Keyword arguments as per : func : zarr . creation . zeros . [CODESPLIT] def zeros ( self , name , * * kwargs ) : return self . _write_op ( self . _zeros_nosync , name , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wait until all task are executed . [CODESPLIT] async def wait_and_quit ( loop ) : from pylp . lib . tasks import running if running : await asyncio . wait ( map ( lambda runner : runner . future , running ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the given code line by line with printing as list of lines and return variable ans . [CODESPLIT] def runcode ( code ) : for line in code : print ( '# ' + line ) exec ( line , globals ( ) ) print ( '# return ans' ) return ans", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs all linters [CODESPLIT] def lint ( ctx : click . Context , amend : bool = False , stage : bool = False ) : _lint ( ctx , amend , stage )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a python string to c array . [CODESPLIT] def c_array ( ctype , values ) : if isinstance ( values , np . ndarray ) and values . dtype . itemsize == ctypes . sizeof ( ctype ) : return ( ctype * len ( values ) ) . from_buffer_copy ( values ) return ( ctype * len ( values ) ) ( * values )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs all linters [CODESPLIT] def lint ( ctx : click . Context , amend : bool = False , stage : bool = False ) : _lint ( ctx , amend , stage )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform triple index into a 1 - D numpy array . [CODESPLIT] def _transform_triple_numpy ( x ) : return np . array ( [ x . head , x . relation , x . tail ] , dtype = np . int64 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Save cookies to a file . [CODESPLIT] def _save_cookies ( requests_cookiejar , filename ) : with open ( filename , 'wb' ) as handle : pickle . dump ( requests_cookiejar , handle )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "\\ Asserts that two iterables contain the same values . [CODESPLIT] def expect_all ( a , b ) : assert all ( _a == _b for _a , _b in zip_longest ( a , b ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "position in 3d space [CODESPLIT] def list ( self ) : return [ self . _pos3d . x , self . _pos3d . y , self . _pos3d . z ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "if_statement : IF LPAREN expr RPAREN statement ELSE statement [CODESPLIT] def p_if_statement_2 ( self , p ) : p [ 0 ] = ast . If ( predicate = p [ 3 ] , consequent = p [ 5 ] , alternative = p [ 7 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add this instance as a row on a astropy . table . Table [CODESPLIT] def update_table_row ( self , table , row_idx ) : try : table [ row_idx ] [ 'timestamp' ] = self . timestamp table [ row_idx ] [ 'status' ] = self . status except IndexError : print ( \"Index error\" , len ( table ) , row_idx )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove missing values according to Baloo s convention . [CODESPLIT] def dropna ( self , subset = None ) : subset = check_and_obtain_subset_columns ( subset , self ) not_nas = [ v . notna ( ) for v in self [ subset ] . _iter ( ) ] and_filter = reduce ( lambda x , y : x & y , not_nas ) return self [ and_filter ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coroutine called by MapAsync . It s wrapping the call of run_in_executor to run the synchronous function as thread [CODESPLIT] async def _thread_coro ( self , * args ) : return await self . _loop . run_in_executor ( self . _executor , self . _function , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Memory efficient function for loading a table from a FITS file . [CODESPLIT] def create_table_from_fits ( fitsfile , hduname , colnames = None ) : if colnames is None : return Table . read ( fitsfile , hduname ) cols = [ ] with fits . open ( fitsfile , memmap = True ) as h : for k in colnames : data = h [ hduname ] . data . field ( k ) cols += [ Column ( name = k , data = data ) ] return Table ( cols )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Assert an element does not exist matching the given selector . [CODESPLIT] def check_no_element_by_selector ( self , selector ) : elems = find_elements_by_jquery ( world . browser , selector ) if elems : raise AssertionError ( \"Expected no matching elements, found {}.\" . format ( len ( elems ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coroutine called by MapAsync . It s wrapping the call of run_in_executor to run the synchronous function as thread [CODESPLIT] async def _thread_coro ( self , * args ) : return await self . _loop . run_in_executor ( self . _executor , self . _function , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "POST request [CODESPLIT] def POST ( self , * args , * * kwargs ) : return self . _handle_api ( self . API_POST , args , kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Manually shutdown the async API . [CODESPLIT] def shutdown ( ) : global handler , transport , protocol if handler is not None : handler . close ( ) transport . close ( ) handler = None transport = None protocol = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets an object attribute with the correct data type . [CODESPLIT] def setobjattr ( obj , key , value ) : try : setattr ( obj , key , int ( value ) ) except ValueError : try : setattr ( obj , key , float ( value ) ) except ValueError : # string if not number try : setattr ( obj , key , str ( value ) ) except UnicodeEncodeError : setattr ( obj , key , value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r A function to support exiting from exit hooks . [CODESPLIT] def exit ( exit_code = 0 ) : core . processExitHooks ( ) if state . isExitHooked and not hasattr ( sys , 'exitfunc' ) : # The function is called from the exit hook sys . stderr . flush ( ) sys . stdout . flush ( ) os . _exit ( exit_code ) #pylint: disable=W0212 sys . exit ( exit_code )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Construct a single page PDF from the provided page in memory [CODESPLIT] def _single_page_pdf ( page ) : pdf = Pdf . new ( ) pdf . pages . append ( page ) bio = BytesIO ( ) pdf . save ( bio ) bio . seek ( 0 ) return bio . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns an axis label for one or more dimensions . [CODESPLIT] def dim_axis_label ( dimensions , separator = ', ' ) : if not isinstance ( dimensions , list ) : dimensions = [ dimensions ] return separator . join ( [ d . pprint_label for d in dimensions ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the default stream encoding if not found . [CODESPLIT] def get_best_encoding ( stream ) : rv = getattr ( stream , 'encoding' , None ) or sys . getdefaultencoding ( ) if is_ascii_encoding ( rv ) : return 'utf-8' return rv", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the channels of a palettebar . [CODESPLIT] def palettebar ( height , length , colormap ) : cbar = np . tile ( np . arange ( length ) * 1.0 / ( length - 1 ) , ( height , 1 ) ) cbar = ( cbar * ( colormap . values . max ( ) + 1 - colormap . values . min ( ) ) + colormap . values . min ( ) ) return colormap . palettize ( cbar )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes the write permissions for the given file for owner groups and others . [CODESPLIT] def make_file_read_only ( file_path ) : old_permissions = os . stat ( file_path ) . st_mode os . chmod ( file_path , old_permissions & ~ WRITE_PERMISSIONS )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Main window move event [CODESPLIT] def OnMove ( self , event ) : # Store window position in config position = self . main_window . GetScreenPositionTuple ( ) config [ \"window_position\" ] = repr ( position )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace masked - out elements in an array using an iterative image inpainting algorithm . [CODESPLIT] def inpaint ( self ) : import inpaint filled = inpaint . replace_nans ( np . ma . filled ( self . raster_data , np . NAN ) . astype ( np . float32 ) , 3 , 0.01 , 2 ) self . raster_data = np . ma . masked_invalid ( filled )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the contents of a file . [CODESPLIT] def writefile ( openedfile , newcontents ) : openedfile . seek ( 0 ) openedfile . truncate ( ) openedfile . write ( newcontents )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "converts a base64 string to a file [CODESPLIT] def base64ToImage ( imgData , out_path , out_file ) : fh = open ( os . path . join ( out_path , out_file ) , \"wb\" ) fh . write ( imgData . decode ( 'base64' ) ) fh . close ( ) del fh return os . path . join ( out_path , out_file )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Enable a default web proxy [CODESPLIT] def enable_proxy ( self , host , port ) : self . proxy = [ host , _number ( port ) ] self . proxy_enabled = True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make sympy symbols q0 q1 ... Args : n ( int ) m ( int optional ) : If specified both n and m returns [ qn q ( n + 1 ) ... qm ] Only n is specified returns [ q0 q1 ... qn ] . [CODESPLIT] def make_qs ( n , m = None ) : try : import sympy except ImportError : raise ImportError ( \"This function requires sympy. Please install it.\" ) if m is None : syms = sympy . symbols ( \" \" . join ( f\"q{i}\" for i in range ( n ) ) ) if isinstance ( syms , tuple ) : return syms else : return ( syms , ) syms = sympy . symbols ( \" \" . join ( f\"q{i}\" for i in range ( n , m ) ) ) if isinstance ( syms , tuple ) : return syms else : return ( syms , )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Represent string / bytes s as base64 omitting newlines [CODESPLIT] def toBase64 ( s ) : if isinstance ( s , str ) : s = s . encode ( \"utf-8\" ) return binascii . b2a_base64 ( s ) [ : - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Scroll both categories Canvas and scrolling container [CODESPLIT] def _set_scroll_v ( self , * args ) : self . _canvas_categories . yview ( * args ) self . _canvas_scroll . yview ( * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates image to be displayed with new time frame . [CODESPLIT] def update ( self ) : if self . single_channel : self . im . set_data ( self . data [ self . ind , : , : ] ) else : self . im . set_data ( self . data [ self . ind , : , : , : ] ) self . ax . set_ylabel ( 'time frame %s' % self . ind ) self . im . axes . figure . canvas . draw ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the topmost parent of the current category . [CODESPLIT] def root_parent ( self , category = None ) : return next ( filter ( lambda c : c . is_root , self . hierarchy ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get comments only . [CODESPLIT] def comments ( tag , limit = 0 , flags = 0 , * * kwargs ) : return [ comment for comment in cm . CommentsMatch ( tag ) . get_comments ( limit ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an image with the binarised version of the data of img . [CODESPLIT] def abs_img ( img ) : bool_img = np . abs ( read_img ( img ) . get_data ( ) ) return bool_img . astype ( int )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Attempt to setattr but catch AttributeErrors . [CODESPLIT] def safe_setattr ( obj , name , value ) : try : setattr ( obj , name , value ) return True except AttributeError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Command line interface for PyBEL . [CODESPLIT] def main ( ctx , connection ) : ctx . obj = Manager ( connection = connection ) ctx . obj . bind ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prints the top row of a table [CODESPLIT] def top ( n , width = WIDTH , style = STYLE ) : return hrule ( n , width , linestyle = STYLES [ style ] . top )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse a bool from a string . [CODESPLIT] def FromString ( self , string ) : if string . lower ( ) in ( \"false\" , \"no\" , \"n\" ) : return False if string . lower ( ) in ( \"true\" , \"yes\" , \"y\" ) : return True raise TypeValueError ( \"%s is not recognized as a boolean value.\" % string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the smallest angle going from angle source to angle target . [CODESPLIT] def smallest_signed_angle ( source , target ) : dth = target - source dth = ( dth + np . pi ) % ( 2.0 * np . pi ) - np . pi return dth", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Close error dialog . [CODESPLIT] def close_error_dlg ( self ) : if self . error_dlg . dismiss_box . isChecked ( ) : self . dismiss_error = True self . error_dlg . reject ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if value can be part of binary / bitwise operations . [CODESPLIT] def isbinary ( * args ) : return all ( map ( lambda c : isnumber ( c ) or isbool ( c ) , args ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "List all Auto Scaling Groups . [CODESPLIT] def list_autoscaling_group ( region , filter_by_kwargs ) : conn = boto . ec2 . autoscale . connect_to_region ( region ) groups = conn . get_all_groups ( ) return lookup ( groups , filter_by = filter_by_kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generalised logarithm [CODESPLIT] def glog ( x , l = 2 ) : return np . log ( ( x + np . sqrt ( x ** 2 + l ** 2 ) ) / 2 ) / np . log ( l )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Batches a list into a list of lists with sub - lists sized by a specified batch size . [CODESPLIT] def batch ( items , size ) : return [ items [ x : x + size ] for x in xrange ( 0 , len ( items ) , size ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return total data length of the list and its headers . [CODESPLIT] def __len__ ( self ) : return self . chunk_length ( ) + len ( self . type ) + len ( self . header ) + 4", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse string into Identity dictionary . [CODESPLIT] def string_to_identity ( identity_str ) : m = _identity_regexp . match ( identity_str ) result = m . groupdict ( ) log . debug ( 'parsed identity: %s' , result ) return { k : v for k , v in result . items ( ) if v }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return total data length of the list and its headers . [CODESPLIT] def __len__ ( self ) : return self . chunk_length ( ) + len ( self . type ) + len ( self . header ) + 4", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert to byte string . [CODESPLIT] def _to_bstr ( l ) : if isinstance ( l , str ) : l = l . encode ( 'ascii' , 'backslashreplace' ) elif not isinstance ( l , bytes ) : l = str ( l ) . encode ( 'ascii' , 'backslashreplace' ) return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Batches data from an iterator that returns single items at a time . [CODESPLIT] def batch ( input_iter , batch_size = 32 ) : input_iter = iter ( input_iter ) next_ = list ( itertools . islice ( input_iter , batch_size ) ) while next_ : yield next_ next_ = list ( itertools . islice ( input_iter , batch_size ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get the number of quartets as n - choose - k . This is used in equal splits to decide whether a split should be exhaustively sampled or randomly sampled . Edges near tips can be exhaustive while highly nested edges probably have too many quartets [CODESPLIT] def n_choose_k ( n , k ) : return int ( reduce ( MUL , ( Fraction ( n - i , i + 1 ) for i in range ( k ) ) , 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a C array using the given string . [CODESPLIT] def bytes_to_c_array ( data ) : chars = [ \"'{}'\" . format ( encode_escape ( i ) ) for i in decode_escape ( data ) ] return ', ' . join ( chars ) + ', 0'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Matrix solve op . [CODESPLIT] def MatrixSolve ( a , rhs , adj ) : return np . linalg . solve ( a if not adj else _adjoint ( a ) , rhs ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Build a C ++ binary executable [CODESPLIT] def cpp_prog_builder ( build_context , target ) : yprint ( build_context . conf , 'Build CppProg' , target ) workspace_dir = build_context . get_workspace ( 'CppProg' , target . name ) build_cpp ( build_context , target , target . compiler_config , workspace_dir )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Matrix solve op . [CODESPLIT] def MatrixSolve ( a , rhs , adj ) : return np . linalg . solve ( a if not adj else _adjoint ( a ) , rhs ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adjust image balance and contrast [CODESPLIT] def lighting ( im , b , c ) : if b == 0 and c == 1 : return im mu = np . average ( im ) return np . clip ( ( im - mu ) * c + mu + b , 0. , 1. ) . astype ( np . float32 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the indices of the lexicographical sorting order of the supplied arrays . [CODESPLIT] def arglexsort ( arrays ) : dtypes = ',' . join ( array . dtype . str for array in arrays ) recarray = np . empty ( len ( arrays [ 0 ] ) , dtype = dtypes ) for i , array in enumerate ( arrays ) : recarray [ 'f%s' % i ] = array return recarray . argsort ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates the distance between two points on earth . [CODESPLIT] def _calculate_distance ( latlon1 , latlon2 ) : lat1 , lon1 = latlon1 lat2 , lon2 = latlon2 dlon = lon2 - lon1 dlat = lat2 - lat1 R = 6371 # radius of the earth in kilometers a = np . sin ( dlat / 2 ) ** 2 + np . cos ( lat1 ) * np . cos ( lat2 ) * ( np . sin ( dlon / 2 ) ) ** 2 c = 2 * np . pi * R * np . arctan2 ( np . sqrt ( a ) , np . sqrt ( 1 - a ) ) / 180 return c", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a list unique retaining order of initial appearance . [CODESPLIT] def unique_list ( lst ) : uniq = [ ] for item in lst : if item not in uniq : uniq . append ( item ) return uniq", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates the Jaccard similarity between two sets of nodes . Called by mroc . [CODESPLIT] def jaccard ( c_1 , c_2 ) : nom = np . intersect1d ( c_1 , c_2 ) . size denom = np . union1d ( c_1 , c_2 ) . size return nom / denom", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a list unique retaining order of initial appearance . [CODESPLIT] def unique_list ( lst ) : uniq = [ ] for item in lst : if item not in uniq : uniq . append ( item ) return uniq", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the offset between the given point and this point [CODESPLIT] def getOffset ( self , loc ) : return Location ( loc . x - self . x , loc . y - self . y )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sort data rows and order columns [CODESPLIT] def sort_data ( data , cols ) : return data . sort_values ( cols ) [ cols + [ 'value' ] ] . reset_index ( drop = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Order - preserving sorting function . [CODESPLIT] def csort ( objs , key ) : idxs = dict ( ( obj , i ) for ( i , obj ) in enumerate ( objs ) ) return sorted ( objs , key = lambda obj : ( key ( obj ) , idxs [ obj ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get byte offset of type s ty element at the given position [CODESPLIT] def get_element_offset ( self , ty , position ) : offset = ffi . lib . LLVMPY_OffsetOfElement ( self , ty , position ) if offset == - 1 : raise ValueError ( \"Could not determined offset of {}th \" \"element of the type '{}'. Is it a struct type?\" . format ( position , str ( ty ) ) ) return offset", "target": 1, "target_options": ["no_match", "match"]}
{"input": "logical_or ( t ) = self ( t ) or other ( t ) . [CODESPLIT] def logical_or ( self , other ) : return self . operation ( other , lambda x , y : int ( x or y ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if we want to skip this module . [CODESPLIT] def shall_skip ( app , module , private ) : logger . debug ( 'Testing if %s should be skipped.' , module ) # skip if it has a \"private\" name and this is selected if module != '__init__.py' and module . startswith ( '_' ) and not private : logger . debug ( 'Skip %s because its either private or __init__.' , module ) return True logger . debug ( 'Do not skip %s' , module ) return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns dicts with header - keys and psm statistic values [CODESPLIT] def generate_split_tsv_lines ( fn , header ) : for line in generate_tsv_psms_line ( fn ) : yield { x : y for ( x , y ) in zip ( header , line . strip ( ) . split ( '\\t' ) ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform underscore separated string to pascal case [CODESPLIT] def to_pascal_case ( s ) : return re . sub ( r'(?!^)_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , s . capitalize ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse string into Identity dictionary . [CODESPLIT] def string_to_identity ( identity_str ) : m = _identity_regexp . match ( identity_str ) result = m . groupdict ( ) log . debug ( 'parsed identity: %s' , result ) return { k : v for k , v in result . items ( ) if v }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert CamelCase to lower_and_underscore . [CODESPLIT] def decamelise ( text ) : s = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Unpacks sqlite rows as returned by fetchall into an array of simple dicts . [CODESPLIT] def sqliteRowsToDicts ( sqliteRows ) : return map ( lambda r : dict ( zip ( r . keys ( ) , r ) ) , sqliteRows )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The function compares strings ignoring case [CODESPLIT] def is_equal_strings_ignore_case ( first , second ) : if first and second : return first . upper ( ) == second . upper ( ) else : return not ( first or second )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If value is a datetime convert to timestamp [CODESPLIT] def dt_to_ts ( value ) : if not isinstance ( value , datetime ) : return value return calendar . timegm ( value . utctimetuple ( ) ) + value . microsecond / 1000000.0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "will plot a stack of traces one above the other assuming marray . shape = numRows numSamples [CODESPLIT] def stackplot ( marray , seconds = None , start_time = None , ylabels = None ) : tarray = np . transpose ( marray ) stackplot_t ( tarray , seconds = seconds , start_time = start_time , ylabels = ylabels ) plt . show ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert comma - delimited list / string into a list of strings [CODESPLIT] def comma_delimited_to_list ( list_param ) : if isinstance ( list_param , list ) : return list_param if isinstance ( list_param , str ) : return list_param . split ( ',' ) else : return [ ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sends plain text using _send_text () . [CODESPLIT] async def _send_plain_text ( self , request : Request , stack : Stack ) : await self . _send_text ( request , stack , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate standard deviation weighted by errors [CODESPLIT] def weighted_std ( values , weights ) : average = np . average ( values , weights = weights ) variance = np . average ( ( values - average ) ** 2 , weights = weights ) return np . sqrt ( variance )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Type casting . [CODESPLIT] def convert_value ( bind , value ) : type_name = get_type ( bind ) try : return typecast . cast ( type_name , value ) except typecast . ConverterError : return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the mean absolute error . [CODESPLIT] def _mean_absolute_error ( y , y_pred , w ) : return np . average ( np . abs ( y_pred - y ) , weights = w )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Round a number to a precision [CODESPLIT] def round_to_int ( number , precision ) : precision = int ( precision ) rounded = ( int ( number ) + precision / 2 ) // precision * precision return rounded", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the estimated standard error of the mean ( sx - bar ) of the values in the passed list . sem = stdev / sqrt ( n ) [CODESPLIT] def lsem ( inlist ) : sd = stdev ( inlist ) n = len ( inlist ) return sd / math . sqrt ( n )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a given range of numbers . [CODESPLIT] def range ( * args , interval = 0 ) : agen = from_iterable . raw ( builtins . range ( * args ) ) return time . spaceout . raw ( agen , interval ) if interval else agen", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Loads and returns foreign library . [CODESPLIT] def load ( self , name ) : name = ctypes . util . find_library ( name ) return ctypes . cdll . LoadLibrary ( name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the exectuable bit on the given filename [CODESPLIT] def set_executable ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update a staticmethod update . [CODESPLIT] def _update_staticmethod ( self , oldsm , newsm ) : # While we can't modify the staticmethod object itself (it has no # mutable attributes), we *can* extract the underlying function # (by calling __get__(), which returns it) and update it in-place. # We don't have the class available to pass to __get__() but any # object except None will do. self . _update ( None , None , oldsm . __get__ ( 0 ) , newsm . __get__ ( 0 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find task with the given record ID . [CODESPLIT] def find_task_by_id ( self , id , session = None ) : with self . _session ( session ) as session : return session . query ( TaskRecord ) . get ( id )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "list active ( running or completed ) experiments [CODESPLIT] def getExperiments ( uuid : str ) : return jsonify ( [ x . deserialize ( ) for x in Experiment . query . all ( ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "exit without breaking pipes . [CODESPLIT] def safe_exit ( output ) : try : sys . stdout . write ( output ) sys . stdout . flush ( ) except IOError : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert CamelCase to snake_case . [CODESPLIT] def convert_camel_case_to_snake_case ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Stop the thread . [CODESPLIT] def stop ( self , timeout = None ) : logger . debug ( \"docker plugin - Close thread for container {}\" . format ( self . _container . name ) ) self . _stopper . set ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Increment the date by a certain number and return date object . as the specific string format . [CODESPLIT] def inc_date ( date_obj , num , date_fmt ) : return ( date_obj + timedelta ( days = num ) ) . strftime ( date_fmt )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Not Used : Custom exception hook to replace sys . excepthook [CODESPLIT] def excepthook ( self , except_type , exception , traceback ) : if except_type is DeepReferenceError : print ( exception . msg ) else : self . default_excepthook ( except_type , exception , traceback )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a list of words given text removing punctuation . [CODESPLIT] def wordify ( text ) : stopset = set ( nltk . corpus . stopwords . words ( 'english' ) ) tokens = nltk . WordPunctTokenizer ( ) . tokenize ( text ) return [ w for w in tokens if w not in stopset ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like dict . update but does not overwrite items [CODESPLIT] def dict_update_newkeys ( dict_ , dict2 ) : for key , val in six . iteritems ( dict2 ) : if key not in dict_ : dict_ [ key ] = val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a variable of type string int float to a list containing the variable as the only element . [CODESPLIT] def toList ( variable , types = ( basestring , int , float , ) ) : if isinstance ( variable , types ) : return [ variable ] else : return variable", "target": 1, "target_options": ["no_match", "match"]}
{"input": "manipulate json data on the fly [CODESPLIT] def set_json_item ( key , value ) : data = get_json ( ) data [ key ] = value request = get_request ( ) request [ \"BODY\" ] = json . dumps ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Portable cast function . [CODESPLIT] def to_binary ( s , encoding = 'utf8' ) : if PY3 : # pragma: no cover return s if isinstance ( s , binary_type ) else binary_type ( s , encoding = encoding ) return binary_type ( s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Evaluate the XPath expression in the given context . [CODESPLIT] def xpathEvalExpression ( self , str ) : ret = libxml2mod . xmlXPathEvalExpression ( str , self . _o ) if ret is None : raise xpathError ( 'xmlXPathEvalExpression() failed' ) return xpathObjectRet ( ret )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a legal python name for the given name for use as a unit key . [CODESPLIT] def unit_key_from_name ( name ) : result = name for old , new in six . iteritems ( UNIT_KEY_REPLACEMENTS ) : result = result . replace ( old , new ) # Collapse redundant underscores and convert to uppercase. result = re . sub ( r'_+' , '_' , result . upper ( ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deserialize s ( a str ) to a Python object . [CODESPLIT] def loads ( s , model = None , parser = None ) : with StringIO ( s ) as f : return load ( f , model = model , parser = parser )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add dots . [CODESPLIT] def _dotify ( cls , data ) : return '' . join ( char if char in cls . PRINTABLE_DATA else '.' for char in data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function for conversion of various data types into numeric representation . [CODESPLIT] def _to_numeric ( val ) : if isinstance ( val , ( int , float , datetime . datetime , datetime . timedelta ) ) : return val return float ( val )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check if the query is a normal search or select query : param query : : return : [CODESPLIT] def is_stats_query ( query ) : if not query : return False # remove all \" enclosed strings\n nq = re . sub ( r'\"[^\"]*\"' , '' , query ) # check if there's | .... select\n if re . findall ( r'\\|.*\\bselect\\b' , nq , re . I | re . DOTALL ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "numpy . ndarray dumper . [CODESPLIT] def dump_nparray ( self , obj , class_name = numpy_ndarray_class_name ) : return { \"$\" + class_name : self . _json_convert ( obj . tolist ( ) ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get object from string reference . [CODESPLIT] def get_obj ( ref ) : oid = int ( ref ) return server . id2ref . get ( oid ) or server . id2obj [ oid ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds passed value to node s globals [CODESPLIT] def set_global ( node : Node , key : str , value : Any ) : node . node_globals [ key ] = value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if an element from a list is in a string . [CODESPLIT] def isin ( elems , line ) : found = False for e in elems : if e in line . lower ( ) : found = True break return found", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a multiline string into a list excluding blank lines . [CODESPLIT] def split_multiline ( value ) : return [ element for element in ( line . strip ( ) for line in value . split ( '\\n' ) ) if element ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cleans trailing whitespaces and replaces also multiple whitespaces with a single space . [CODESPLIT] def strip_spaces ( value , sep = None , join = True ) : value = value . strip ( ) value = [ v . strip ( ) for v in value . split ( sep ) ] join_sep = sep or ' ' return join_sep . join ( value ) if join else value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Recursively iterate through values in nested lists . [CODESPLIT] def empty_tree ( input_list ) : for item in input_list : if not isinstance ( item , list ) or not empty_tree ( item ) : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert camelcase names to underscore [CODESPLIT] def camelcase_underscore ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks whether the re module can compile the given regular expression . [CODESPLIT] def is_valid_regex ( string ) : try : re . compile ( string ) is_valid = True except re . error : is_valid = False return is_valid", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A non - optimal implementation of a regex filter [CODESPLIT] def subn_filter ( s , find , replace , count = 0 ) : return re . gsub ( find , replace , count , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raises a requests . exceptions . HTTPError if the response has a non - 200 status code . [CODESPLIT] def raise_for_not_ok_status ( response ) : if response . code != OK : raise HTTPError ( 'Non-200 response code (%s) for url: %s' % ( response . code , uridecode ( response . request . absoluteURI ) ) ) return response", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Total sum of squares . [CODESPLIT] def ss_tot ( self ) : return np . sum ( np . square ( self . y - self . ybar ) , axis = 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks whether a variable is a numpy integer array . [CODESPLIT] def is_integer_array ( val ) : return is_np_array ( val ) and issubclass ( val . dtype . type , np . integer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a 1D list to a single long string for file output using the string . join function . [CODESPLIT] def list2string ( inlist , delimit = ' ' ) : stringlist = [ makestr ( _ ) for _ in inlist ] return string . join ( stringlist , delimit )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wait until all task are executed . [CODESPLIT] async def wait_and_quit ( loop ) : from pylp . lib . tasks import running if running : await asyncio . wait ( map ( lambda runner : runner . future , running ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print results straight to stdout [CODESPLIT] def stdout_display ( ) : if sys . version_info [ 0 ] == 2 : yield SmartBuffer ( sys . stdout ) else : yield SmartBuffer ( sys . stdout . buffer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if we are on a Lyon machine [CODESPLIT] def we_are_in_lyon ( ) : import socket try : hostname = socket . gethostname ( ) ip = socket . gethostbyname ( hostname ) except socket . gaierror : return False return ip . startswith ( \"134.158.\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the screen coordinate for the top - left corner of a tile . [CODESPLIT] def get_tile_location ( self , x , y ) : x1 , y1 = self . origin x1 += self . BORDER + ( self . BORDER + self . cell_width ) * x y1 += self . BORDER + ( self . BORDER + self . cell_height ) * y return x1 , y1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Provide the root module of a TF - 2 . 0 API for use within TensorBoard . [CODESPLIT] def tf2 ( ) : # Import the `tf` compat API from this file and check if it's already TF 2.0. if tf . __version__ . startswith ( '2.' ) : return tf elif hasattr ( tf , 'compat' ) and hasattr ( tf . compat , 'v2' ) : # As a fallback, try `tensorflow.compat.v2` if it's defined. return tf . compat . v2 raise ImportError ( 'cannot import tensorflow 2.0 API' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "detect if a model has a given field has [CODESPLIT] def has_field ( mc , field_name ) : try : mc . _meta . get_field ( field_name ) except FieldDoesNotExist : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Path to tensorflow_datasets directory . [CODESPLIT] def tfds_dir ( ) : return os . path . dirname ( os . path . dirname ( os . path . dirname ( __file__ ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if the file is binary [CODESPLIT] def is_binary ( filename ) : with open ( filename , 'rb' ) as fp : data = fp . read ( 1024 ) if not data : return False if b'\\0' in data : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit the shell session . [CODESPLIT] def do_exit ( self , arg ) : if self . current : self . current . close ( ) self . resource_manager . close ( ) del self . resource_manager return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Assert that a value must be a given type . [CODESPLIT] def _assert_is_type ( name , value , value_type ) : if not isinstance ( value , value_type ) : if type ( value_type ) is tuple : types = ', ' . join ( t . __name__ for t in value_type ) raise ValueError ( '{0} must be one of ({1})' . format ( name , types ) ) else : raise ValueError ( '{0} must be {1}' . format ( name , value_type . __name__ ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if this enum has a particular name among its values . [CODESPLIT] def has_value_name ( self , name ) : for val , _ in self . _values : if val == name : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test whether the current python environment is the correct lore env . [CODESPLIT] def launched ( ) : if not PREFIX : return False return os . path . realpath ( sys . prefix ) == os . path . realpath ( PREFIX )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert datetime / str to date : param arg : : return : [CODESPLIT] def _datetime_to_date ( arg ) : _arg = parse ( arg ) if isinstance ( _arg , datetime . datetime ) : _arg = _arg . date ( ) return _arg", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": return : generator of tuples ( isLastFlag item ) [CODESPLIT] def iter_with_last ( iterable ) : # Ensure it's an iterator and get the first field iterable = iter ( iterable ) prev = next ( iterable ) for item in iterable : # Lag by one item so I know I'm not at the end yield False , prev prev = item # Last item yield True , prev", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Singleton definition . [CODESPLIT] def singleton ( class_ ) : instances = { } def get_instance ( * args , * * kwargs ) : if class_ not in instances : instances [ class_ ] = class_ ( * args , * * kwargs ) return instances [ class_ ] return get_instance", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Recursively iterate through values in nested lists . [CODESPLIT] def empty_tree ( input_list ) : for item in input_list : if not isinstance ( item , list ) or not empty_tree ( item ) : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pops the element that has the top ( smallest ) priority . [CODESPLIT] def get_top_priority ( self ) : if self . is_empty ( ) : raise IndexError ( \"Priority queue is empty.\" ) _ , _ , element = heapq . heappop ( self . pq ) if element in self . element_finder : del self . element_finder [ element ] return element", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if the given object is a list of IPAChar objects . [CODESPLIT] def is_list_of_ipachars ( obj ) : if isinstance ( obj , list ) : for e in obj : if not isinstance ( e , IPAChar ) : return False return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a copy of the list without duplicates . [CODESPLIT] def unique ( list ) : unique = [ ] [ unique . append ( x ) for x in list if x not in unique ] return unique", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a millisecond accuracy timestamp to a datetime [CODESPLIT] def ms_to_datetime ( ms ) : dt = datetime . datetime . utcfromtimestamp ( ms / 1000 ) return dt . replace ( microsecond = ( ms % 1000 ) * 1000 ) . replace ( tzinfo = pytz . utc )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if there s something to read on stdin ( posix version ) . [CODESPLIT] def _stdin_ready_posix ( ) : infds , outfds , erfds = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return bool ( infds )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return whether the handler is using sys . stdout . [CODESPLIT] def _using_stdout ( self ) : if WINDOWS and colorama : # Then self.stream is an AnsiToWin32 object. return self . stream . wrapped is sys . stdout return self . stream is sys . stdout", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a text into separate words . [CODESPLIT] def tokenize_list ( self , text ) : return [ self . get_record_token ( record ) for record in self . analyze ( text ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Report whether the given value is a byte or unicode string . [CODESPLIT] def isstring ( value ) : classes = ( str , bytes ) if pyutils . PY3 else basestring # noqa: F821 return isinstance ( value , classes )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a datetime to a millisecond accuracy timestamp [CODESPLIT] def datetime_to_ms ( dt ) : seconds = calendar . timegm ( dt . utctimetuple ( ) ) return seconds * 1000 + int ( dt . microsecond / 1000 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the string is only composed of hex characters . [CODESPLIT] def is_hex_string ( string ) : pattern = re . compile ( r'[A-Fa-f0-9]+' ) if isinstance ( string , six . binary_type ) : string = str ( string ) return pattern . match ( string ) is not None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Register callbacks for button press events and selection changed [CODESPLIT] def register_view ( self , view ) : super ( ListViewController , self ) . register_view ( view ) self . tree_view . connect ( 'button_press_event' , self . mouse_click )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes non - alpha characters and converts spaces to hyphens . Useful for making file names . Source : http : // stackoverflow . com / questions / 5574042 / string - slugification - in - python [CODESPLIT] def slugify ( string ) : string = re . sub ( '[^\\w .-]' , '' , string ) string = string . replace ( \" \" , \"-\" ) return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts the string representation of a json number into its python object equivalent an int long float or whatever type suits . [CODESPLIT] def default_number_converter ( number_str ) : is_int = ( number_str . startswith ( '-' ) and number_str [ 1 : ] . isdigit ( ) ) or number_str . isdigit ( ) # FIXME: this handles a wider range of numbers than allowed by the json standard, # etc.: float('nan') and float('inf'). But is this a problem? return int ( number_str ) if is_int else float ( number_str )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "On Python 3 opens a file in text mode by using fs encoding and a proper en / decoding errors handler . On Python 2 this is just an alias for open ( name rt ) . [CODESPLIT] def _open_text ( fname , * * kwargs ) : if PY3 : kwargs . setdefault ( 'encoding' , ENCODING ) kwargs . setdefault ( 'errors' , ENCODING_ERRS ) return open ( fname , \"rt\" , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the currently focused window [CODESPLIT] def get_active_window ( ) : active_win = None default = wnck . screen_get_default ( ) while gtk . events_pending ( ) : gtk . main_iteration ( False ) window_list = default . get_windows ( ) if len ( window_list ) == 0 : print \"No Windows Found\" for win in window_list : if win . is_active ( ) : active_win = win . get_name ( ) return active_win", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check whether the item is list ( tuple ) and consist of list ( tuple ) elements [CODESPLIT] def is_list_of_list ( item ) : if ( type ( item ) in ( list , tuple ) and len ( item ) and isinstance ( item [ 0 ] , ( list , tuple ) ) ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a structured NumPy array into a Table . [CODESPLIT] def from_array ( cls , arr ) : return cls ( ) . with_columns ( [ ( f , arr [ f ] ) for f in arr . dtype . names ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is this an integer . [CODESPLIT] def is_integer ( obj ) : if PYTHON3 : return isinstance ( obj , int ) return isinstance ( obj , ( int , long ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a comma separated string to a list [CODESPLIT] def _str_to_list ( s ) : _list = s . split ( \",\" ) return list ( map ( lambda i : i . lstrip ( ) , _list ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "converts a csv string into a list [CODESPLIT] def csvtolist ( inputstr ) : reader = csv . reader ( [ inputstr ] , skipinitialspace = True ) output = [ ] for r in reader : output += r return output", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all child objects in nested lists of strings . [CODESPLIT] def as_list ( self ) : return [ self . name , self . value , [ x . as_list for x in self . children ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a file into a string PRE : fname is a small file ( to avoid hogging memory and its discontents ) [CODESPLIT] def file_to_str ( fname ) : data = None # rU = read with Universal line terminator with open ( fname , 'rU' ) as fd : data = fd . read ( ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Match two names . [CODESPLIT] def _match_literal ( self , a , b = None ) : return a . lower ( ) == b if not self . case_sensitive else a == b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert string to int or float . [CODESPLIT] def covstr ( s ) : try : ret = int ( s ) except ValueError : ret = float ( s ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if an array is a square matrix . [CODESPLIT] def is_square_matrix ( mat ) : mat = np . array ( mat ) if mat . ndim != 2 : return False shape = mat . shape return shape [ 0 ] == shape [ 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Attempts to convert given object to a string object [CODESPLIT] def to_str ( obj ) : if not isinstance ( obj , str ) and PY3 and isinstance ( obj , bytes ) : obj = obj . decode ( 'utf-8' ) return obj if isinstance ( obj , string_types ) else str ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Do all elements of x have a type from types? [CODESPLIT] def _valid_other_type ( x , types ) : return all ( any ( isinstance ( el , t ) for t in types ) for el in np . ravel ( x ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a str if a bytes object is given . [CODESPLIT] def bytes_to_str ( s , encoding = 'utf-8' ) : if six . PY3 and isinstance ( s , bytes ) : return s . decode ( encoding ) return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Callback for is_valid_url . [CODESPLIT] def _is_valid_url ( self , url ) : try : r = requests . head ( url , proxies = self . proxy_servers ) value = r . status_code in [ 200 ] except Exception as error : logger . error ( str ( error ) ) value = False return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simplest required implementation of collections . Counter . Required as 2 . 6 does not have Counter in collections . [CODESPLIT] def counter ( items ) : results = { } for item in items : results [ item ] = results . get ( item , 0 ) + 1 return results", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if dtype is a numeric type . [CODESPLIT] def is_numeric_dtype ( dtype ) : dtype = np . dtype ( dtype ) return np . issubsctype ( getattr ( dtype , 'base' , None ) , np . number )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "reads the zip file determines compression and unzips recursively until source files are extracted [CODESPLIT] def extract_all ( zipfile , dest_folder ) : z = ZipFile ( zipfile ) print ( z ) z . extract ( dest_folder )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes in an object and a variable length amount of named attributes and checks to see if the object has each property . If any of the attributes are missing this returns false . [CODESPLIT] def hasattrs ( object , * names ) : for name in names : if not hasattr ( object , name ) : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make sure that the file is writeable . Useful if our source is read - only . [CODESPLIT] def make_writeable ( filename ) : if not os . access ( filename , os . W_OK ) : st = os . stat ( filename ) new_permissions = stat . S_IMODE ( st . st_mode ) | stat . S_IWUSR os . chmod ( filename , new_permissions )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates one element of the collection [CODESPLIT] def update_one ( self , query , doc ) : if self . table is None : self . build_table ( ) if u\"$set\" in doc : doc = doc [ u\"$set\" ] allcond = self . parse_query ( query ) try : result = self . table . update ( doc , allcond ) except : # TODO: check table.update result # check what pymongo does in that case result = None return UpdateResult ( raw_result = result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper parse action to convert tokens to upper case . [CODESPLIT] def upcaseTokens ( s , l , t ) : return [ tt . upper ( ) for tt in map ( _ustr , t ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get rid of all axis ticks lines etc . [CODESPLIT] def axes_off ( ax ) : ax . set_frame_on ( False ) ax . axes . get_yaxis ( ) . set_visible ( False ) ax . axes . get_xaxis ( ) . set_visible ( False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Qt slot when the window is closed . [CODESPLIT] def closeEvent ( self , e ) : self . emit ( 'close_widget' ) super ( DockWidget , self ) . closeEvent ( e )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add an object to Javascript . [CODESPLIT] def add_to_js ( self , name , var ) : frame = self . page ( ) . mainFrame ( ) frame . addToJavaScriptWindowObject ( name , var )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove a directory and it contents . Ignore any failures . [CODESPLIT] def _clear_dir ( dirName ) : # If we got here, clear dir   for fname in os . listdir ( dirName ) : try : os . remove ( os . path . join ( dirName , fname ) ) except Exception : pass try : os . rmdir ( dirName ) except Exception : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Detach from all tracked classes and objects . Restore the original constructors and cleanse the tracking lists . [CODESPLIT] def detach_all ( self ) : self . detach_all_classes ( ) self . objects . clear ( ) self . index . clear ( ) self . _keepalive [ : ] = [ ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform triple index into a 1 - D numpy array . [CODESPLIT] def _transform_triple_numpy ( x ) : return np . array ( [ x . head , x . relation , x . tail ] , dtype = np . int64 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clone a bitset [CODESPLIT] def bit_clone ( bits ) : new = BitSet ( bits . size ) new . ior ( bits ) return new", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ensure attributes are copied to subsequent queries . [CODESPLIT] def _clone ( self , * args , * * kwargs ) : for attr in ( \"_search_terms\" , \"_search_fields\" , \"_search_ordered\" ) : kwargs [ attr ] = getattr ( self , attr ) return super ( SearchableQuerySet , self ) . _clone ( * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a shell - escaped version of the string s . [CODESPLIT] def quote ( self , s ) : if six . PY2 : from pipes import quote else : from shlex import quote return quote ( s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Kill the browser . [CODESPLIT] def kill ( self ) : if self . process : self . process . kill ( ) self . process . wait ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Close log [CODESPLIT] def close_log ( log , verbose = True ) : if verbose : print ( 'Closing log file:' , log . name ) # Send closing message. log . info ( 'The log file has been closed.' ) # Remove all handlers from log. [ log . removeHandler ( handler ) for handler in log . handlers ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Close all connections . [CODESPLIT] def cleanup ( self , app ) : if hasattr ( self . database . obj , 'close_all' ) : self . database . close_all ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function returns a pretty table used to display the port results . [CODESPLIT] def get_table ( ports ) : table = PrettyTable ( [ \"Name\" , \"Port\" , \"Protocol\" , \"Description\" ] ) table . align [ \"Name\" ] = \"l\" table . align [ \"Description\" ] = \"l\" table . padding_width = 1 for port in ports : table . add_row ( port ) return table", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Square of the euclidean distance [CODESPLIT] def euclidean ( c1 , c2 ) : diffs = ( ( i - j ) for i , j in zip ( c1 , c2 ) ) return sum ( x * x for x in diffs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Callback for is_valid_url . [CODESPLIT] def _is_valid_url ( self , url ) : try : r = requests . head ( url , proxies = self . proxy_servers ) value = r . status_code in [ 200 ] except Exception as error : logger . error ( str ( error ) ) value = False return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Executes a method forever until the method returns a false value . [CODESPLIT] def execute_until_false ( method , interval_s ) : # pylint: disable=invalid-name interval = Interval ( method , stop_if_false = True ) interval . start ( interval_s ) return interval", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper for inserting int64 features into Example proto . [CODESPLIT] def _int64_feature ( value ) : if not isinstance ( value , list ) : value = [ value ] return tf . train . Feature ( int64_list = tf . train . Int64List ( value = value ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve requested URL [CODESPLIT] def _get_url ( url ) : try : data = HTTP_SESSION . get ( url , stream = True ) data . raise_for_status ( ) except requests . exceptions . RequestException as exc : raise FetcherException ( exc ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the data type for * value * . [CODESPLIT] def _get_type ( self , value ) : if value is None : return type ( None ) elif type ( value ) in int_types : return int elif type ( value ) in float_types : return float elif isinstance ( value , binary_type ) : return binary_type else : return text_type", "target": 1, "target_options": ["no_match", "match"]}
{"input": "iterator version of get_list_column [CODESPLIT] def iget_list_column_slice ( list_ , start = None , stop = None , stride = None ) : if isinstance ( start , slice ) : slice_ = start else : slice_ = slice ( start , stop , stride ) return ( row [ slice_ ] for row in list_ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get all the prime factor of given integer [CODESPLIT] def getPrimeFactors ( n ) : lo = [ 1 ] n2 = n // 2 k = 2 for k in range ( 2 , n2 + 1 ) : if ( n // k ) * k == n : lo . append ( k ) return lo + [ n , ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterates over the file in blocks . [CODESPLIT] def read_next_block ( infile , block_size = io . DEFAULT_BUFFER_SIZE ) : chunk = infile . read ( block_size ) while chunk : yield chunk chunk = infile . read ( block_size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if arg is a valid file that already exists on the file system . [CODESPLIT] def is_valid_file ( parser , arg ) : arg = os . path . abspath ( arg ) if not os . path . exists ( arg ) : parser . error ( \"The file %s does not exist!\" % arg ) else : return arg", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a table row to a dictionary . [CODESPLIT] def row_to_dict ( row ) : o = { } for colname in row . colnames : if isinstance ( row [ colname ] , np . string_ ) and row [ colname ] . dtype . kind in [ 'S' , 'U' ] : o [ colname ] = str ( row [ colname ] ) else : o [ colname ] = row [ colname ] return o", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if a given string is an url [CODESPLIT] def is_valid_url ( url ) : pieces = urlparse ( url ) return all ( [ pieces . scheme , pieces . netloc ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Do all elements of x have a type from types? [CODESPLIT] def _valid_other_type ( x , types ) : return all ( any ( isinstance ( el , t ) for t in types ) for el in np . ravel ( x ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Makes the given dictionary symmetric . Values are assumed to be unique . [CODESPLIT] def make_symmetric ( dict ) : for key , value in list ( dict . items ( ) ) : dict [ value ] = key return dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Called when a new DropDownItem gets selected . [CODESPLIT] def onchange ( self , value ) : log . debug ( 'combo box. selected %s' % value ) self . select_by_value ( value ) return ( value , )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate how much variance in returns do the values explain [CODESPLIT] def explained_variance ( returns , values ) : exp_var = 1 - torch . var ( returns - values ) / torch . var ( returns ) return exp_var . item ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Callback for comboboxes : notifies us that a combobox for the given item and column has changed [CODESPLIT] def _updateItemComboBoxIndex ( self , item , column , num ) : item . _combobox_current_index [ column ] = num item . _combobox_current_value [ column ] = item . _combobox_option_list [ column ] [ num ] [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply a function in parallel to each element of the input [CODESPLIT] def apply ( f , obj , * args , * * kwargs ) : return vectorize ( f ) ( obj , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of characters in two strings that don t exactly match [CODESPLIT] def count_string_diff ( a , b ) : shortest = min ( len ( a ) , len ( b ) ) return sum ( a [ i ] != b [ i ] for i in range ( shortest ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the final coverage report . This outputs the coverage report aggregating coverage from the unit test runs ( not system test runs ) and then erases coverage data . [CODESPLIT] def cover ( session ) : session . interpreter = 'python3.6' session . install ( 'coverage' , 'pytest-cov' ) session . run ( 'coverage' , 'report' , '--show-missing' , '--fail-under=100' ) session . run ( 'coverage' , 'erase' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of characters in two strings that don t exactly match [CODESPLIT] def count_string_diff ( a , b ) : shortest = min ( len ( a ) , len ( b ) ) return sum ( a [ i ] != b [ i ] for i in range ( shortest ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "based on our axes compute the expected nrows [CODESPLIT] def nrows_expected ( self ) : return np . prod ( [ i . cvalues . shape [ 0 ] for i in self . index_axes ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The Euclidean distance between two vectors . [CODESPLIT] def vector_distance ( a , b ) : a = np . array ( a ) b = np . array ( b ) return np . linalg . norm ( a - b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set foreground - and background colors and intensity . [CODESPLIT] def set_color ( self , fg = None , bg = None , intensify = False , target = sys . stdout ) : raise NotImplementedError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Configuration - friendly boolean type converter . [CODESPLIT] def boolean ( value ) : if isinstance ( value , bool ) : return value if value == \"\" : return False return strtobool ( value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the next non - blank line in an ASCII file . [CODESPLIT] def rAsciiLine ( ifile ) : _line = ifile . readline ( ) . strip ( ) while len ( _line ) == 0 : _line = ifile . readline ( ) . strip ( ) return _line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compose all given tuples together . [CODESPLIT] def compose_all ( tups ) : from . import ast # I weep for humanity return functools . reduce ( lambda x , y : x . compose ( y ) , map ( ast . make_tuple , tups ) , ast . make_tuple ( { } ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the maximum value of the domain . [CODESPLIT] def max ( self ) : return int ( self . _max ) if not np . isinf ( self . _max ) else self . _max", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns data as : class : numpy . recarray . [CODESPLIT] def recarray ( self ) : return numpy . rec . fromrecords ( self . records , names = self . names )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Dictionary of noun phrase frequencies in this text . [CODESPLIT] def np_counts ( self ) : counts = defaultdict ( int ) for phrase in self . noun_phrases : counts [ phrase ] += 1 return counts", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Idempotent and None - safe version of strict_bool . [CODESPLIT] def less_strict_bool ( x ) : if x is None : return False elif x is True or x is False : return x else : return strict_bool ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write the configuration dictionary to an output file . [CODESPLIT] def write_config ( self , outfile ) : utils . write_yaml ( self . config , outfile , default_flow_style = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return Student - t statistic for given DOF and confidence interval . [CODESPLIT] def student_t ( degrees_of_freedom , confidence = 0.95 ) : return scipy . stats . t . interval ( alpha = confidence , df = degrees_of_freedom ) [ - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": return : list (( option value ) ... ) pairs of all items in the given section [CODESPLIT] def items ( self , section_name ) : return [ ( k , v ) for k , v in super ( GitConfigParser , self ) . items ( section_name ) if k != '__name__' ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates or returns a singleton : class : . Connection object [CODESPLIT] def connect ( * args , * * kwargs ) : global __CONNECTION if __CONNECTION is None : __CONNECTION = Connection ( * args , * * kwargs ) return __CONNECTION", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Install Postgres on remote [CODESPLIT] def install_postgres ( user = None , dbname = None , password = None ) : execute ( pydiploy . django . install_postgres_server , user = user , dbname = dbname , password = password )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create list of line segments from x and y coordinates in the correct format for LineCollection : an array of the form numlines x ( points per line ) x 2 ( x and y ) array [CODESPLIT] def make_segments ( x , y ) : points = np . array ( [ x , y ] ) . T . reshape ( - 1 , 1 , 2 ) segments = np . concatenate ( [ points [ : - 1 ] , points [ 1 : ] ] , axis = 1 ) return segments", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets main window icon to given wx . Bitmap [CODESPLIT] def set_icon ( self , bmp ) : _icon = wx . EmptyIcon ( ) _icon . CopyFromBitmap ( bmp ) self . SetIcon ( _icon )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "dictionary of conversion [CODESPLIT] def conv_dict ( self ) : return dict ( integer = self . integer , real = self . real , no_type = self . no_type )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates text font color button [CODESPLIT] def _update_fontcolor ( self , fontcolor ) : textcolor = wx . SystemSettings_GetColour ( wx . SYS_COLOUR_WINDOWTEXT ) textcolor . SetRGB ( fontcolor ) self . textcolor_choice . SetColour ( textcolor )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Interpolated flux at a given wavelength ( calls np . interp ) . [CODESPLIT] def get_line_flux ( line_wave , wave , flux , * * kwargs ) : return np . interp ( line_wave , wave , flux , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sizer hell returns a sizer that contains all widgets [CODESPLIT] def _do_layout ( self ) : sizer_csvoptions = wx . FlexGridSizer ( 5 , 4 , 5 , 5 ) # Adding parameter widgets to sizer_csvoptions leftpos = wx . LEFT | wx . ADJUST_MINSIZE rightpos = wx . RIGHT | wx . EXPAND current_label_margin = 0 # smaller for left column other_label_margin = 15 for label , widget in zip ( self . param_labels , self . param_widgets ) : sizer_csvoptions . Add ( label , 0 , leftpos , current_label_margin ) sizer_csvoptions . Add ( widget , 0 , rightpos , current_label_margin ) current_label_margin , other_label_margin = other_label_margin , current_label_margin sizer_csvoptions . AddGrowableCol ( 1 ) sizer_csvoptions . AddGrowableCol ( 3 ) self . sizer_csvoptions = sizer_csvoptions", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert camelcase names to underscore [CODESPLIT] def camelcase_underscore ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert an int of form yyyymmdd to a python date object . [CODESPLIT] def int_to_date ( date ) : year = date // 10 ** 4 month = date % 10 ** 4 // 10 ** 2 day = date % 10 ** 2 return datetime . date ( year , month , day )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set x - axis limits of a subplot . [CODESPLIT] def set_xlimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_xlimits ( min , max )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pull comma separated string values out of a text file and converts them to float list [CODESPLIT] def string_to_float_list ( string_var ) : try : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ', ' ) ] except : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ',' ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sophisticated simulation of multiplication [CODESPLIT] def multiply ( traj ) : z = traj . x * traj . y traj . f_add_result ( 'z' , z = z , comment = 'I am the product of two reals!' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "parse a schema definition resource and build an internal XML Shema struture which can be used to validate instances . [CODESPLIT] def schemaParse ( self ) : ret = libxml2mod . xmlSchemaParse ( self . _o ) if ret is None : raise parserError ( 'xmlSchemaParse() failed' ) __tmp = Schema ( _obj = ret ) return __tmp", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses a YAML source into a Python object . [CODESPLIT] def Parse ( text ) : precondition . AssertType ( text , Text ) if compatibility . PY2 : text = text . encode ( \"utf-8\" ) return yaml . safe_load ( text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convolve 2d gaussian . [CODESPLIT] def convolve_gaussian_2d ( image , gaussian_kernel_1d ) : result = scipy . ndimage . filters . correlate1d ( image , gaussian_kernel_1d , axis = 0 ) result = scipy . ndimage . filters . correlate1d ( result , gaussian_kernel_1d , axis = 1 ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pad each cell to the size of the largest cell in its column . [CODESPLIT] def pad_cells ( table ) : col_sizes = [ max ( map ( len , col ) ) for col in zip ( * table ) ] for row in table : for cell_num , cell in enumerate ( row ) : row [ cell_num ] = pad_to ( cell , col_sizes [ cell_num ] ) return table", "target": 1, "target_options": ["no_match", "match"]}
{"input": "converts py2 unicode / py3 bytestring into str Args : string ( unicode byte_string ) : string to be converted Returns : ( str ) [CODESPLIT] def ub_to_str ( string ) : if not isinstance ( string , str ) : if six . PY2 : return str ( string ) else : return string . decode ( ) return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a string of data after gzip decoding [CODESPLIT] def ungzip_data ( input_data ) : buf = StringIO ( input_data ) f = gzip . GzipFile ( fileobj = buf ) return f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Join list of columns into a string for a SQL query [CODESPLIT] def join_cols ( cols ) : return \", \" . join ( [ i for i in cols ] ) if isinstance ( cols , ( list , tuple , set ) ) else cols", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a date into a datetime [CODESPLIT] def date_to_datetime ( x ) : if not isinstance ( x , datetime ) and isinstance ( x , date ) : return datetime . combine ( x , time ( ) ) return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cast uint32 RGB image to 4 uint8 channels . [CODESPLIT] def uint32_to_uint8 ( cls , img ) : return np . flipud ( img . view ( dtype = np . uint8 ) . reshape ( img . shape + ( 4 , ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return enum constant s converted to a canonical snake - case . [CODESPLIT] def normalize_enum_constant ( s ) : if s . islower ( ) : return s if s . isupper ( ) : return s . lower ( ) return \"\" . join ( ch if ch . islower ( ) else \"_\" + ch . lower ( ) for ch in s ) . strip ( \"_\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The underlying array of shape ( N L I ) [CODESPLIT] def array ( self ) : return numpy . array ( [ self [ sid ] . array for sid in sorted ( self ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "1x1 convolution [CODESPLIT] def conv1x1 ( in_planes , out_planes , stride = 1 ) : return nn . Conv2d ( in_planes , out_planes , kernel_size = 1 , stride = stride , bias = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Interpolated flux at a given wavelength ( calls np . interp ) . [CODESPLIT] def get_line_flux ( line_wave , wave , flux , * * kwargs ) : return np . interp ( line_wave , wave , flux , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the intersection point of two lines [CODESPLIT] def line_line_intersect ( x , y ) : A = x [ 0 ] * y [ 1 ] - y [ 0 ] * x [ 1 ] B = x [ 2 ] * y [ 3 ] - y [ 2 ] * x [ 4 ] C = ( x [ 0 ] - x [ 1 ] ) * ( y [ 2 ] - y [ 3 ] ) - ( y [ 0 ] - y [ 1 ] ) * ( x [ 2 ] - x [ 3 ] ) Ix = ( A * ( x [ 2 ] - x [ 3 ] ) - ( x [ 0 ] - x [ 1 ] ) * B ) / C Iy = ( A * ( y [ 2 ] - y [ 3 ] ) - ( y [ 0 ] - y [ 1 ] ) * B ) / C return Ix , Iy", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Builds a comment . [CODESPLIT] def to_comment ( value ) : if value is None : return if len ( value . split ( '\\n' ) ) == 1 : return \"* \" + value else : return '\\n' . join ( [ ' * ' + l for l in value . split ( '\\n' ) [ : - 1 ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deseralize a PercentRankTransform the given pandas . Series as returned by to_series () . [CODESPLIT] def from_series ( series ) : result = PercentRankTransform ( ) result . cdf = series . values result . bin_edges = series . index . values [ 1 : - 1 ] return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns current grid cursor cell ( row col tab ) [CODESPLIT] def get_cursor ( self ) : return self . grid . GetGridCursorRow ( ) , self . grid . GetGridCursorCol ( ) , self . grid . current_table", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Traverse parent refs to top . [CODESPLIT] def find_root ( self ) : cmd = self while cmd . parent : cmd = cmd . parent return cmd", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pull a form value from the request . [CODESPLIT] def parse_form ( self , req , name , field ) : return get_value ( req . body_arguments , name , field )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Increment ( or add ) numeric suffix to identifier . [CODESPLIT] def _increment_numeric_suffix ( s ) : if re . match ( r\".*\\d+$\" , s ) : return re . sub ( r\"\\d+$\" , lambda n : str ( int ( n . group ( 0 ) ) + 1 ) , s ) return s + \"_2\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Counts the word frequences in a list of sentences . [CODESPLIT] def count ( lines ) : words = [ w for l in lines for w in l . strip ( ) . split ( ) ] return Counter ( words )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update conda packages in a conda env [CODESPLIT] def update ( packages , env = None , user = None ) : packages = ' ' . join ( packages . split ( ',' ) ) cmd = _create_conda_cmd ( 'update' , args = [ packages , '--yes' , '-q' ] , env = env , user = user ) return _execcmd ( cmd , user = user )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create namedtuple object with GOEA fields . [CODESPLIT] def get_ntobj ( self ) : if self . nts : return cx . namedtuple ( \"ntgoea\" , \" \" . join ( vars ( next ( iter ( self . nts ) ) ) . keys ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility to generate enum classes used by annotations . [CODESPLIT] def _Enum ( docstring , * names ) : enums = dict ( zip ( names , range ( len ( names ) ) ) ) reverse = dict ( ( value , key ) for key , value in enums . iteritems ( ) ) enums [ 'reverse_mapping' ] = reverse enums [ '__doc__' ] = docstring return type ( 'Enum' , ( object , ) , enums )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shot noise corruption to images . [CODESPLIT] def shot_noise ( x , severity = 1 ) : c = [ 60 , 25 , 12 , 5 , 3 ] [ severity - 1 ] x = np . array ( x ) / 255. x_clip = np . clip ( np . random . poisson ( x * c ) / float ( c ) , 0 , 1 ) * 255 return around_and_astype ( x_clip )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads an array from bytestring with big - endian data . [CODESPLIT] def be_array_from_bytes ( fmt , data ) : arr = array . array ( str ( fmt ) , data ) return fix_byteorder ( arr )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert an image by adding text [CODESPLIT] def add_text_to_image ( fname , txt , opFilename ) : ft = ImageFont . load ( \"T://user//dev//src//python//_AS_LIB//timR24.pil\" ) #wh = ft.getsize(txt) print ( \"Adding text \" , txt , \" to \" , fname , \" pixels wide to file \" , opFilename ) im = Image . open ( fname ) draw = ImageDraw . Draw ( im ) draw . text ( ( 0 , 0 ) , txt , fill = ( 0 , 0 , 0 ) , font = ft ) del draw im . save ( opFilename )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert a code sequence to HTML [CODESPLIT] def make_html_code ( self , lines ) : line = code_header + '\\n' for l in lines : line = line + html_quote ( l ) + '\\n' return line + code_footer", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a legal python name for the given name for use as a unit key . [CODESPLIT] def unit_key_from_name ( name ) : result = name for old , new in six . iteritems ( UNIT_KEY_REPLACEMENTS ) : result = result . replace ( old , new ) # Collapse redundant underscores and convert to uppercase. result = re . sub ( r'_+' , '_' , result . upper ( ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize time in arbitrary timezone to UTC naive object . [CODESPLIT] def normalize_time ( timestamp ) : offset = timestamp . utcoffset ( ) if offset is None : return timestamp return timestamp . replace ( tzinfo = None ) - offset", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generates an mxn sparse d matrix with round ( a * m * n ) nonzeros . [CODESPLIT] def sp_rand ( m , n , a ) : if m == 0 or n == 0 : return spmatrix ( [ ] , [ ] , [ ] , ( m , n ) ) nnz = min ( max ( 0 , int ( round ( a * m * n ) ) ) , m * n ) nz = matrix ( random . sample ( range ( m * n ) , nnz ) , tc = 'i' ) return spmatrix ( normal ( nnz , 1 ) , nz % m , matrix ( [ int ( ii ) for ii in nz / m ] ) , ( m , n ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rewrite a file adding a line to its beginning . [CODESPLIT] def prepend_line ( filepath , line ) : with open ( filepath ) as f : lines = f . readlines ( ) lines . insert ( 0 , line ) with open ( filepath , 'w' ) as f : f . writelines ( lines )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def save_image ( pdf_path , img_path , page_num ) : pdf_img = Image ( filename = \"{}[{}]\" . format ( pdf_path , page_num ) ) with pdf_img . convert ( \"png\" ) as converted : # Set white background. converted . background_color = Color ( \"white\" ) converted . alpha_channel = \"remove\" converted . save ( filename = img_path )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty print a CSV file . [CODESPLIT] def csvpretty ( csvfile : csvfile = sys . stdin ) : shellish . tabulate ( csv . reader ( csvfile ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert from full to linspace [CODESPLIT] def to_linspace ( self ) : if hasattr ( self . shape , '__len__' ) : raise NotImplementedError ( \"can only convert flat Full arrays to linspace\" ) return Linspace ( self . fill_value , self . fill_value , self . shape )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If rex expression is not found then raise DataNotFound exception . [CODESPLIT] def rex_assert ( self , rex , byte = False ) : self . rex_search ( rex , byte = byte )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A wrapper for the user - defined handle . [CODESPLIT] def _monitor_callback_wrapper ( callback ) : def callback_handle ( name , array , _ ) : \"\"\" ctypes function \"\"\" callback ( name , array ) return callback_handle", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Open an asyncio file . [CODESPLIT] def _open ( file , mode = 'r' , buffering = - 1 , encoding = None , errors = None , newline = None , closefd = True , opener = None , * , loop = None , executor = None ) : if loop is None : loop = asyncio . get_event_loop ( ) cb = partial ( sync_open , file , mode = mode , buffering = buffering , encoding = encoding , errors = errors , newline = newline , closefd = closefd , opener = opener ) f = yield from loop . run_in_executor ( executor , cb ) return wrap ( f , loop = loop , executor = executor )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Copy [CODESPLIT] def getBuffer ( x ) : b = bytes ( x ) return ( c_ubyte * len ( b ) ) . from_buffer_copy ( bytes ( x ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create ctypes pointer to object . [CODESPLIT] def POINTER ( obj ) : p = ctypes . POINTER ( obj ) if not isinstance ( p . from_param , classmethod ) : def from_param ( cls , x ) : if x is None : return cls ( ) else : return x p . from_param = classmethod ( from_param ) return p", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create ctypes pointer to object . [CODESPLIT] def POINTER ( obj ) : p = ctypes . POINTER ( obj ) if not isinstance ( p . from_param , classmethod ) : def from_param ( cls , x ) : if x is None : return cls ( ) else : return x p . from_param = classmethod ( from_param ) return p", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Centre and normalize a given array . [CODESPLIT] def min_max_normalize ( img ) : min_img = img . min ( ) max_img = img . max ( ) return ( img - min_img ) / ( max_img - min_img )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a ctypes int pointer array to a numpy array . [CODESPLIT] def cint32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int32 ) ) : return np . fromiter ( cptr , dtype = np . int32 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Use the S3 SWAG backend . [CODESPLIT] def s3 ( ctx , bucket_name , data_file , region ) : if not ctx . data_file : ctx . data_file = data_file if not ctx . bucket_name : ctx . bucket_name = bucket_name if not ctx . region : ctx . region = region ctx . type = 's3'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Lists files / objects on a bucket . TODO : docstring [CODESPLIT] def get_files ( client , bucket , prefix = '' ) : bucket = client . get_bucket ( bucket ) files = list ( bucket . list_blobs ( prefix = prefix ) ) return files", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a blob exists [CODESPLIT] def exists ( self , digest ) : return self . conn . client . blob_exists ( self . container_name , digest )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "String to binary . [CODESPLIT] def s2b ( s ) : ret = [ ] for c in s : ret . append ( bin ( ord ( c ) ) [ 2 : ] . zfill ( 8 ) ) return \"\" . join ( ret )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Weeks start are fixes at Monday for now . [CODESPLIT] def weekly ( date = datetime . date . today ( ) ) : return date - datetime . timedelta ( days = date . weekday ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple measure of similarity : Number of letters in common / max length [CODESPLIT] def basic_word_sim ( word1 , word2 ) : return sum ( [ 1 for c in word1 if c in word2 ] ) / max ( len ( word1 ) , len ( word2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple directory walker [CODESPLIT] def get_files ( dir_name ) : return [ ( os . path . join ( '.' , d ) , [ os . path . join ( d , f ) for f in files ] ) for d , _ , files in os . walk ( dir_name ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a new datetime . datetime object with values that represent a start of a month . : param val : Date to ... : type val : datetime . datetime | datetime . date : rtype : datetime . datetime [CODESPLIT] def start_of_month ( val ) : if type ( val ) == date : val = datetime . fromordinal ( val . toordinal ( ) ) return start_of_day ( val ) . replace ( day = 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Invoke this command on a remote Python . [CODESPLIT] def check_dependencies_remote ( args ) : cmd = [ args . python , '-m' , 'depends' , args . requirement ] env = dict ( PYTHONPATH = os . path . dirname ( __file__ ) ) return subprocess . check_call ( cmd , env = env )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts Timestamp to datetime . [CODESPLIT] def ToDatetime ( self ) : return datetime . utcfromtimestamp ( self . seconds + self . nanos / float ( _NANOS_PER_SECOND ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a dict of 1d array to a numpy recarray [CODESPLIT] def dict_to_numpy_array ( d ) : return fromarrays ( d . values ( ) , np . dtype ( [ ( str ( k ) , v . dtype ) for k , v in d . items ( ) ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decision Tree [CODESPLIT] def human__decision_tree ( ) : # build data N = 1000000 M = 3 X = np . zeros ( ( N , M ) ) X . shape y = np . zeros ( N ) X [ 0 , 0 ] = 1 y [ 0 ] = 8 X [ 1 , 1 ] = 1 y [ 1 ] = 8 X [ 2 , 0 : 2 ] = 1 y [ 2 ] = 4 # fit model xor_model = sklearn . tree . DecisionTreeRegressor ( max_depth = 2 ) xor_model . fit ( X , y ) return xor_model", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decodes a given bencoded string or bytestring . [CODESPLIT] def read_string ( cls , string ) : if PY3 and not isinstance ( string , byte_types ) : string = string . encode ( ) return cls . decode ( string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A magic method to implement shallow copy behavior . [CODESPLIT] def __copy__ ( self ) : return self . __class__ . load ( self . dump ( ) , context = self . context )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Evaluates a piece of Javascript in the context of the current page and returns its value . [CODESPLIT] def eval_script ( self , expr ) : ret = self . conn . issue_command ( \"Evaluate\" , expr ) return json . loads ( \"[%s]\" % ret ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validate that the input is a list of strings . [CODESPLIT] def validate_string_list ( lst ) : if not isinstance ( lst , list ) : raise ValueError ( 'input %r must be a list' % lst ) for x in lst : if not isinstance ( x , basestring ) : raise ValueError ( 'element %r in list must be a string' % x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is builtin in python2 but we have to roll our own on py3 . [CODESPLIT] def execfile ( fname , variables ) : with open ( fname ) as f : code = compile ( f . read ( ) , fname , 'exec' ) exec ( code , variables )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts camel - case string to lowercase string separated by underscores . [CODESPLIT] def camel_to_under ( name ) : s1 = re . sub ( \"(.)([A-Z][a-z]+)\" , r\"\\1_\\2\" , name ) return re . sub ( \"([a-z0-9])([A-Z])\" , r\"\\1_\\2\" , s1 ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return default argument value as given by argparse s add_argument () . [CODESPLIT] def arg_default ( * args , * * kwargs ) : parser = argparse . ArgumentParser ( ) parser . add_argument ( * args , * * kwargs ) args = vars ( parser . parse_args ( [ ] ) ) _ , default = args . popitem ( ) return default", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return minimal quantum of a number as defined by precision . [CODESPLIT] def get_decimal_quantum ( precision ) : assert isinstance ( precision , ( int , decimal . Decimal ) ) return decimal . Decimal ( 10 ) ** ( - precision )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets a global variable given its name . [CODESPLIT] def get_var ( name , factory = None ) : if name not in _VARS and factory is not None : _VARS [ name ] = factory ( ) return _VARS . get ( name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Evaluates a piece of Javascript in the context of the current page and returns its value . [CODESPLIT] def eval_script ( self , expr ) : ret = self . conn . issue_command ( \"Evaluate\" , expr ) return json . loads ( \"[%s]\" % ret ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove the package manager from the system . [CODESPLIT] def uninstall ( cls ) : if os . path . exists ( cls . home ) : shutil . rmtree ( cls . home )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility function to remove duplicates from a list : param seq : The sequence ( list ) to deduplicate : return : A list with original duplicates removed [CODESPLIT] def dedupe_list ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the shape of the region as ( x y w h ) [CODESPLIT] def getTuple ( self ) : return ( self . x , self . y , self . w , self . h )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete a file safely . If it s not present no - op . [CODESPLIT] def safe_delete ( filename ) : try : os . unlink ( filename ) except OSError as e : if e . errno != errno . ENOENT : raise", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a dictionary and a key list remove any data in the dictionary with the given keys . [CODESPLIT] def rm_keys_from_dict ( d , keys ) : # Loop for each key given for key in keys : # Is the key in the dictionary? if key in d : try : d . pop ( key , None ) except KeyError : # Not concerned with an error. Keep going. pass return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert snake case string to camel case . [CODESPLIT] def _snake_to_camel_case ( value ) : words = value . split ( \"_\" ) return words [ 0 ] + \"\" . join ( map ( str . capitalize , words [ 1 : ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is the current OS a Windows? [CODESPLIT] def _platform_is_windows ( platform = sys . platform ) : matched = platform in ( 'cygwin' , 'win32' , 'win64' ) if matched : error_msg = \"Windows isn't supported yet\" raise OSError ( error_msg ) return matched", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the given command ( with shell = False ) and return a tuple of ( int returncode str output ) . Strip the output of enclosing whitespace . [CODESPLIT] def call_out ( command ) : # start external command process p = subprocess . Popen ( command , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) # get outputs out , _ = p . communicate ( ) return p . returncode , out . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse a bool from a string . [CODESPLIT] def FromString ( self , string ) : if string . lower ( ) in ( \"false\" , \"no\" , \"n\" ) : return False if string . lower ( ) in ( \"true\" , \"yes\" , \"y\" ) : return True raise TypeValueError ( \"%s is not recognized as a boolean value.\" % string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to turn a string representation of true into boolean True . [CODESPLIT] def strToBool ( val ) : if isinstance ( val , str ) : val = val . lower ( ) return val in [ 'true' , 'on' , 'yes' , True ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wraps the given dictionary such that the given fallback function will be called when a nonexistent key is accessed . [CODESPLIT] def _defaultdict ( dct , fallback = _illegal_character ) : out = defaultdict ( lambda : fallback ) for k , v in six . iteritems ( dct ) : out [ k ] = v return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a date into a datetime [CODESPLIT] def date_to_datetime ( x ) : if not isinstance ( x , datetime ) and isinstance ( x , date ) : return datetime . combine ( x , time ( ) ) return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "copy the dict filter_keywords [CODESPLIT] def _remove_keywords ( d ) : return { k : v for k , v in iteritems ( d ) if k not in RESERVED }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a string representing a numpy array of 0 s and 1 s [CODESPLIT] def bitsToString ( arr ) : s = array ( 'c' , '.' * len ( arr ) ) for i in xrange ( len ( arr ) ) : if arr [ i ] == 1 : s [ i ] = '*' return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Store a copy of the data . [CODESPLIT] def data ( self , data ) : self . _data = { det : d . copy ( ) for ( det , d ) in data . items ( ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This turns off stdout buffering so that outputs are immediately materialized and log messages show up before the program exits [CODESPLIT] def disable_stdout_buffering ( ) : stdout_orig = sys . stdout sys . stdout = os . fdopen ( sys . stdout . fileno ( ) , 'w' , 0 ) # NOTE(brandyn): This removes the original stdout return stdout_orig", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resizes an image preserving the aspect ratio . [CODESPLIT] def scale_image ( image , new_width ) : ( original_width , original_height ) = image . size aspect_ratio = original_height / float ( original_width ) new_height = int ( aspect_ratio * new_width ) # This scales it wider than tall, since characters are biased new_image = image . resize ( ( new_width * 2 , new_height ) ) return new_image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the time with TZ enabled [CODESPLIT] def with_tz ( request ) : dt = datetime . now ( ) t = Template ( '{% load tz %}{% localtime on %}{% get_current_timezone as TIME_ZONE %}{{ TIME_ZONE }}{% endlocaltime %}' ) c = RequestContext ( request ) response = t . render ( c ) return HttpResponse ( response )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add executable permissions to the file [CODESPLIT] def add_exec_permission_to ( target_file ) : mode = os . stat ( target_file ) . st_mode os . chmod ( target_file , mode | stat . S_IXUSR )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get distance matrix given a matrix . Used in testing . [CODESPLIT] def get_distance_matrix ( x ) : square = nd . sum ( x ** 2.0 , axis = 1 , keepdims = True ) distance_square = square + square . transpose ( ) - ( 2.0 * nd . dot ( x , x . transpose ( ) ) ) return nd . sqrt ( distance_square )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert dict of ascii str / unicode to dict of str if necessary [CODESPLIT] def str_dict ( some_dict ) : return { str ( k ) : str ( v ) for k , v in some_dict . items ( ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shape a list of lists into the appropriate shape and data type [CODESPLIT] def shape_list ( l , shape , dtype ) : return np . array ( l , dtype = dtype ) . reshape ( shape )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clear the database . [CODESPLIT] def delete_all_from_db ( ) : # The models.CASCADE property is set on all ForeignKey fields, so tables can # be deleted in any order without breaking constraints. for model in django . apps . apps . get_models ( ) : model . objects . all ( ) . delete ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Efficient conversion from scipy sparse matrix to cvxopt sparse matrix [CODESPLIT] def scipy_sparse_to_spmatrix ( A ) : coo = A . tocoo ( ) SP = spmatrix ( coo . data . tolist ( ) , coo . row . tolist ( ) , coo . col . tolist ( ) , size = A . shape ) return SP", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if the user requested interactive mode . [CODESPLIT] def is_interactive ( self ) : # The Python interpreter sets sys.flags correctly, so use them! if sys . flags . interactive : return True # IPython does not set sys.flags when -i is specified, so first # check it if it is already imported. if '__IPYTHON__' not in dir ( six . moves . builtins ) : return False # Then we check the application singleton and determine based on # a variable it sets. try : from IPython . config . application import Application as App return App . initialized ( ) and App . instance ( ) . interact except ( ImportError , AttributeError ) : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Install Postgres on remote [CODESPLIT] def install_postgres ( user = None , dbname = None , password = None ) : execute ( pydiploy . django . install_postgres_server , user = user , dbname = dbname , password = password )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a Vector as the product of the vector and a real number . [CODESPLIT] def multiply ( self , number ) : return self . from_list ( [ x * number for x in self . to_list ( ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set __doc__ of * method * to __doc__ of * method * in its parent class . [CODESPLIT] def inheritdoc ( method ) : method . __doc__ = getattr ( str , method . __name__ ) . __doc__ return method", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A very thin wrapper around textwrap . fill to consistently wrap documentation text for display in a command line environment . The text is wrapped to 99 characters with an indentation depth of 4 spaces . Each line is wrapped independently in order to preserve manually added line breaks . [CODESPLIT] def format_doc_text ( text ) : return '\\n' . join ( textwrap . fill ( line , width = 99 , initial_indent = '    ' , subsequent_indent = '    ' ) for line in inspect . cleandoc ( text ) . splitlines ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Round a number to a precision [CODESPLIT] def round_to_int ( number , precision ) : precision = int ( precision ) rounded = ( int ( number ) + precision / 2 ) // precision * precision return rounded", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return locale from GET lang param or automatically . [CODESPLIT] def set_locale ( request ) : return request . query . get ( 'lang' , app . ps . babel . select_locale_by_request ( request ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Inline all input latex files references by this document . The inlining is accomplished recursively . The document is modified in place . [CODESPLIT] def inline_inputs ( self ) : self . text = texutils . inline ( self . text , os . path . dirname ( self . _filepath ) ) # Remove children self . _children = { }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the terminal window size of the child tty . [CODESPLIT] def setwinsize ( self , rows , cols ) : self . _winsize = ( rows , cols ) self . pty . set_size ( cols , rows )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the default stream encoding if not found . [CODESPLIT] def get_best_encoding ( stream ) : rv = getattr ( stream , 'encoding' , None ) or sys . getdefaultencoding ( ) if is_ascii_encoding ( rv ) : return 'utf-8' return rv", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a prettier version of obj [CODESPLIT] def _get_pretty_string ( obj ) : sio = StringIO ( ) pprint . pprint ( obj , stream = sio ) return sio . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compile and return a Module s code object . [CODESPLIT] def get_code ( module ) : fp = open ( module . path ) try : return compile ( fp . read ( ) , str ( module . name ) , 'exec' ) finally : fp . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Label a method as a command with name . [CODESPLIT] def command ( name , mode ) : def decorator ( fn ) : commands [ name ] = fn . __name__ _Client . _addMethod ( fn . __name__ , name , mode ) return fn return decorator", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clear all indexes in the es core [CODESPLIT] def clear_es ( ) : # TODO: should receive a catalog slug. ESHypermap . es . indices . delete ( ESHypermap . index_name , ignore = [ 400 , 404 ] ) LOGGER . debug ( 'Elasticsearch: Index cleared' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Checks if l is a numpy array of integers [CODESPLIT] def is_int_vector ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 1 and ( l . dtype . kind == 'i' or l . dtype . kind == 'u' ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handle the + operator . [CODESPLIT] def __add__ ( self , other ) : return self . _handle_type ( other ) ( self . value + other . value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the response failed because of an expired access token . [CODESPLIT] def _is_expired_response ( self , response ) : if response . status_code != 401 : return False challenge = response . headers . get ( 'www-authenticate' , '' ) return 'error=\"invalid_token\"' in challenge", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if value can be part of binary / bitwise operations . [CODESPLIT] def isbinary ( * args ) : return all ( map ( lambda c : isnumber ( c ) or isbool ( c ) , args ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to validate that URLs are well formed i . e that it contains a valid protocol and a valid domain . It does not actually check if the URL exists [CODESPLIT] def _is_valid_url ( url ) : try : parsed = urlparse ( url ) mandatory_parts = [ parsed . scheme , parsed . netloc ] return all ( mandatory_parts ) except : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raises a requests . exceptions . HTTPError if the response has a non - 200 status code . [CODESPLIT] def raise_for_not_ok_status ( response ) : if response . code != OK : raise HTTPError ( 'Non-200 response code (%s) for url: %s' % ( response . code , uridecode ( response . request . absoluteURI ) ) ) return response", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if array is an array of real numbers . [CODESPLIT] def contains_all ( self , array ) : dtype = getattr ( array , 'dtype' , None ) if dtype is None : dtype = np . result_type ( * array ) return is_real_dtype ( dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses the get - all - user - accounts Portals API to retrieve the user - id by supplying an email . [CODESPLIT] def get_user_id_from_email ( self , email ) : accts = self . get_all_user_accounts ( ) for acct in accts : if acct [ 'email' ] == email : return acct [ 'id' ] return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return True if callback is a vanilla plain jane function [CODESPLIT] def is_function ( self ) : if self . is_instance ( ) or self . is_class ( ) : return False return isinstance ( self . callback , ( Callable , classmethod ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if val is of integer type . [CODESPLIT] def is_int_type ( val ) : try : # Python 2 return isinstance ( val , ( int , long ) ) except NameError : # Python 3 return isinstance ( val , int )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Expand a filesystem path that may or may not contain user / env vars . [CODESPLIT] def expandpath ( path ) : return os . path . expandvars ( os . path . expanduser ( path ) ) . replace ( \"//\" , \"/\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if filename1 and filename2 point to the same file object . There can be false negatives ie . the result is False but it is the same file anyway . Reason is that network filesystems can create different paths to the same physical file . [CODESPLIT] def is_same_file ( filename1 , filename2 ) : if filename1 == filename2 : return True if os . name == 'posix' : return os . path . samefile ( filename1 , filename2 ) return is_same_filename ( filename1 , filename2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates that value is an instance of basestring for Python 2 or str for Python 3 . [CODESPLIT] def validate_string ( option , value ) : if isinstance ( value , string_type ) : return value raise TypeError ( \"Wrong type for %s, value must be \" \"an instance of %s\" % ( option , string_type . __name__ ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine whether two strings are equivalent . [CODESPLIT] def eqstr ( a , b ) : return bool ( libspice . eqstr_c ( stypes . stringToCharP ( a ) , stypes . stringToCharP ( b ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Computes the unnormalized PDF of the normal distribution . [CODESPLIT] def EvalGaussianPdf ( x , mu , sigma ) : return scipy . stats . norm . pdf ( x , mu , sigma )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve contents of each page of PDF [CODESPLIT] def resources ( self ) : return [ self . pdf . getPage ( i ) for i in range ( self . pdf . getNumPages ( ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of active CPUs on a Darwin system . [CODESPLIT] def _num_cpus_darwin ( ) : p = subprocess . Popen ( [ 'sysctl' , '-n' , 'hw.ncpu' ] , stdout = subprocess . PIPE ) return p . stdout . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "parse the domain from the url [CODESPLIT] def parse_domain ( url ) : domain_match = lib . DOMAIN_REGEX . match ( url ) if domain_match : return domain_match . group ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip absolute components from path . Inspired from zipfile . write () . [CODESPLIT] def _relpath ( name ) : return os . path . normpath ( os . path . splitdrive ( name ) [ 1 ] ) . lstrip ( _allsep )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks to see if a 2D list is a valid 2D matrix [CODESPLIT] def _rectangular ( n ) : for i in n : if len ( i ) != len ( n [ 0 ] ) : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the absolute path to the directory containing the package data . [CODESPLIT] def data_directory ( ) : package_directory = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( package_directory , \"data\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if val is of integer type . [CODESPLIT] def is_int_type ( val ) : try : # Python 2 return isinstance ( val , ( int , long ) ) except NameError : # Python 3 return isinstance ( val , int )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if two images have the same height and width ( and optionally channels ) . [CODESPLIT] def is_same_shape ( self , other_im , check_channels = False ) : if self . height == other_im . height and self . width == other_im . width : if check_channels and self . channels != other_im . channels : return False return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Filter out any values in target not in image : param image : image containing values to appear in filtered image : param target : the image to filter : rtype : 2d : class : numpy . ndarray containing only value in image and with the same dimensions as target [CODESPLIT] def filter_greys_using_image ( image , target ) : maskbase = numpy . array ( range ( 256 ) , dtype = numpy . uint8 ) mask = numpy . where ( numpy . in1d ( maskbase , numpy . unique ( image ) ) , maskbase , 0 ) return mask [ target ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "function to get return code of a url [CODESPLIT] def get_url_nofollow ( url ) : try : response = urlopen ( url ) code = response . getcode ( ) return code except HTTPError as e : return e . code except : return 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A handy wrapper to get a remote file content [CODESPLIT] def get_remote_content ( filepath ) : with hide ( 'running' ) : temp = BytesIO ( ) get ( filepath , temp ) content = temp . getvalue ( ) . decode ( 'utf-8' ) return content . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return frequencies for DFT [CODESPLIT] def fft_freqs ( n_fft , fs ) : return np . arange ( 0 , ( n_fft // 2 + 1 ) ) / float ( n_fft ) * float ( fs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "To know the allocated memory at function termination . [CODESPLIT] def memory_used ( self ) : if self . _end_memory : memory_used = self . _end_memory - self . _start_memory return memory_used else : return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the percentile of a list of values . [CODESPLIT] def percentile ( values , k ) : if not values : return None values . sort ( ) index = ( len ( values ) * ( float ( k ) / 100 ) ) - 1 return values [ int ( math . ceil ( index ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a text and drops all non - printable and non - ascii characters and also any whitespace characters that aren t space . [CODESPLIT] def drop_bad_characters ( text ) : # Strip all non-ascii and non-printable characters text = '' . join ( [ c for c in text if c in ALLOWED_CHARS ] ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterate through lines of file . [CODESPLIT] def txt_line_iterator ( path ) : with tf . gfile . Open ( path ) as f : for line in f : yield line . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flush all items from cache . [CODESPLIT] def Flush ( self ) : while self . _age : node = self . _age . PopLeft ( ) self . KillObject ( node . data ) self . _hash = dict ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Open a file . [CODESPLIT] def open_file ( file , mode ) : if hasattr ( file , \"read\" ) : return file if hasattr ( file , \"open\" ) : return file . open ( mode ) return open ( file , mode )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clears globals and reloads modules [CODESPLIT] def clear_globals_reload_modules ( self ) : self . code_array . clear_globals ( ) self . code_array . reload_modules ( ) # Clear result cache self . code_array . result_cache . clear ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rewind the file to the start of the body ( if seekable ) . [CODESPLIT] def rewindbody ( self ) : if not self . seekable : raise IOError , \"unseekable file\" self . fp . seek ( self . startofbody )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns file name of file at given url . [CODESPLIT] def get_file_name ( url ) : return os . path . basename ( urllib . parse . urlparse ( url ) . path ) or 'unknown_name'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Close all files but the current one [CODESPLIT] def close_all_but_this ( self ) : self . close_all_right ( ) for i in range ( 0 , self . get_stack_count ( ) - 1 ) : self . close_file ( 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fill an array from a list [CODESPLIT] def _fill_array_from_list ( the_list , the_array ) : for i , val in enumerate ( the_list ) : the_array [ i ] = val return the_array", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Basic filtering for a dataframe . [CODESPLIT] def apply_filters ( df , filters ) : idx = pd . Series ( [ True ] * df . shape [ 0 ] ) for k , v in list ( filters . items ( ) ) : if k not in df . columns : continue idx &= ( df [ k ] == v ) return df . loc [ idx ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "calculate the fill similarity over the image [CODESPLIT] def _sim_fill ( r1 , r2 , imsize ) : bbsize = ( ( max ( r1 [ \"max_x\" ] , r2 [ \"max_x\" ] ) - min ( r1 [ \"min_x\" ] , r2 [ \"min_x\" ] ) ) * ( max ( r1 [ \"max_y\" ] , r2 [ \"max_y\" ] ) - min ( r1 [ \"min_y\" ] , r2 [ \"min_y\" ] ) ) ) return 1.0 - ( bbsize - r1 [ \"size\" ] - r2 [ \"size\" ] ) / imsize", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply the coefficients from a linear fit to an array of x y positions . [CODESPLIT] def apply_fit ( xy , coeffs ) : x_new = coeffs [ 0 ] [ 2 ] + coeffs [ 0 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 0 ] [ 1 ] * xy [ : , 1 ] y_new = coeffs [ 1 ] [ 2 ] + coeffs [ 1 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 1 ] [ 1 ] * xy [ : , 1 ] return x_new , y_new", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run lint checks using flake8 . [CODESPLIT] def lint ( args ) : application = get_current_application ( ) if not args : args = [ application . name , 'tests' ] args = [ 'flake8' ] + list ( args ) run . main ( args , standalone_mode = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "calculate the fill similarity over the image [CODESPLIT] def _sim_fill ( r1 , r2 , imsize ) : bbsize = ( ( max ( r1 [ \"max_x\" ] , r2 [ \"max_x\" ] ) - min ( r1 [ \"min_x\" ] , r2 [ \"min_x\" ] ) ) * ( max ( r1 [ \"max_y\" ] , r2 [ \"max_y\" ] ) - min ( r1 [ \"min_y\" ] , r2 [ \"min_y\" ] ) ) ) return 1.0 - ( bbsize - r1 [ \"size\" ] - r2 [ \"size\" ] ) / imsize", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Annotate a function using information from its docstring . [CODESPLIT] def docannotate ( func ) : func = annotated ( func ) func . metadata . load_from_doc = True if func . decorated : return func func . decorated = True return decorate ( func , _check_and_execute )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove any duplicate entries . [CODESPLIT] def unique ( transactions ) : seen = set ( ) # TODO: Handle comments return [ x for x in transactions if not ( x in seen or seen . add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check for convergence by determining if matrix1 and matrix2 are approximately equal . : param matrix1 : The matrix to compare with matrix2 : param matrix2 : The matrix to compare with matrix1 : returns : True if matrix1 and matrix2 approximately equal [CODESPLIT] def converged ( matrix1 , matrix2 ) : if isspmatrix ( matrix1 ) or isspmatrix ( matrix2 ) : return sparse_allclose ( matrix1 , matrix2 ) return np . allclose ( matrix1 , matrix2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the location of the static data directory . [CODESPLIT] def staticdir ( ) : root = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( root , \"static\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a virtual concatenate of several NumPy arrays . [CODESPLIT] def _concatenate_virtual_arrays ( arrs , cols = None , scaling = None ) : return None if not len ( arrs ) else ConcatenatedArrays ( arrs , cols , scaling = scaling )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple function to add two numbers [CODESPLIT] def generic_add ( a , b ) : logger . debug ( 'Called generic_add({}, {})' . format ( a , b ) ) return a + b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a list of tuples describing a table into a HTML string [CODESPLIT] def html ( header_rows ) : name = 'table%d' % next ( tablecounter ) return HtmlTable ( [ map ( str , row ) for row in header_rows ] , name ) . render ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Enable a default web proxy [CODESPLIT] def enable_proxy ( self , host , port ) : self . proxy = [ host , _number ( port ) ] self . proxy_enabled = True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns coordinates for point at t on the line . Calculates the coordinates of x and y for a point at t on a straight line . The t parameter is a number between 0 . 0 and 1 . 0 x0 and y0 define the starting point of the line x1 and y1 the ending point of the line . [CODESPLIT] def _linepoint ( self , t , x0 , y0 , x1 , y1 ) : # Originally from nodebox-gl out_x = x0 + t * ( x1 - x0 ) out_y = y0 + t * ( y1 - y0 ) return ( out_x , out_y )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the Webserver / SocketIO and app [CODESPLIT] def run ( context , port ) : global ctx ctx = context app . run ( port = port )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Index all available documents using streaming_bulk for speed Args : [CODESPLIT] def index_all ( self , index_name ) : oks = 0 notoks = 0 for ok , item in streaming_bulk ( self . es_client , self . _iter_documents ( index_name ) ) : if ok : oks += 1 else : notoks += 1 logging . info ( \"Import results: %d ok, %d not ok\" , oks , notoks )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return number of empty lines at the end of the document . [CODESPLIT] def empty_line_count_at_the_end ( self ) : count = 0 for line in self . lines [ : : - 1 ] : if not line or line . isspace ( ) : count += 1 else : break return count", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function used internally to format string data for output to XML . Escapes back - slashes and quotes and wraps the resulting string in quotes . [CODESPLIT] def string_format_func ( s ) : return u\"\\\"%s\\\"\" % unicode ( s ) . replace ( u\"\\\\\" , u\"\\\\\\\\\" ) . replace ( u\"\\\"\" , u\"\\\\\\\"\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Connect to FTP server login and return an ftplib . FTP instance . [CODESPLIT] def connect ( ) : ftp_class = ftplib . FTP if not SSL else ftplib . FTP_TLS ftp = ftp_class ( timeout = TIMEOUT ) ftp . connect ( HOST , PORT ) ftp . login ( USER , PASSWORD ) if SSL : ftp . prot_p ( ) # secure data connection return ftp", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": type root : TreeNode : rtype : int [CODESPLIT] def min_depth ( self , root ) : if root is None : return 0 if root . left is not None or root . right is not None : return max ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1 return min ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the fully - qualified name of a function . [CODESPLIT] def _fullname ( o ) : return o . __module__ + \".\" + o . __name__ if o . __module__ else o . __name__", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a 3x3 cross - product matrix from a 3 - element vector . [CODESPLIT] def cross_product_matrix ( vec ) : return np . array ( [ [ 0 , - vec [ 2 ] , vec [ 1 ] ] , [ vec [ 2 ] , 0 , - vec [ 0 ] ] , [ - vec [ 1 ] , vec [ 0 ] , 0 ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Method wrapper that adds the name of the method being called to its arguments list in Pascal case [CODESPLIT] def method_name ( func ) : @ wraps ( func ) def _method_name ( * args , * * kwargs ) : name = to_pascal_case ( func . __name__ ) return func ( name = name , * args , * * kwargs ) return _method_name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Constructs an object holding a datetime / timestamp value . [CODESPLIT] def Timestamp ( year , month , day , hour , minute , second ) : return datetime . datetime ( year , month , day , hour , minute , second )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get input from the user given an input function and an input string [CODESPLIT] def get_input ( input_func , input_str ) : val = input_func ( \"Please enter your {0}: \" . format ( input_str ) ) while not val or not len ( val . strip ( ) ) : val = input_func ( \"You didn't enter a valid {0}, please try again: \" . format ( input_str ) ) return val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generates a LaTeX table from parameter summaries . [CODESPLIT] def get_latex_table ( self , parameters = None , transpose = False , caption = None , label = \"tab:model_params\" , hlines = True , blank_fill = \"--\" ) : # pragma: no cover if parameters is None : parameters = self . parent . _all_parameters for p in parameters : assert isinstance ( p , str ) , \"Generating a LaTeX table requires all parameters have labels\" num_parameters = len ( parameters ) num_chains = len ( self . parent . chains ) fit_values = self . get_summary ( squeeze = False ) if label is None : label = \"\" if caption is None : caption = \"\" end_text = \" \\\\\\\\ \\n\" if transpose : column_text = \"c\" * ( num_chains + 1 ) else : column_text = \"c\" * ( num_parameters + 1 ) center_text = \"\" hline_text = \"\\\\hline\\n\" if hlines : center_text += hline_text + \"\\t\\t\" if transpose : center_text += \" & \" . join ( [ \"Parameter\" ] + [ c . name for c in self . parent . chains ] ) + end_text if hlines : center_text += \"\\t\\t\" + hline_text for p in parameters : arr = [ \"\\t\\t\" + p ] for chain_res in fit_values : if p in chain_res : arr . append ( self . get_parameter_text ( * chain_res [ p ] , wrap = True ) ) else : arr . append ( blank_fill ) center_text += \" & \" . join ( arr ) + end_text else : center_text += \" & \" . join ( [ \"Model\" ] + parameters ) + end_text if hlines : center_text += \"\\t\\t\" + hline_text for name , chain_res in zip ( [ c . name for c in self . parent . chains ] , fit_values ) : arr = [ \"\\t\\t\" + name ] for p in parameters : if p in chain_res : arr . append ( self . get_parameter_text ( * chain_res [ p ] , wrap = True ) ) else : arr . append ( blank_fill ) center_text += \" & \" . join ( arr ) + end_text if hlines : center_text += \"\\t\\t\" + hline_text final_text = get_latex_table_frame ( caption , label ) % ( column_text , center_text ) return final_text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print emphasized good the given txt message [CODESPLIT] def good ( txt ) : print ( \"%s# %s%s%s\" % ( PR_GOOD_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create all your database objects ( SQLAlchemy specific ) . [CODESPLIT] def create_db ( app , appbuilder ) : from flask_appbuilder . models . sqla import Base _appbuilder = import_application ( app , appbuilder ) engine = _appbuilder . get_session . get_bind ( mapper = None , clause = None ) Base . metadata . create_all ( engine ) click . echo ( click . style ( \"DB objects created\" , fg = \"green\" ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Whitespace normalization : [CODESPLIT] def text_remove_empty_lines ( text ) : lines = [ line . rstrip ( ) for line in text . splitlines ( ) if line . strip ( ) ] return \"\\n\" . join ( lines )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If output is string then print the string and also time used [CODESPLIT] def timeit ( output ) : b = time . time ( ) yield print output , 'time used: %.3fs' % ( time . time ( ) - b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a Python function name return the function it refers to . [CODESPLIT] def get_function ( function_name ) : module , basename = str ( function_name ) . rsplit ( '.' , 1 ) try : return getattr ( __import__ ( module , fromlist = [ basename ] ) , basename ) except ( ImportError , AttributeError ) : raise FunctionNotFound ( function_name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns all dates between two dates . [CODESPLIT] def dates_in_range ( start_date , end_date ) : return [ start_date + timedelta ( n ) for n in range ( int ( ( end_date - start_date ) . days ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return list of Logger classes . [CODESPLIT] def _get_loggers ( ) : from . . import loader modules = loader . get_package_modules ( 'logger' ) return list ( loader . get_plugins ( modules , [ _Logger ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list consisting of the cumulative sum of the items in the passed list . [CODESPLIT] def cumsum ( inlist ) : newlist = copy . deepcopy ( inlist ) for i in range ( 1 , len ( newlist ) ) : newlist [ i ] = newlist [ i ] + newlist [ i - 1 ] return newlist", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a generator of tuples k c such that k is the name of the python attribute for the column and c is the name of the column in the sql table . [CODESPLIT] def get_column_keys_and_names ( table ) : ins = inspect ( table ) return ( ( k , c . name ) for k , c in ins . mapper . c . items ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a value or list of values and returns a single result joined by if necessary . [CODESPLIT] def vectorize ( values ) : if isinstance ( values , list ) : return ',' . join ( str ( v ) for v in values ) return values", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coerce value to an JSON - compatible representation . [CODESPLIT] def _time_to_json ( value ) : if isinstance ( value , datetime . time ) : value = value . isoformat ( ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the month start date a nd end date [CODESPLIT] def get_month_start_end_day ( ) : t = date . today ( ) n = mdays [ t . month ] return ( date ( t . year , t . month , 1 ) , date ( t . year , t . month , n ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decision Tree [CODESPLIT] def human__decision_tree ( ) : # build data N = 1000000 M = 3 X = np . zeros ( ( N , M ) ) X . shape y = np . zeros ( N ) X [ 0 , 0 ] = 1 y [ 0 ] = 8 X [ 1 , 1 ] = 1 y [ 1 ] = 8 X [ 2 , 0 : 2 ] = 1 y [ 2 ] = 4 # fit model xor_model = sklearn . tree . DecisionTreeRegressor ( max_depth = 2 ) xor_model . fit ( X , y ) return xor_model", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get element by name [CODESPLIT] def get_by ( self , name ) : return next ( ( item for item in self if item . name == name ) , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Merge all the strings . Put space between them . [CODESPLIT] def join ( mapping , bind , values ) : return [ ' ' . join ( [ six . text_type ( v ) for v in values if v is not None ] ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print security object information for a pdf document [CODESPLIT] def security ( self ) : return { k : v for i in self . pdf . resolvedObjects . items ( ) for k , v in i [ 1 ] . items ( ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return default argument value as given by argparse s add_argument () . [CODESPLIT] def arg_default ( * args , * * kwargs ) : parser = argparse . ArgumentParser ( ) parser . add_argument ( * args , * * kwargs ) args = vars ( parser . parse_args ( [ ] ) ) _ , default = args . popitem ( ) return default", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a dict of 1d array to a numpy recarray [CODESPLIT] def dict_to_numpy_array ( d ) : return fromarrays ( d . values ( ) , np . dtype ( [ ( str ( k ) , v . dtype ) for k , v in d . items ( ) ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds passed value to node s globals [CODESPLIT] def set_global ( node : Node , key : str , value : Any ) : node . node_globals [ key ] = value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove tags from a file . [CODESPLIT] def delete ( filething ) : f = FLAC ( filething ) filething . fileobj . seek ( 0 ) f . delete ( filething )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return first occurrence matching f otherwise None [CODESPLIT] def findfirst ( f , coll ) : result = list ( dropwhile ( f , coll ) ) return result [ 0 ] if result else None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete a directory if it s present . If it s not present no - op . [CODESPLIT] def safe_rmtree ( directory ) : if os . path . exists ( directory ) : shutil . rmtree ( directory , True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Do a pingback call for the target URL . [CODESPLIT] def pingback_url ( self , server_name , target_url ) : try : server = ServerProxy ( server_name ) reply = server . pingback . ping ( self . entry_url , target_url ) except ( Error , socket . error ) : reply = '%s cannot be pinged.' % target_url return reply", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get one - line description of HEAD commit for repository in current dir . [CODESPLIT] def get_last_commit_line ( git_path = None ) : if git_path is None : git_path = GIT_PATH output = check_output ( [ git_path , \"log\" , \"--pretty=format:'%ad %h %s'\" , \"--date=short\" , \"-n1\" ] ) return output . strip ( ) [ 1 : - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the size of the shared memory file system . [CODESPLIT] def get_shared_memory_bytes ( ) : # Make sure this is only called on Linux. assert sys . platform == \"linux\" or sys . platform == \"linux2\" shm_fd = os . open ( \"/dev/shm\" , os . O_RDONLY ) try : shm_fs_stats = os . fstatvfs ( shm_fd ) # The value shm_fs_stats.f_bsize is the block size and the # value shm_fs_stats.f_bavail is the number of available # blocks. shm_avail = shm_fs_stats . f_bsize * shm_fs_stats . f_bavail finally : os . close ( shm_fd ) return shm_avail", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve the previous quarter for dt [CODESPLIT] def previous_quarter ( d ) : from django_toolkit . datetime_util import quarter as datetime_quarter return quarter ( ( datetime_quarter ( datetime ( d . year , d . month , d . day ) ) [ 0 ] + timedelta ( days = - 1 ) ) . date ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a gid given a group name . [CODESPLIT] def _get_gid ( name ) : if getgrnam is None or name is None : return None try : result = getgrnam ( name ) except KeyError : result = None if result is not None : return result [ 2 ] return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a JSSObject for the element with ID id_ [CODESPLIT] def retrieve_by_id ( self , id_ ) : items_with_id = [ item for item in self if item . id == int ( id_ ) ] if len ( items_with_id ) == 1 : return items_with_id [ 0 ] . retrieve ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Region formed by taking border elements . [CODESPLIT] def border ( self ) : border_array = self . bitmap - self . inner . bitmap return Region ( border_array )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "An iterable of column names for a particular table or view . [CODESPLIT] def column_names ( self , table ) : table_info = self . execute ( u'PRAGMA table_info(%s)' % quote ( table ) ) return ( column [ 'name' ] for column in table_info )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call tf . Print . [CODESPLIT] def Print ( x , data , message , * * kwargs ) : # pylint: disable=invalid-name return PrintOperation ( x , data , message , * * kwargs ) . outputs [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the absolute position of table top [CODESPLIT] def table_top_abs ( self ) : table_height = np . array ( [ 0 , 0 , self . table_full_size [ 2 ] ] ) return string_to_array ( self . floor . get ( \"pos\" ) ) + table_height", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the approximate size of the queue ( not reliable! ) . [CODESPLIT] def qsize ( self ) : self . mutex . acquire ( ) n = self . _qsize ( ) self . mutex . release ( ) return n", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a string for various input types [CODESPLIT] def check_str ( obj ) : if isinstance ( obj , str ) : return obj if isinstance ( obj , float ) : return str ( int ( obj ) ) else : return str ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split text into list of sentences . [CODESPLIT] def split_into_sentences ( s ) : s = re . sub ( r\"\\s+\" , \" \" , s ) s = re . sub ( r\"[\\\\.\\\\?\\\\!]\" , \"\\n\" , s ) return s . split ( \"\\n\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print security object information for a pdf document [CODESPLIT] def security ( self ) : return { k : v for i in self . pdf . resolvedObjects . items ( ) for k , v in i [ 1 ] . items ( ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rollback a migration with given name . [CODESPLIT] def rollback ( name , database = None , directory = None , verbose = None ) : router = get_router ( directory , database , verbose ) router . rollback ( name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Downloads and returns the full text of a particular page in the document . [CODESPLIT] def get_page_text ( self , page ) : url = self . get_page_text_url ( page ) return self . _get_url ( url )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets the closest monday to the date provided . [CODESPLIT] def _get_closest_week ( self , metric_date ) : #find the offset to the closest monday days_after_monday = metric_date . isoweekday ( ) - 1 return metric_date - datetime . timedelta ( days = days_after_monday )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Start the Django dev server . [CODESPLIT] def server ( port ) : args = [ 'python' , 'manage.py' , 'runserver' ] if port : args . append ( port ) run . main ( args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns ( width height ) for the given variable [CODESPLIT] def get_grid_spatial_dimensions ( self , variable ) : data = self . open_dataset ( self . service ) . variables [ variable . variable ] dimensions = list ( data . dimensions ) return data . shape [ dimensions . index ( variable . x_dimension ) ] , data . shape [ dimensions . index ( variable . y_dimension ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts given argument to float . On fail logs warning and returns 0 . 0 . [CODESPLIT] def _force_float ( v ) : try : return float ( v ) except Exception as exc : return float ( 'nan' ) logger . warning ( 'Failed to convert {} to float with {} error. Using 0 instead.' . format ( v , exc ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function for running binary search on a sorted list . [CODESPLIT] def binSearch ( arr , val ) : i = bisect_left ( arr , val ) if i != len ( arr ) and arr [ i ] == val : return i return - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the 1 - based index of the last object on this page relative to total objects found ( hits ) . [CODESPLIT] def end_index ( self ) : return ( ( self . number - 1 ) * self . paginator . per_page + len ( self . object_list ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the dot product of two vectors [CODESPLIT] def dot_v2 ( vec1 , vec2 ) : return vec1 . x * vec2 . x + vec1 . y * vec2 . y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the size of the shared memory file system . [CODESPLIT] def get_shared_memory_bytes ( ) : # Make sure this is only called on Linux. assert sys . platform == \"linux\" or sys . platform == \"linux2\" shm_fd = os . open ( \"/dev/shm\" , os . O_RDONLY ) try : shm_fs_stats = os . fstatvfs ( shm_fd ) # The value shm_fs_stats.f_bsize is the block size and the # value shm_fs_stats.f_bavail is the number of available # blocks. shm_avail = shm_fs_stats . f_bsize * shm_fs_stats . f_bavail finally : os . close ( shm_fd ) return shm_avail", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Drop all tables in the database [CODESPLIT] def drop_all_tables ( self ) : for table_name in self . table_names ( ) : self . execute_sql ( \"DROP TABLE %s\" % table_name ) self . connection . commit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a string for various input types [CODESPLIT] def check_str ( obj ) : if isinstance ( obj , str ) : return obj if isinstance ( obj , float ) : return str ( int ( obj ) ) else : return str ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clean a pandas dataframe by : 1 . Filling empty values with Nan 2 . Dropping columns with all empty values [CODESPLIT] def clean_df ( df , fill_nan = True , drop_empty_columns = True ) : if fill_nan : df = df . fillna ( value = np . nan ) if drop_empty_columns : df = df . dropna ( axis = 1 , how = 'all' ) return df . sort_index ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get width and height of a PDF [CODESPLIT] def dimensions ( self ) : size = self . pdf . getPage ( 0 ) . mediaBox return { 'w' : float ( size [ 2 ] ) , 'h' : float ( size [ 3 ] ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of unique items ( similar to set functionality ) . [CODESPLIT] def unique ( input_list ) : output = [ ] for item in input_list : if item not in output : output . append ( item ) return output", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates an email address Source : Himanshu Shankar ( https : // github . com / iamhssingh ) Parameters ---------- email : str [CODESPLIT] def validate_email ( email ) : from django . core . validators import validate_email from django . core . exceptions import ValidationError try : validate_email ( email ) return True except ValidationError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This parallel fetcher uses gevent one uses gevent [CODESPLIT] def fetch_event ( urls ) : rs = ( grequests . get ( u ) for u in urls ) return [ content . json ( ) for content in grequests . map ( rs ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coerce value to an JSON - compatible representation . [CODESPLIT] def _bytes_to_json ( value ) : if isinstance ( value , bytes ) : value = base64 . standard_b64encode ( value ) . decode ( \"ascii\" ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print the header for the CSV table . [CODESPLIT] def printheader ( h = None ) : writer = csv . writer ( sys . stdout ) writer . writerow ( header_fields ( h ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute average gradient norm of an image [CODESPLIT] def average_gradient ( data , * kwargs ) : return np . average ( np . array ( np . gradient ( data ) ) ** 2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper method that escapes parameters to a SQL query . [CODESPLIT] def _escape ( s ) : e = s e = e . replace ( '\\\\' , '\\\\\\\\' ) e = e . replace ( '\\n' , '\\\\n' ) e = e . replace ( '\\r' , '\\\\r' ) e = e . replace ( \"'\" , \"\\\\'\" ) e = e . replace ( '\"' , '\\\\\"' ) return e", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a value to a job id . [CODESPLIT] def normalize_job_id ( job_id ) : if not isinstance ( job_id , uuid . UUID ) : job_id = uuid . UUID ( job_id ) return job_id", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a string of data after gzip decoding [CODESPLIT] def ungzip_data ( input_data ) : buf = StringIO ( input_data ) f = gzip . GzipFile ( fileobj = buf ) return f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Standard euclidean distance . [CODESPLIT] def euclidean ( x , y ) : result = 0.0 for i in range ( x . shape [ 0 ] ) : result += ( x [ i ] - y [ i ] ) ** 2 return np . sqrt ( result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the given code line by line with printing as list of lines and return variable ans . [CODESPLIT] def runcode ( code ) : for line in code : print ( '# ' + line ) exec ( line , globals ( ) ) print ( '# return ans' ) return ans", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sorts the rows of a matrix by hierarchical clustering . [CODESPLIT] def hclust_linearize ( U ) : from scipy . cluster import hierarchy Z = hierarchy . ward ( U ) return hierarchy . leaves_list ( hierarchy . optimal_leaf_ordering ( Z , U ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes stopwords contained in a list of words . [CODESPLIT] def _removeStopwords ( text_list ) : output_list = [ ] for word in text_list : if word . lower ( ) not in _stopwords : output_list . append ( word ) return output_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert input argument to bytes [CODESPLIT] def str2bytes ( x ) : if type ( x ) is bytes : return x elif type ( x ) is str : return bytes ( [ ord ( i ) for i in x ] ) else : return str2bytes ( str ( x ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Entry point for tappy command . [CODESPLIT] def main ( argv = sys . argv , stream = sys . stderr ) : args = parse_args ( argv ) suite = build_suite ( args ) runner = unittest . TextTestRunner ( verbosity = args . verbose , stream = stream ) result = runner . run ( suite ) return get_status ( result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Stops the loop after the time specified in the loop call . [CODESPLIT] def _loop_timeout_cb ( self , main_loop ) : self . _anything_done = True logger . debug ( \"_loop_timeout_cb() called\" ) main_loop . quit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extracts all integers from a string an return them in a list [CODESPLIT] def get_numbers ( s ) : result = map ( int , re . findall ( r'[0-9]+' , unicode ( s ) ) ) return result + [ 1 ] * ( 2 - len ( result ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Search twitter API [CODESPLIT] def search_for_tweets_about ( user_id , params ) : url = \"https://api.twitter.com/1.1/search/tweets.json\" response = make_twitter_request ( url , user_id , params ) return process_tweets ( response . json ( ) [ \"statuses\" ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given something that closely resembles a dictionary we attempt to coerce it into a propery dictionary . [CODESPLIT] def to_dict ( dictish ) : if hasattr ( dictish , 'iterkeys' ) : m = dictish . iterkeys elif hasattr ( dictish , 'keys' ) : m = dictish . keys else : raise ValueError ( dictish ) return dict ( ( k , dictish [ k ] ) for k in m ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determines if value value is empty . Keyword arguments : value str -- the value of the associated field to compare [CODESPLIT] def run ( self , value ) : if self . pass_ and not value . strip ( ) : return True if not value : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert a ctypes structure to a dictionary [CODESPLIT] def struct2dict ( struct ) : return { x : getattr ( struct , x ) for x in dict ( struct . _fields_ ) . keys ( ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deletes all the unnamed columns [CODESPLIT] def del_Unnamed ( df ) : cols_del = [ c for c in df . columns if 'Unnamed' in c ] return df . drop ( cols_del , axis = 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a modified list containing only the indices indicated . [CODESPLIT] def filter_list_by_indices ( lst , indices ) : return [ x for i , x in enumerate ( lst ) if i in indices ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the code to create the argtype to assign to the methods argtypes attribute . [CODESPLIT] def _py_ex_argtype ( executable ) : result = [ ] for p in executable . ordered_parameters : atypes = p . argtypes if atypes is not None : result . extend ( p . argtypes ) else : print ( ( \"No argtypes for: {}\" . format ( p . definition ( ) ) ) ) if type ( executable ) . __name__ == \"Function\" : result . extend ( executable . argtypes ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "All compartment properties as a dict . [CODESPLIT] def properties ( self ) : properties = { 'id' : self . _id } if self . _name is not None : properties [ 'name' ] = self . _name return properties", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Locate the command s man page . [CODESPLIT] def locate ( command , on ) : location = find_page_location ( command , on ) click . echo ( location )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get object from string reference . [CODESPLIT] def get_obj ( ref ) : oid = int ( ref ) return server . id2ref . get ( oid ) or server . id2obj [ oid ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates the average value of a list of numbers Returns a float [CODESPLIT] def calc_list_average ( l ) : total = 0.0 for value in l : total += value return total / len ( l )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coerce value to an JSON - compatible representation . [CODESPLIT] def _time_to_json ( value ) : if isinstance ( value , datetime . time ) : value = value . isoformat ( ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def copy ( obj ) : def copy ( self ) : \"\"\"\n        Copy self to a new object.\n        \"\"\" from copy import deepcopy return deepcopy ( self ) obj . copy = copy return obj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add widget actions to toolbar [CODESPLIT] def add_to_toolbar ( self , toolbar , widget ) : actions = widget . toolbar_actions if actions is not None : add_actions ( toolbar , actions )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the L1 - norm ( Manhattan ) distance between two points . [CODESPLIT] def distL1 ( x1 , y1 , x2 , y2 ) : return int ( abs ( x2 - x1 ) + abs ( y2 - y1 ) + .5 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper for lxml s find . [CODESPLIT] def find ( self , node , path ) : return node . find ( path , namespaces = self . namespaces )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Mark an operation deprecated . [CODESPLIT] def deprecated ( operation = None ) : def inner ( o ) : o . deprecated = True return o return inner ( operation ) if operation else inner", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def _make_proxy_property ( bind_attr , attr_name ) : def proxy_property ( self ) : \"\"\"\n        proxy\n        \"\"\" bind = getattr ( self , bind_attr ) return getattr ( bind , attr_name ) return property ( proxy_property )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function used to fit the exponential decay . [CODESPLIT] def exp_fit_fun ( x , a , tau , c ) : # pylint: disable=invalid-name return a * np . exp ( - x / tau ) + c", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get trace_id from flask request headers . [CODESPLIT] def get_trace_id_from_flask ( ) : if flask is None or not flask . request : return None header = flask . request . headers . get ( _FLASK_TRACE_HEADER ) if header is None : return None trace_id = header . split ( \"/\" , 1 ) [ 0 ] return trace_id", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Formats the given number in decimal format using a period and commas [CODESPLIT] def fixed ( ctx , number , decimals = 2 , no_commas = False ) : value = _round ( ctx , number , decimals ) format_str = '{:f}' if no_commas else '{:,f}' return format_str . format ( value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert from latitude to the y position in overall map . [CODESPLIT] def _convert_latitude ( self , latitude ) : return int ( ( 180 - ( 180 / pi * log ( tan ( pi / 4 + latitude * pi / 360 ) ) ) ) * ( 2 ** self . _zoom ) * self . _size / 360 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the path of java executable [CODESPLIT] def get_java_path ( ) : java_home = os . environ . get ( \"JAVA_HOME\" ) return os . path . join ( java_home , BIN_DIR , \"java\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Manually specify the x - axis log tick values . [CODESPLIT] def set_logxticks_for_all ( self , row_column_list = None , logticks = None ) : if row_column_list is None : self . ticks [ 'x' ] = [ '1e%d' % u for u in logticks ] else : for row , column in row_column_list : self . set_logxticks ( row , column , logticks )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the kind ( type ) of the attribute [CODESPLIT] def get_kind ( self , value ) : if isinstance ( value , float ) : return 'f' elif isinstance ( value , int ) : return 'i' else : raise ValueError ( \"Only integer or floating point values can be stored.\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Square of the euclidean distance [CODESPLIT] def euclidean ( c1 , c2 ) : diffs = ( ( i - j ) for i , j in zip ( c1 , c2 ) ) return sum ( x * x for x in diffs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieves a list of member - like objects ( members or properties ) that are publically exposed . [CODESPLIT] def get_public_members ( obj ) : return { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( \"_\" ) and not hasattr ( getattr ( obj , attr ) , '__call__' ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Plot the empirical histogram versus best - fit distribution s PDF . [CODESPLIT] def plot ( self ) : plt . plot ( self . bin_edges , self . hist , self . bin_edges , self . best_pdf )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "writes the line and count newlines after the line [CODESPLIT] def write_line ( self , line , count = 1 ) : self . write ( line ) self . write_newlines ( count )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generates a LaTeX table from parameter summaries . [CODESPLIT] def get_latex_table ( self , parameters = None , transpose = False , caption = None , label = \"tab:model_params\" , hlines = True , blank_fill = \"--\" ) : # pragma: no cover if parameters is None : parameters = self . parent . _all_parameters for p in parameters : assert isinstance ( p , str ) , \"Generating a LaTeX table requires all parameters have labels\" num_parameters = len ( parameters ) num_chains = len ( self . parent . chains ) fit_values = self . get_summary ( squeeze = False ) if label is None : label = \"\" if caption is None : caption = \"\" end_text = \" \\\\\\\\ \\n\" if transpose : column_text = \"c\" * ( num_chains + 1 ) else : column_text = \"c\" * ( num_parameters + 1 ) center_text = \"\" hline_text = \"\\\\hline\\n\" if hlines : center_text += hline_text + \"\\t\\t\" if transpose : center_text += \" & \" . join ( [ \"Parameter\" ] + [ c . name for c in self . parent . chains ] ) + end_text if hlines : center_text += \"\\t\\t\" + hline_text for p in parameters : arr = [ \"\\t\\t\" + p ] for chain_res in fit_values : if p in chain_res : arr . append ( self . get_parameter_text ( * chain_res [ p ] , wrap = True ) ) else : arr . append ( blank_fill ) center_text += \" & \" . join ( arr ) + end_text else : center_text += \" & \" . join ( [ \"Model\" ] + parameters ) + end_text if hlines : center_text += \"\\t\\t\" + hline_text for name , chain_res in zip ( [ c . name for c in self . parent . chains ] , fit_values ) : arr = [ \"\\t\\t\" + name ] for p in parameters : if p in chain_res : arr . append ( self . get_parameter_text ( * chain_res [ p ] , wrap = True ) ) else : arr . append ( blank_fill ) center_text += \" & \" . join ( arr ) + end_text if hlines : center_text += \"\\t\\t\" + hline_text final_text = get_latex_table_frame ( caption , label ) % ( column_text , center_text ) return final_text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Init a noise variable . [CODESPLIT] def normal_noise ( points ) : return np . random . rand ( 1 ) * np . random . randn ( points , 1 ) + random . sample ( [ 2 , - 2 ] , 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test for ReverseDNS class [CODESPLIT] def test ( ) : dns = ReverseDNS ( ) print ( dns . lookup ( '192.168.0.1' ) ) print ( dns . lookup ( '8.8.8.8' ) ) # Test cache print ( dns . lookup ( '8.8.8.8' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find rightmost value less than or equal to x . [CODESPLIT] def find_le ( a , x ) : i = bs . bisect_right ( a , x ) if i : return i - 1 raise ValueError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns whether the specified element selector is present on the page . [CODESPLIT] def is_element_present ( driver , selector , by = By . CSS_SELECTOR ) : try : driver . find_element ( by = by , value = selector ) return True except Exception : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the circular permutation for a given list of items . [CODESPLIT] def circ_permutation ( items ) : permutations = [ ] for i in range ( len ( items ) ) : permutations . append ( items [ i : ] + items [ : i ] ) return permutations", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a tif file to a 2D NumPy array [CODESPLIT] def ReadTif ( tifFile ) : img = Image . open ( tifFile ) img = np . array ( img ) return img", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get attribute from the target object [CODESPLIT] def get_attr ( self , method_name ) : return self . attrs . get ( method_name ) or self . get_callable_attr ( method_name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the index of elem in the reversed iterator . [CODESPLIT] def index ( self , elem ) : return _coconut . len ( self . _iter ) - self . _iter . index ( elem ) - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a tuple that contains ( width height ) Pass in a url to an image and find out its size without loading the whole file If the image wxh could not be found the tuple will contain None values [CODESPLIT] def get_image_dimension ( self , url ) : w_h = ( None , None ) try : if url . startswith ( '//' ) : url = 'http:' + url data = requests . get ( url ) . content im = Image . open ( BytesIO ( data ) ) w_h = im . size except Exception : logger . warning ( \"Error getting image size {}\" . format ( url ) , exc_info = True ) return w_h", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a single datatable according to the hint GET variable from an AJAX request . [CODESPLIT] def get_active_ajax_datatable ( self ) : data = getattr ( self . request , self . request . method ) datatables_dict = self . get_datatables ( only = data [ 'datatable' ] ) return list ( datatables_dict . values ( ) ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Finds parent folder of file [CODESPLIT] def get_parent_folder_name ( file_path ) : return os . path . split ( os . path . split ( os . path . abspath ( file_path ) ) [ 0 ] ) [ - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a vector and return the normalized vector : param v : a vector v : returns : normalized vector v [CODESPLIT] def normalize_vector ( v ) : norm = np . linalg . norm ( v ) return v / norm if not norm == 0 else v", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the output shape from an array . [CODESPLIT] def out_shape_from_array ( arr ) : arr = np . asarray ( arr ) if arr . ndim == 1 : return arr . shape else : return ( arr . shape [ 1 ] , )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If pair is in search_list return the index . Otherwise return - 1 [CODESPLIT] def is_in ( self , search_list , pair ) : index = - 1 for nr , i in enumerate ( search_list ) : if ( np . all ( i == pair ) ) : return nr return index", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return indices of inputs to the node with the given index . [CODESPLIT] def get_inputs_from_cm ( index , cm ) : return tuple ( i for i in range ( cm . shape [ 0 ] ) if cm [ i ] [ index ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Provide a command prompt . [CODESPLIT] def input ( self , prompt , default = None , show_default = True ) : return click . prompt ( prompt , default = default , show_default = show_default )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Close the db and release memory [CODESPLIT] def close ( self ) : if self . db is not None : self . db . commit ( ) self . db . close ( ) self . db = None return", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Just the last entry . [CODESPLIT] def get_last ( self , table = None ) : if table is None : table = self . main_table query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table return self . own_cursor . execute ( query ) . fetchone ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def difference ( ydata1 , ydata2 ) : y1 = _n . array ( ydata1 ) y2 = _n . array ( ydata2 ) return ( sum ( y2 - y1 ) / len ( ydata1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call ioctl () with given parameters . [CODESPLIT] def _ioctl ( self , func , args ) : import fcntl return fcntl . ioctl ( self . sockfd . fileno ( ) , func , args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert iterable object into numpy array [CODESPLIT] def A ( * a ) : return np . array ( a [ 0 ] ) if len ( a ) == 1 else [ np . array ( o ) for o in a ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pops a row default the last [CODESPLIT] def pop_row ( self , idr = None , tags = False ) : idr = idr if idr is not None else len ( self . body ) - 1 row = self . body . pop ( idr ) return row if tags else [ cell . childs [ 0 ] for cell in row ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Change a date string from the format 2018 - 08 - 15T23 : 55 : 17 into a datetime object [CODESPLIT] def convert_time_string ( date_str ) : dt , _ , _ = date_str . partition ( \".\" ) dt = datetime . strptime ( dt , \"%Y-%m-%dT%H:%M:%S\" ) return dt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the nth value of array [CODESPLIT] def _nth ( arr , n ) : try : return arr . iloc [ n ] except ( KeyError , IndexError ) : return np . nan", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a JSON - compatible structure capable turn the new record back into the old record . The parameters must be structures compatible with json . dumps * or * strings compatible with json . loads . Note that by design old == record_patch ( new record_diff ( old new )) [CODESPLIT] def record_diff ( old , new ) : old , new = _norm_json_params ( old , new ) return json_delta . diff ( new , old , verbose = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return current free memory on the machine for windows . [CODESPLIT] def get_free_memory_win ( ) : stat = MEMORYSTATUSEX ( ) ctypes . windll . kernel32 . GlobalMemoryStatusEx ( ctypes . byref ( stat ) ) return int ( stat . ullAvailPhys / 1024 / 1024 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Open and load JSON from file . [CODESPLIT] def read_json ( location ) : location = ensure_path ( location ) with location . open ( 'r' , encoding = 'utf8' ) as f : return ujson . load ( f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dictionary of words and word counts in a string . [CODESPLIT] def wordfreq ( text , is_filename = False ) : if is_filename : with open ( text ) as f : text = f . read ( ) freqs = { } for word in text . split ( ) : lword = word . lower ( ) freqs [ lword ] = freqs . get ( lword , 0 ) + 1 return freqs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function used to fit the exponential decay . [CODESPLIT] def exp_fit_fun ( x , a , tau , c ) : # pylint: disable=invalid-name return a * np . exp ( - x / tau ) + c", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert JSON object to a string [CODESPLIT] def get_prep_value ( self , value ) : if self . null and value is None : return None return json . dumps ( value , * * self . dump_kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if a value is numeric . [CODESPLIT] def is_numeric ( value ) : return type ( value ) in [ int , float , np . int8 , np . int16 , np . int32 , np . int64 , np . float16 , np . float32 , np . float64 , np . float128 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator to explicitly mark functions that are exposed in a lib . [CODESPLIT] def export ( defn ) : globals ( ) [ defn . __name__ ] = defn __all__ . append ( defn . __name__ ) return defn", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check to see if this matrix is an identity matrix . [CODESPLIT] def is_identity ( ) : for index , row in enumerate ( self . dta ) : if row [ index ] == 1 : for num , element in enumerate ( row ) : if num != index : if element != 0 : return False else : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "One - hot encode labels from input [CODESPLIT] def one_hot_encoding ( input_tensor , num_labels ) : xview = input_tensor . view ( - 1 , 1 ) . to ( torch . long ) onehot = torch . zeros ( xview . size ( 0 ) , num_labels , device = input_tensor . device , dtype = torch . float ) onehot . scatter_ ( 1 , xview , 1 ) return onehot . view ( list ( input_tensor . shape ) + [ - 1 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a leading hash # at the beginning of every line in the source . [CODESPLIT] def _add_hash ( source ) : source = '\\n' . join ( '# ' + line . rstrip ( ) for line in source . splitlines ( ) ) return source", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compare the attr of the entry dn with given value . [CODESPLIT] def compare ( self , dn , attr , value ) : return self . connection . compare_s ( dn , attr , value ) == 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "at least one file must exist for multiqc to run properly [CODESPLIT] def _one_exists ( input_files ) : for f in input_files : if os . path . exists ( f ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Maxheap version of a heappop . [CODESPLIT] def heappop_max ( heap ) : lastelt = heap . pop ( ) # raises appropriate IndexError if heap is empty if heap : returnitem = heap [ 0 ] heap [ 0 ] = lastelt _siftup_max ( heap , 0 ) return returnitem return lastelt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns number of days for the given year and month [CODESPLIT] def days_in_month ( year , month ) : eom = _days_per_month [ month - 1 ] if is_leap_year ( year ) and month == 2 : eom += 1 return eom", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Disable event loop integration with wxPython . [CODESPLIT] def disable_wx ( self ) : if self . _apps . has_key ( GUI_WX ) : self . _apps [ GUI_WX ] . _in_event_loop = False self . clear_inputhook ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print the given item and all children items [CODESPLIT] def print_item_with_children ( ac , classes , level ) : print_row ( ac . id , ac . name , f\"{ac.allocation:,.2f}\" , level ) print_children_recursively ( classes , ac , level + 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Computes l2 norm of params by flattening them into a vector . [CODESPLIT] def l2_norm ( params ) : flattened , _ = flatten ( params ) return np . dot ( flattened , flattened )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "abstract method [CODESPLIT] def poke_array ( self , store , name , elemtype , elements , container , visited , _stack ) : raise NotImplementedError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if list contains either values of type vtype or None . [CODESPLIT] def is_nullable_list ( val , vtype ) : return ( isinstance ( val , list ) and any ( isinstance ( v , vtype ) for v in val ) and all ( ( isinstance ( v , vtype ) or v is None ) for v in val ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param list_of_points : : return : list_of_points with None s removed [CODESPLIT] def filter_none ( list_of_points ) : remove_elementnone = filter ( lambda p : p is not None , list_of_points ) remove_sublistnone = filter ( lambda p : not contains_none ( p ) , remove_elementnone ) return list ( remove_sublistnone )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Establish tunnel connection early because otherwise httplib would improperly set Host : header to proxy s IP : port . [CODESPLIT] def _prepare_proxy ( self , conn ) : conn . set_tunnel ( self . _proxy_host , self . port , self . proxy_headers ) conn . connect ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shape a list of lists into the appropriate shape and data type [CODESPLIT] def shape_list ( l , shape , dtype ) : return np . array ( l , dtype = dtype ) . reshape ( shape )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert special characters using %xx escape . [CODESPLIT] def url_encode ( url ) : if isinstance ( url , text_type ) : url = url . encode ( 'utf8' ) return quote ( url , ':/%?&=' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rebuild list_object removing duplicated and keeping order [CODESPLIT] def deduplicate ( list_object ) : new = [ ] for item in list_object : if item not in new : new . append ( item ) return new", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Natural logarithm [CODESPLIT] def log ( x ) : if isinstance ( x , UncertainFunction ) : mcpts = np . log ( x . _mcpts ) return UncertainFunction ( mcpts ) else : return np . log ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "load the content of an hdf5 file to a dict . [CODESPLIT] def hdf5_to_dict ( filepath , group = '/' ) : if not h5py . is_hdf5 ( filepath ) : raise RuntimeError ( filepath , 'is not a valid HDF5 file.' ) with h5py . File ( filepath , 'r' ) as handler : dic = walk_hdf5_to_dict ( handler [ group ] ) return dic", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Loads a model from specified file [CODESPLIT] def Load ( file ) : with open ( file , 'rb' ) as file : model = dill . load ( file ) return model", "target": 1, "target_options": ["no_match", "match"]}
{"input": "save something to a pickle file [CODESPLIT] def pickle_save ( thing , fname ) : pickle . dump ( thing , open ( fname , \"wb\" ) , pickle . HIGHEST_PROTOCOL ) return thing", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Loads a model from specified file [CODESPLIT] def Load ( file ) : with open ( file , 'rb' ) as file : model = dill . load ( file ) return model", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert snake case to camel case [CODESPLIT] def camel_case ( self , snake_case ) : components = snake_case . split ( '_' ) return components [ 0 ] + \"\" . join ( x . title ( ) for x in components [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns locals dictionary from a given frame . [CODESPLIT] def get_frame_locals ( stepback = 0 ) : with Frame ( stepback = stepback ) as frame : locals_dict = frame . f_locals return locals_dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a datetime object of a given timestamp ( in local tz ) . [CODESPLIT] def fromtimestamp ( cls , timestamp ) : d = cls . utcfromtimestamp ( timestamp ) return d . astimezone ( localtz ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Lock connection from being used else where [CODESPLIT] def lock ( self , block = True ) : self . _locked = True return self . _lock . acquire ( block )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "underscore to mixed case notation [CODESPLIT] def case_us2mc ( x ) : return re . sub ( r'_([a-z])' , lambda m : ( m . group ( 1 ) . upper ( ) ) , x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Output file contents to stdout [CODESPLIT] def do_file_show ( client , args ) : for src_uri in args . uris : client . download_file ( src_uri , sys . stdout . buffer ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns all lines written to the passed in stream [CODESPLIT] def getLinesFromLogFile ( stream ) : stream . flush ( ) stream . seek ( 0 ) lines = stream . readlines ( ) return lines", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convenient shorthand for toarray ( * args ** kwargs ) . view ( np . recarray ) . [CODESPLIT] def torecarray ( * args , * * kwargs ) : import numpy as np return toarray ( * args , * * kwargs ) . view ( np . recarray )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Display all available logging information . [CODESPLIT] def pylog ( self , * args , * * kwargs ) : printerr ( self . name , args , kwargs , traceback . format_exc ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a conda environment inside the current sandbox for the given list of dependencies and options . [CODESPLIT] def create_conda_env ( sandbox_dir , env_name , dependencies , options = ( ) ) : env_dir = os . path . join ( sandbox_dir , env_name ) cmdline = [ \"conda\" , \"create\" , \"--yes\" , \"--copy\" , \"--quiet\" , \"-p\" , env_dir ] + list ( options ) + dependencies log . info ( \"Creating conda environment: \" ) log . info ( \"  command line: %s\" , cmdline ) subprocess . check_call ( cmdline , stderr = subprocess . PIPE , stdout = subprocess . PIPE ) log . debug ( \"Environment created\" ) return env_dir , env_name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Input validation for YHSM_YubiKeySecret or string . [CODESPLIT] def input_validate_yubikey_secret ( data , name = 'data' ) : if isinstance ( data , pyhsm . aead_cmd . YHSM_YubiKeySecret ) : data = data . pack ( ) return input_validate_str ( data , name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform auth request for token . [CODESPLIT] def auth_request ( self , url , headers , body ) : return self . req . post ( url , headers , body = body )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Log all data received from RFLink to file . [CODESPLIT] def log_all ( self , file ) : global rflink_log if file == None : rflink_log = None else : log . debug ( 'logging to: %s' , file ) rflink_log = open ( file , 'a' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adjust the bounding box as specified by user . Returns the adjusted bounding box . [CODESPLIT] def adjust_bounding_box ( bbox ) : for i in range ( 0 , 4 ) : if i in bounding_box : bbox [ i ] = bounding_box [ i ] else : bbox [ i ] += delta_bounding_box [ i ] return bbox", "target": 1, "target_options": ["no_match", "match"]}
{"input": "print the message to the predefined log file without newline [CODESPLIT] def log_no_newline ( self , msg ) : self . print2file ( self . logfile , False , False , msg )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Attempts to turn a SIGTERM exception into a SystemExit exception . [CODESPLIT] def _turn_sigterm_into_systemexit ( ) : # pragma: no cover try : import signal except ImportError : return def handle_term ( signo , frame ) : raise SystemExit signal . signal ( signal . SIGTERM , handle_term )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Draw lines between groups [CODESPLIT] def patch_lines ( x ) : for idx in range ( len ( x ) - 1 ) : x [ idx ] = np . vstack ( [ x [ idx ] , x [ idx + 1 ] [ 0 , : ] ] ) return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a queue log handler to the global logger . [CODESPLIT] def add_queue_handler ( queue ) : handler = QueueLogHandler ( queue ) handler . setFormatter ( QueueFormatter ( ) ) handler . setLevel ( DEBUG ) GLOBAL_LOGGER . addHandler ( handler )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The constants referenced in this code object . [CODESPLIT] def consts ( self ) : # We cannot use a set comprehension because consts do not need # to be hashable. consts = [ ] append_const = consts . append for instr in self . instrs : if isinstance ( instr , LOAD_CONST ) and instr . arg not in consts : append_const ( instr . arg ) return tuple ( consts )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Left addition . [CODESPLIT] def __add__ ( self , other ) : return chaospy . poly . collection . arithmetics . add ( self , other )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transforms the regular socket . socket to an ssl . SSLSocket for secure connections . Any arguments are passed to ssl . wrap_socket : http : // docs . python . org / dev / library / ssl . html#ssl . wrap_socket [CODESPLIT] def enable_ssl ( self , * args , * * kwargs ) : if self . handshake_sent : raise SSLError ( 'can only enable SSL before handshake' ) self . secure = True self . sock = ssl . wrap_socket ( self . sock , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "These actions will be done after SIGTERM . [CODESPLIT] def sigterm ( self , signum , frame ) : self . logger . warning ( \"Caught signal %s. Stopping daemon.\" % signum ) sys . exit ( 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes input from user . Works for Python 2 and 3 . [CODESPLIT] def _stdin_ ( p ) : _v = sys . version [ 0 ] return input ( p ) if _v is '3' else raw_input ( p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes quotes and decodes escape sequences from given MySQL string literal returning the result . [CODESPLIT] def decode_mysql_string_literal ( text ) : assert text . startswith ( \"'\" ) assert text . endswith ( \"'\" ) # Ditch quotes from the string literal. text = text [ 1 : - 1 ] return MYSQL_STRING_ESCAPE_SEQUENCE_PATTERN . sub ( unescape_single_character , text , )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print emphasized good the given txt message [CODESPLIT] def good ( txt ) : print ( \"%s# %s%s%s\" % ( PR_GOOD_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The how well do the features plus a constant base rate sum up to the model output . [CODESPLIT] def local_accuracy ( X_train , y_train , X_test , y_test , attr_test , model_generator , metric , trained_model ) : X_train , X_test = to_array ( X_train , X_test ) # how many features to mask assert X_train . shape [ 1 ] == X_test . shape [ 1 ] # keep nkeep top features and re-train the model for each test explanation yp_test = trained_model . predict ( X_test ) return metric ( yp_test , strip_list ( attr_test ) . sum ( 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the area of a bounding box in pixels . [CODESPLIT] def calculate_bbox_area ( bbox , rows , cols ) : bbox = denormalize_bbox ( bbox , rows , cols ) x_min , y_min , x_max , y_max = bbox [ : 4 ] area = ( x_max - x_min ) * ( y_max - y_min ) return area", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clean up environment [CODESPLIT] def tearDown ( self ) : if self . sdkobject and self . sdkobject . id : self . sdkobject . delete ( ) self . sdkobject . id = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit the program due to user s choices . [CODESPLIT] def quit ( self ) : self . script . LOG . warn ( \"Abort due to user choice!\" ) sys . exit ( self . QUIT_RC )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param string s : under_scored string to be CamelCased : return : CamelCase version of input : rtype : str [CODESPLIT] def to_camel ( s ) : # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups return re . sub ( r'_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , '_' + s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "manually set the default figure size of plots :: Arguments :: x ( float ) : x - axis size y ( float ) : y - axis size aspect ( float ) : aspect ratio scalar [CODESPLIT] def figsize ( x = 8 , y = 7. , aspect = 1. ) : # update rcparams with adjusted figsize params mpl . rcParams . update ( { 'figure.figsize' : ( x * aspect , y ) } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns svg from matplotlib chart [CODESPLIT] def fig2x ( figure , format ) : # Save svg to file like object svg_io io = StringIO ( ) figure . savefig ( io , format = format ) # Rewind the file like object io . seek ( 0 ) data = io . getvalue ( ) io . close ( ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Scale the image in a channel . Also see : meth : zoom_to . [CODESPLIT] def set_scale ( self , scale , no_reset = False ) : return self . scale_to ( * scale [ : 2 ] , no_reset = no_reset )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Maxheap version of a heappop . [CODESPLIT] def _heappop_max ( heap ) : lastelt = heap . pop ( ) # raises appropriate IndexError if heap is empty if heap : returnitem = heap [ 0 ] heap [ 0 ] = lastelt _siftup_max ( heap , 0 ) return returnitem return lastelt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Merge two nested dicts . [CODESPLIT] def nested_update ( d , u ) : for k , v in list ( u . items ( ) ) : if isinstance ( v , collections . Mapping ) : r = nested_update ( d . get ( k , { } ) , v ) d [ k ] = r else : d [ k ] = u [ k ] return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flat nested list of lists into a single list . [CODESPLIT] def flatten ( l , types = ( list , float ) ) : l = [ item if isinstance ( item , types ) else [ item ] for item in l ] return [ item for sublist in l for item in sublist ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a Status instance from its string representation . [CODESPLIT] def from_string ( cls , s ) : for num , text in cls . _STATUS2STR . items ( ) : if text == s : return cls ( num ) else : raise ValueError ( \"Wrong string %s\" % s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get a value from a tag ( if it exists ) [CODESPLIT] def _get_minidom_tag_value ( station , tag_name ) : tag = station . getElementsByTagName ( tag_name ) [ 0 ] . firstChild if tag : return tag . nodeValue return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Populates an object s attributes using the provided dict [CODESPLIT] def populate_obj ( obj , attrs ) : for k , v in attrs . iteritems ( ) : setattr ( obj , k , v )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handle conversion of pymongo cursor into a JSON object formatted for UI consumption [CODESPLIT] def _obj_cursor_to_dictionary ( self , cursor ) : if not cursor : return cursor cursor = json . loads ( json . dumps ( cursor , cls = BSONEncoder ) ) if cursor . get ( \"_id\" ) : cursor [ \"id\" ] = cursor . get ( \"_id\" ) del cursor [ \"_id\" ] return cursor", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns an active connection cursor to the database . [CODESPLIT] def create_cursor ( self , name = None ) : return Cursor ( self . client_connection , self . connection , self . djongo_connection )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert arrays of datetime . datetime and datetime . timedelta objects into datetime64 and timedelta64 according to the pandas convention . [CODESPLIT] def _possibly_convert_objects ( values ) : return np . asarray ( pd . Series ( values . ravel ( ) ) ) . reshape ( values . shape )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns whether the provided name is a valid variable name in Python [CODESPLIT] def is_valid_variable_name ( string_to_check ) : try : parse ( '{} = None' . format ( string_to_check ) ) return True except ( SyntaxError , ValueError , TypeError ) : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Move the cursor up a number of lines . [CODESPLIT] def move_up ( lines = 1 , file = sys . stdout ) : move . up ( lines ) . write ( file = file )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply func to lines of text in parallel or sequential . [CODESPLIT] def apply ( self , func , workers = 1 , job_size = 10000 ) : if workers == 1 : for lines in self . iter_chunks ( job_size ) : yield func ( lines ) else : with ProcessPoolExecutor ( max_workers = workers ) as executor : for result in executor . map ( func , self . iter_chunks ( job_size ) ) : yield result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine whether indicated file appears to be a gzipped FASTQ . [CODESPLIT] def is_gzipped_fastq ( file_name ) : _ , ext = os . path . splitext ( file_name ) return file_name . endswith ( \".fastq.gz\" ) or file_name . endswith ( \".fq.gz\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine whether two strings are equivalent . [CODESPLIT] def eqstr ( a , b ) : return bool ( libspice . eqstr_c ( stypes . stringToCharP ( a ) , stypes . stringToCharP ( b ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Callable function for the multiprocessing pool . [CODESPLIT] def compute ( args ) : x , y , params = args return x , y , mandelbrot ( x , y , params )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if element is empty ( if requested ) . [CODESPLIT] def match_empty ( self , el ) : is_empty = True for child in self . get_children ( el , tags = False ) : if self . is_tag ( child ) : is_empty = False break elif self . is_content_string ( child ) and RE_NOT_EMPTY . search ( child ) : is_empty = False break return is_empty", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check that value is in values [CODESPLIT] def isin ( value , values ) : for i , v in enumerate ( value ) : if v not in np . array ( values ) [ : , i ] : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Scipy norm function [CODESPLIT] def norm ( x , mu , sigma = 1.0 ) : return stats . norm ( loc = mu , scale = sigma ) . pdf ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an instance of QApplication . Creates one if neccessary . [CODESPLIT] def get_qapp ( ) : global app app = QtGui . QApplication . instance ( ) if app is None : app = QtGui . QApplication ( [ ] , QtGui . QApplication . GuiClient ) return app", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Abstraction over executemany method [CODESPLIT] def store_many ( self , sql , values ) : cursor = self . get_cursor ( ) cursor . executemany ( sql , values ) self . conn . commit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse bytes and return a namedtuple . [CODESPLIT] def unpack ( self , s ) : return self . _create ( super ( NamedStruct , self ) . unpack ( s ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates data is a timestamp [CODESPLIT] def is_timestamp ( instance ) : if not isinstance ( instance , ( int , str ) ) : return True return datetime . fromtimestamp ( int ( instance ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Report whether another set contains this RangeSet . [CODESPLIT] def issubset ( self , other ) : self . _binary_sanity_check ( other ) return set . issubset ( self , other )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check lowercase key item . [CODESPLIT] def __contains__ ( self , key ) : assert isinstance ( key , basestring ) return dict . __contains__ ( self , key . lower ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Unary negation [CODESPLIT] def __neg__ ( self ) : return self . __class__ ( self [ 0 ] , self . _curve . p ( ) - self [ 1 ] , self . _curve )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Output a networkx graph to a DOT file . [CODESPLIT] def to_dotfile ( G : nx . DiGraph , filename : str ) : A = to_agraph ( G ) A . write ( filename )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if given string is a punctuation [CODESPLIT] def is_punctuation ( text ) : return not ( text . lower ( ) in config . AVRO_VOWELS or text . lower ( ) in config . AVRO_CONSONANTS )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write DOT comment . [CODESPLIT] def comment ( self , s , * * args ) : self . write ( u\"// \" ) self . writeln ( s = s , * * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The how well do the features plus a constant base rate sum up to the model output . [CODESPLIT] def local_accuracy ( X_train , y_train , X_test , y_test , attr_test , model_generator , metric , trained_model ) : X_train , X_test = to_array ( X_train , X_test ) # how many features to mask assert X_train . shape [ 1 ] == X_test . shape [ 1 ] # keep nkeep top features and re-train the model for each test explanation yp_test = trained_model . predict ( X_test ) return metric ( yp_test , strip_list ( attr_test ) . sum ( 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Init a noise variable . [CODESPLIT] def normal_noise ( points ) : return np . random . rand ( 1 ) * np . random . randn ( points , 1 ) + random . sample ( [ 2 , - 2 ] , 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return number of empty lines at the end of the document . [CODESPLIT] def empty_line_count_at_the_end ( self ) : count = 0 for line in self . lines [ : : - 1 ] : if not line or line . isspace ( ) : count += 1 else : break return count", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is an object iterable like a list ( and not a string ) ? [CODESPLIT] def listlike ( obj ) : return hasattr ( obj , \"__iter__\" ) and not issubclass ( type ( obj ) , str ) and not issubclass ( type ( obj ) , unicode )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper that clears the composition . [CODESPLIT] def _clear ( self ) : draw = ImageDraw . Draw ( self . _background_image ) draw . rectangle ( self . _device . bounding_box , fill = \"black\" ) del draw", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize name for the Statsd convention [CODESPLIT] def normalize ( name ) : # Name should not contain some specials chars (issue #1068) ret = name . replace ( ':' , '' ) ret = ret . replace ( '%' , '' ) ret = ret . replace ( ' ' , '_' ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run application tests [CODESPLIT] def test ( nose_argsuments ) : from nose import run params = [ '__main__' , '-c' , 'nose.ini' ] params . extend ( nose_argsuments ) run ( argv = params )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple measure of similarity : Number of letters in common / max length [CODESPLIT] def basic_word_sim ( word1 , word2 ) : return sum ( [ 1 for c in word1 if c in word2 ] ) / max ( len ( word1 ) , len ( word2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "move to util_iter [CODESPLIT] def isetdiff_flags ( list1 , list2 ) : set2 = set ( list2 ) return ( item not in set2 for item in list1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Note that this code compresses into a buffer held in memory rather than a disk file . This is done through the use of cStringIO . StringIO () . [CODESPLIT] def compressBuffer ( buffer ) : # http://jython.xhaus.com/http-compression-in-python-and-jython/ zbuf = cStringIO . StringIO ( ) zfile = gzip . GzipFile ( mode = 'wb' , fileobj = zbuf , compresslevel = 9 ) zfile . write ( buffer ) zfile . close ( ) return zbuf . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generates and returns a numpy array from raw data bytes . [CODESPLIT] def _arrayFromBytes ( dataBytes , metadata ) : array = numpy . fromstring ( dataBytes , dtype = numpy . typeDict [ metadata [ 'dtype' ] ] ) if 'shape' in metadata : array = array . reshape ( metadata [ 'shape' ] ) return array", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like argsort but returns an index suitable for sorting the the original array even if that array is multidimensional [CODESPLIT] def argsort_indices ( a , axis = - 1 ) : a = np . asarray ( a ) ind = list ( np . ix_ ( * [ np . arange ( d ) for d in a . shape ] ) ) ind [ axis ] = a . argsort ( axis ) return tuple ( ind )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a stream discarding the data read and returns its size . [CODESPLIT] def _read_stream_for_size ( stream , buf_size = 65536 ) : size = 0 while True : buf = stream . read ( buf_size ) size += len ( buf ) if not buf : break return size", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like netCDF4 . stringtochar but faster and more flexible . [CODESPLIT] def _numpy_bytes_to_char ( arr ) : # ensure the array is contiguous arr = np . array ( arr , copy = False , order = 'C' , dtype = np . string_ ) return arr . reshape ( arr . shape + ( 1 , ) ) . view ( 'S1' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the log of the magnitude spectrum of frames [CODESPLIT] def log_magnitude_spectrum ( frames ) : return N . log ( N . abs ( N . fft . rfft ( frames ) ) . clip ( 1e-5 , N . inf ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a 1D list to a single long string for file output using the string . join function . [CODESPLIT] def list2string ( inlist , delimit = ' ' ) : stringlist = [ makestr ( _ ) for _ in inlist ] return string . join ( stringlist , delimit )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set up the logging file for a new session - include date and some whitespace [CODESPLIT] def setupLogFile ( self ) : self . logWrite ( \"\\n###############################################\" ) self . logWrite ( \"calcpkg.py log from \" + str ( datetime . datetime . now ( ) ) ) self . changeLogging ( True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "As a convenience turn Python lists and tuples into NumPy arrays . [CODESPLIT] def _to_array ( value ) : if isinstance ( value , ( tuple , list ) ) : return array ( value ) elif isinstance ( value , ( float , int ) ) : return np . float64 ( value ) else : return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve a simple OAuth Token for use with the local http client . [CODESPLIT] def get_oauth_token ( ) : url = \"{0}/token\" . format ( DEFAULT_ORIGIN [ \"Origin\" ] ) r = s . get ( url = url ) return r . json ( ) [ \"t\" ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is an object iterable like a list ( and not a string ) ? [CODESPLIT] def listlike ( obj ) : return hasattr ( obj , \"__iter__\" ) and not issubclass ( type ( obj ) , str ) and not issubclass ( type ( obj ) , unicode )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns factor and offset of linear regression function by least squares method . [CODESPLIT] def linearRegressionAnalysis ( series ) : n = safeLen ( series ) sumI = sum ( [ i for i , v in enumerate ( series ) if v is not None ] ) sumV = sum ( [ v for i , v in enumerate ( series ) if v is not None ] ) sumII = sum ( [ i * i for i , v in enumerate ( series ) if v is not None ] ) sumIV = sum ( [ i * v for i , v in enumerate ( series ) if v is not None ] ) denominator = float ( n * sumII - sumI * sumI ) if denominator == 0 : return None else : factor = ( n * sumIV - sumI * sumV ) / denominator / series . step offset = sumII * sumV - sumIV * sumI offset = offset / denominator - factor * series . start return factor , offset", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a json string representing the python object obj . [CODESPLIT] def to_json ( obj ) : i = StringIO . StringIO ( ) w = Writer ( i , encoding = 'UTF-8' ) w . write_value ( obj ) return i . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete index entirely ( removes all documents and mapping ) . [CODESPLIT] def delete_index ( index ) : logger . info ( \"Deleting search index: '%s'\" , index ) client = get_client ( ) return client . indices . delete ( index = index )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert the vector of labels dataY into one - hot encoding . [CODESPLIT] def to_one_hot ( dataY ) : nc = 1 + np . max ( dataY ) onehot = [ np . zeros ( nc , dtype = np . int8 ) for _ in dataY ] for i , j in enumerate ( dataY ) : onehot [ i ] [ j ] = 1 return onehot", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if the string is a palindrome ( https : // en . wikipedia . org / wiki / Palindrome ) . [CODESPLIT] def is_palindrome ( string , strict = True ) : if is_full_string ( string ) : if strict : return reverse ( string ) == string return is_palindrome ( SPACES_RE . sub ( '' , string ) ) return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def mouse_get_pos ( ) : p = POINT ( ) AUTO_IT . AU3_MouseGetPos ( ctypes . byref ( p ) ) return p . x , p . y", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def _index_ordering ( redshift_list ) : redshift_list = np . array ( redshift_list ) sort_index = np . argsort ( redshift_list ) return sort_index", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the coordinates from position in meters [CODESPLIT] def unproject ( self , xy ) : ( x , y ) = xy lng = x / EARTH_RADIUS * RAD_TO_DEG lat = 2 * atan ( exp ( y / EARTH_RADIUS ) ) - pi / 2 * RAD_TO_DEG return ( lng , lat )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pad the text . [CODESPLIT] def _pad ( self , text ) : top_bottom = ( \"\\n\" * self . _padding ) + \" \" right_left = \" \" * self . _padding * self . PAD_WIDTH return top_bottom + right_left + text + right_left + top_bottom", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Init a noise variable . [CODESPLIT] def normal_noise ( points ) : return np . random . rand ( 1 ) * np . random . randn ( points , 1 ) + random . sample ( [ 2 , - 2 ] , 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine with width in pixels of string . [CODESPLIT] def text_width ( string , font_name , font_size ) : return stringWidth ( string , fontName = font_name , fontSize = font_size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a datetime from the Amazon - provided datetime string [CODESPLIT] def clean_time ( time_string ) : # Get a timezone-aware datetime object from the string time = dateutil . parser . parse ( time_string ) if not settings . USE_TZ : # If timezone support is not active, convert the time to UTC and # remove the timezone field time = time . astimezone ( timezone . utc ) . replace ( tzinfo = None ) return time", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse a host : port string into separate components . [CODESPLIT] def parse_host_port ( host_port ) : host , port = urllib . splitport ( host_port . strip ( ) ) if port is not None : if urlutil . is_numeric_port ( port ) : port = int ( port ) return host , port", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts markdown content to text [CODESPLIT] def md_to_text ( content ) : text = None html = markdown . markdown ( content ) if html : text = html_to_text ( content ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The how well do the features plus a constant base rate sum up to the model output . [CODESPLIT] def local_accuracy ( X_train , y_train , X_test , y_test , attr_test , model_generator , metric , trained_model ) : X_train , X_test = to_array ( X_train , X_test ) # how many features to mask assert X_train . shape [ 1 ] == X_test . shape [ 1 ] # keep nkeep top features and re-train the model for each test explanation yp_test = trained_model . predict ( X_test ) return metric ( yp_test , strip_list ( attr_test ) . sum ( 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads the date from a string in the format YYYY / MM / DD and returns : class : datetime . date [CODESPLIT] def _read_date_from_string ( str1 ) : full_date = [ int ( x ) for x in str1 . split ( '/' ) ] return datetime . date ( full_date [ 0 ] , full_date [ 1 ] , full_date [ 2 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "iterator version of get_list_column [CODESPLIT] def iget_list_column_slice ( list_ , start = None , stop = None , stride = None ) : if isinstance ( start , slice ) : slice_ = start else : slice_ = slice ( start , stop , stride ) return ( row [ slice_ ] for row in list_ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clipboard paste as event handler [CODESPLIT] def OnPasteAs ( self , event ) : data = self . main_window . clipboard . get_clipboard ( ) key = self . main_window . grid . actions . cursor with undo . group ( _ ( \"Paste As...\" ) ) : self . main_window . actions . paste_as ( key , data ) self . main_window . grid . ForceRefresh ( ) event . Skip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a value in the range [ 0 1 ] to an RGB tuple using a colormap . [CODESPLIT] def _value_to_color ( value , cmap ) : cm = plt . get_cmap ( cmap ) rgba = cm ( value ) return [ int ( round ( 255 * v ) ) for v in rgba [ 0 : 3 ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return the first n sentences with highest ranking [CODESPLIT] def _rank ( self , ranking , n ) : return nlargest ( n , ranking , key = ranking . get )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Code due to Thomas Heller - published in Python Cookbook ( O Reilley ) [CODESPLIT] def debug_on_error ( type , value , tb ) : traceback . print_exc ( type , value , tb ) print ( ) pdb . pm ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get width and height of a PDF [CODESPLIT] def dimensions ( self ) : size = self . pdf . getPage ( 0 ) . mediaBox return { 'w' : float ( size [ 2 ] ) , 'h' : float ( size [ 3 ] ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns ------- topk : TopK filter expression [CODESPLIT] def topk ( arg , k , by = None ) : op = ops . TopK ( arg , k , by = by ) return op . to_expr ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flatten an iterable except for string elements . [CODESPLIT] def flatten ( iterables ) : for it in iterables : if isinstance ( it , str ) : yield it else : for element in it : yield element", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get letters from string only . [CODESPLIT] def return_letters_from_string ( text ) : out = \"\" for letter in text : if letter . isalpha ( ) : out += letter return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Draw a set of lines [CODESPLIT] def polyline ( self , arr ) : for i in range ( 0 , len ( arr ) - 1 ) : self . line ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] , arr [ i + 1 ] [ 0 ] , arr [ i + 1 ] [ 1 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "sets the aspect ratio of the current zoom level of the imshow image [CODESPLIT] def image_set_aspect ( aspect = 1.0 , axes = \"gca\" ) : if axes is \"gca\" : axes = _pylab . gca ( ) e = axes . get_images ( ) [ 0 ] . get_extent ( ) axes . set_aspect ( abs ( ( e [ 1 ] - e [ 0 ] ) / ( e [ 3 ] - e [ 2 ] ) ) / aspect )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Log - normal function from scipy [CODESPLIT] def lognorm ( x , mu , sigma = 1.0 ) : return stats . lognorm ( sigma , scale = mu ) . pdf ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a Seaborn linear regression plot [CODESPLIT] def _linear_seaborn_ ( self , label = None , style = None , opts = None ) : xticks , yticks = self . _get_ticks ( opts ) try : fig = sns . lmplot ( self . x , self . y , data = self . df ) fig = self . _set_with_height ( fig , opts ) return fig except Exception as e : self . err ( e , self . linear_ , \"Can not draw linear regression chart\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get rid of all axis ticks lines etc . [CODESPLIT] def axes_off ( ax ) : ax . set_frame_on ( False ) ax . axes . get_yaxis ( ) . set_visible ( False ) ax . axes . get_xaxis ( ) . set_visible ( False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "generic plotting method overplotting any existing plot [CODESPLIT] def oplot ( self , x , y , * * kw ) : self . panel . oplot ( x , y , * * kw )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list of string names of all available GPUs [CODESPLIT] def get_available_gpus ( ) : local_device_protos = device_lib . list_local_devices ( ) return [ x . name for x in local_device_protos if x . device_type == 'GPU' ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns all dates between two dates . [CODESPLIT] def dates_in_range ( start_date , end_date ) : return [ start_date + timedelta ( n ) for n in range ( int ( ( end_date - start_date ) . days ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty print the underlying literal Python object [CODESPLIT] def pprint ( self , stream = None , indent = 1 , width = 80 , depth = None ) : pp . pprint ( to_literal ( self ) , stream , indent , width , depth )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a generator of tuples k c such that k is the name of the python attribute for the column and c is the name of the column in the sql table . [CODESPLIT] def get_column_keys_and_names ( table ) : ins = inspect ( table ) return ( ( k , c . name ) for k , c in ins . mapper . c . items ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty printing for numpy matrix X [CODESPLIT] def print_matrix ( X , decimals = 1 ) : for row in np . round ( X , decimals = decimals ) : print ( row )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the base directory [CODESPLIT] def get_base_dir ( ) : return os . path . split ( os . path . abspath ( os . path . dirname ( __file__ ) ) ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts SoftLayer . CLI . formatting . Table instance to a prettytable . [CODESPLIT] def format_prettytable ( table ) : for i , row in enumerate ( table . rows ) : for j , item in enumerate ( row ) : table . rows [ i ] [ j ] = format_output ( item ) ptable = table . prettytable ( ) ptable . hrules = prettytable . FRAME ptable . horizontal_char = '.' ptable . vertical_char = ':' ptable . junction_char = ':' return ptable", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate combined size of tiles . [CODESPLIT] def get_combined_size ( tiles ) : # TODO: Refactor calculating layout to avoid repetition. columns , rows = calc_columns_rows ( len ( tiles ) ) tile_size = tiles [ 0 ] . image . size return ( tile_size [ 0 ] * columns , tile_size [ 1 ] * rows )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show current configuration . [CODESPLIT] def cli ( env ) : settings = config . get_settings_from_client ( env . client ) env . fout ( config . config_table ( settings ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the md5 hash for a file . [CODESPLIT] def get_md5_for_file ( file ) : md5 = hashlib . md5 ( ) while True : data = file . read ( md5 . block_size ) if not data : break md5 . update ( data ) return md5 . hexdigest ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print object information using a namedtuple and a format pattern . [CODESPLIT] def _prtstr ( self , obj , dashes ) : self . prt . write ( '{DASHES:{N}}' . format ( DASHES = self . fmt_dashes . format ( DASHES = dashes , ID = obj . item_id ) , N = self . dash_len ) ) self . prt . write ( \"{INFO}\\n\" . format ( INFO = str ( obj ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Used for debugging . [CODESPLIT] def debug ( ftn , txt ) : if debug_p : sys . stdout . write ( \"{0}.{1}:{2}\\n\" . format ( modname , ftn , txt ) ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def process_instance ( self , instance ) : self . log . debug ( \"e = mc^2\" ) self . log . info ( \"About to fail..\" ) self . log . warning ( \"Failing.. soooon..\" ) self . log . critical ( \"Ok, you're done.\" ) assert False , \"\"\"ValidateFailureMock was destined to fail..\n\nHere's some extended information about what went wrong.\n\nIt has quite the long string associated with it, including\na few newlines and a list.\n\n- Item 1\n- Item 2\n\n\"\"\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the week start date and end date [CODESPLIT] def get_week_start_end_day ( ) : t = date . today ( ) wd = t . weekday ( ) return ( t - timedelta ( wd ) , t + timedelta ( 6 - wd ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "kill process Args : process - Popen object for process [CODESPLIT] def kill_mprocess ( process ) : if process and proc_alive ( process ) : process . terminate ( ) process . communicate ( ) return not proc_alive ( process )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set __doc__ of * method * to __doc__ of * method * in its parent class . [CODESPLIT] def inheritdoc ( method ) : method . __doc__ = getattr ( str , method . __name__ ) . __doc__ return method", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Provide a command prompt . [CODESPLIT] def input ( self , prompt , default = None , show_default = True ) : return click . prompt ( prompt , default = default , show_default = show_default )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Value of property . [CODESPLIT] def value ( self ) : if self . _prop . fget is None : raise AttributeError ( 'Unable to read attribute' ) return self . _prop . fget ( self . _obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Private method that sets the value currently of the property [CODESPLIT] def _set_property ( self , val , * args ) : val = UserClassAdapter . _set_property ( self , val , * args ) if val : Adapter . _set_property ( self , val , * args ) return val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Value of property . [CODESPLIT] def value ( self ) : if self . _prop . fget is None : raise AttributeError ( 'Unable to read attribute' ) return self . _prop . fget ( self . _obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse a string into a Message object model . [CODESPLIT] def message_from_string ( s , * args , * * kws ) : from future . backports . email . parser import Parser return Parser ( * args , * * kws ) . parsestr ( s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns true if the specified error category is suppressed on this line . [CODESPLIT] def IsErrorSuppressedByNolint ( category , linenum ) : return ( linenum in _error_suppressions . get ( category , set ( ) ) or linenum in _error_suppressions . get ( None , set ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads the 4 first bytes of the stream to check that is LASF [CODESPLIT] def _raise_if_wrong_file_signature ( stream ) : file_sig = stream . read ( len ( headers . LAS_FILE_SIGNATURE ) ) if file_sig != headers . LAS_FILE_SIGNATURE : raise errors . PylasError ( \"File Signature ({}) is not {}\" . format ( file_sig , headers . LAS_FILE_SIGNATURE ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return unmatched part of re . Match object . [CODESPLIT] def unmatched ( match ) : start , end = match . span ( 0 ) return match . string [ : start ] + match . string [ end : ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Communicate with the child process without closing stdin . [CODESPLIT] def correspond ( text ) : subproc . stdin . write ( text ) subproc . stdin . flush ( ) return drain ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates aggregated mean loss . [CODESPLIT] def loss ( loss_value ) : total_loss = tf . Variable ( 0.0 , False ) loss_count = tf . Variable ( 0 , False ) total_loss_update = tf . assign_add ( total_loss , loss_value ) loss_count_update = tf . assign_add ( loss_count , 1 ) loss_op = total_loss / tf . cast ( loss_count , tf . float32 ) return [ total_loss_update , loss_count_update ] , loss_op", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a python datetime . datetime object to QDateTime [CODESPLIT] def dt_to_qdatetime ( dt ) : return QtCore . QDateTime ( QtCore . QDate ( dt . year , dt . month , dt . day ) , QtCore . QTime ( dt . hour , dt . minute , dt . second ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the unique items from iterable * seq * ( in order ) . [CODESPLIT] def unique_items ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns unique elements from a list preserving the original order [CODESPLIT] def unique_element ( ll ) : seen = { } result = [ ] for item in ll : if item in seen : continue seen [ item ] = 1 result . append ( item ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the size of x along axis dimensions only . [CODESPLIT] def array_size ( x , axis ) : axis_shape = x . shape if axis is None else tuple ( x . shape [ a ] for a in axis ) return max ( numpy . prod ( axis_shape ) , 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute a rabbitmqctl command inside a running container . [CODESPLIT] def exec_rabbitmqctl ( self , command , args = [ ] , rabbitmqctl_opts = [ '-q' ] ) : cmd = [ 'rabbitmqctl' ] + rabbitmqctl_opts + [ command ] + args return self . inner ( ) . exec_run ( cmd )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds passed value to node s globals [CODESPLIT] def set_global ( node : Node , key : str , value : Any ) : node . node_globals [ key ] = value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The url of this window [CODESPLIT] def url ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . url", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Init a uniform noise variable . [CODESPLIT] def uniform_noise ( points ) : return np . random . rand ( 1 ) * np . random . uniform ( points , 1 ) + random . sample ( [ 2 , - 2 ] , 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given an list of words this function highlights the matched words in the given string . [CODESPLIT] def highlight_words ( string , keywords , cls_name = 'highlighted' ) : if not keywords : return string if not string : return '' include , exclude = get_text_tokenizer ( keywords ) highlighted = highlight_text ( include , string , cls_name , words = True ) return highlighted", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fetch environment variables returning a default if not found [CODESPLIT] def get_env_default ( self , variable , default ) : if variable in os . environ : env_var = os . environ [ variable ] else : env_var = default return env_var", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flushes the prompt before requesting the input [CODESPLIT] def _normal_prompt ( self ) : sys . stdout . write ( self . __get_ps1 ( ) ) sys . stdout . flush ( ) return safe_input ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a string from a file - like object . [CODESPLIT] def read_string ( buff , byteorder = 'big' ) : length = read_numeric ( USHORT , buff , byteorder ) return buff . read ( length ) . decode ( 'utf-8' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show the home page for the API with all methods [CODESPLIT] def api_home ( request , key = None , hproPk = None ) : if not check_api_key ( request , key , hproPk ) : return HttpResponseForbidden return render_to_response ( 'plugIt/api.html' , { } , context_instance = RequestContext ( request ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Performs drag a element to another elmenet . [CODESPLIT] def drag_and_drop ( self , droppable ) : self . scroll_to ( ) ActionChains ( self . parent . driver ) . drag_and_drop ( self . _element , droppable . _element ) . perform ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract from the given iterable of lines the list of words . [CODESPLIT] def extract_words ( lines ) : for line in lines : for word in re . findall ( r\"\\w+\" , line ) : yield word", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads the date from a string in the format YYYY / MM / DD and returns : class : datetime . date [CODESPLIT] def _read_date_from_string ( str1 ) : full_date = [ int ( x ) for x in str1 . split ( '/' ) ] return datetime . date ( full_date [ 0 ] , full_date [ 1 ] , full_date [ 2 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determines if a list is sorted [CODESPLIT] def issorted ( list_ , op = operator . le ) : return all ( op ( list_ [ ix ] , list_ [ ix + 1 ] ) for ix in range ( len ( list_ ) - 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a value from the cache . [CODESPLIT] def get ( self , key ) : value = redis_conn . get ( key ) if value is not None : value = pickle . loads ( value ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns type of the data for the given FeatureType . [CODESPLIT] def type ( self ) : if self is FeatureType . TIMESTAMP : return list if self is FeatureType . BBOX : return BBox return dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if * key * is present else False . [CODESPLIT] def __contains__ ( self , key ) : pickled_key = self . _pickle_key ( key ) return bool ( self . redis . hexists ( self . key , pickled_key ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Loads UTF8 string : param reader : : return : [CODESPLIT] async def load_unicode ( reader ) : ivalue = await load_uvarint ( reader ) fvalue = bytearray ( ivalue ) await reader . areadinto ( fvalue ) return str ( fvalue , 'utf8' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility function to create regexp for matching escaped separators in strings . [CODESPLIT] def make_regex ( separator ) : return re . compile ( r'(?:' + re . escape ( separator ) + r')?((?:[^' + re . escape ( separator ) + r'\\\\]|\\\\.)+)' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ajout d un message de log de type ERROR [CODESPLIT] def error ( self , text ) : self . logger . error ( \"{}{}\" . format ( self . message_prefix , text ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if email is valid [CODESPLIT] def is_valid_email ( email ) : pattern = re . compile ( r'[\\w\\.-]+@[\\w\\.-]+[.]\\w+' ) return bool ( pattern . match ( email ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a region from a numpy array . : param array : : class : numpy . ndarray : param identifier : value representing the region to select in the array : returns : : class : jicimagelib . region . Region [CODESPLIT] def select_from_array ( cls , array , identifier ) : base_array = np . zeros ( array . shape ) array_coords = np . where ( array == identifier ) base_array [ array_coords ] = 1 return cls ( base_array )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace accentuated chars in string by their non accentuated equivalent . [CODESPLIT] def unaccentuate ( s ) : return \"\" . join ( c for c in unicodedata . normalize ( \"NFKD\" , s ) if not unicodedata . combining ( c ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs a thing once and once only . [CODESPLIT] def once ( func ) : lock = threading . Lock ( ) def new_func ( * args , * * kwargs ) : if new_func . called : return with lock : if new_func . called : return rv = func ( * args , * * kwargs ) new_func . called = True return rv new_func = update_wrapper ( new_func , func ) new_func . called = False return new_func", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a scalar validator in a list validator [CODESPLIT] def as_list ( callable ) : @ wraps ( callable ) def wrapper ( value_iter ) : return [ callable ( value ) for value in value_iter ] return wrapper", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deletes key cell [CODESPLIT] def delete_cell ( self , key ) : try : self . code_array . pop ( key ) except KeyError : pass self . grid . code_array . result_cache . clear ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create the stream handler . Used for console / debug output . [CODESPLIT] def make_stream_handler ( graph , formatter ) : return { \"class\" : graph . config . logging . stream_handler . class_ , \"formatter\" : formatter , \"level\" : graph . config . logging . level , \"stream\" : graph . config . logging . stream_handler . stream , }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip agents from a string . [CODESPLIT] def strip_accents ( text ) : normalized_str = unicodedata . normalize ( 'NFD' , text ) return '' . join ( [ c for c in normalized_str if unicodedata . category ( c ) != 'Mn' ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Log a quit or part event . [CODESPLIT] def log_leave ( event , nick , channel ) : if channel not in pmxbot . config . log_channels : return ParticipantLogger . store . log ( nick , channel , event . type )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove duplicates from a sequence preserving order [CODESPLIT] def remove_dups ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cumulative product of a list . [CODESPLIT] def _cumprod ( l ) : ret = [ 1 ] for item in l : ret . append ( ret [ - 1 ] * item ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Attempt to guess the title from the filename [CODESPLIT] def guess_title ( basename ) : base , _ = os . path . splitext ( basename ) return re . sub ( r'[ _-]+' , r' ' , base ) . title ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts markdown content to text [CODESPLIT] def md_to_text ( content ) : text = None html = markdown . markdown ( content ) if html : text = html_to_text ( content ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cast unknown type into integer [CODESPLIT] def cast_int ( x ) : try : x = int ( x ) except ValueError : try : x = x . strip ( ) except AttributeError as e : logger_misc . warn ( \"parse_str: AttributeError: String not number or word, {}, {}\" . format ( x , e ) ) return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if number is integer or not . [CODESPLIT] def check_int ( integer ) : if not isinstance ( integer , str ) : return False if integer [ 0 ] in ( '-' , '+' ) : return integer [ 1 : ] . isdigit ( ) return integer . isdigit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace accentuated chars in string by their non accentuated equivalent . [CODESPLIT] def unaccentuate ( s ) : return \"\" . join ( c for c in unicodedata . normalize ( \"NFKD\" , s ) if not unicodedata . combining ( c ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Plot a scatterplot matrix for a list of features colored by target value . [CODESPLIT] def scatterplot_matrix ( df , features , downsample_frac = None , figsize = ( 15 , 15 ) ) : if downsample_frac : df = df . sample ( frac = downsample_frac ) plt . figure ( figsize = figsize ) sns . pairplot ( df [ features ] , hue = 'target' ) plt . show ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a histogram for the data to the axes . [CODESPLIT] def _histplot_op ( ax , data , * * kwargs ) : bins = get_bins ( data ) ax . hist ( data , bins = bins , align = \"left\" , density = True , * * kwargs ) return ax", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the string without any initial or final quotes . [CODESPLIT] def _repr_strip ( mystring ) : r = repr ( mystring ) if r . startswith ( \"'\" ) and r . endswith ( \"'\" ) : return r [ 1 : - 1 ] else : return r", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize time in arbitrary timezone to UTC naive object . [CODESPLIT] def normalize_time ( timestamp ) : offset = timestamp . utcoffset ( ) if offset is None : return timestamp return timestamp . replace ( tzinfo = None ) - offset", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Python 3 input () / Python 2 raw_input () [CODESPLIT] def string_input ( prompt = '' ) : v = sys . version [ 0 ] if v == '3' : return input ( prompt ) else : return raw_input ( prompt )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert string column into datetime column [CODESPLIT] def convert_str_to_datetime ( df , * , column : str , format : str ) : df [ column ] = pd . to_datetime ( df [ column ] , format = format ) return df", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param string s : under_scored string to be CamelCased : return : CamelCase version of input : rtype : str [CODESPLIT] def to_camel ( s ) : # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups return re . sub ( r'_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , '_' + s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the language parameter from the current request . [CODESPLIT] def get_language_parameter ( request , query_language_key = 'language' , object = None , default = None ) : # This is the same logic as the django-admin uses. # The only difference is the origin of the request parameter. if not is_multilingual_project ( ) : # By default, the objects are stored in a single static language. # This makes the transition to multilingual easier as well. # The default language can operate as fallback language too. return default or appsettings . PARLER_LANGUAGES . get_default_language ( ) else : # In multilingual mode, take the provided language of the request. code = request . GET . get ( query_language_key ) if not code : # forms: show first tab by default code = default or appsettings . PARLER_LANGUAGES . get_first_language ( ) return normalize_language_code ( code )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "There s probably a way to do this with string functions but I was lazy . Replace all instances of \\ r or \\ n in a string with something else . [CODESPLIT] def replaceNewlines ( string , newlineChar ) : if newlineChar in string : segments = string . split ( newlineChar ) string = \"\" for segment in segments : string += segment return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns an updated copy of the dictionary without modifying the original [CODESPLIT] def copy_and_update ( dictionary , update ) : newdict = dictionary . copy ( ) newdict . update ( update ) return newdict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform check_array ( X ) after removing infinite values ( numpy . inf ) from the given distance matrix . [CODESPLIT] def check_precomputed_distance_matrix ( X ) : tmp = X . copy ( ) tmp [ np . isinf ( tmp ) ] = 1 check_array ( tmp )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "if the value is in the list move it to the front and return it . [CODESPLIT] def list_move_to_front ( l , value = 'other' ) : l = list ( l ) if value in l : l . remove ( value ) l . insert ( 0 , value ) return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "right button up : put back to cursor mode [CODESPLIT] def onRightUp ( self , event = None ) : if event is None : return self . cursor_mode_action ( 'rightup' , event = event ) self . ForwardEvent ( event = event . guiEvent )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the URL that was the source of this response . If the request that generated this response redirected this method will return the final redirect location . [CODESPLIT] def geturl ( self ) : if self . retries is not None and len ( self . retries . history ) : return self . retries . history [ - 1 ] . redirect_location else : return self . _request_url", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform a chunked PUT request to url with requests . session This is specifically to upload files . [CODESPLIT] def rest_put_stream ( self , url , stream , headers = None , session = None , verify = True , cert = None ) : res = session . put ( url , headers = headers , data = stream , verify = verify , cert = cert ) return res . text , res . status_code", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read delimited text from a text file . [CODESPLIT] def from_file ( cls , path , encoding , dialect , fields , converters , field_index ) : return cls ( open ( path , 'r' , encoding = encoding ) , dialect , fields , converters , field_index )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Internal utility function to reset binding . [CODESPLIT] def _reset_bind ( self ) : self . binded = False self . _buckets = { } self . _curr_module = None self . _curr_bucket_key = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert string to int or float . [CODESPLIT] def covstr ( s ) : try : ret = int ( s ) except ValueError : ret = float ( s ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts and image to matrix ( one pixel per line ) [CODESPLIT] def im2mat ( I ) : return I . reshape ( ( I . shape [ 0 ] * I . shape [ 1 ] , I . shape [ 2 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract the result return value and context from a result object [CODESPLIT] def _parse_return ( cls , result ) : return_value = None success = result [ 'result' ] context = result [ 'context' ] if 'return_value' in result : return_value = result [ 'return_value' ] return success , return_value , context", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resize and image to fit the passed in width keeping the aspect ratio the same [CODESPLIT] def resize_image_to_fit_width ( image , dest_w ) : scale_factor = dest_w / image . size [ 0 ] dest_h = image . size [ 1 ] * scale_factor scaled_image = image . resize ( ( int ( dest_w ) , int ( dest_h ) ) , PIL . Image . ANTIALIAS ) return scaled_image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pause the music [CODESPLIT] def pause ( self ) : mixer . music . pause ( ) self . pause_time = self . get_time ( ) self . paused = True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Unpickles the classifier used [CODESPLIT] def load ( self , filename = 'classifier.dump' ) : ifile = open ( filename , 'r+' ) self . classifier = pickle . load ( ifile ) ifile . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove connections to all chassis ( test ports ) in this session . [CODESPLIT] def do_stc_disconnectall ( self , s ) : if self . _not_joined ( ) : return try : self . _stc . disconnectall ( ) except resthttp . RestHttpError as e : print ( e ) return print ( 'OK' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return data as a JSON string . [CODESPLIT] def to_json ( data ) : return json . dumps ( data , default = lambda x : x . __dict__ , sort_keys = True , indent = 4 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return list - lookalike of representation string of objects [CODESPLIT] def __repr__ ( self ) : strings = [ ] for currItem in self : strings . append ( \"%s\" % currItem ) return \"(%s)\" % ( \", \" . join ( strings ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print a dictionary of attributes in the DOT format [CODESPLIT] def _attrprint ( d , delimiter = ', ' ) : return delimiter . join ( ( '\"%s\"=\"%s\"' % item ) for item in sorted ( d . items ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return grandparent s path string [CODESPLIT] def grandparent_path ( self ) : return os . path . basename ( os . path . join ( self . path , '../..' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "wrapper for usage of profiling [CODESPLIT] def _run_parallel_process_with_profiling ( self , start_path , stop_path , queue , filename ) : runctx ( 'Engine._run_parallel_process(self,  start_path, stop_path, queue)' , globals ( ) , locals ( ) , filename )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "wrapper for usage of profiling [CODESPLIT] def _run_parallel_process_with_profiling ( self , start_path , stop_path , queue , filename ) : runctx ( 'Engine._run_parallel_process(self,  start_path, stop_path, queue)' , globals ( ) , locals ( ) , filename )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Aggregation function to get the first non - zero value . [CODESPLIT] def reduce_fn ( x ) : values = x . values if pd and isinstance ( x , pd . Series ) else x for v in values : if not is_nan ( v ) : return v return np . NaN", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Re - raises the error that was processed by prepare_for_reraise earlier . [CODESPLIT] def reraise ( error ) : if hasattr ( error , \"_type_\" ) : six . reraise ( type ( error ) , error , error . _traceback ) raise error", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes stopwords contained in a list of words . [CODESPLIT] def _removeStopwords ( text_list ) : output_list = [ ] for word in text_list : if word . lower ( ) not in _stopwords : output_list . append ( word ) return output_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes input from user . Works for Python 2 and 3 . [CODESPLIT] def _stdin_ ( p ) : _v = sys . version [ 0 ] return input ( p ) if _v is '3' else raw_input ( p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform an asyncio sleep for the time specified in seconds . T his method should be used in place of time . sleep () [CODESPLIT] def sleep ( self , time ) : try : task = asyncio . ensure_future ( self . core . sleep ( time ) ) self . loop . run_until_complete ( task ) except asyncio . CancelledError : pass except RuntimeError : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ensure that the parent directory for a file is present . [CODESPLIT] def safe_mkdir_for ( path , clean = False ) : safe_mkdir ( os . path . dirname ( path ) , clean = clean )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Save cookies to a file . [CODESPLIT] def save_cache ( data , filename ) : with open ( filename , 'wb' ) as handle : pickle . dump ( data , handle )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "reads an RDF file into a graph [CODESPLIT] def load_graph_from_rdf ( fname ) : print ( \"reading RDF from \" + fname + \"....\" ) store = Graph ( ) store . parse ( fname , format = \"n3\" ) print ( \"Loaded \" + str ( len ( store ) ) + \" tuples\" ) return store", "target": 1, "target_options": ["no_match", "match"]}
{"input": "save something to a pickle file [CODESPLIT] def pickle_save ( thing , fname ) : pickle . dump ( thing , open ( fname , \"wb\" ) , pickle . HIGHEST_PROTOCOL ) return thing", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A datetime - version that takes datetime object list as x_axis [CODESPLIT] def spline_interpolate_by_datetime ( datetime_axis , y_axis , datetime_new_axis ) : numeric_datetime_axis = [ totimestamp ( a_datetime ) for a_datetime in datetime_axis ] numeric_datetime_new_axis = [ totimestamp ( a_datetime ) for a_datetime in datetime_new_axis ] return spline_interpolate ( numeric_datetime_axis , y_axis , numeric_datetime_new_axis )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts html content to plain text [CODESPLIT] def html_to_text ( content ) : text = None h2t = html2text . HTML2Text ( ) h2t . ignore_links = False text = h2t . handle ( content ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Efficient conversion from scipy sparse matrix to cvxopt sparse matrix [CODESPLIT] def scipy_sparse_to_spmatrix ( A ) : coo = A . tocoo ( ) SP = spmatrix ( coo . data . tolist ( ) , coo . row . tolist ( ) , coo . col . tolist ( ) , size = A . shape ) return SP", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove ticks tick labels and frame from axis [CODESPLIT] def clean_axis ( axis ) : axis . get_xaxis ( ) . set_ticks ( [ ] ) axis . get_yaxis ( ) . set_ticks ( [ ] ) for spine in list ( axis . spines . values ( ) ) : spine . set_visible ( False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "function to get return code of a url [CODESPLIT] def get_url_nofollow ( url ) : try : response = urlopen ( url ) code = response . getcode ( ) return code except HTTPError as e : return e . code except : return 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the indent size in spaces at the start of a line of text . [CODESPLIT] def indentsize ( line ) : expline = string . expandtabs ( line ) return len ( expline ) - len ( string . lstrip ( expline ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove duplicated elements in a list . Args : lista : List with elements to clean duplicates . [CODESPLIT] def remove_list_duplicates ( lista , unique = False ) : result = [ ] allready = [ ] for elem in lista : if elem not in result : result . append ( elem ) else : allready . append ( elem ) if unique : for elem in allready : result = list ( filter ( ( elem ) . __ne__ , result ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the scroll region on the canvas [CODESPLIT] def set_scrollregion ( self , event = None ) : self . canvas . configure ( scrollregion = self . canvas . bbox ( 'all' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return line ending . [CODESPLIT] def get_line_ending ( line ) : non_whitespace_index = len ( line . rstrip ( ) ) - len ( line ) if not non_whitespace_index : return '' else : return line [ non_whitespace_index : ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format a string for screen printing . [CODESPLIT] def format_screen ( strng ) : # Paragraph continue par_re = re . compile ( r'\\\\$' , re . MULTILINE ) strng = par_re . sub ( '' , strng ) return strng", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Select rows where the given field evaluates True . [CODESPLIT] def selecttrue ( table , field , complement = False ) : return select ( table , field , lambda v : bool ( v ) , complement = complement )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Select rows where the given field evaluates True . [CODESPLIT] def selecttrue ( table , field , complement = False ) : return select ( table , field , lambda v : bool ( v ) , complement = complement )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a comma separated string to a list [CODESPLIT] def _str_to_list ( s ) : _list = s . split ( \",\" ) return list ( map ( lambda i : i . lstrip ( ) , _list ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fix bad Unicode special dashes in string . [CODESPLIT] def fix_dashes ( string ) : string = string . replace ( u'\\u05BE' , '-' ) string = string . replace ( u'\\u1806' , '-' ) string = string . replace ( u'\\u2E3A' , '-' ) string = string . replace ( u'\\u2E3B' , '-' ) string = unidecode ( string ) return re . sub ( r'--+' , '-' , string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create an identical ( deep ) copy of this element . [CODESPLIT] def copy ( self ) : result = self . space . element ( ) result . assign ( self ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate an OWL representation of a biolink model [CODESPLIT] def cli ( yamlfile , format , output ) : print ( OwlSchemaGenerator ( yamlfile , format ) . serialize ( output = output ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return lines of a file with whitespace removed [CODESPLIT] def get_stripped_file_lines ( filename ) : try : lines = open ( filename ) . readlines ( ) except FileNotFoundError : fatal ( \"Could not open file: {!r}\" . format ( filename ) ) return [ line . strip ( ) for line in lines ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Process a matplotlib image object and call renderer . draw_image [CODESPLIT] def draw_image ( self , ax , image ) : self . renderer . draw_image ( imdata = utils . image_to_base64 ( image ) , extent = image . get_extent ( ) , coordinates = \"data\" , style = { \"alpha\" : image . get_alpha ( ) , \"zorder\" : image . get_zorder ( ) } , mplobj = image )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If values in a series match a specified value change them to np . nan . [CODESPLIT] def na_if ( series , * values ) : series = pd . Series ( series ) series [ series . isin ( values ) ] = np . nan return series", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get input from the user given an input function and an input string [CODESPLIT] def get_input ( input_func , input_str ) : val = input_func ( \"Please enter your {0}: \" . format ( input_str ) ) while not val or not len ( val . strip ( ) ) : val = input_func ( \"You didn't enter a valid {0}, please try again: \" . format ( input_str ) ) return val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convenience method that wraps asfreq_actual with M param ( method = ffill how = end ) . [CODESPLIT] def to_monthly ( series , method = 'ffill' , how = 'end' ) : return series . asfreq_actual ( 'M' , method = method , how = how )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wraps the dispatch method to add session support . [CODESPLIT] def dispatch ( self ) : try : webapp2 . RequestHandler . dispatch ( self ) finally : self . session_store . save_sessions ( self . response )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a new image by copying the image on a * color * background . [CODESPLIT] def copy_image_on_background ( image , color = WHITE ) : background = Image . new ( \"RGB\" , image . size , color ) background . paste ( image , mask = image . split ( ) [ 3 ] ) return background", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Record CPU usage . [CODESPLIT] def _cpu ( self ) : value = int ( psutil . cpu_percent ( ) ) set_metric ( \"cpu\" , value , category = self . category ) gauge ( \"cpu\" , value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "round to closest resolution [CODESPLIT] def roundClosestValid ( val , res , decimals = None ) : if decimals is None and \".\" in str ( res ) : decimals = len ( str ( res ) . split ( '.' ) [ 1 ] ) return round ( round ( val / res ) * res , decimals )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ensure the cursor is within horizontal screen bounds . [CODESPLIT] def ensure_hbounds ( self ) : self . cursor . x = min ( max ( 0 , self . cursor . x ) , self . columns - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function for splitting 2D data into x and y component to make equations simpler [CODESPLIT] def unpack2D ( _x ) : _x = np . atleast_2d ( _x ) x = _x [ : , 0 ] y = _x [ : , 1 ] return x , y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "R x M x R^ - 1 [CODESPLIT] def similarity_transformation ( rot , mat ) : return np . dot ( rot , np . dot ( mat , np . linalg . inv ( rot ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a sha1 of the given string [CODESPLIT] def sha1 ( s ) : h = hashlib . new ( 'sha1' ) h . update ( s ) return h . hexdigest ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Saves a pdf of the current matplotlib figure . [CODESPLIT] def save_pdf ( path ) : pp = PdfPages ( path ) pp . savefig ( pyplot . gcf ( ) ) pp . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Open handle [CODESPLIT] def open ( self , flag = \"c\" ) : return shelve . open ( os . path . join ( gettempdir ( ) , self . index ) , flag = flag , protocol = 2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Horizontally flip the given PIL Image . [CODESPLIT] def hflip ( img ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) return img . transpose ( Image . FLIP_LEFT_RIGHT )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make sure key is a valid python attribute [CODESPLIT] def normalise_key ( self , key ) : key = key . replace ( '-' , '_' ) if key . startswith ( \"noy_\" ) : key = key [ 4 : ] return key", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Checks if l is a numpy array of integers [CODESPLIT] def is_int_vector ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 1 and ( l . dtype . kind == 'i' or l . dtype . kind == 'u' ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like print_exc () but return a string . Backport for Python 2 . 3 . [CODESPLIT] def format_exc ( limit = None ) : try : etype , value , tb = sys . exc_info ( ) return '' . join ( traceback . format_exception ( etype , value , tb , limit ) ) finally : etype = value = tb = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple measure of similarity : Number of letters in common / max length [CODESPLIT] def basic_word_sim ( word1 , word2 ) : return sum ( [ 1 for c in word1 if c in word2 ] ) / max ( len ( word1 ) , len ( word2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Estimates the memory of the supplied array in bytes [CODESPLIT] def array_bytes ( array ) : return np . product ( array . shape ) * np . dtype ( array . dtype ) . itemsize", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Imputes data set containing Nan values [CODESPLIT] def impute_data ( self , x ) : imp = Imputer ( missing_values = 'NaN' , strategy = 'mean' , axis = 0 ) return imp . fit_transform ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Upermutate 1 - D data that is sorted by indices_of_increasing . [CODESPLIT] def unsort_vector ( data , indices_of_increasing ) : return numpy . array ( [ data [ indices_of_increasing . index ( i ) ] for i in range ( len ( data ) ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sort list elements by name . [CODESPLIT] def sort_by_name ( self ) : super ( JSSObjectList , self ) . sort ( key = lambda k : k . name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses a date string formatted like YYYY - MM - DD . [CODESPLIT] def parse ( self , s ) : return datetime . datetime . strptime ( s , self . date_format ) . date ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sort key for sorting keys in grevlex order . [CODESPLIT] def sort_key ( val ) : return numpy . sum ( ( max ( val ) + 1 ) ** numpy . arange ( len ( val ) - 1 , - 1 , - 1 ) * val )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sort the data . [CODESPLIT] def sort_data ( x , y ) : xy = sorted ( zip ( x , y ) ) x , y = zip ( * xy ) return x , y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create the proxy to PyPI XML - RPC Server [CODESPLIT] def set_proxy ( proxy_url , transport_proxy = None ) : global proxy , PYPI_URL PYPI_URL = proxy_url proxy = xmlrpc . ServerProxy ( proxy_url , transport = RequestsTransport ( proxy_url . startswith ( 'https://' ) ) , allow_none = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Display error message via stderr or GUI . [CODESPLIT] def error ( * args ) : if sys . stdin . isatty ( ) : print ( 'ERROR:' , * args , file = sys . stderr ) else : notify_error ( * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Display Bloch sphere and corresponding data sets . [CODESPLIT] def show ( self , title = '' ) : self . render ( title = title ) if self . fig : plt . show ( self . fig )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split input / output value into two values . [CODESPLIT] def _split ( value ) : if isinstance ( value , str ) : # iterable, but not meant for splitting return value , value try : invalue , outvalue = value except TypeError : invalue = outvalue = value except ValueError : raise ValueError ( \"Only single values and pairs are allowed\" ) return invalue , outvalue", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield successive n - sized chunks from l . [CODESPLIT] def _split_batches ( self , data , batch_size ) : for i in range ( 0 , len ( data ) , batch_size ) : yield data [ i : i + batch_size ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Quit and Restart Spyder application . If reset True it allows to reset spyder on restart . [CODESPLIT] def restart ( self , reset = False ) : # Get start path to use in restart script\n spyder_start_directory = get_module_path ( 'spyder' ) restart_script = osp . join ( spyder_start_directory , 'app' , 'restart.py' ) # Get any initial argument passed when spyder was started\n # Note: Variables defined in bootstrap.py and spyder/app/start.py\n env = os . environ . copy ( ) bootstrap_args = env . pop ( 'SPYDER_BOOTSTRAP_ARGS' , None ) spyder_args = env . pop ( 'SPYDER_ARGS' ) # Get current process and python running spyder\n pid = os . getpid ( ) python = sys . executable # Check if started with bootstrap.py\n if bootstrap_args is not None : spyder_args = bootstrap_args is_bootstrap = True else : is_bootstrap = False # Pass variables as environment variables (str) to restarter subprocess\n env [ 'SPYDER_ARGS' ] = spyder_args env [ 'SPYDER_PID' ] = str ( pid ) env [ 'SPYDER_IS_BOOTSTRAP' ] = str ( is_bootstrap ) env [ 'SPYDER_RESET' ] = str ( reset ) if DEV : if os . name == 'nt' : env [ 'PYTHONPATH' ] = ';' . join ( sys . path ) else : env [ 'PYTHONPATH' ] = ':' . join ( sys . path ) # Build the command and popen arguments depending on the OS\n if os . name == 'nt' : # Hide flashing command prompt\n startupinfo = subprocess . STARTUPINFO ( ) startupinfo . dwFlags |= subprocess . STARTF_USESHOWWINDOW shell = False else : startupinfo = None shell = True command = '\"{0}\" \"{1}\"' command = command . format ( python , restart_script ) try : if self . closing ( True ) : subprocess . Popen ( command , shell = shell , env = env , startupinfo = startupinfo ) self . console . quit ( ) except Exception as error : # If there is an error with subprocess, Spyder should not quit and\n # the error can be inspected in the internal console\n print ( error ) # spyder: test-skip\n print ( command )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Quit and Restart Spyder application . If reset True it allows to reset spyder on restart . [CODESPLIT] def restart ( self , reset = False ) : # Get start path to use in restart script\n spyder_start_directory = get_module_path ( 'spyder' ) restart_script = osp . join ( spyder_start_directory , 'app' , 'restart.py' ) # Get any initial argument passed when spyder was started\n # Note: Variables defined in bootstrap.py and spyder/app/start.py\n env = os . environ . copy ( ) bootstrap_args = env . pop ( 'SPYDER_BOOTSTRAP_ARGS' , None ) spyder_args = env . pop ( 'SPYDER_ARGS' ) # Get current process and python running spyder\n pid = os . getpid ( ) python = sys . executable # Check if started with bootstrap.py\n if bootstrap_args is not None : spyder_args = bootstrap_args is_bootstrap = True else : is_bootstrap = False # Pass variables as environment variables (str) to restarter subprocess\n env [ 'SPYDER_ARGS' ] = spyder_args env [ 'SPYDER_PID' ] = str ( pid ) env [ 'SPYDER_IS_BOOTSTRAP' ] = str ( is_bootstrap ) env [ 'SPYDER_RESET' ] = str ( reset ) if DEV : if os . name == 'nt' : env [ 'PYTHONPATH' ] = ';' . join ( sys . path ) else : env [ 'PYTHONPATH' ] = ':' . join ( sys . path ) # Build the command and popen arguments depending on the OS\n if os . name == 'nt' : # Hide flashing command prompt\n startupinfo = subprocess . STARTUPINFO ( ) startupinfo . dwFlags |= subprocess . STARTF_USESHOWWINDOW shell = False else : startupinfo = None shell = True command = '\"{0}\" \"{1}\"' command = command . format ( python , restart_script ) try : if self . closing ( True ) : subprocess . Popen ( command , shell = shell , env = env , startupinfo = startupinfo ) self . console . quit ( ) except Exception as error : # If there is an error with subprocess, Spyder should not quit and\n # the error can be inspected in the internal console\n print ( error ) # spyder: test-skip\n print ( command )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Solves a linear equation system with a matrix of shape ( n n ) and an array of shape ( n ... ) . The output has the same shape as the second argument . [CODESPLIT] def solve ( A , x ) : # https://stackoverflow.com/a/48387507/353337 x = numpy . asarray ( x ) return numpy . linalg . solve ( A , x . reshape ( x . shape [ 0 ] , - 1 ) ) . reshape ( x . shape )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Join list of columns into a string for a SQL query [CODESPLIT] def join_cols ( cols ) : return \", \" . join ( [ i for i in cols ] ) if isinstance ( cols , ( list , tuple , set ) ) else cols", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to add timezone information to datetime so that datetime is comparable to other datetime objects in recent versions that now also have timezone information . [CODESPLIT] def datetime_from_timestamp ( timestamp , content ) : return set_date_tzinfo ( datetime . fromtimestamp ( timestamp ) , tz_name = content . settings . get ( 'TIMEZONE' , None ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create database tables from sqlalchemy models [CODESPLIT] def createdb ( ) : manager . db . engine . echo = True manager . db . create_all ( ) set_alembic_revision ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a user has a given permission . [CODESPLIT] def has_permission ( user , permission_name ) : if user and user . is_superuser : return True return permission_name in available_perm_names ( user )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return opened file with a specific encoding . [CODESPLIT] def open_with_encoding ( filename , encoding , mode = 'r' ) : return io . open ( filename , mode = mode , encoding = encoding , newline = '' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator to explicitly mark functions that are exposed in a lib . [CODESPLIT] def export ( defn ) : globals ( ) [ defn . __name__ ] = defn __all__ . append ( defn . __name__ ) return defn", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split text into list of sentences . [CODESPLIT] def split_into_sentences ( s ) : s = re . sub ( r\"\\s+\" , \" \" , s ) s = re . sub ( r\"[\\\\.\\\\?\\\\!]\" , \"\\n\" , s ) return s . split ( \"\\n\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator which dynamically binds static methods to the model for later use . [CODESPLIT] def static_method ( cls , f ) : setattr ( cls , f . __name__ , staticmethod ( f ) ) return f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A static value ( does not change at runtime ) which is known at compile time [CODESPLIT] def is_static ( * p ) : return all ( is_CONST ( x ) or is_number ( x ) or is_const ( x ) for x in p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return IPython s guess for the default encoding for bytes as text . [CODESPLIT] def getdefaultencoding ( ) : enc = get_stream_enc ( sys . stdin ) if not enc or enc == 'ascii' : try : # There are reports of getpreferredencoding raising errors # in some cases, which may well be fixed, but let's be conservative here. enc = locale . getpreferredencoding ( ) except Exception : pass return enc or sys . getdefaultencoding ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Saves an animation [CODESPLIT] def save ( self , * args , * * kwargs ) : self . timeline . index -= 1 # required for proper starting point for save self . animation . save ( * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initializes an stdin input reader . [CODESPLIT] def __init__ ( self , encoding = 'utf-8' ) : super ( StdinInputReader , self ) . __init__ ( sys . stdin , encoding = encoding )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns dicts with header - keys and psm statistic values [CODESPLIT] def generate_split_tsv_lines ( fn , header ) : for line in generate_tsv_psms_line ( fn ) : yield { x : y for ( x , y ) in zip ( header , line . strip ( ) . split ( '\\t' ) ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convenience function to print messages on a single line in the terminal [CODESPLIT] def println ( msg ) : sys . stdout . write ( msg ) sys . stdout . flush ( ) sys . stdout . write ( '\\x08' * len ( msg ) ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determines if a list is sorted [CODESPLIT] def issorted ( list_ , op = operator . le ) : return all ( op ( list_ [ ix ] , list_ [ ix + 1 ] ) for ix in range ( len ( list_ ) - 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "quit command when there s just one thread . [CODESPLIT] def nothread_quit ( self , arg ) : self . debugger . core . stop ( ) self . debugger . core . execution_status = 'Quit command' raise Mexcept . DebuggerQuit", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns whether this is a complex floating point type . [CODESPLIT] def is_complex ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'is_complex' ) : return dtype . is_complex return np . issubdtype ( np . dtype ( dtype ) , np . complex )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert an integer list into a string list . [CODESPLIT] def list_i2str ( ilist ) : slist = [ ] for el in ilist : slist . append ( str ( el ) ) return slist", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Similar to #itertools . chain . from_iterable () . [CODESPLIT] def concat ( cls , iterables ) : def generator ( ) : for it in iterables : for element in it : yield element return cls ( generator ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is to support iterators over a file - like object . [CODESPLIT] def next ( self ) : # File-like object. result = self . readline ( ) if result == self . _empty_buffer : raise StopIteration return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Packs a list of triple indexes into a 2D numpy array . [CODESPLIT] def pack_triples_numpy ( triples ) : if len ( triples ) == 0 : return np . array ( [ ] , dtype = np . int64 ) return np . stack ( list ( map ( _transform_triple_numpy , triples ) ) , axis = 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute entropy on the string [CODESPLIT] def entropy ( string ) : p , lns = Counter ( string ) , float ( len ( string ) ) return - sum ( count / lns * math . log ( count / lns , 2 ) for count in p . values ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like isin but checks whether this expression s value ( s ) are not contained in the passed values . See isin docs for full usage . [CODESPLIT] def notin ( arg , values ) : op = ops . NotContains ( arg , values ) return op . to_expr ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a key from a tag entity [CODESPLIT] def graph_key_from_tag ( tag , entity_index ) : start_token = tag . get ( 'start_token' ) entity = tag . get ( 'entities' , [ ] ) [ entity_index ] return str ( start_token ) + '-' + entity . get ( 'key' ) + '-' + str ( entity . get ( 'confidence' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if string matches this argument s format . [CODESPLIT] def __is__ ( cls , s ) : return s . startswith ( cls . delims ( ) [ 0 ] ) and s . endswith ( cls . delims ( ) [ 1 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Search into instance attributes properties and return values of no - args methods . [CODESPLIT] def instance_contains ( container , item ) : return item in ( member for _ , member in inspect . getmembers ( container ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove punctuation from string s . [CODESPLIT] def unpunctuate ( s , * , char_blacklist = string . punctuation ) : # remove punctuation s = \"\" . join ( c for c in s if c not in char_blacklist ) # remove consecutive spaces return \" \" . join ( filter ( None , s . split ( \" \" ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Short Time Fourier Transform for real data keeping the full FFT block . [CODESPLIT] def stft ( func = None , * * kwparams ) : from numpy . fft import fft , ifft ifft_r = lambda * args : ifft ( * args ) . real return stft . base ( transform = fft , inverse_transform = ifft_r ) ( func , * * kwparams )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Request that the Outstation perform a cold restart . Command syntax is : restart [CODESPLIT] def do_restart ( self , line ) : self . application . master . Restart ( opendnp3 . RestartType . COLD , restart_callback )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to print connection status messages when in verbose mode . [CODESPLIT] def _print ( self , msg , flush = False , end = \"\\n\" ) : if self . _verbose : print2 ( msg , end = end , flush = flush )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a lowercased string with non alphabetic chars removed . [CODESPLIT] def _to_lower_alpha_only ( s ) : s = re . sub ( r'\\n' , ' ' , s . lower ( ) ) return re . sub ( r'[^a-z\\s]' , '' , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Drops the trailinz zeros from decimal value . Returns a string [CODESPLIT] def drop_trailing_zeros_decimal ( num ) : out = str ( num ) return out . rstrip ( '0' ) . rstrip ( '.' ) if '.' in out else out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "a normal old python function to return the Nth fibonacci number . [CODESPLIT] def software_fibonacci ( n ) : a , b = 0 , 1 for i in range ( n ) : a , b = b , a + b return a", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write a Text document to file . [CODESPLIT] def write_document ( doc , fnm ) : with codecs . open ( fnm , 'wb' , 'ascii' ) as f : f . write ( json . dumps ( doc , indent = 2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This strategy uses an exponential approximation for cut - off frequency calculation found by matching the one - pole Laplace lowpass filter and mirroring the resulting filter to get a highpass . [CODESPLIT] def highpass ( cutoff ) : R = thub ( exp ( cutoff - pi ) , 2 ) return ( 1 - R ) / ( 1 + R * z ** - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Drops and re - creates the SQL schema [CODESPLIT] def init_db ( ) : db . drop_all ( ) db . configure_mappers ( ) db . create_all ( ) db . session . commit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap an item in optional parentheses only applying them if necessary . [CODESPLIT] def maybeparens ( lparen , item , rparen ) : return item | lparen . suppress ( ) + item + rparen . suppress ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether the cluster already exists . [CODESPLIT] def exists ( self ) : client = self . _instance . _client try : client . instance_admin_client . get_cluster ( name = self . name ) return True # NOTE: There could be other exceptions that are returned to the user. except NotFound : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handles the specified flask request for one of the POST URLS Invokes the specified endpoint to generate a response . [CODESPLIT] def handleFlaskPostRequest ( flaskRequest , endpoint ) : if flaskRequest . method == \"POST\" : return handleHttpPost ( flaskRequest , endpoint ) elif flaskRequest . method == \"OPTIONS\" : return handleHttpOptions ( ) else : raise exceptions . MethodNotAllowedException ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prints the top row of a table [CODESPLIT] def top ( n , width = WIDTH , style = STYLE ) : return hrule ( n , width , linestyle = STYLES [ style ] . top )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an authentication error . [CODESPLIT] def _handle_authentication_error ( self ) : response = make_response ( 'Access Denied' ) response . headers [ 'WWW-Authenticate' ] = self . auth . get_authenticate_header ( ) response . status_code = 401 return response", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a unique list of seq [CODESPLIT] def uniqify ( cls , seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if x not in seen and not seen_add ( x ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call ioctl () with given parameters . [CODESPLIT] def _ioctl ( self , func , args ) : import fcntl return fcntl . ioctl ( self . sockfd . fileno ( ) , func , args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Draw a vertical line up to a given length . [CODESPLIT] def vline ( self , x , y , height , color ) : self . rect ( x , y , 1 , height , color , fill = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This method asserts that only one value of the provided list is True . [CODESPLIT] def assert_exactly_one_true ( bool_list ) : assert isinstance ( bool_list , list ) counter = 0 for item in bool_list : if item : counter += 1 return counter == 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make bars in horizontal bar chart thinner [CODESPLIT] def _change_height ( self , ax , new_value ) : for patch in ax . patches : current_height = patch . get_height ( ) diff = current_height - new_value # we change the bar height patch . set_height ( new_value ) # we recenter the bar patch . set_y ( patch . get_y ( ) + diff * .5 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Are all entities connected to other entities . [CODESPLIT] def is_closed ( self ) : closed = all ( i == 2 for i in dict ( self . vertex_graph . degree ( ) ) . values ( ) ) return closed", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get zero - indexed line from an open file - like . [CODESPLIT] def get_lines ( handle , line ) : for i , l in enumerate ( handle ) : if i == line : return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns whether * obj * is iterable lazily such as generators range objects etc . [CODESPLIT] def is_lazy_iterable ( obj ) : return isinstance ( obj , ( types . GeneratorType , collections . MappingView , six . moves . range , enumerate ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function for running binary search on a sorted list . [CODESPLIT] def binSearch ( arr , val ) : i = bisect_left ( arr , val ) if i != len ( arr ) and arr [ i ] == val : return i return - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return True if callback is a vanilla plain jane function [CODESPLIT] def is_function ( self ) : if self . is_instance ( ) or self . is_class ( ) : return False return isinstance ( self . callback , ( Callable , classmethod ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine whether stdin has any data to read . [CODESPLIT] def stdin_readable ( ) : if not WINDOWS : try : return bool ( select ( [ sys . stdin ] , [ ] , [ ] , 0 ) [ 0 ] ) except Exception : logger . log_exc ( ) try : return not sys . stdin . isatty ( ) except Exception : logger . log_exc ( ) return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if the root node contains no child elements no text and no attributes other than ** type ** . Returns False if any are present . [CODESPLIT] def is_empty ( self ) : non_type_attributes = [ attr for attr in self . node . attrib . keys ( ) if attr != 'type' ] return len ( self . node ) == 0 and len ( non_type_attributes ) == 0 and not self . node . text and not self . node . tail", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Close connection to NATS when used in a context manager [CODESPLIT] def __exit__ ( self , * exc_info ) : self . _loop . create_task ( self . _close ( Client . CLOSED , True ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty Prints seconds as Hours : Minutes : Seconds . MilliSeconds [CODESPLIT] def pprint ( self , seconds ) : return ( \"%d:%02d:%02d.%03d\" , reduce ( lambda ll , b : divmod ( ll [ 0 ] , b ) + ll [ 1 : ] , [ ( seconds * 1000 , ) , 1000 , 60 , 60 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "helper function for quick base conversions from integers to strings [CODESPLIT] def int2str ( num , radix = 10 , alphabet = BASE85 ) : return NumConv ( radix , alphabet ) . int2str ( num )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns seconds since 0h00 . [CODESPLIT] def time2seconds ( t ) : return t . hour * 3600 + t . minute * 60 + t . second + float ( t . microsecond ) / 1e6", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Checks if l is iterable and contains only integral types [CODESPLIT] def is_iterable_of_int ( l ) : if not is_iterable ( l ) : return False return all ( is_int ( value ) for value in l )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return x as a binary type . [CODESPLIT] def Binary ( x ) : if isinstance ( x , text_type ) and not ( JYTHON or IRONPYTHON ) : return x . encode ( ) return bytes ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Interpolate linearly between start and end [CODESPLIT] def value ( self , progress_indicator ) : return interpolate . interpolate_linear_single ( self . initial_value , self . final_value , progress_indicator )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes an object / rabalist from registery . This is useful if you want to allow the garbage collector to free the memory taken by the objects you ve already loaded . Be careful might cause some discrepenties in your scripts . For objects cascades to free the registeries of related rabalists also [CODESPLIT] def removeFromRegistery ( obj ) : if isRabaObject ( obj ) : _unregisterRabaObjectInstance ( obj ) elif isRabaList ( obj ) : _unregisterRabaListInstance ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Scroll both categories Canvas and scrolling container [CODESPLIT] def _set_scroll_v ( self , * args ) : self . _canvas_categories . yview ( * args ) self . _canvas_scroll . yview ( * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns all items in the combobox dictionary . [CODESPLIT] def get_all_items ( self ) : return [ self . _widget . itemText ( k ) for k in range ( self . _widget . count ( ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Restoring scrollbar position after main window is visible [CODESPLIT] def restore_scrollbar_position ( self ) : scrollbar_pos = self . get_option ( 'scrollbar_position' , None ) if scrollbar_pos is not None : self . explorer . treewidget . set_scrollbar_position ( scrollbar_pos )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Singleton definition . [CODESPLIT] def singleton ( class_ ) : instances = { } def get_instance ( * args , * * kwargs ) : if class_ not in instances : instances [ class_ ] = class_ ( * args , * * kwargs ) return instances [ class_ ] return get_instance", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds noise to Y [CODESPLIT] def add_noise ( Y , sigma ) : return Y + np . random . normal ( 0 , sigma , Y . shape )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds the bundled jars to the JVM s classpath . [CODESPLIT] def add_bundled_jars ( ) : # determine lib directory with jars rootdir = os . path . split ( os . path . dirname ( __file__ ) ) [ 0 ] libdir = rootdir + os . sep + \"lib\" # add jars from lib directory for l in glob . glob ( libdir + os . sep + \"*.jar\" ) : if l . lower ( ) . find ( \"-src.\" ) == - 1 : javabridge . JARS . append ( str ( l ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dict from entries in a scala . collection . immutable . Map [CODESPLIT] def get_python_dict ( scala_map ) : python_dict = { } keys = get_python_list ( scala_map . keys ( ) . toList ( ) ) for key in keys : python_dict [ key ] = scala_map . apply ( key ) return python_dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Entry point for the jupytext script [CODESPLIT] def jupytext_cli ( args = None ) : try : jupytext ( args ) except ( ValueError , TypeError , IOError ) as err : sys . stderr . write ( '[jupytext] Error: ' + str ( err ) + '\\n' ) exit ( 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param unicode fpath : : param unicode encoding : : rtype : dict | list [CODESPLIT] def load_jsonf ( fpath , encoding ) : with codecs . open ( fpath , encoding = encoding ) as f : return json . load ( f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Hacked run function which installs the trace . [CODESPLIT] def __run ( self ) : sys . settrace ( self . globaltrace ) self . __run_backup ( ) self . run = self . __run_backup", "target": 1, "target_options": ["no_match", "match"]}
{"input": "pretty prints the tree with indentation [CODESPLIT] def pprint ( self , ind ) : pp = pprint . PrettyPrinter ( indent = ind ) pp . pprint ( self . tree )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Trim left - right given string [CODESPLIT] def _trim ( self , somestr ) : tmp = RE_LSPACES . sub ( \"\" , somestr ) tmp = RE_TSPACES . sub ( \"\" , tmp ) return str ( tmp )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Trim left - right given string [CODESPLIT] def _trim ( self , somestr ) : tmp = RE_LSPACES . sub ( \"\" , somestr ) tmp = RE_TSPACES . sub ( \"\" , tmp ) return str ( tmp )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Join a thread but if the thread doesn t terminate for some time ignore it instead of waiting infinitely . [CODESPLIT] def _try_join_cancelled_thread ( thread ) : thread . join ( 10 ) if thread . is_alive ( ) : logging . warning ( \"Thread %s did not terminate within grace period after cancellation\" , thread . name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a callable func trap the indicated exceptions for up to retries times invoking cleanup on the exception . On the final attempt allow any exceptions to propagate . [CODESPLIT] def retry_call ( func , cleanup = lambda : None , retries = 0 , trap = ( ) ) : attempts = count ( ) if retries == float ( 'inf' ) else range ( retries ) for attempt in attempts : try : return func ( ) except trap : cleanup ( ) return func ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply KMeans Clustering X : dataset with feature vectors [CODESPLIT] def fit ( self , X ) : self . centers_ , self . labels_ , self . sse_arr_ , self . n_iter_ = _kmeans ( X , self . n_clusters , self . max_iter , self . n_trials , self . tol )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform a O ( 1 ) memory hash of an iterable of arbitrary length . [CODESPLIT] def hash_iterable ( it ) : hash_value = hash ( type ( it ) ) for value in it : hash_value = hash ( ( hash_value , value ) ) return hash_value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize the length of a vector to one [CODESPLIT] def norm_vec ( vector ) : assert len ( vector ) == 3 v = np . array ( vector ) return v / np . sqrt ( np . sum ( v ** 2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Subclassing hook to specialize how JSON data is converted to keyword arguments [CODESPLIT] def json_to_initkwargs ( self , json_data , kwargs ) : if isinstance ( json_data , basestring ) : json_data = json . loads ( json_data ) return json_to_initkwargs ( self , json_data , kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "numpy . ndarray dumper . [CODESPLIT] def dump_nparray ( self , obj , class_name = numpy_ndarray_class_name ) : return { \"$\" + class_name : self . _json_convert ( obj . tolist ( ) ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses OLS to fit the regression . [CODESPLIT] def fit_linear ( X , y ) : model = linear_model . LinearRegression ( ) model . fit ( X , y ) return model", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return current free memory on the machine for windows . [CODESPLIT] def get_free_memory_win ( ) : stat = MEMORYSTATUSEX ( ) ctypes . windll . kernel32 . GlobalMemoryStatusEx ( ctypes . byref ( stat ) ) return int ( stat . ullAvailPhys / 1024 / 1024 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Search twitter API [CODESPLIT] def search_for_tweets_about ( user_id , params ) : url = \"https://api.twitter.com/1.1/search/tweets.json\" response = make_twitter_request ( url , user_id , params ) return process_tweets ( response . json ( ) [ \"statuses\" ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a list of ( key value ) pairs and turns it into a dict . [CODESPLIT] def list2dict ( lst ) : dic = { } for k , v in lst : dic [ k ] = v return dic", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a hdf5 file into a dictionary [CODESPLIT] def h5ToDict ( h5 , readH5pyDataset = True ) : h = h5py . File ( h5 , \"r\" ) ret = unwrapArray ( h , recursive = True , readH5pyDataset = readH5pyDataset ) if readH5pyDataset : h . close ( ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load : class : mongomock . database . Database from a local file . [CODESPLIT] def load_db ( file , db , verbose = True ) : db_data = json . load ( file , verbose = verbose ) return _load ( db_data , db )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get time from a locally running NTP server [CODESPLIT] def get_time ( ) : time_request = '\\x1b' + 47 * '\\0' now = struct . unpack ( \"!12I\" , ntp_service . request ( time_request , timeout = 5.0 ) . data . read ( ) ) [ 10 ] return time . ctime ( now - EPOCH_START )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handle logging . [CODESPLIT] def logger ( message , level = 10 ) : logging . getLogger ( __name__ ) . log ( level , str ( message ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "open usb port [CODESPLIT] def open_usb_handle ( self , port_num ) : serial = self . get_usb_serial ( port_num ) return local_usb . LibUsbHandle . open ( serial_number = serial )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a histogram for the data to the axes . [CODESPLIT] def _histplot_op ( ax , data , * * kwargs ) : bins = get_bins ( data ) ax . hist ( data , bins = bins , align = \"left\" , density = True , * * kwargs ) return ax", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transforms a list of 2 element tuples to a dictionary [CODESPLIT] def list2dict ( list_of_options ) : d = { } for key , value in list_of_options : d [ key ] = value return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exponential survival likelihood accounting for censoring [CODESPLIT] def survival ( value = t , lam = lam , f = failure ) : return sum ( f * log ( lam ) - lam * value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute Gaussian log - density at X for a tied model . [CODESPLIT] def _log_multivariate_normal_density_tied ( X , means , covars ) : cv = np . tile ( covars , ( means . shape [ 0 ] , 1 , 1 ) ) return _log_multivariate_normal_density_full ( X , means , cv )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param string s : under_scored string to be CamelCased : return : CamelCase version of input : rtype : str [CODESPLIT] def to_camel ( s ) : # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups return re . sub ( r'_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , '_' + s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def copy ( obj ) : def copy ( self ) : \"\"\"\n        Copy self to a new object.\n        \"\"\" from copy import deepcopy return deepcopy ( self ) obj . copy = copy return obj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generator that loops through all absolute paths of the files within folder [CODESPLIT] def get_all_files ( folder ) : for path , dirlist , filelist in os . walk ( folder ) : for fn in filelist : yield op . join ( path , fn )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform triple index into a 1 - D numpy array . [CODESPLIT] def _transform_triple_numpy ( x ) : return np . array ( [ x . head , x . relation , x . tail ] , dtype = np . int64 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Concatenate list of columns into a string . [CODESPLIT] def cols_str ( columns ) : cols = \"\" for c in columns : cols = cols + wrap ( c ) + ', ' return cols [ : - 2 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a property by name [CODESPLIT] def get_property_by_name ( pif , name ) : return next ( ( x for x in pif . properties if x . name == name ) , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Recurses the subkeys starting with the key . [CODESPLIT] def RecurseKeys ( self ) : yield self for subkey in self . GetSubkeys ( ) : for key in subkey . RecurseKeys ( ) : yield key", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Invert mapping of dictionary ( i . e . map values to list of keys ) [CODESPLIT] def invertDictMapping ( d ) : inv_map = { } for k , v in d . items ( ) : inv_map [ v ] = inv_map . get ( v , [ ] ) inv_map [ v ] . append ( k ) return inv_map", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Saves dictionary as CSV file . [CODESPLIT] def save_dict_to_file ( filename , dictionary ) : with open ( filename , 'w' ) as f : writer = csv . writer ( f ) for k , v in iteritems ( dictionary ) : writer . writerow ( [ str ( k ) , str ( v ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Saves the Jupyter work_notebook to write_file [CODESPLIT] def save_notebook ( work_notebook , write_file ) : with open ( write_file , 'w' ) as out_nb : json . dump ( work_notebook , out_nb , indent = 2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility method to convert list to tsv line with carriage return [CODESPLIT] def write_tsv_line_from_list ( linelist , outfp ) : line = '\\t' . join ( linelist ) outfp . write ( line ) outfp . write ( '\\n' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a 3x3 cross - product matrix from a 3 - element vector . [CODESPLIT] def cross_product_matrix ( vec ) : return np . array ( [ [ 0 , - vec [ 2 ] , vec [ 1 ] ] , [ vec [ 2 ] , 0 , - vec [ 0 ] ] , [ - vec [ 1 ] , vec [ 0 ] , 0 ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a string composed of elements in inlist with each element separated by delimiter . Used by function writedelimited . Use \\ t for tab - delimiting . [CODESPLIT] def linedelimited ( inlist , delimiter ) : outstr = '' for item in inlist : if type ( item ) != StringType : item = str ( item ) outstr = outstr + item + delimiter outstr = outstr [ 0 : - 1 ] return outstr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This method returns a shallow copy of a XML - Element . This method is for compatibility with Python 2 . 6 or earlier .. In Python 2 . 7 you can use copyElem = elem . copy () instead . [CODESPLIT] def copy_of_xml_element ( elem ) : copyElem = ElementTree . Element ( elem . tag , elem . attrib ) for child in elem : copyElem . append ( child ) return copyElem", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The main machinery of the Pipe calling the chosen callable with the recorded arguments . [CODESPLIT] def __ror__ ( self , other ) : return self . callable ( * ( self . args + ( other , ) ) , * * self . kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transforms an XML string it to python - zimbra dict format [CODESPLIT] def xml_str_to_dict ( s ) : xml = minidom . parseString ( s ) return pythonzimbra . tools . xmlserializer . dom_to_dict ( xml . firstChild )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Hparams for transformer on LM pretraining ( with 64k vocab ) on TPU . [CODESPLIT] def transformer_tall_pretrain_lm_tpu_adafactor ( ) : hparams = transformer_tall_pretrain_lm ( ) update_hparams_for_tpu ( hparams ) hparams . max_length = 1024 # For multi-problem on TPU we need it in absolute examples. hparams . batch_size = 8 hparams . multiproblem_vocab_size = 2 ** 16 return hparams", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield all non - sytem collections in db . [CODESPLIT] def all_collections ( db ) : include_pattern = r'(?!system\\.)' return ( db [ name ] for name in db . list_collection_names ( ) if re . match ( include_pattern , name ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses given YAML file . [CODESPLIT] def _ParseYamlFromFile ( filedesc ) : content = filedesc . read ( ) return yaml . Parse ( content ) or collections . OrderedDict ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a fixed axis [CODESPLIT] def get_axis ( array , axis , slice_num ) : slice_list = [ slice ( None ) ] * array . ndim slice_list [ axis ] = slice_num slice_data = array [ tuple ( slice_list ) ] . T # transpose for proper orientation return slice_data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty print an object as YAML . [CODESPLIT] def print_yaml ( o ) : print ( yaml . dump ( o , default_flow_style = False , indent = 4 , encoding = 'utf-8' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract the content of the zip - file at zip_path into target_folder . [CODESPLIT] def extract_zip ( zip_path , target_folder ) : with zipfile . ZipFile ( zip_path ) as archive : archive . extractall ( target_folder )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Temporarily replace sys . argv with current arguments [CODESPLIT] def replace_sys_args ( new_args ) : # Replace sys.argv arguments # for module import old_args = sys . argv sys . argv = new_args try : yield finally : sys . argv = old_args", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Implementation of map that recurses . This tests the same keys at every level of dict and in lists : param f : 2 - ary function expecting a key and value and returns a modified key : param dct : Dict for deep processing : return : Modified dct with matching props mapped [CODESPLIT] def map_keys_deep ( f , dct ) : return _map_deep ( lambda k , v : [ f ( k , v ) , v ] , dct )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initializes a gzip member decompressor wrapper . [CODESPLIT] def __init__ ( self , stream_start ) : self . _decompressor = zlib_decompressor . DeflateDecompressor ( ) self . last_read = stream_start self . uncompressed_offset = 0 self . _compressed_data = b''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Bulk insert or update . [CODESPLIT] def bulk_query ( self , query , * multiparams ) : with self . get_connection ( ) as conn : conn . bulk_query ( query , * multiparams )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Nested lists to single - level list does not split strings [CODESPLIT] def flatten_list ( l ) : return list ( chain . from_iterable ( repeat ( x , 1 ) if isinstance ( x , str ) else x for x in l ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks whether the value has changed since the last call . [CODESPLIT] def changed ( self , * value ) : if self . _last_checked_value != value : self . _last_checked_value = value return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Output a networkx graph to a DOT file . [CODESPLIT] def to_dotfile ( G : nx . DiGraph , filename : str ) : A = to_agraph ( G ) A . write ( filename )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generator that loops through all absolute paths of the files within folder [CODESPLIT] def get_all_files ( folder ) : for path , dirlist , filelist in os . walk ( folder ) : for fn in filelist : yield op . join ( path , fn )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return a normalized version of abmn [CODESPLIT] def _normalize_abmn ( abmn ) : abmn_2d = np . atleast_2d ( abmn ) abmn_normalized = np . hstack ( ( np . sort ( abmn_2d [ : , 0 : 2 ] , axis = 1 ) , np . sort ( abmn_2d [ : , 2 : 4 ] , axis = 1 ) , ) ) return abmn_normalized", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param dt : pythone datetime . datetime : return : 1999 - 02 - 01 string type [CODESPLIT] def QA_util_datetime_to_strdate ( dt ) : strdate = \"%04d-%02d-%02d\" % ( dt . year , dt . month , dt . day ) return strdate", "target": 1, "target_options": ["no_match", "match"]}
{"input": "rescales a numpy array so that min is 0 and max is 255 [CODESPLIT] def _normalize ( mat : np . ndarray ) : return ( ( mat - mat . min ( ) ) * ( 255 / mat . max ( ) ) ) . astype ( np . uint8 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a datetime to a millisecond accuracy timestamp [CODESPLIT] def datetime_to_ms ( dt ) : seconds = calendar . timegm ( dt . utctimetuple ( ) ) return seconds * 1000 + int ( dt . microsecond / 1000 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize a field to a ( min max ) exposure range default is ( 0 255 ) . ( min max ) exposure values . Invert the image if requested . [CODESPLIT] def normalize ( im , invert = False , scale = None , dtype = np . float64 ) : if dtype not in { np . float16 , np . float32 , np . float64 } : raise ValueError ( 'dtype must be numpy.float16, float32, or float64.' ) out = im . astype ( 'float' ) . copy ( ) scale = scale or ( 0.0 , 255.0 ) l , u = ( float ( i ) for i in scale ) out = ( out - l ) / ( u - l ) if invert : out = - out + ( out . max ( ) + out . min ( ) ) return out . astype ( dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper to get bins for histplot . [CODESPLIT] def _histplot_bins ( column , bins = 100 ) : col_min = np . min ( column ) col_max = np . max ( column ) return range ( col_min , col_max + 2 , max ( ( col_max - col_min ) // bins , 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert RGB arrays from mask canvas object back to boolean mask . [CODESPLIT] def _rgbtomask ( self , obj ) : dat = obj . get_image ( ) . get_data ( ) # RGB arrays return dat . sum ( axis = 2 ) . astype ( np . bool )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove tags from a file . [CODESPLIT] def delete ( filething ) : f = FLAC ( filething ) filething . fileobj . seek ( 0 ) f . delete ( filething )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wraps openjpeg library function cio_close . [CODESPLIT] def cio_close ( cio ) : OPENJPEG . opj_cio_close . argtypes = [ ctypes . POINTER ( CioType ) ] OPENJPEG . opj_cio_close ( cio )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the serial port e . g . : / dev / tty . usbserial - A4001ib8 [CODESPLIT] def do_serial ( self , p ) : try : self . serial . port = p self . serial . open ( ) print 'Opening serial port: %s' % p except Exception , e : print 'Unable to open serial port: %s' % p", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates data is a timestamp [CODESPLIT] def is_timestamp ( instance ) : if not isinstance ( instance , ( int , str ) ) : return True return datetime . fromtimestamp ( int ( instance ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Monkey - patch urllib3 with SecureTransport - backed SSL - support . [CODESPLIT] def inject_into_urllib3 ( ) : util . ssl_ . SSLContext = SecureTransportContext util . HAS_SNI = HAS_SNI util . ssl_ . HAS_SNI = HAS_SNI util . IS_SECURETRANSPORT = True util . ssl_ . IS_SECURETRANSPORT = True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove the querystring from the end of a URL . [CODESPLIT] def strip_querystring ( url ) : p = six . moves . urllib . parse . urlparse ( url ) return p . scheme + \"://\" + p . netloc + p . path", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reimplemented to only return GraphicsItems [CODESPLIT] def parent_widget ( self ) : parent = self . parent ( ) if parent is not None and isinstance ( parent , QtGraphicsItem ) : return parent . widget", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a str of decimal with two digits after a decimal mark . [CODESPLIT] def money ( min = 0 , max = 10 ) : value = random . choice ( range ( min * 100 , max * 100 ) ) return \"%1.2f\" % ( float ( value ) / 100 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Also converts either to ints or to floats . [CODESPLIT] def minus ( * args ) : if len ( args ) == 1 : return - to_numeric ( args [ 0 ] ) return to_numeric ( args [ 0 ] ) - to_numeric ( args [ 1 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turns a Python unicode string list into a Java String array . [CODESPLIT] def string_list_to_array ( l ) : result = javabridge . get_env ( ) . make_object_array ( len ( l ) , javabridge . get_env ( ) . find_class ( \"java/lang/String\" ) ) for i in range ( len ( l ) ) : javabridge . get_env ( ) . set_object_array_element ( result , i , javabridge . get_env ( ) . new_string_utf ( l [ i ] ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make copy and remove non - ascii characters from it . [CODESPLIT] def _remove_nonascii ( self , df ) : df_copy = df . copy ( deep = True ) for col in df_copy . columns : if ( df_copy [ col ] . dtype == np . dtype ( 'O' ) ) : df_copy [ col ] = df [ col ] . apply ( lambda x : re . sub ( r'[^\\x00-\\x7f]' , r'' , x ) if isinstance ( x , six . string_types ) else x ) return df_copy", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a string from a file - like object . [CODESPLIT] def read_string ( buff , byteorder = 'big' ) : length = read_numeric ( USHORT , buff , byteorder ) return buff . read ( length ) . decode ( 'utf-8' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a 20 char passphrase with easily typeable chars . [CODESPLIT] def GeneratePassphrase ( length = 20 ) : valid_chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" valid_chars += \"0123456789 ,-_&$#\" return \"\" . join ( random . choice ( valid_chars ) for i in range ( length ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read tag data from file and return as unicode string . [CODESPLIT] def read_utf8 ( fh , byteorder , dtype , count , offsetsize ) : return fh . read ( count ) . decode ( 'utf-8' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exponential survival likelihood accounting for censoring [CODESPLIT] def survival ( value = t , lam = lam , f = failure ) : return sum ( f * log ( lam ) - lam * value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Choose k random elements of array . [CODESPLIT] def downsample ( array , k ) : length = array . shape [ 0 ] indices = random . sample ( xrange ( length ) , k ) return array [ indices ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Recieving the JSON file from uulm [CODESPLIT] def get ( url ) : response = urllib . request . urlopen ( url ) data = response . read ( ) data = data . decode ( \"utf-8\" ) data = json . loads ( data ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pause the music [CODESPLIT] def pause ( self ) : mixer . music . pause ( ) self . pause_time = self . get_time ( ) self . paused = True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "yields a connected socket [CODESPLIT] def connected_socket ( address , timeout = 3 ) : sock = socket . create_connection ( address , timeout ) yield sock sock . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Use pymovie to render ( visual + audio ) + text overlays . [CODESPLIT] def makeAnimation ( self ) : aclip = mpy . AudioFileClip ( \"sound.wav\" ) self . iS = self . iS . set_audio ( aclip ) self . iS . write_videofile ( \"mixedVideo.webm\" , 15 , audio = True ) print ( \"wrote \" + \"mixedVideo.webm\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a histogram for the data to the axes . [CODESPLIT] def _histplot_op ( ax , data , * * kwargs ) : bins = get_bins ( data ) ax . hist ( data , bins = bins , align = \"left\" , density = True , * * kwargs ) return ax", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a password is valid [CODESPLIT] def is_password_valid ( password ) : pattern = re . compile ( r\"^.{4,75}$\" ) return bool ( pattern . match ( password ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Log - normal function from scipy [CODESPLIT] def lognorm ( x , mu , sigma = 1.0 ) : return stats . lognorm ( sigma , scale = mu ) . pdf ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cartesian to Polar coordinates conversion . [CODESPLIT] def cart2pol ( x , y ) : theta = np . arctan2 ( y , x ) rho = np . hypot ( x , y ) return theta , rho", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make copy and remove non - ascii characters from it . [CODESPLIT] def _remove_nonascii ( self , df ) : df_copy = df . copy ( deep = True ) for col in df_copy . columns : if ( df_copy [ col ] . dtype == np . dtype ( 'O' ) ) : df_copy [ col ] = df [ col ] . apply ( lambda x : re . sub ( r'[^\\x00-\\x7f]' , r'' , x ) if isinstance ( x , six . string_types ) else x ) return df_copy", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cleans trailing whitespaces and replaces also multiple whitespaces with a single space . [CODESPLIT] def strip_spaces ( value , sep = None , join = True ) : value = value . strip ( ) value = [ v . strip ( ) for v in value . split ( sep ) ] join_sep = sep or ' ' return join_sep . join ( value ) if join else value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "prints the top n lines of a file [CODESPLIT] def head ( filename , n = 10 ) : with freader ( filename ) as fr : for _ in range ( n ) : print ( fr . readline ( ) . strip ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a list ( l ) will removing duplicates from the list preserving the original order of the list . Assumes that the list entrie are hashable . [CODESPLIT] def dedup_list ( l ) : dedup = set ( ) return [ x for x in l if not ( x in dedup or dedup . add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Serialises a protobuf object as json [CODESPLIT] def toJson ( protoObject , indent = None ) : # Using the internal method because this way we can reformat the JSON js = json_format . MessageToDict ( protoObject , False ) return json . dumps ( js , indent = indent )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if filename exists and remove [CODESPLIT] def file_remove ( self , path , filename ) : if os . path . isfile ( path + filename ) : os . remove ( path + filename )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print in color . [CODESPLIT] def printc ( cls , txt , color = colors . red ) : print ( cls . color_txt ( txt , color ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raw print to sys . __stdout__ otherwise identical interface to print () . [CODESPLIT] def raw_print ( * args , * * kw ) : print ( * args , sep = kw . get ( 'sep' , ' ' ) , end = kw . get ( 'end' , '\\n' ) , file = sys . __stdout__ ) sys . __stdout__ . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show the received object as precise as possible . [CODESPLIT] def _repr ( obj ) : vals = \", \" . join ( \"{}={!r}\" . format ( name , getattr ( obj , name ) ) for name in obj . _attribs ) if vals : t = \"{}(name={}, {})\" . format ( obj . __class__ . __name__ , obj . name , vals ) else : t = \"{}(name={})\" . format ( obj . __class__ . __name__ , obj . name ) return t", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print emphasized neutral the given txt message [CODESPLIT] def info ( txt ) : print ( \"%s# %s%s%s\" % ( PR_EMPH_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove comments and empty lines [CODESPLIT] def lines ( input ) : for raw_line in input : line = raw_line . strip ( ) if line and not line . startswith ( '#' ) : yield strip_comments ( line )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator for clean docstring formatting [CODESPLIT] def format_docstring ( * args , * * kwargs ) : def decorator ( func ) : func . __doc__ = getdoc ( func ) . format ( * args , * * kwargs ) return func return decorator", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip apostrophe and s from the end of a string . [CODESPLIT] def unapostrophe ( text ) : text = re . sub ( r'[%s]s?$' % '' . join ( APOSTROPHES ) , '' , text ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "cv2 Image of current window screen [CODESPLIT] def screen_cv2 ( self ) : pil_image = self . screen . convert ( 'RGB' ) cv2_image = np . array ( pil_image ) pil_image . close ( ) # Convert RGB to BGR \n cv2_image = cv2_image [ : , : , : : - 1 ] return cv2_image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add 0x to string at start . [CODESPLIT] def add_0x ( string ) : if isinstance ( string , bytes ) : string = string . decode ( 'utf-8' ) return '0x' + str ( string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a list of words given text removing punctuation . [CODESPLIT] def wordify ( text ) : stopset = set ( nltk . corpus . stopwords . words ( 'english' ) ) tokens = nltk . WordPunctTokenizer ( ) . tokenize ( text ) return [ w for w in tokens if w not in stopset ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the unique elements of a collection even if those elements are unhashable and unsortable like dicts and sets [CODESPLIT] def unique ( seq ) : cleaned = [ ] for each in seq : if each not in cleaned : cleaned . append ( each ) return cleaned", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Synthesize white noise [CODESPLIT] def synthesize ( self , duration ) : sr = self . samplerate . samples_per_second seconds = duration / Seconds ( 1 ) samples = np . random . uniform ( low = - 1. , high = 1. , size = int ( sr * seconds ) ) return AudioSamples ( samples , self . samplerate )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace regex with string . [CODESPLIT] def fmt_subst ( regex , subst ) : return lambda text : re . sub ( regex , subst , text ) if text else text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Min reduction op . [CODESPLIT] def Min ( a , axis , keep_dims ) : return np . amin ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A basic slug version of a given parameter list . [CODESPLIT] def delistify ( x ) : if isinstance ( x , list ) : x = [ e . replace ( \"'\" , \"\" ) for e in x ] return '-' . join ( sorted ( x ) ) return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace multiple values in a string [CODESPLIT] def replace ( s , replace ) : for r in replace : s = s . replace ( * r ) return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "\\ Asserts that two iterables contain the same values . [CODESPLIT] def expect_all ( a , b ) : assert all ( _a == _b for _a , _b in zip_longest ( a , b ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def mouse_get_pos ( ) : p = POINT ( ) AUTO_IT . AU3_MouseGetPos ( ctypes . byref ( p ) ) return p . x , p . y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove unwanted list indices . First argument is the list of indices to remove . Other elements are the lists to trim . [CODESPLIT] def rm_empty_indices ( * args ) : rm_inds = args [ 0 ] if not rm_inds : return args [ 1 : ] keep_inds = [ i for i in range ( len ( args [ 1 ] ) ) if i not in rm_inds ] return [ [ a [ i ] for i in keep_inds ] for a in args [ 1 : ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Look for a form on the page and submit it . [CODESPLIT] def submit_the_only_form ( self ) : form = ElementSelector ( world . browser , str ( '//form' ) ) assert form , \"Cannot find a form on the page.\" form . submit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the string without any initial or final quotes . [CODESPLIT] def _repr_strip ( mystring ) : r = repr ( mystring ) if r . startswith ( \"'\" ) and r . endswith ( \"'\" ) : return r [ 1 : - 1 ] else : return r", "target": 1, "target_options": ["no_match", "match"]}
{"input": "When inside a loop logger created a new iteration [CODESPLIT] def new_iteration ( self , prefix ) : # Flush data for the current iteration self . flush ( ) # Fix prefix self . prefix [ - 1 ] = prefix self . reset_formatter ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Mengembalikan hasil serialisasi objek Makna ini . [CODESPLIT] def serialisasi ( self ) : return { \"kelas\" : self . kelas , \"submakna\" : self . submakna , \"info\" : self . info , \"contoh\" : self . contoh }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a 3x3 cross - product matrix from a 3 - element vector . [CODESPLIT] def cross_product_matrix ( vec ) : return np . array ( [ [ 0 , - vec [ 2 ] , vec [ 1 ] ] , [ vec [ 2 ] , 0 , - vec [ 0 ] ] , [ - vec [ 1 ] , vec [ 0 ] , 0 ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raises a requests . exceptions . HTTPError if the response has a non - 200 status code . [CODESPLIT] def raise_for_not_ok_status ( response ) : if response . code != OK : raise HTTPError ( 'Non-200 response code (%s) for url: %s' % ( response . code , uridecode ( response . request . absoluteURI ) ) ) return response", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Populates an object s attributes using the provided dict [CODESPLIT] def populate_obj ( obj , attrs ) : for k , v in attrs . iteritems ( ) : setattr ( obj , k , v )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a confusion matrix returns the accuracy . Accuracy Definition : http : // research . ics . aalto . fi / events / eyechallenge2005 / evaluation . shtml [CODESPLIT] def accuracy ( conf_matrix ) : total , correct = 0.0 , 0.0 for true_response , guess_dict in conf_matrix . items ( ) : for guess , count in guess_dict . items ( ) : if true_response == guess : correct += count total += count return correct / total", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds noise to Y [CODESPLIT] def add_noise ( Y , sigma ) : return Y + np . random . normal ( 0 , sigma , Y . shape )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Align the position in the file to the next block of specified size [CODESPLIT] def align_file_position ( f , size ) : align = ( size - 1 ) - ( f . tell ( ) % size ) f . seek ( align , 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts from hex to hsv [CODESPLIT] def hex_to_hsv ( color ) : color = normalize ( color ) color = color [ 1 : ] # color=tuple(ord(c)/255.0 for c in color.decode('hex')) color = ( int ( color [ 0 : 2 ] , base = 16 ) / 255.0 , int ( color [ 2 : 4 ] , base = 16 ) / 255.0 , int ( color [ 4 : 6 ] , base = 16 ) / 255.0 ) return colorsys . rgb_to_hsv ( * color )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rotates an image by deg degrees [CODESPLIT] def rotate_img ( im , deg , mode = cv2 . BORDER_CONSTANT , interpolation = cv2 . INTER_AREA ) : r , c ,  * _ = im . shape M = cv2 . getRotationMatrix2D ( ( c // 2 , r // 2 ) , deg , 1 ) return cv2 . warpAffine ( im , M , ( c , r ) , borderMode = mode , flags = cv2 . WARP_FILL_OUTLIERS + interpolation )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the largest real value h such that all elements in x are integer multiples of h . [CODESPLIT] def _gcd_array ( X ) : greatest_common_divisor = 0.0 for x in X : greatest_common_divisor = _gcd ( greatest_common_divisor , x ) return greatest_common_divisor", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield successive n - sized chunks from l . [CODESPLIT] def chunk_sequence ( sequence , chunk_length ) : for index in range ( 0 , len ( sequence ) , chunk_length ) : yield sequence [ index : index + chunk_length ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Round a time DOWN to half nearest half - hour . [CODESPLIT] def _round_half_hour ( record ) : k = record . datetime + timedelta ( minutes = - ( record . datetime . minute % 30 ) ) return datetime ( k . year , k . month , k . day , k . hour , k . minute , 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the RMS of the audio [CODESPLIT] def calc_volume ( self , sample : np . ndarray ) : return sqrt ( np . mean ( np . square ( sample ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Round the number to the specified number of significant figures [CODESPLIT] def round_sig ( x , sig ) : return round ( x , sig - int ( floor ( log10 ( abs ( x ) ) ) ) - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns x rounded to n significant figures . [CODESPLIT] def round_figures ( x , n ) : return round ( x , int ( n - math . ceil ( math . log10 ( abs ( x ) ) ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Round to sig figs [CODESPLIT] def round_to_n ( x , n ) : return round ( x , - int ( np . floor ( np . log10 ( x ) ) ) + ( n - 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "apply a function to all non - dict values in a dictionary [CODESPLIT] def dictapply ( d , fn ) : for k , v in d . items ( ) : if isinstance ( v , dict ) : v = dictapply ( v , fn ) else : d [ k ] = fn ( v ) return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Abstraction over executemany method [CODESPLIT] def store_many ( self , sql , values ) : cursor = self . get_cursor ( ) cursor . executemany ( sql , values ) self . conn . commit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resizes the given image to fit inside a box of the given size . [CODESPLIT] def resize_image ( self , data , size ) : from machina . core . compat import PILImage as Image image = Image . open ( BytesIO ( data ) ) # Resize! image . thumbnail ( size , Image . ANTIALIAS ) string = BytesIO ( ) image . save ( string , format = 'PNG' ) return string . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "composion of preprocessing functions [CODESPLIT] def compose ( func_list ) : def f ( G , bim ) : for func in func_list : G , bim = func ( G , bim ) return G , bim return f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "An argparse type representing an email address . [CODESPLIT] def email_type ( arg ) : if not is_valid_email_address ( arg ) : raise argparse . ArgumentTypeError ( \"{0} is not a valid email address\" . format ( repr ( arg ) ) ) return arg", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a parser for setting one or more configuration paths [CODESPLIT] def parser ( ) : parser = argparse . ArgumentParser ( ) parser . add_argument ( '-c' , '--config_paths' , default = [ ] , action = 'append' , help = 'path to a configuration directory' ) return parser", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Store the user session for a client . [CODESPLIT] def save_session ( self , sid , session , namespace = None ) : return self . server . save_session ( sid , session , namespace = namespace or self . namespace )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Select rows where the given field is not None . [CODESPLIT] def selectnotnone ( table , field , complement = False ) : return select ( table , field , lambda v : v is not None , complement = complement )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Command line parser . [CODESPLIT] def parse_command_args ( ) : parser = argparse . ArgumentParser ( description = 'Register PB devices.' ) parser . add_argument ( 'num_pb' , type = int , help = 'Number of PBs devices to register.' ) return parser . parse_args ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets args and kwargs that are passed when creating a subparsers group in an argparse . ArgumentParser i . e . when calling argparser . ArgumentParser . add_subparsers [CODESPLIT] def set_subparsers_args ( self , * args , * * kwargs ) : self . subparsers_args = args self . subparsers_kwargs = kwargs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Selects columns where fun ( ction ) is true Args : fun : a function that will be applied to columns [CODESPLIT] def select_if ( df , fun ) : def _filter_f ( col ) : try : return fun ( df [ col ] ) except : return False cols = list ( filter ( _filter_f , df . columns ) ) return df [ cols ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "An argparse type representing an email address . [CODESPLIT] def email_type ( arg ) : if not is_valid_email_address ( arg ) : raise argparse . ArgumentTypeError ( \"{0} is not a valid email address\" . format ( repr ( arg ) ) ) return arg", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if arg is a valid file that already exists on the file system . [CODESPLIT] def is_valid_folder ( parser , arg ) : arg = os . path . abspath ( arg ) if not os . path . isdir ( arg ) : parser . error ( \"The folder %s does not exist!\" % arg ) else : return arg", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function to split every line in a list and retain spaces for a rejoin : param orig_list : Original list : return : A List with split lines [CODESPLIT] def split_strings_in_list_retain_spaces ( orig_list ) : temp_list = list ( ) for line in orig_list : line_split = __re . split ( r'(\\s+)' , line ) temp_list . append ( line_split ) return temp_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if the given value is a scalar . [CODESPLIT] def is_scalar ( value ) : return np . isscalar ( value ) or ( isinstance ( value , np . ndarray ) and ( len ( np . squeeze ( value ) . shape ) == 0 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Assert that a value must be a given type . [CODESPLIT] def _assert_is_type ( name , value , value_type ) : if not isinstance ( value , value_type ) : if type ( value_type ) is tuple : types = ', ' . join ( t . __name__ for t in value_type ) raise ValueError ( '{0} must be one of ({1})' . format ( name , types ) ) else : raise ValueError ( '{0} must be {1}' . format ( name , value_type . __name__ ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If rex expression is not found then raise DataNotFound exception . [CODESPLIT] def rex_assert ( self , rex , byte = False ) : self . rex_search ( rex , byte = byte )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raises an AssertionError if obj is not in seq . [CODESPLIT] def assert_in ( obj , seq , message = None , extra = None ) : assert obj in seq , _assert_fail_message ( message , obj , seq , \"is not in\" , extra )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raises an AssertionError if value is not an instance of type ( s ) . [CODESPLIT] def assert_is_instance ( value , types , message = None , extra = None ) : assert isinstance ( value , types ) , _assert_fail_message ( message , value , types , \"is not an instance of\" , extra )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Toggle linear / log scale for Y - axis . [CODESPLIT] def log_y_cb ( self , w , val ) : self . tab_plot . logy = val self . plot_two_columns ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the output shape from an array . [CODESPLIT] def out_shape_from_array ( arr ) : arr = np . asarray ( arr ) if arr . ndim == 1 : return arr . shape else : return ( arr . shape [ 1 ] , )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load proxy list from configured proxy source [CODESPLIT] def load ( self ) : self . _list = self . _source . load ( ) self . _list_iter = itertools . cycle ( self . _list )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the length of the longest consecutive run of identical values . [CODESPLIT] def longest_run_1d ( arr ) : v , rl = rle_1d ( arr ) [ : 2 ] return np . where ( v , rl , 0 ) . max ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "List all RDS thingys . [CODESPLIT] def list_rds ( region , filter_by_kwargs ) : conn = boto . rds . connect_to_region ( region ) instances = conn . get_all_dbinstances ( ) return lookup ( instances , filter_by = filter_by_kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set up a new instance . [CODESPLIT] def __init__ ( self , enumtype , index , key ) : self . _enumtype = enumtype self . _index = index self . _key = key", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show the x - axis tick labels for a subplot . [CODESPLIT] def show_xticklabels ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . show_xticklabels ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for plotting . [CODESPLIT] def finish_plot ( ) : plt . legend ( ) plt . grid ( color = '0.7' ) plt . xlabel ( 'x' ) plt . ylabel ( 'y' ) plt . show ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coerce value to an JSON - compatible representation . [CODESPLIT] def _bytes_to_json ( value ) : if isinstance ( value , bytes ) : value = base64 . standard_b64encode ( value ) . decode ( \"ascii\" ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a one element byte string to signed int for python 2 support . [CODESPLIT] def bin_to_int ( string ) : if isinstance ( string , str ) : return struct . unpack ( \"b\" , string ) [ 0 ] else : return struct . unpack ( \"b\" , bytes ( [ string ] ) ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Skip the next time frame [CODESPLIT] def _skip_frame ( self ) : for line in self . _f : if line == 'ITEM: ATOMS\\n' : break for i in range ( self . num_atoms ) : next ( self . _f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Bootstrapped mean with confidence limits [CODESPLIT] def mean_cl_boot ( series , n_samples = 1000 , confidence_interval = 0.95 , random_state = None ) : return bootstrap_statistics ( series , np . mean , n_samples = n_samples , confidence_interval = confidence_interval , random_state = random_state )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Starts the web server . [CODESPLIT] def start ( ) : global app bottle . run ( app , host = conf . WebHost , port = conf . WebPort , debug = conf . WebAutoReload , reloader = conf . WebAutoReload , quiet = conf . WebQuiet )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "split string into list of strings by specified number . [CODESPLIT] def _split_str ( s , n ) : length = len ( s ) return [ s [ i : i + n ] for i in range ( 0 , length , n ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "split string into list of strings by specified number . [CODESPLIT] def _split_str ( s , n ) : length = len ( s ) return [ s [ i : i + n ] for i in range ( 0 , length , n ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Used internally by memoize decorator to get / store function results [CODESPLIT] def _get_memoized_value ( func , args , kwargs ) : key = ( repr ( args ) , repr ( kwargs ) ) if not key in func . _cache_dict : ret = func ( * args , * * kwargs ) func . _cache_dict [ key ] = ret return func . _cache_dict [ key ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "There are two error - handling policies implemented here : a fail - fast policy intended for stand - alone scripts which fails on all responses except HTTP 200 . The other policy is intended for long - running tasks that need to respect rate - limiting errors from the server and paper over outages of up to 1 hour . [CODESPLIT] def post_ratelimited ( protocol , session , url , headers , data , allow_redirects = False , stream = False ) : thread_id = get_ident ( ) wait = 10 # seconds retry = 0 redirects = 0 # In Python 2, we want this to be a 'str' object so logging doesn't break (all formatting arguments are 'str'). # We activated 'unicode_literals' at the top of this file, so it would be a 'unicode' object unless we convert # to 'str' explicitly. This is a no-op for Python 3. log_msg = str ( '''\\\nRetry: %(retry)s\nWaited: %(wait)s\nTimeout: %(timeout)s\nSession: %(session_id)s\nThread: %(thread_id)s\nAuth type: %(auth)s\nURL: %(url)s\nHTTP adapter: %(adapter)s\nAllow redirects: %(allow_redirects)s\nStreaming: %(stream)s\nResponse time: %(response_time)s\nStatus code: %(status_code)s\nRequest headers: %(request_headers)s\nResponse headers: %(response_headers)s\nRequest data: %(xml_request)s\nResponse data: %(xml_response)s\n''' ) log_vals = dict ( retry = retry , wait = wait , timeout = protocol . TIMEOUT , session_id = session . session_id , thread_id = thread_id , auth = session . auth , url = url , adapter = session . get_adapter ( url ) , allow_redirects = allow_redirects , stream = stream , response_time = None , status_code = None , request_headers = headers , response_headers = None , xml_request = data , xml_response = None , ) try : while True : _back_off_if_needed ( protocol . credentials . back_off_until ) log . debug ( 'Session %s thread %s: retry %s timeout %s POST\\'ing to %s after %ss wait' , session . session_id , thread_id , retry , protocol . TIMEOUT , url , wait ) d_start = time_func ( ) # Always create a dummy response for logging purposes, in case we fail in the following r = DummyResponse ( url = url , headers = { } , request_headers = headers ) try : r = session . post ( url = url , headers = headers , data = data , allow_redirects = False , timeout = protocol . TIMEOUT , stream = stream ) except CONNECTION_ERRORS as e : log . debug ( 'Session %s thread %s: connection error POST\\'ing to %s' , session . session_id , thread_id , url ) r = DummyResponse ( url = url , headers = { 'TimeoutException' : e } , request_headers = headers ) finally : log_vals . update ( retry = retry , wait = wait , session_id = session . session_id , url = str ( r . url ) , response_time = time_func ( ) - d_start , status_code = r . status_code , request_headers = r . request . headers , response_headers = r . headers , xml_response = '[STREAMING]' if stream else r . content , ) log . debug ( log_msg , log_vals ) if _may_retry_on_error ( r , protocol , wait ) : log . info ( \"Session %s thread %s: Connection error on URL %s (code %s). Cool down %s secs\" , session . session_id , thread_id , r . url , r . status_code , wait ) time . sleep ( wait ) # Increase delay for every retry retry += 1 wait *= 2 session = protocol . renew_session ( session ) continue if r . status_code in ( 301 , 302 ) : if stream : r . close ( ) url , redirects = _redirect_or_fail ( r , redirects , allow_redirects ) continue break except ( RateLimitError , RedirectError ) as e : log . warning ( e . value ) protocol . retire_session ( session ) raise except Exception as e : # Let higher layers handle this. Add full context for better debugging. log . error ( str ( '%s: %s\\n%s' ) , e . __class__ . __name__ , str ( e ) , log_msg % log_vals ) protocol . retire_session ( session ) raise if r . status_code == 500 and r . content and is_xml ( r . content ) : # Some genius at Microsoft thinks it's OK to send a valid SOAP response as an HTTP 500 log . debug ( 'Got status code %s but trying to parse content anyway' , r . status_code ) elif r . status_code != 200 : protocol . retire_session ( session ) try : _raise_response_errors ( r , protocol , log_msg , log_vals ) # Always raises an exception finally : if stream : r . close ( ) log . debug ( 'Session %s thread %s: Useful response from %s' , session . session_id , thread_id , url ) return r , session", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get hue value of HSL color . [CODESPLIT] def _hue ( color , * * kwargs ) : h = colorsys . rgb_to_hls ( * [ x / 255.0 for x in color . value [ : 3 ] ] ) [ 0 ] return NumberValue ( h * 360.0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate standard deviation weighted by errors [CODESPLIT] def weighted_std ( values , weights ) : average = np . average ( values , weights = weights ) variance = np . average ( ( values - average ) ** 2 , weights = weights ) return np . sqrt ( variance )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update a staticmethod update . [CODESPLIT] def _update_staticmethod ( self , oldsm , newsm ) : # While we can't modify the staticmethod object itself (it has no # mutable attributes), we *can* extract the underlying function # (by calling __get__(), which returns it) and update it in-place. # We don't have the class available to pass to __get__() but any # object except None will do. self . _update ( None , None , oldsm . __get__ ( 0 ) , newsm . __get__ ( 0 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Submit an operation [CODESPLIT] def submit ( self , fn , * args , * * kwargs ) : corofn = asyncio . coroutine ( lambda : fn ( * args , * * kwargs ) ) return run_coroutine_threadsafe ( corofn ( ) , self . loop )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Stops the video stream and resets the clock . [CODESPLIT] def stop ( self ) : logger . debug ( \"Stopping playback\" ) # Stop the clock self . clock . stop ( ) # Set plauyer status to ready self . status = READY", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coroutine called by MapAsync . It s wrapping the call of run_in_executor to run the synchronous function as thread [CODESPLIT] async def _thread_coro ( self , * args ) : return await self . _loop . run_in_executor ( self . _executor , self . _function , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prints the specified message and exits the program with the specified exit status . [CODESPLIT] def fail ( message = None , exit_status = None ) : print ( 'Error:' , message , file = sys . stderr ) sys . exit ( exit_status or 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deserializes a JSONified : obj : numpy . ndarray that was created using numpy s : obj : save function . [CODESPLIT] def deserialize_ndarray_npy ( d ) : with io . BytesIO ( ) as f : f . write ( json . loads ( d [ 'npy' ] ) . encode ( 'latin-1' ) ) f . seek ( 0 ) return np . load ( f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes underscores and capitalizes the neighbouring character [CODESPLIT] def mixedcase ( path ) : words = path . split ( '_' ) return words [ 0 ] + '' . join ( word . title ( ) for word in words [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Called by remote workers . Useful to populate main module globals () for interactive shells . Retrieves the serialized function . [CODESPLIT] def getFunction ( self ) : return functionFactory ( self . code , self . name , self . defaults , self . globals , self . imports , )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert spherical coordinates to cartesian unit vectors . [CODESPLIT] def angle_to_cartesian ( lon , lat ) : theta = np . array ( np . pi / 2. - lat ) return np . vstack ( ( np . sin ( theta ) * np . cos ( lon ) , np . sin ( theta ) * np . sin ( lon ) , np . cos ( theta ) ) ) . T", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a one - hot encoded array back to string [CODESPLIT] def one_hot2string ( arr , vocab ) : tokens = one_hot2token ( arr ) indexToLetter = _get_index_dict ( vocab ) return [ '' . join ( [ indexToLetter [ x ] for x in row ] ) for row in tokens ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cartesian to Polar coordinates conversion . [CODESPLIT] def cart2pol ( x , y ) : theta = np . arctan2 ( y , x ) rho = np . hypot ( x , y ) return theta , rho", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string to bytes . [CODESPLIT] def to_bytes ( s , encoding = \"utf-8\" ) : if isinstance ( s , six . binary_type ) : return s if six . PY3 : return bytes ( s , encoding ) return s . encode ( encoding )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "helper function for parsing FRED date string into datetime [CODESPLIT] def _parse ( self , date_str , format = '%Y-%m-%d' ) : rv = pd . to_datetime ( date_str , format = format ) if hasattr ( rv , 'to_pydatetime' ) : rv = rv . to_pydatetime ( ) return rv", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip SGML / XML tags and replace adjacent whitespace by one space . [CODESPLIT] def do_striptags ( value ) : if hasattr ( value , '__html__' ) : value = value . __html__ ( ) return Markup ( unicode ( value ) ) . striptags ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Increment the date by a certain number and return date object . as the specific string format . [CODESPLIT] def inc_date ( date_obj , num , date_fmt ) : return ( date_obj + timedelta ( days = num ) ) . strftime ( date_fmt )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Whitespace normalization : [CODESPLIT] def text_remove_empty_lines ( text ) : lines = [ line . rstrip ( ) for line in text . splitlines ( ) if line . strip ( ) ] return \"\\n\" . join ( lines )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Acquire the lock to write [CODESPLIT] def writer_acquire ( self ) : self . _order_mutex . acquire ( ) self . _access_mutex . acquire ( ) self . _order_mutex . release ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert naive datetime to timezone - aware datetime [CODESPLIT] def datetime_to_timezone ( date , tz = \"UTC\" ) : if not date . tzinfo : date = date . replace ( tzinfo = timezone ( get_timezone ( ) ) ) return date . astimezone ( timezone ( tz ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Indicate whether the specified image file is valid or not . [CODESPLIT] def is_image_file_valid ( file_path_name ) : # Image.verify is only implemented for PNG images, and it only verifies # the CRC checksum in the image.  The only way to check from within # Pillow is to load the image in a try/except and check the error.  If # as much info as possible is from the image is needed, # ``ImageFile.LOAD_TRUNCATED_IMAGES=True`` needs to bet set and it # will attempt to parse as much as possible. try : with Image . open ( file_path_name ) as image : image . load ( ) except IOError : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to turn a string representation of true into boolean True . [CODESPLIT] def strToBool ( val ) : if isinstance ( val , str ) : val = val . lower ( ) return val in [ 'true' , 'on' , 'yes' , True ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Small transformer model with small batch size for fast step times . [CODESPLIT] def afx_small ( ) : hparams = transformer . transformer_tpu ( ) hparams . filter_size = 1024 hparams . num_heads = 4 hparams . num_hidden_layers = 3 hparams . batch_size = 512 return hparams", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return True if callback is a vanilla plain jane function [CODESPLIT] def is_function ( self ) : if self . is_instance ( ) or self . is_class ( ) : return False return isinstance ( self . callback , ( Callable , classmethod ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove commas from a float [CODESPLIT] def clean_float ( v ) : if v is None or not str ( v ) . strip ( ) : return None return float ( str ( v ) . replace ( ',' , '' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if two images have the same height and width ( and optionally channels ) . [CODESPLIT] def is_same_shape ( self , other_im , check_channels = False ) : if self . height == other_im . height and self . width == other_im . width : if check_channels and self . channels != other_im . channels : return False return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is this a call with exactly 1 argument where that argument is positional? [CODESPLIT] def _is_one_arg_pos_call ( call ) : return isinstance ( call , astroid . Call ) and len ( call . args ) == 1 and not call . keywords", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clear the contents of the TimeLine Canvas [CODESPLIT] def clear_timeline ( self ) : self . _timeline . delete ( tk . ALL ) self . _canvas_ticks . delete ( tk . ALL )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Se asegura de que un directorio exista . [CODESPLIT] def ensure_dir_exists ( directory ) : if directory and not os . path . exists ( directory ) : os . makedirs ( directory )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tokenizes * source * and returns the tokens as a list of lists . [CODESPLIT] def listified_tokenizer ( source ) : io_obj = io . StringIO ( source ) return [ list ( a ) for a in tokenize . generate_tokens ( io_obj . readline ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Drops the trailing zeros in a float that is printed . [CODESPLIT] def drop_trailing_zeros ( num ) : txt = '%f' % ( num ) txt = txt . rstrip ( '0' ) if txt . endswith ( '.' ) : txt = txt [ : - 1 ] return txt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns true if all of the elements in the list are equal . [CODESPLIT] def _check_elements_equal ( lst ) : assert isinstance ( lst , list ) , \"Input value must be a list.\" return not lst or lst . count ( lst [ 0 ] ) == len ( lst )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts html content to plain text [CODESPLIT] def html_to_text ( content ) : text = None h2t = html2text . HTML2Text ( ) h2t . ignore_links = False text = h2t . handle ( content ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tests if an object is a collection . [CODESPLIT] def is_collection ( obj ) : col = getattr ( obj , '__getitem__' , False ) val = False if ( not col ) else True if isinstance ( obj , basestring ) : val = False return val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if an http server runs on a given port . [CODESPLIT] def is_http_running_on ( port ) : try : conn = httplib . HTTPConnection ( '127.0.0.1:' + str ( port ) ) conn . connect ( ) conn . close ( ) return True except Exception : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Invoked when determining whether a specific key is in the dictionary using key in d . [CODESPLIT] def __contains__ ( self , key ) : k = self . _real_key ( key ) return k in self . _data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks whether a variable is a numpy integer array . [CODESPLIT] def is_integer_array ( val ) : return is_np_array ( val ) and issubclass ( val . dtype . type , np . integer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform a O ( 1 ) memory hash of an iterable of arbitrary length . [CODESPLIT] def hash_iterable ( it ) : hash_value = hash ( type ( it ) ) for value in it : hash_value = hash ( ( hash_value , value ) ) return hash_value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if session was closed . [CODESPLIT] def is_closed ( self ) : return ( self . state == SESSION_STATE . CLOSED or self . state == SESSION_STATE . CLOSING )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a list of ( key value ) pairs and turns it into a dict . [CODESPLIT] def list2dict ( lst ) : dic = { } for k , v in lst : dic [ k ] = v return dic", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if file is a regular file and is readable . [CODESPLIT] def is_readable ( filename ) : return os . path . isfile ( filename ) and os . access ( filename , os . R_OK )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return peak memory usage in MB [CODESPLIT] def peak_memory_usage ( ) : if sys . platform . startswith ( 'win' ) : p = psutil . Process ( ) return p . memory_info ( ) . peak_wset / 1024 / 1024 mem = resource . getrusage ( resource . RUSAGE_SELF ) . ru_maxrss factor_mb = 1 / 1024 if sys . platform == 'darwin' : factor_mb = 1 / ( 1024 * 1024 ) return mem * factor_mb", "target": 1, "target_options": ["no_match", "match"]}
{"input": "assert the mock has been called with the specified arguments . [CODESPLIT] def assert_any_call ( self , * args , * * kwargs ) : kall = call ( * args , * * kwargs ) if kall not in self . call_args_list : expected_string = self . _format_mock_call_signature ( args , kwargs ) raise AssertionError ( '%s call not found' % expected_string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether a certain column exists [CODESPLIT] def column_exists ( cr , table , column ) : cr . execute ( 'SELECT count(attname) FROM pg_attribute ' 'WHERE attrelid = ' '( SELECT oid FROM pg_class WHERE relname = %s ) ' 'AND attname = %s' , ( table , column ) ) return cr . fetchone ( ) [ 0 ] == 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check configuration file type is JSON Return a boolean indicating wheather the file is JSON format or not [CODESPLIT] def is_json_file ( filename , show_warnings = False ) : try : config_dict = load_config ( filename , file_type = \"json\" ) is_json = True except : is_json = False return ( is_json )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return locale from GET lang param or automatically . [CODESPLIT] def set_locale ( request ) : return request . query . get ( 'lang' , app . ps . babel . select_locale_by_request ( request ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns file name of file at given url . [CODESPLIT] def get_file_name ( url ) : return os . path . basename ( urllib . parse . urlparse ( url ) . path ) or 'unknown_name'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if there s something to read on stdin ( posix version ) . [CODESPLIT] def _stdin_ready_posix ( ) : infds , outfds , erfds = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return bool ( infds )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks object if it s a peewee model and unique . [CODESPLIT] def _check_model ( obj , models = None ) : return isinstance ( obj , type ) and issubclass ( obj , pw . Model ) and hasattr ( obj , '_meta' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the file size of a given file [CODESPLIT] def get_file_size ( filename ) : if os . path . isfile ( filename ) : return convert_size ( os . path . getsize ( filename ) ) return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a single iterator of n elements of lists of length 3 given a sequence of len n . [CODESPLIT] def pool_args ( function , sequence , kwargs ) : return zip ( itertools . repeat ( function ) , sequence , itertools . repeat ( kwargs ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates and returns a month number basing on PESEL standard . [CODESPLIT] def calculate_month ( birth_date ) : year = int ( birth_date . strftime ( '%Y' ) ) month = int ( birth_date . strftime ( '%m' ) ) + ( ( int ( year / 100 ) - 14 ) % 5 ) * 20 return month", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns whether the provided name is a valid variable name in Python [CODESPLIT] def is_valid_variable_name ( string_to_check ) : try : parse ( '{} = None' . format ( string_to_check ) ) return True except ( SyntaxError , ValueError , TypeError ) : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if a Path or string is a file on the file system . [CODESPLIT] def is_file ( path ) : try : return path . expanduser ( ) . absolute ( ) . is_file ( ) except AttributeError : return os . path . isfile ( os . path . abspath ( os . path . expanduser ( str ( path ) ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets the date for the first and the last day of the previous complete week . [CODESPLIT] def get_last_week_range ( weekday_start = \"Sunday\" ) : today = date . today ( ) # Get the first day of the past complete week. start_of_week = snap_to_beginning_of_week ( today , weekday_start ) - timedelta ( weeks = 1 ) end_of_week = start_of_week + timedelta ( days = 6 ) return ( start_of_week , end_of_week )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check a JSON server response to see if it was successful [CODESPLIT] def __check_success ( resp ) : if \"success\" not in resp . keys ( ) : try : raise APIError ( '200' , 'Operation Failed' , resp [ \"error\" ] ) except KeyError : raise APIError ( '200' , 'Operation Failed' , str ( resp ) ) return resp [ \"success\" ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns whether a path names an existing directory we can list and read files from . [CODESPLIT] def is_readable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . R_OK ) and os . access ( path , os . X_OK )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a Boto connection to the provided S3 bucket . [CODESPLIT] def s3_connect ( bucket_name , s3_access_key_id , s3_secret_key ) : conn = connect_s3 ( s3_access_key_id , s3_secret_key ) try : return conn . get_bucket ( bucket_name ) except S3ResponseError as e : if e . status == 403 : raise Exception ( \"Bad Amazon S3 credentials.\" ) raise", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates the returned positional object [CODESPLIT] def _validate_pos ( df ) : assert isinstance ( df , pd . DataFrame ) assert [ \"seqname\" , \"position\" , \"strand\" ] == df . columns . tolist ( ) assert df . position . dtype == np . dtype ( \"int64\" ) assert df . strand . dtype == np . dtype ( \"O\" ) assert df . seqname . dtype == np . dtype ( \"O\" ) return df", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a 20 char passphrase with easily typeable chars . [CODESPLIT] def GeneratePassphrase ( length = 20 ) : valid_chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" valid_chars += \"0123456789 ,-_&$#\" return \"\" . join ( random . choice ( valid_chars ) for i in range ( length ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "change mod to writeable [CODESPLIT] def chmod ( f ) : try : os . chmod ( f , S_IWRITE ) # windows (cover all) except Exception as e : pass try : os . chmod ( f , 0o777 ) # *nix except Exception as e : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns string with actor and verb allowing target / object to be filled in manually . [CODESPLIT] def short_action_string ( self ) : output = \"{0} \" . format ( self . actor ) if self . override_string : output += self . override_string else : output += self . verb return output", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check x and y fields parameters and initialize [CODESPLIT] def _check_fields ( self , x , y ) : if x is None : if self . x is None : self . err ( self . _check_fields , \"X field is not set: please specify a parameter\" ) return x = self . x if y is None : if self . y is None : self . err ( self . _check_fields , \"Y field is not set: please specify a parameter\" ) return y = self . y return x , y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Implements string formatting along with color specified in colorama . Fore [CODESPLIT] def colorize ( string , color , * args , * * kwargs ) : string = string . format ( * args , * * kwargs ) return color + string + colorama . Fore . RESET", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return pinyin of string the string must be unicode [CODESPLIT] def get ( s , delimiter = '' , format = \"diacritical\" ) : return delimiter . join ( _pinyin_generator ( u ( s ) , format = format ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a new dict with any empty items removed . [CODESPLIT] def _remove_empty_items ( d , required ) : new_dict = { } for k , v in d . items ( ) : if k in required : new_dict [ k ] = v elif isinstance ( v , int ) or v : # \"if v\" would suppress emitting int(0) new_dict [ k ] = v return new_dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a tuple of numbers . e . g . vertices normals or teture coords . [CODESPLIT] def readTuple ( self , line , n = 3 ) : numbers = [ num for num in line . split ( ' ' ) if num ] return [ float ( num ) for num in numbers [ 1 : n + 1 ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a translation object in the default django domain . [CODESPLIT] def translation ( language ) : global _translations if language not in _translations : _translations [ language ] = Translations ( language ) return _translations [ language ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clips a prefix from the beginning of a string if it exists . [CODESPLIT] def _clip ( sid , prefix ) : return sid [ len ( prefix ) : ] if sid . startswith ( prefix ) else sid", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Close all connections . [CODESPLIT] def cleanup ( self , app ) : if hasattr ( self . database . obj , 'close_all' ) : self . database . close_all ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Performs a mouse out the element . [CODESPLIT] def mouse_out ( self ) : self . scroll_to ( ) ActionChains ( self . parent . driver ) . move_by_offset ( 0 , 0 ) . click ( ) . perform ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function called when Cancel - button clicked . [CODESPLIT] def cancel ( self , event = None ) : if self . parent != None : self . parent . focus_set ( ) self . destroy ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convenience function to print messages on a single line in the terminal [CODESPLIT] def println ( msg ) : sys . stdout . write ( msg ) sys . stdout . flush ( ) sys . stdout . write ( '\\x08' * len ( msg ) ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets main window icon to given wx . Bitmap [CODESPLIT] def set_icon ( self , bmp ) : _icon = wx . EmptyIcon ( ) _icon . CopyFromBitmap ( bmp ) self . SetIcon ( _icon )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates an email address Source : Himanshu Shankar ( https : // github . com / iamhssingh ) Parameters ---------- email : str [CODESPLIT] def validate_email ( email ) : from django . core . validators import validate_email from django . core . exceptions import ValidationError try : validate_email ( email ) return True except ValidationError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates text font color button [CODESPLIT] def _update_fontcolor ( self , fontcolor ) : textcolor = wx . SystemSettings_GetColour ( wx . SYS_COLOUR_WINDOWTEXT ) textcolor . SetRGB ( fontcolor ) self . textcolor_choice . SetColour ( textcolor )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses http : // www . cplusplus . com / reference / string / to_string / for formatting [CODESPLIT] def format ( x , format ) : # don't change the dtype, otherwise for each block the dtype may be different (string length) sl = vaex . strings . format ( x , format ) return column . ColumnStringArrow ( sl . bytes , sl . indices , sl . length , sl . offset , string_sequence = sl )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract text from a given lxml node . [CODESPLIT] def _extract_node_text ( node ) : texts = map ( six . text_type . strip , map ( six . text_type , map ( unescape , node . xpath ( \".//text()\" ) ) ) ) return \" \" . join ( text for text in texts if text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if filename1 and filename2 point to the same file object . There can be false negatives ie . the result is False but it is the same file anyway . Reason is that network filesystems can create different paths to the same physical file . [CODESPLIT] def is_same_file ( filename1 , filename2 ) : if filename1 == filename2 : return True if os . name == 'posix' : return os . path . samefile ( filename1 , filename2 ) return is_same_filename ( filename1 , filename2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses given YAML file . [CODESPLIT] def _ParseYamlFromFile ( filedesc ) : content = filedesc . read ( ) return yaml . Parse ( content ) or collections . OrderedDict ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compare two strings while protecting against timing attacks [CODESPLIT] def compare ( string1 , string2 ) : if len ( string1 ) != len ( string2 ) : return False result = True for c1 , c2 in izip ( string1 , string2 ) : result &= c1 == c2 return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Proximal operator to project onto zero [CODESPLIT] def prox_zero ( X , step ) : return np . zeros ( X . shape , dtype = X . dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize and compare XML documents for equality . The document may or may not be a DataONE type . [CODESPLIT] def are_equal_xml ( a_xml , b_xml ) : a_dom = xml . dom . minidom . parseString ( a_xml ) b_dom = xml . dom . minidom . parseString ( b_xml ) return are_equal_elements ( a_dom . documentElement , b_dom . documentElement )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Closes the browser and shuts down the WebKitGTKDriver executable that is started when starting the WebKitGTKDriver [CODESPLIT] def quit ( self ) : try : RemoteWebDriver . quit ( self ) except http_client . BadStatusLine : pass finally : self . service . stop ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sort input filename list by datetime [CODESPLIT] def sort_fn_list ( fn_list ) : dt_list = get_dt_list ( fn_list ) fn_list_sort = [ fn for ( dt , fn ) in sorted ( zip ( dt_list , fn_list ) ) ] return fn_list_sort", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert list of key value lists to dict [CODESPLIT] def list_of_lists_to_dict ( l ) : d = { } for key , val in l : d . setdefault ( key , [ ] ) . append ( val ) return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update conda packages in a conda env [CODESPLIT] def update ( packages , env = None , user = None ) : packages = ' ' . join ( packages . split ( ',' ) ) cmd = _create_conda_cmd ( 'update' , args = [ packages , '--yes' , '-q' ] , env = env , user = user ) return _execcmd ( cmd , user = user )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "HTTP response for forbidden access ( status code 403 ) [CODESPLIT] def HttpResponse403 ( request , template = KEY_AUTH_403_TEMPLATE , content = KEY_AUTH_403_CONTENT , content_type = KEY_AUTH_403_CONTENT_TYPE ) : return AccessFailedResponse ( request , template , content , content_type , status = 403 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Special case of version () when the executable is a JAR file . [CODESPLIT] def version_jar ( self ) : cmd = config . get_command ( 'java' ) cmd . append ( '-jar' ) cmd += self . cmd self . version ( cmd = cmd , path = self . cmd [ 0 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True when alias already in shell config . [CODESPLIT] def _is_already_configured ( configuration_details ) : path = Path ( configuration_details . path ) . expanduser ( ) with path . open ( 'r' ) as shell_config : return configuration_details . content in shell_config . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Counts the word frequences in a list of sentences . [CODESPLIT] def count ( lines ) : words = [ w for l in lines for w in l . strip ( ) . split ( ) ] return Counter ( words )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prints the top row of a table [CODESPLIT] def top ( n , width = WIDTH , style = STYLE ) : return hrule ( n , width , linestyle = STYLES [ style ] . top )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the key ( aka database value ) of a human key ( aka Python identifier ) . [CODESPLIT] def get_from_human_key ( self , key ) : if key in self . _identifier_map : return self . _identifier_map [ key ] raise KeyError ( key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn an arbitrary object into a unicode string . If complex ( dict / list / tuple ) will be json - encoded . [CODESPLIT] def obj_to_string ( obj , top = True ) : obj = prepare_for_json_encoding ( obj ) if type ( obj ) == six . text_type : return obj return json . dumps ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Populates an object s attributes using the provided dict [CODESPLIT] def populate_obj ( obj , attrs ) : for k , v in attrs . iteritems ( ) : setattr ( obj , k , v )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "From : http : // stackoverflow . com / questions / 13062300 / convert - a - dict - to - sorted - dict - in - python [CODESPLIT] def format_result ( input ) : items = list ( iteritems ( input ) ) return OrderedDict ( sorted ( items , key = lambda x : x [ 0 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "From : http : // stackoverflow . com / questions / 13062300 / convert - a - dict - to - sorted - dict - in - python [CODESPLIT] def format_result ( input ) : items = list ( iteritems ( input ) ) return OrderedDict ( sorted ( items , key = lambda x : x [ 0 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if two revisions have actually changed . [CODESPLIT] def default_diff ( latest_config , current_config ) : # Pop off the fields we don't care about: pop_no_diff_fields ( latest_config , current_config ) diff = DeepDiff ( latest_config , current_config , ignore_order = True ) return diff", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of all the variable types that exist in the Variables object . [CODESPLIT] def types ( self ) : output = set ( ) for var in self . values ( ) : if var . has_value ( ) : output . update ( var . types ( ) ) return list ( output )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Display productpage with normal user and test user buttons [CODESPLIT] def index ( ) : global productpage table = json2html . convert ( json = json . dumps ( productpage ) , table_attributes = \"class=\\\"table table-condensed table-bordered table-hover\\\"\" ) return render_template ( 'index.html' , serviceTable = table )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses box coordinates to crop an image without resizing it first . [CODESPLIT] def crop_box ( im , box = False , * * kwargs ) : if box : im = im . crop ( box ) return im", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set of hyperparameters . [CODESPLIT] def transformer_ae_a3 ( ) : hparams = transformer_ae_base ( ) hparams . batch_size = 4096 hparams . layer_prepostprocess_dropout = 0.3 hparams . optimizer = \"Adafactor\" hparams . learning_rate = 0.25 hparams . learning_rate_warmup_steps = 10000 return hparams", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a csv and returns a List of Dicts with keys given by header row . [CODESPLIT] def csv_to_dicts ( file , header = None ) : with open ( file ) as csvfile : return [ row for row in csv . DictReader ( csvfile , fieldnames = header ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Setup the RAM buffer from the C ++ code . [CODESPLIT] def _ram_buffer ( self ) : # get the address of the RAM address = _LIB . Memory ( self . _env ) # create a buffer from the contents of the address location buffer_ = ctypes . cast ( address , ctypes . POINTER ( RAM_VECTOR ) ) . contents # create a NumPy array from the buffer return np . frombuffer ( buffer_ , dtype = 'uint8' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A wrapper for the user - defined handle . [CODESPLIT] def _monitor_callback_wrapper ( callback ) : def callback_handle ( name , array , _ ) : \"\"\" ctypes function \"\"\" callback ( name , array ) return callback_handle", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list consisting of the cumulative sum of the items in the passed list . [CODESPLIT] def cumsum ( inlist ) : newlist = copy . deepcopy ( inlist ) for i in range ( 1 , len ( newlist ) ) : newlist [ i ] = newlist [ i ] + newlist [ i - 1 ] return newlist", "target": 1, "target_options": ["no_match", "match"]}
{"input": "set colouring on if STDOUT is a terminal device off otherwise [CODESPLIT] def auto ( ) : try : Style . enabled = False Style . enabled = sys . stdout . isatty ( ) except ( AttributeError , TypeError ) : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transforms a DataFrame in place . Computes all outputs of the DataFrame . [CODESPLIT] def transform ( self , df ) : for name , function in self . outputs : df [ name ] = function ( df )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create an array . Keyword arguments as per : func : zarr . creation . zeros . [CODESPLIT] def zeros ( self , name , * * kwargs ) : return self . _write_op ( self . _zeros_nosync , name , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sort data rows and order columns [CODESPLIT] def sort_data ( data , cols ) : return data . sort_values ( cols ) [ cols + [ 'value' ] ] . reset_index ( drop = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Close all connections . [CODESPLIT] def cleanup ( self , app ) : if hasattr ( self . database . obj , 'close_all' ) : self . database . close_all ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Appends tzinfo and assumes UTC if datetime object has no tzinfo already . [CODESPLIT] def make_aware ( dt ) : return dt if dt . tzinfo else dt . replace ( tzinfo = timezone . utc )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Appends tzinfo and assumes UTC if datetime object has no tzinfo already . [CODESPLIT] def make_aware ( dt ) : return dt if dt . tzinfo else dt . replace ( tzinfo = timezone . utc )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Allow this package to be used as Sphinx extension . This is also called from the top - level __init__ . py . [CODESPLIT] def setup ( app ) : from . patches import patch_django_for_autodoc # When running, make sure Django doesn't execute querysets patch_django_for_autodoc ( ) # Generate docstrings for Django model fields # Register the docstring processor with sphinx app . connect ( 'autodoc-process-docstring' , improve_model_docstring ) # influence skip rules app . connect ( \"autodoc-skip-member\" , autodoc_skip )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "variance of the values must have 2 or more entries . [CODESPLIT] def variance ( arr ) : avg = average ( arr ) return sum ( [ ( float ( x ) - avg ) ** 2 for x in arr ] ) / float ( len ( arr ) - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert an ARF timestamp to a datetime . datetime object ( naive local time ) [CODESPLIT] def timestamp_to_datetime ( timestamp ) : from datetime import datetime , timedelta obj = datetime . fromtimestamp ( timestamp [ 0 ] ) return obj + timedelta ( microseconds = int ( timestamp [ 1 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a python file and returns a awslambda . Code object : param python_file : : return : [CODESPLIT] def lambda_from_file ( python_file ) : lambda_function = [ ] with open ( python_file , 'r' ) as f : lambda_function . extend ( f . read ( ) . splitlines ( ) ) return awslambda . Code ( ZipFile = ( Join ( '\\n' , lambda_function ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Represent string / bytes s as base64 omitting newlines [CODESPLIT] def toBase64 ( s ) : if isinstance ( s , str ) : s = s . encode ( \"utf-8\" ) return binascii . b2a_base64 ( s ) [ : - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a : py : class : datetime . datetime instance representing the current time . [CODESPLIT] def now ( self ) : if self . use_utc : return datetime . datetime . utcnow ( ) else : return datetime . datetime . now ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts Timestamp to datetime . [CODESPLIT] def ToDatetime ( self ) : return datetime . utcfromtimestamp ( self . seconds + self . nanos / float ( _NANOS_PER_SECOND ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Linear oldstyle interpolation of the transform matrix . [CODESPLIT] def _linearInterpolationTransformMatrix ( matrix1 , matrix2 , value ) : return tuple ( _interpolateValue ( matrix1 [ i ] , matrix2 [ i ] , value ) for i in range ( len ( matrix1 ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts python datetime to epoch microseconds . [CODESPLIT] def _DateToEpoch ( date ) : tz_zero = datetime . datetime . utcfromtimestamp ( 0 ) diff_sec = int ( ( date - tz_zero ) . total_seconds ( ) ) return diff_sec * 1000000", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert naive datetime to timezone - aware datetime [CODESPLIT] def datetime_to_timezone ( date , tz = \"UTC\" ) : if not date . tzinfo : date = date . replace ( tzinfo = timezone ( get_timezone ( ) ) ) return date . astimezone ( timezone ( tz ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "image resize function used by quite a few image problems . [CODESPLIT] def resize_by_area ( img , size ) : return tf . to_int64 ( tf . image . resize_images ( img , [ size , size ] , tf . image . ResizeMethod . AREA ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "decorator to convert a method taking a iterable to a * args one [CODESPLIT] def _iterable_to_varargs_method ( func ) : def wrapped ( self , * args , * * kwargs ) : return func ( self , args , * * kwargs ) return wrapped", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute a python code object in the given environment . [CODESPLIT] def exec_function ( ast , globals_map ) : locals_map = globals_map exec ast in globals_map , locals_map return locals_map", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Construct and return the URL for a specific API service . [CODESPLIT] def url ( self , action , * * kwargs ) : # TODO : should be static method ? return self . URLS [ 'BASE' ] % self . URLS [ action ] % kwargs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove item with given key from the mapping . [CODESPLIT] def __delitem__ ( self , key ) : index , value = self . _dict . pop ( key ) key2 , value2 = self . _list . pop ( index ) assert key == key2 assert value is value2 self . _fix_indices_after_delete ( index )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes the tlink for the given tlink identifier [CODESPLIT] def remove_this_tlink ( self , tlink_id ) : for tlink in self . get_tlinks ( ) : if tlink . get_id ( ) == tlink_id : self . node . remove ( tlink . get_node ( ) ) break", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a list of coords for 3 points Compute the area of this triangle . [CODESPLIT] def get_tri_area ( pts ) : a , b , c = pts [ 0 ] , pts [ 1 ] , pts [ 2 ] v1 = np . array ( b ) - np . array ( a ) v2 = np . array ( c ) - np . array ( a ) area_tri = abs ( sp . linalg . norm ( sp . cross ( v1 , v2 ) ) / 2 ) return area_tri", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return sanitized Eidos text field for human readability . [CODESPLIT] def _sanitize ( text ) : d = { '-LRB-' : '(' , '-RRB-' : ')' } return re . sub ( '|' . join ( d . keys ( ) ) , lambda m : d [ m . group ( 0 ) ] , text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True positive rate tp / ( tp + fn ) [CODESPLIT] def tpr ( y , z ) : tp , tn , fp , fn = contingency_table ( y , z ) return tp / ( tp + fn )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Check calculatable descriptor class or not . [CODESPLIT] def is_descriptor_class ( desc , include_abstract = False ) : return ( isinstance ( desc , type ) and issubclass ( desc , Descriptor ) and ( True if include_abstract else not inspect . isabstract ( desc ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "inverse hyperbolic sine transformation [CODESPLIT] def inh ( table ) : t = [ ] for i in table : t . append ( np . ndarray . tolist ( np . arcsinh ( i ) ) ) return t", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine whether we re in an interactive shell . Sets interactivity off if appropriate . cf http : // stackoverflow . com / questions / 24861351 / how - to - detect - if - python - script - is - being - run - as - a - background - process [CODESPLIT] def determine_interactive ( self ) : try : if not sys . stdout . isatty ( ) or os . getpgrp ( ) != os . tcgetpgrp ( sys . stdout . fileno ( ) ) : self . interactive = 0 return False except Exception : self . interactive = 0 return False if self . interactive == 0 : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Computes the unnormalized PDF of the normal distribution . [CODESPLIT] def EvalGaussianPdf ( x , mu , sigma ) : return scipy . stats . norm . pdf ( x , mu , sigma )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Whether the pattern matches anywhere in the string s . [CODESPLIT] def matches ( self , s ) : regex_matches = self . compiled_regex . search ( s ) is not None return not regex_matches if self . inverted else regex_matches", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Logs a function s run time [CODESPLIT] def timed_call ( func , * args , log_level = 'DEBUG' , * * kwargs ) : start = time ( ) r = func ( * args , * * kwargs ) t = time ( ) - start log ( log_level , \"Call to '{}' took {:0.6f}s\" . format ( func . __name__ , t ) ) return r", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Checks if l is a numpy array of integers [CODESPLIT] def is_int_vector ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 1 and ( l . dtype . kind == 'i' or l . dtype . kind == 'u' ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calls the specified Trigger of another Area with the optionally given parameters . [CODESPLIT] def trigger ( self , target : str , trigger : str , parameters : Dict [ str , Any ] = { } ) : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Registers url_rules on the blueprint [CODESPLIT] def register ( self , target ) : for rule , options in self . url_rules : target . add_url_rule ( rule , self . name , self . dispatch_request , * * options )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether the provided value is a valid enum constant . [CODESPLIT] def check ( self , var ) : if not isinstance ( var , _str_type ) : return False return _enum_mangle ( var ) in self . _consts", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like dict but does not hold any null values . [CODESPLIT] def nonull_dict ( self ) : return { k : v for k , v in six . iteritems ( self . dict ) if v and k != '_codes' }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialize the state of the object [CODESPLIT] def __init__ ( self ) : self . state = self . STATE_INITIALIZING self . state_start = time . time ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Redirects to the specified view or url [CODESPLIT] def redirect ( view = None , url = None , * * kwargs ) : if view : if url : kwargs [ \"url\" ] = url url = flask . url_for ( view , * * kwargs ) current_context . exit ( flask . redirect ( url ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "internal helper function to run shell commands and get output [CODESPLIT] def run_cmd ( command , verbose = True , shell = '/bin/bash' ) : process = Popen ( command , shell = True , stdout = PIPE , stderr = STDOUT , executable = shell ) output = process . stdout . read ( ) . decode ( ) . strip ( ) . split ( '\\n' ) if verbose : # return full output including empty lines return output return [ line for line in output if line . strip ( ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Die on SIGTERM or SIGINT [CODESPLIT] def set_terminate_listeners ( stream ) : def stop ( signum , frame ) : terminate ( stream . listener ) # Installs signal handlers for handling SIGINT and SIGTERM # gracefully. signal . signal ( signal . SIGINT , stop ) signal . signal ( signal . SIGTERM , stop )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "shows JSON indented representation of d [CODESPLIT] def pretty_dict_str ( d , indent = 2 ) : b = StringIO ( ) write_pretty_dict_str ( b , d , indent = indent ) return b . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the box ( for horizontal graphs ) [CODESPLIT] def swap ( self ) : self . xmin , self . ymin = self . ymin , self . xmin self . xmax , self . ymax = self . ymax , self . xmax", "target": 1, "target_options": ["no_match", "match"]}
{"input": "shows JSON indented representation of d [CODESPLIT] def pretty_dict_str ( d , indent = 2 ) : b = StringIO ( ) write_pretty_dict_str ( b , d , indent = indent ) return b . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a new image by copying the image on a * color * background . [CODESPLIT] def copy_image_on_background ( image , color = WHITE ) : background = Image . new ( \"RGB\" , image . size , color ) background . paste ( image , mask = image . split ( ) [ 3 ] ) return background", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return request s X_POLYAXON_ ... : header as a bytestring . [CODESPLIT] def get_header ( request , header_service ) : service = request . META . get ( 'HTTP_{}' . format ( header_service ) , b'' ) if isinstance ( service , str ) : # Work around django test client oddness service = service . encode ( HTTP_HEADER_ENCODING ) return service", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets the caption_found and plot_found variables to False . [CODESPLIT] def prepare ( doc ) : doc . caption_found = False doc . plot_found = False doc . listings_counter = 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Attempts to convert given object to a string object [CODESPLIT] def to_str ( obj ) : if not isinstance ( obj , str ) and PY3 and isinstance ( obj , bytes ) : obj = obj . decode ( 'utf-8' ) return obj if isinstance ( obj , string_types ) else str ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "cv2 Image of current window screen [CODESPLIT] def screen_cv2 ( self ) : pil_image = self . screen . convert ( 'RGB' ) cv2_image = np . array ( pil_image ) pil_image . close ( ) # Convert RGB to BGR \n cv2_image = cv2_image [ : , : , : : - 1 ] return cv2_image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Display all available logging information . [CODESPLIT] def pylog ( self , * args , * * kwargs ) : printerr ( self . name , args , kwargs , traceback . format_exc ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "implementation of safe dumper using Ordered Dict Yaml Dumper [CODESPLIT] def safe_dump ( data , stream = None , * * kwds ) : return yaml . dump ( data , stream = stream , Dumper = ODYD , * * kwds )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if end - of - file is reached for file fd . [CODESPLIT] def eof ( fd ) : b = fd . read ( 1 ) end = len ( b ) == 0 if not end : curpos = fd . tell ( ) fd . seek ( curpos - 1 ) return end", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add params to doc string [CODESPLIT] def _add_params_docstring ( params ) : p_string = \"\\nAccepts the following paramters: \\n\" for param in params : p_string += \"name: %s, required: %s, description: %s \\n\" % ( param [ 'name' ] , param [ 'required' ] , param [ 'description' ] ) return p_string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Matches a paren . [CODESPLIT] def match_paren ( self , tokens , item ) : match , = tokens return self . match ( match , item )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if the queue is full [CODESPLIT] def full ( self ) : if not self . size : return False return len ( self . pq ) == ( self . size + self . removed_count )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Re - index every document in a named index . [CODESPLIT] def update_index ( index ) : logger . info ( \"Updating search index: '%s'\" , index ) client = get_client ( ) responses = [ ] for model in get_index_models ( index ) : logger . info ( \"Updating search index model: '%s'\" , model . search_doc_type ) objects = model . objects . get_search_queryset ( index ) . iterator ( ) actions = bulk_actions ( objects , index = index , action = \"index\" ) response = helpers . bulk ( client , actions , chunk_size = get_setting ( \"chunk_size\" ) ) responses . append ( response ) return responses", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine ES type names from request data . [CODESPLIT] def determine_types ( self ) : from nefertari . elasticsearch import ES collections = self . get_collections ( ) resources = self . get_resources ( collections ) models = set ( [ res . view . Model for res in resources ] ) es_models = [ mdl for mdl in models if mdl and getattr ( mdl , '_index_enabled' , False ) ] types = [ ES . src2type ( mdl . __name__ ) for mdl in es_models ] return types", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns true if the input can be interpreted as a true vector [CODESPLIT] def is_vector ( inp ) : inp = np . asarray ( inp ) nr_dim = np . ndim ( inp ) if nr_dim == 1 : return True elif ( nr_dim == 2 ) and ( 1 in inp . shape ) : return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check lowercase key item . [CODESPLIT] def __contains__ ( self , key ) : assert isinstance ( key , basestring ) return dict . __contains__ ( self , key . lower ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Close the db and release memory [CODESPLIT] def close ( self ) : if self . db is not None : self . db . commit ( ) self . db . close ( ) self . db = None return", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator for methods that are allowed to modify immutable objects [CODESPLIT] def mutating_method ( func ) : def wrapper ( self , * __args , * * __kwargs ) : old_mutable = self . _mutable self . _mutable = True try : # Call the wrapped function return func ( self , * __args , * * __kwargs ) finally : self . _mutable = old_mutable return wrapper", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Dump single enum type . Keyword arguments : top -- top namespace [CODESPLIT] def _dump_enum ( self , e , top = '' ) : self . _print ( ) self . _print ( 'enum {} {{' . format ( e . name ) ) self . defines . append ( '{}.{}' . format ( top , e . name ) ) self . tabs += 1 for v in e . value : self . _print ( '{} = {};' . format ( v . name , v . number ) ) self . tabs -= 1 self . _print ( '}' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if object is defined [CODESPLIT] def is_defined ( self , objtxt , force_import = False ) : return self . interpreter . is_defined ( objtxt , force_import )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if the given string starts with one of the prefixes in the given list otherwise return False . [CODESPLIT] def starts_with_prefix_in_list ( text , prefixes ) : for prefix in prefixes : if text . startswith ( prefix ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def unpack_out ( self , name ) : return self . parse ( \"\"\"\n            $enum = $enum_class($value.value)\n            \"\"\" , enum_class = self . _import_type ( ) , value = name ) [ \"enum\" ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates the returned positional object [CODESPLIT] def _validate_pos ( df ) : assert isinstance ( df , pd . DataFrame ) assert [ \"seqname\" , \"position\" , \"strand\" ] == df . columns . tolist ( ) assert df . position . dtype == np . dtype ( \"int64\" ) assert df . strand . dtype == np . dtype ( \"O\" ) assert df . seqname . dtype == np . dtype ( \"O\" ) return df", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform sed text substitution . [CODESPLIT] def sed ( match , replacement , path , modifiers = \"\" ) : cmd = \"sed -r -i 's/%s/%s/%s' %s\" % ( match , replacement , modifiers , path ) process = Subprocess ( cmd , shell = True ) ret , out , err = process . run ( timeout = 60 ) if ret : raise SubprocessError ( \"Sed command failed!\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "TODO DEPRECATE THIS? [CODESPLIT] def euler ( self ) : e_xyz = transformations . euler_from_matrix ( self . rotation , 'sxyz' ) return np . array ( [ 180.0 / np . pi * a for a in e_xyz ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether the provided value is a valid enum constant . [CODESPLIT] def check ( self , var ) : if not isinstance ( var , _str_type ) : return False return _enum_mangle ( var ) in self . _consts", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function is called to check if a username / password combination is valid . [CODESPLIT] def check_auth ( username , pwd ) : cfg = get_current_config ( ) return username == cfg [ \"dashboard_httpauth\" ] . split ( \":\" ) [ 0 ] and pwd == cfg [ \"dashboard_httpauth\" ] . split ( \":\" ) [ 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A function to vend the current zipfile if any [CODESPLIT] def current_zipfile ( ) : if zipfile . is_zipfile ( sys . argv [ 0 ] ) : fd = open ( sys . argv [ 0 ] , \"rb\" ) return zipfile . ZipFile ( fd )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "change mod to writeable [CODESPLIT] def chmod ( f ) : try : os . chmod ( f , S_IWRITE ) # windows (cover all) except Exception as e : pass try : os . chmod ( f , 0o777 ) # *nix except Exception as e : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns system clipboard contents . [CODESPLIT] def paste ( cmd = paste_cmd , stdout = PIPE ) : return Popen ( cmd , stdout = stdout ) . communicate ( ) [ 0 ] . decode ( 'utf-8' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Restoring scrollbar position after main window is visible [CODESPLIT] def restore_scrollbar_position ( self ) : scrollbar_pos = self . get_option ( 'scrollbar_position' , None ) if scrollbar_pos is not None : self . explorer . treewidget . set_scrollbar_position ( scrollbar_pos )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a string containing the type and text of the exception . [CODESPLIT] def format_exception ( e ) : from . utils . printing import fill return '\\n' . join ( fill ( line ) for line in traceback . format_exception_only ( type ( e ) , e ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "expects a _n . array returns the global minimum of ( value - array ) ^2 [CODESPLIT] def index_nearest ( value , array ) : a = ( array - value ) ** 2 return index ( a . min ( ) , a )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates the average value of a list of numbers Returns a float [CODESPLIT] def calc_list_average ( l ) : total = 0.0 for value in l : total += value return total / len ( l )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert the README file into the long description . [CODESPLIT] def get_long_description ( ) : with open ( path . join ( root_path , 'README.md' ) , encoding = 'utf-8' ) as f : long_description = f . read ( ) return long_description", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Main command line interface . [CODESPLIT] def main ( argv = None ) : if argv is None : argv = sys . argv [ 1 : ] cli = CommandLineTool ( ) return cli . run ( argv )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get source from filename and make a code object of it . [CODESPLIT] def make_code_from_py ( filename ) : # Open the source file. try : source_file = open_source ( filename ) except IOError : raise NoSource ( \"No file to run: %r\" % filename ) try : source = source_file . read ( ) finally : source_file . close ( ) # We have the source.  `compile` still needs the last line to be clean, # so make sure it is, then compile a code object from it. if not source or source [ - 1 ] != '\\n' : source += '\\n' code = compile ( source , filename , \"exec\" ) return code", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Square of the euclidean distance [CODESPLIT] def euclidean ( c1 , c2 ) : diffs = ( ( i - j ) for i , j in zip ( c1 , c2 ) ) return sum ( x * x for x in diffs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function for running binary search on a sorted list . [CODESPLIT] def binSearch ( arr , val ) : i = bisect_left ( arr , val ) if i != len ( arr ) and arr [ i ] == val : return i return - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Join list of columns into a string for a SQL query [CODESPLIT] def join_cols ( cols ) : return \", \" . join ( [ i for i in cols ] ) if isinstance ( cols , ( list , tuple , set ) ) else cols", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a value or list of values and returns a single result joined by if necessary . [CODESPLIT] def vectorize ( values ) : if isinstance ( values , list ) : return ',' . join ( str ( v ) for v in values ) return values", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse a fixed width line . [CODESPLIT] def parse_fixed_width ( types , lines ) : values = [ ] line = [ ] for width , parser in types : if not line : line = lines . pop ( 0 ) . replace ( '\\n' , '' ) values . append ( parser ( line [ : width ] ) ) line = line [ width : ] return values", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Step over the next statement [CODESPLIT] def do_next ( self , args ) : self . _do_print_from_last_cmd = True self . _interp . step_over ( ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "1x1 convolution [CODESPLIT] def conv1x1 ( in_planes , out_planes , stride = 1 ) : return nn . Conv2d ( in_planes , out_planes , kernel_size = 1 , stride = stride , bias = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wraps the dispatch method to add session support . [CODESPLIT] def dispatch ( self ) : try : webapp2 . RequestHandler . dispatch ( self ) finally : self . session_store . save_sessions ( self . response )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Count the number of non - NA in this array along the given axis or axes [CODESPLIT] def count ( data , axis = None ) : return np . sum ( np . logical_not ( isnull ( data ) ) , axis = axis )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the location of the static data directory . [CODESPLIT] def staticdir ( ) : root = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( root , \"static\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Random normal variates . [CODESPLIT] def rnormal ( mu , tau , size = None ) : return np . random . normal ( mu , 1. / np . sqrt ( tau ) , size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns parent directory of mac . app [CODESPLIT] def get_mac_dot_app_dir ( directory ) : return os . path . dirname ( os . path . dirname ( os . path . dirname ( directory ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Force commit changes to the file and stdout [CODESPLIT] def flush ( self ) : if not self . nostdout : self . stdout . flush ( ) if self . file is not None : self . file . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a dataframe and string - i - fy a column of values . Turn nan / None into and all other values into strings . [CODESPLIT] def stringify_col ( df , col_name ) : df = df . copy ( ) df [ col_name ] = df [ col_name ] . fillna ( \"\" ) df [ col_name ] = df [ col_name ] . astype ( str ) return df", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Daemonize the running process . [CODESPLIT] def go_to_background ( ) : try : if os . fork ( ) : sys . exit ( ) except OSError as errmsg : LOGGER . error ( 'Fork failed: {0}' . format ( errmsg ) ) sys . exit ( 'Fork failed' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Daemonize the running process . [CODESPLIT] def go_to_background ( ) : try : if os . fork ( ) : sys . exit ( ) except OSError as errmsg : LOGGER . error ( 'Fork failed: {0}' . format ( errmsg ) ) sys . exit ( 'Fork failed' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Packs a list of triple indexes into a 2D numpy array . [CODESPLIT] def pack_triples_numpy ( triples ) : if len ( triples ) == 0 : return np . array ( [ ] , dtype = np . int64 ) return np . stack ( list ( map ( _transform_triple_numpy , triples ) ) , axis = 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Formats the given number in decimal format using a period and commas [CODESPLIT] def fixed ( ctx , number , decimals = 2 , no_commas = False ) : value = _round ( ctx , number , decimals ) format_str = '{:f}' if no_commas else '{:,f}' return format_str . format ( value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Maps parameters to form field names [CODESPLIT] def map_parameters ( cls , params ) : d = { } for k , v in six . iteritems ( params ) : d [ cls . FIELD_MAP . get ( k . lower ( ) , k ) ] = v return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator to ensure the given snake_case method is also written in UpperCamelCase in the given namespace . That was mainly written to avoid confusion when using wxPython and its UpperCamelCaseMethods . [CODESPLIT] def ucamel_method ( func ) : frame_locals = inspect . currentframe ( ) . f_back . f_locals frame_locals [ snake2ucamel ( func . __name__ ) ] = func return func", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator to ensure the given snake_case method is also written in UpperCamelCase in the given namespace . That was mainly written to avoid confusion when using wxPython and its UpperCamelCaseMethods . [CODESPLIT] def ucamel_method ( func ) : frame_locals = inspect . currentframe ( ) . f_back . f_locals frame_locals [ snake2ucamel ( func . __name__ ) ] = func return func", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Packs a list of triple indexes into a 2D numpy array . [CODESPLIT] def pack_triples_numpy ( triples ) : if len ( triples ) == 0 : return np . array ( [ ] , dtype = np . int64 ) return np . stack ( list ( map ( _transform_triple_numpy , triples ) ) , axis = 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write GML comment . [CODESPLIT] def comment ( self , s , * * args ) : self . writeln ( s = u'comment \"%s\"' % s , * * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the circular permutation for a given list of items . [CODESPLIT] def circ_permutation ( items ) : permutations = [ ] for i in range ( len ( items ) ) : permutations . append ( items [ i : ] + items [ : i ] ) return permutations", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Only allows == against query_on . hash_key [CODESPLIT] def check_hash_key ( query_on , key ) : return ( isinstance ( key , BaseCondition ) and ( key . operation == \"==\" ) and ( key . column is query_on . hash_key ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a GistAPI object [CODESPLIT] def __init__ ( self , token , editor = None ) : self . token = token self . editor = editor self . session = requests . Session ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create all your database objects ( SQLAlchemy specific ) . [CODESPLIT] def create_db ( app , appbuilder ) : from flask_appbuilder . models . sqla import Base _appbuilder = import_application ( app , appbuilder ) engine = _appbuilder . get_session . get_bind ( mapper = None , clause = None ) Base . metadata . create_all ( engine ) click . echo ( click . style ( \"DB objects created\" , fg = \"green\" ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return time in milliseconds from start_time [CODESPLIT] def timespan ( start_time ) : timespan = datetime . datetime . now ( ) - start_time timespan_ms = timespan . total_seconds ( ) * 1000 return timespan_ms", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Define bin edges for disaggregation histograms . [CODESPLIT] def lon_lat_bins ( bb , coord_bin_width ) : west , south , east , north = bb west = numpy . floor ( west / coord_bin_width ) * coord_bin_width east = numpy . ceil ( east / coord_bin_width ) * coord_bin_width lon_extent = get_longitudinal_extent ( west , east ) lon_bins , _ , _ = npoints_between ( west , 0 , 0 , east , 0 , 0 , numpy . round ( lon_extent / coord_bin_width + 1 ) ) lat_bins = coord_bin_width * numpy . arange ( int ( numpy . floor ( south / coord_bin_width ) ) , int ( numpy . ceil ( north / coord_bin_width ) + 1 ) ) return lon_bins , lat_bins", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Round a datetime object to a multiple of a timedelta dt : datetime . datetime object default now . [CODESPLIT] def __round_time ( self , dt ) : round_to = self . _resolution . total_seconds ( ) seconds = ( dt - dt . min ) . seconds rounding = ( seconds + round_to / 2 ) // round_to * round_to return dt + timedelta ( 0 , rounding - seconds , - dt . microsecond )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Searches for the specified method and returns its descriptor . [CODESPLIT] def FindMethodByName ( self , name ) : for method in self . methods : if name == method . name : return method return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get letters from string only . [CODESPLIT] def return_letters_from_string ( text ) : out = \"\" for letter in text : if letter . isalpha ( ) : out += letter return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert object that cannot be natively serialized by python to JSON representation . [CODESPLIT] def object_to_json ( obj ) : if isinstance ( obj , ( datetime . datetime , datetime . date , datetime . time ) ) : return obj . isoformat ( ) return str ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list of PIDs currently running on the system . [CODESPLIT] def get_pid_list ( ) : pids = [ int ( x ) for x in os . listdir ( '/proc' ) if x . isdigit ( ) ] return pids", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap a function as a method . [CODESPLIT] def method ( func ) : attr = abc . abstractmethod ( func ) attr . __imethod__ = True return attr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "function to check if input query is not None and set missing arguments to default value [CODESPLIT] def validate_args ( * * args ) : if not args [ 'query' ] : print ( \"\\nMissing required query argument.\" ) sys . exit ( ) for key in DEFAULTS : if key not in args : args [ key ] = DEFAULTS [ key ] return args", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the index of elem in the reversed iterator . [CODESPLIT] def index ( self , elem ) : return _coconut . len ( self . _iter ) - self . _iter . index ( elem ) - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns a dictionary of arg_name : default_values for the input function [CODESPLIT] def get_default_args ( func ) : args , varargs , keywords , defaults = getargspec_no_self ( func ) return dict ( zip ( args [ - len ( defaults ) : ] , defaults ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts python datetime to epoch microseconds . [CODESPLIT] def _DateToEpoch ( date ) : tz_zero = datetime . datetime . utcfromtimestamp ( 0 ) diff_sec = int ( ( date - tz_zero ) . total_seconds ( ) ) return diff_sec * 1000000", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a US format date and return epoch . [CODESPLIT] def AmericanDateToEpoch ( self , date_str ) : try : epoch = time . strptime ( date_str , \"%m/%d/%Y\" ) return int ( calendar . timegm ( epoch ) ) * 1000000 except ValueError : return 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove a variable from this dataset . [CODESPLIT] def __delitem__ ( self , key ) : del self . _variables [ key ] self . _coord_names . discard ( key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the RMS of the audio [CODESPLIT] def calc_volume ( self , sample : np . ndarray ) : return sqrt ( np . mean ( np . square ( sample ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tests if an object is a collection . [CODESPLIT] def is_collection ( obj ) : col = getattr ( obj , '__getitem__' , False ) val = False if ( not col ) else True if isinstance ( obj , basestring ) : val = False return val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the name of the newest file given an iterable of file names . [CODESPLIT] def newest_file ( file_iterable ) : return max ( file_iterable , key = lambda fname : os . path . getmtime ( fname ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is the last line of the cell a line with code? [CODESPLIT] def cell_ends_with_code ( lines ) : if not lines : return False if not lines [ - 1 ] . strip ( ) : return False if lines [ - 1 ] . startswith ( '#' ) : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param str tablename : Name of table to get position of . : return : Upper left ( row col ) coordinate of the named table . [CODESPLIT] def get_table_pos ( self , tablename ) : _table , ( row , col ) = self . __tables [ tablename ] return ( row , col )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the size of x along axis dimensions only . [CODESPLIT] def array_size ( x , axis ) : axis_shape = x . shape if axis is None else tuple ( x . shape [ a ] for a in axis ) return max ( numpy . prod ( axis_shape ) , 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns date range for the previous full month . [CODESPLIT] def get_previous_month ( self ) : end = utils . get_month_start ( ) - relativedelta ( days = 1 ) end = utils . to_datetime ( end ) start = utils . get_month_start ( end ) return start , end", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn off curses [CODESPLIT] def off ( self ) : self . win . keypad ( 0 ) curses . nocbreak ( ) curses . echo ( ) try : curses . curs_set ( 1 ) except : pass curses . endwin ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of days since January 1 of the given year . [CODESPLIT] def gday_of_year ( self ) : return ( self . date - dt . date ( self . date . year , 1 , 1 ) ) . days", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Send a plain text message to the room . [CODESPLIT] def send_text ( self , text ) : return self . client . api . send_message ( self . room_id , text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of active CPUs on a Darwin system . [CODESPLIT] def _num_cpus_darwin ( ) : p = subprocess . Popen ( [ 'sysctl' , '-n' , 'hw.ncpu' ] , stdout = subprocess . PIPE ) return p . stdout . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a tuple of this array s dimensions . This is done by querying the Dim children . Note that once it has been created it is also possible to examine an Array object s . array attribute directly and doing that is much faster . [CODESPLIT] def get_shape ( self ) : return tuple ( int ( c . pcdata ) for c in self . getElementsByTagName ( ligolw . Dim . tagName ) ) [ : : - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all of the columns registered for a given table . [CODESPLIT] def _columns_for_table ( table_name ) : return { cname : col for ( tname , cname ) , col in _COLUMNS . items ( ) if tname == table_name }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs a shell command returns console output . [CODESPLIT] def _run_cmd_get_output ( cmd ) : process = subprocess . Popen ( cmd . split ( ) , stdout = subprocess . PIPE ) out , err = process . communicate ( ) return out or err", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs a shell command returns console output . [CODESPLIT] def _run_cmd_get_output ( cmd ) : process = subprocess . Popen ( cmd . split ( ) , stdout = subprocess . PIPE ) out , err = process . communicate ( ) return out or err", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return grandparent s path string [CODESPLIT] def grandparent_path ( self ) : return os . path . basename ( os . path . join ( self . path , '../..' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return evidence codes in order shown in code2name . [CODESPLIT] def get_order ( self , codes ) : return sorted ( codes , key = lambda e : [ self . ev2idx . get ( e ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Bulk insert or update . [CODESPLIT] def bulk_query ( self , query , * multiparams ) : with self . get_connection ( ) as conn : conn . bulk_query ( query , * multiparams )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates Camera . aspect to match the viewport s aspect ratio . [CODESPLIT] def match_aspect_to_viewport ( self ) : viewport = self . viewport self . aspect = float ( viewport . width ) / viewport . height", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets RAM memory usage [CODESPLIT] def get_memory_usage ( ) : process = psutil . Process ( os . getpid ( ) ) mem = process . memory_info ( ) . rss return mem / ( 1024 * 1024 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns ( module locals ) of the funciton depth frames away from the caller [CODESPLIT] def extract_module_locals ( depth = 0 ) : f = sys . _getframe ( depth + 1 ) global_ns = f . f_globals module = sys . modules [ global_ns [ '__name__' ] ] return ( module , f . f_locals )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update only one property in the dict [CODESPLIT] def set_property ( self , key , value ) : self . properties [ key ] = value self . sync_properties ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the index of the value at the Qth percentile in array a . [CODESPLIT] def percentile_index ( a , q ) : return np . where ( a == np . percentile ( a , q , interpolation = 'nearest' ) ) [ 0 ] [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for pulling a keyed value off various types of objects [CODESPLIT] def get_value ( key , obj , default = missing ) : if isinstance ( key , int ) : return _get_value_for_key ( key , obj , default ) return _get_value_for_keys ( key . split ( '.' ) , obj , default )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a property by name [CODESPLIT] def get_property_by_name ( pif , name ) : return next ( ( x for x in pif . properties if x . name == name ) , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get resource variable . [CODESPLIT] def _get_var_from_string ( item ) : modname , varname = _split_mod_var_names ( item ) if modname : mod = __import__ ( modname , globals ( ) , locals ( ) , [ varname ] , - 1 ) return getattr ( mod , varname ) else : return globals ( ) [ varname ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adjust the bounding box as specified by user . Returns the adjusted bounding box . [CODESPLIT] def adjust_bounding_box ( bbox ) : for i in range ( 0 , 4 ) : if i in bounding_box : bbox [ i ] = bounding_box [ i ] else : bbox [ i ] += delta_bounding_box [ i ] return bbox", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return time in milliseconds from start_time [CODESPLIT] def timespan ( start_time ) : timespan = datetime . datetime . now ( ) - start_time timespan_ms = timespan . total_seconds ( ) * 1000 return timespan_ms", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Spawn a handler function . [CODESPLIT] def _spawn ( self , func , * args , * * kwargs ) : gevent . spawn ( func , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the color as current OpenGL color [CODESPLIT] def set ( self ) : glColor4f ( self . r , self . g , self . b , self . a )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip agents from a string . [CODESPLIT] def strip_accents ( text ) : normalized_str = unicodedata . normalize ( 'NFD' , text ) return '' . join ( [ c for c in normalized_str if unicodedata . category ( c ) != 'Mn' ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param list_of_points : : return : list_of_points with None s removed [CODESPLIT] def filter_none ( list_of_points ) : remove_elementnone = filter ( lambda p : p is not None , list_of_points ) remove_sublistnone = filter ( lambda p : not contains_none ( p ) , remove_elementnone ) return list ( remove_sublistnone )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the file extension for an abi3 - compliant Extension () [CODESPLIT] def get_abi3_suffix ( ) : for suffix , _ , _ in ( s for s in imp . get_suffixes ( ) if s [ 2 ] == imp . C_EXTENSION ) : if '.abi3' in suffix : # Unix return suffix elif suffix == '.pyd' : # Windows return suffix", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the output shape from an array . [CODESPLIT] def out_shape_from_array ( arr ) : arr = np . asarray ( arr ) if arr . ndim == 1 : return arr . shape else : return ( arr . shape [ 1 ] , )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the clipboard s text on OS X . [CODESPLIT] def osx_clipboard_get ( ) : p = subprocess . Popen ( [ 'pbpaste' , '-Prefer' , 'ascii' ] , stdout = subprocess . PIPE ) text , stderr = p . communicate ( ) # Text comes in with old Mac \\r line endings. Change them to \\n. text = text . replace ( '\\r' , '\\n' ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fit a Gaussian to the data [CODESPLIT] def fit_gaussian ( x , y , yerr , p0 ) : try : popt , pcov = curve_fit ( gaussian , x , y , sigma = yerr , p0 = p0 , absolute_sigma = True ) except RuntimeError : return [ 0 ] , [ 0 ] return popt , pcov", "target": 1, "target_options": ["no_match", "match"]}
{"input": "htmlify string [CODESPLIT] def safe_quotes ( text , escape_single_quotes = False ) : if isinstance ( text , str ) : safe_text = text . replace ( '\"' , \"&quot;\" ) if escape_single_quotes : safe_text = safe_text . replace ( \"'\" , \"&#92;'\" ) return safe_text . replace ( 'True' , 'true' ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns path to packaged static files [CODESPLIT] def glr_path_static ( ) : return os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , '_static' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the element with the highest probability . [CODESPLIT] def best ( self ) : b = ( - 1e999999 , None ) for k , c in iteritems ( self . counts ) : b = max ( b , ( c , k ) ) return b [ 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Daemonize the running process . [CODESPLIT] def go_to_background ( ) : try : if os . fork ( ) : sys . exit ( ) except OSError as errmsg : LOGGER . error ( 'Fork failed: {0}' . format ( errmsg ) ) sys . exit ( 'Fork failed' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the MD5 hash for a file . [CODESPLIT] def get_file_md5sum ( path ) : with open ( path , 'rb' ) as fh : h = str ( hashlib . md5 ( fh . read ( ) ) . hexdigest ( ) ) return h", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Daemonize the running process . [CODESPLIT] def go_to_background ( ) : try : if os . fork ( ) : sys . exit ( ) except OSError as errmsg : LOGGER . error ( 'Fork failed: {0}' . format ( errmsg ) ) sys . exit ( 'Fork failed' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Just check if raw_image is completely white . http : // stackoverflow . com / questions / 14041562 / python - pil - detect - if - an - image - is - completely - black - or - white [CODESPLIT] def check_color ( cls , raw_image ) : # sum(img.convert(\"L\").getextrema()) in (0, 2)\n extrema = raw_image . convert ( \"L\" ) . getextrema ( ) if extrema == ( 255 , 255 ) : # all white\n raise cls . MonoImageException", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Download the given JSON file and pretty - print before we output it . [CODESPLIT] def download_json ( local_filename , url , clobber = False ) : with open ( local_filename , 'w' ) as json_file : json_file . write ( json . dumps ( requests . get ( url ) . json ( ) , sort_keys = True , indent = 2 , separators = ( ',' , ': ' ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Starts the loop . Calling a running loop is an error . [CODESPLIT] def start ( self ) : assert not self . has_started ( ) , \"called start() on an active GeventLoop\" self . _stop_event = Event ( ) # note that we don't use safe_greenlets.spawn because we take care of it in _loop by ourselves self . _greenlet = gevent . spawn ( self . _loop )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Give string representation of the callable . [CODESPLIT] def give_str ( self ) : args = self . _args [ : ] kwargs = self . _kwargs return self . _give_str ( args , kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Handles whitespace cleanup . [CODESPLIT] def handle_whitespace ( text ) : text = re_retab . sub ( sub_retab , text ) text = re_whitespace . sub ( '' , text ) . strip ( ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of days since January 1 of the given year . [CODESPLIT] def gday_of_year ( self ) : return ( self . date - dt . date ( self . date . year , 1 , 1 ) ) . days", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse an int robustly ignoring commas and other cruft . [CODESPLIT] def robust_int ( v ) : if isinstance ( v , int ) : return v if isinstance ( v , float ) : return int ( v ) v = str ( v ) . replace ( ',' , '' ) if not v : return None return int ( v )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize the data to be in the [ 0 1 ] range . [CODESPLIT] def normalize ( data ) : out_data = data . copy ( ) for i , sample in enumerate ( out_data ) : out_data [ i ] /= sum ( out_data [ i ] ) return out_data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "DOES NOT WORK WELL WITH MOPIDY Hack from https : // www . daniweb . com / software - development / python / code / 260268 / restart - your - python - program to support updating the settings since mopidy is not able to do that yet Restarts the current program Note : this function does not return . Any cleanup action ( like saving data ) must be done before calling this function [CODESPLIT] def restart_program ( ) : python = sys . executable os . execl ( python , python , * sys . argv )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extracts all integers from a string an return them in a list [CODESPLIT] def get_numbers ( s ) : result = map ( int , re . findall ( r'[0-9]+' , unicode ( s ) ) ) return result + [ 1 ] * ( 2 - len ( result ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Looks at the files in a git root directory and grabs the last modified timestamp [CODESPLIT] def get_last_modified_timestamp ( self ) : cmd = \"find . -print0 | xargs -0 stat -f '%T@ %p' | sort -n | tail -1 | cut -f2- -d' '\" ps = subprocess . Popen ( cmd , shell = True , stdout = subprocess . PIPE , stderr = subprocess . STDOUT ) output = ps . communicate ( ) [ 0 ] print output", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a string containing the type and text of the exception . [CODESPLIT] def format_exception ( e ) : from . utils . printing import fill return '\\n' . join ( fill ( line ) for line in traceback . format_exception_only ( type ( e ) , e ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get string from file . [CODESPLIT] def get_file_string ( filepath ) : with open ( os . path . abspath ( filepath ) ) as f : return f . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Receive the content of url parse it as JSON and return the object . [CODESPLIT] def get_jsonparsed_data ( url ) : response = urlopen ( url ) data = response . read ( ) . decode ( 'utf-8' ) return json . loads ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "printdict [CODESPLIT] def printdict ( adict ) : dlist = list ( adict . keys ( ) ) dlist . sort ( ) for i in range ( 0 , len ( dlist ) ) : print ( dlist [ i ] , adict [ dlist [ i ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return ( and memoize ) a database session [CODESPLIT] def _get_session ( ) : session = getattr ( g , '_session' , None ) if session is None : session = g . _session = db . session ( ) return session", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Saves a pdf of the current matplotlib figure . [CODESPLIT] def save_pdf ( path ) : pp = PdfPages ( path ) pp . savefig ( pyplot . gcf ( ) ) pp . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns file name of file at given url . [CODESPLIT] def get_file_name ( url ) : return os . path . basename ( urllib . parse . urlparse ( url ) . path ) or 'unknown_name'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return zero - th element of a one - element data container . [CODESPLIT] def get_X0 ( X ) : if pandas_available and isinstance ( X , pd . DataFrame ) : assert len ( X ) == 1 x = np . array ( X . iloc [ 0 ] ) else : x , = X return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find rightmost value less than or equal to x . [CODESPLIT] def find_le ( a , x ) : i = bs . bisect_right ( a , x ) if i : return i - 1 raise ValueError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Called when user types and releases a key . The widget should be able to receive the focus in order to emit the event . Assign a tabindex attribute to make it focusable . Args : key ( str ) : the character value keycode ( str ) : the numeric char code [CODESPLIT] def onkeyup ( self , key , keycode , ctrl , shift , alt ) : return ( key , keycode , ctrl , shift , alt )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Method to extract keywords from the text provided . [CODESPLIT] def extract_keywords_from_text ( self , text ) : sentences = nltk . tokenize . sent_tokenize ( text ) self . extract_keywords_from_sentences ( sentences )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tell iTunes to pause [CODESPLIT] def pause ( ) : if not settings . platformCompatible ( ) : return False ( output , error ) = subprocess . Popen ( [ \"osascript\" , \"-e\" , PAUSE ] , stdout = subprocess . PIPE ) . communicate ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If item is not in lst add item to list at its sorted position [CODESPLIT] def insort_no_dup ( lst , item ) : import bisect ix = bisect . bisect_left ( lst , item ) if lst [ ix ] != item : lst [ ix : ix ] = [ item ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "All y values [CODESPLIT] def yvals ( self ) : return [ val [ 1 ] for serie in self . series for val in serie . values if val [ 1 ] is not None ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adapts a Numpy array into an ARRAY string to put into the database . [CODESPLIT] def adapt_array ( arr ) : out = io . BytesIO ( ) np . save ( out , arr ) , out . seek ( 0 ) return buffer ( out . read ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "List all available API calls . [CODESPLIT] def list_all ( dev : Device ) : for name , service in dev . services . items ( ) : click . echo ( click . style ( \"\\nService %s\" % name , bold = True ) ) for method in service . methods : click . echo ( \"  %s\" % method . name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks to see if a 2D list is a valid 2D matrix [CODESPLIT] def _rectangular ( n ) : for i in n : if len ( i ) != len ( n [ 0 ] ) : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return list of Logger classes . [CODESPLIT] def _get_loggers ( ) : from . . import loader modules = loader . get_package_modules ( 'logger' ) return list ( loader . get_plugins ( modules , [ _Logger ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the element with the highest probability . [CODESPLIT] def best ( self ) : b = ( - 1e999999 , None ) for k , c in iteritems ( self . counts ) : b = max ( b , ( c , k ) ) return b [ 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Finds parent folder of file [CODESPLIT] def get_parent_folder_name ( file_path ) : return os . path . split ( os . path . split ( os . path . abspath ( file_path ) ) [ 0 ] ) [ - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the string is only composed of hex characters . [CODESPLIT] def is_hex_string ( string ) : pattern = re . compile ( r'[A-Fa-f0-9]+' ) if isinstance ( string , six . binary_type ) : string = str ( string ) return pattern . match ( string ) is not None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Args : dt : a datetime Returns : tuple of the datetime s year and quarter [CODESPLIT] def datetime_to_year_quarter ( dt ) : year = dt . year quarter = int ( math . ceil ( float ( dt . month ) / 3 ) ) return ( year , quarter )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if an element from a list is in a string . [CODESPLIT] def isin ( elems , line ) : found = False for e in elems : if e in line . lower ( ) : found = True break return found", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the memory byte size of a Numpy array as an integer . [CODESPLIT] def bytesize ( arr ) : byte_size = np . prod ( arr . shape ) * np . dtype ( arr . dtype ) . itemsize return byte_size", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if dtype is a numeric type . [CODESPLIT] def is_numeric_dtype ( dtype ) : dtype = np . dtype ( dtype ) return np . issubsctype ( getattr ( dtype , 'base' , None ) , np . number )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "function to get return code of a url [CODESPLIT] def get_url_nofollow ( url ) : try : response = urlopen ( url ) code = response . getcode ( ) return code except HTTPError as e : return e . code except : return 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a line from provided file skipping any blank or comment lines [CODESPLIT] def readline ( file , skip_blank = False ) : while 1 : line = file . readline ( ) #print \"every line: %r\" % line if not line : return None if line [ 0 ] != '#' and not ( skip_blank and line . isspace ( ) ) : return line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses box coordinates to crop an image without resizing it first . [CODESPLIT] def crop_box ( im , box = False , * * kwargs ) : if box : im = im . crop ( box ) return im", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Google AppEngine Helper to convert a data type into a string . [CODESPLIT] def datatype ( dbtype , description , cursor ) : dt = cursor . db . introspection . get_field_type ( dbtype , description ) if type ( dt ) is tuple : return dt [ 0 ] else : return dt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Displayhook function for PIL Images rendered as PNG . [CODESPLIT] def display_pil_image ( im ) : from IPython . core import display b = BytesIO ( ) im . save ( b , format = 'png' ) data = b . getvalue ( ) ip_img = display . Image ( data = data , format = 'png' , embed = True ) return ip_img . _repr_png_ ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns unique elements from a list preserving the original order [CODESPLIT] def unique_element ( ll ) : seen = { } result = [ ] for item in ll : if item in seen : continue seen [ item ] = 1 result . append ( item ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "upload file to a channel [CODESPLIT] def upload_file ( token , channel_name , file_name ) : slack = Slacker ( token ) slack . files . upload ( file_name , channels = channel_name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get zero - indexed line from an open file - like . [CODESPLIT] def get_lines ( handle , line ) : for i , l in enumerate ( handle ) : if i == line : return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load an instance of this class from YAML . [CODESPLIT] def loads ( cls , s ) : with closing ( StringIO ( s ) ) as fileobj : return cls . load ( fileobj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the Hamming distance between two bit strings [CODESPLIT] def hamming_distance ( str1 , str2 ) : if len ( str1 ) != len ( str2 ) : raise VisualizationError ( 'Strings not same length.' ) return sum ( s1 != s2 for s1 , s2 in zip ( str1 , str2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Python s input () is blocking which means the event loop we set above can t be running while we re blocking there . This method will let the loop run while we wait for input . [CODESPLIT] async def async_input ( prompt ) : print ( prompt , end = '' , flush = True ) return ( await loop . run_in_executor ( None , sys . stdin . readline ) ) . rstrip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Register all globally visible functions . [CODESPLIT] def init_checks_registry ( ) : mod = inspect . getmodule ( register_check ) for ( name , function ) in inspect . getmembers ( mod , inspect . isfunction ) : register_check ( function )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the value from the function with the given name in the given language module . By default language = en . [CODESPLIT] def _multilingual ( function , * args , * * kwargs ) : return getattr ( _module ( kwargs . pop ( \"language\" , \"en\" ) ) , function ) ( * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Hex encode a binary string [CODESPLIT] def hex_escape ( bin_str ) : printable = string . ascii_letters + string . digits + string . punctuation + ' ' return '' . join ( ch if ch in printable else r'0x{0:02x}' . format ( ord ( ch ) ) for ch in bin_str )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flat clusters from distance matrix [CODESPLIT] def allele_clusters ( dists , t = 0.025 ) : clusters = fcluster ( linkage ( dists ) , 0.025 , criterion = 'distance' ) cluster_idx = defaultdict ( list ) for idx , cl in enumerate ( clusters ) : cluster_idx [ cl ] . append ( idx ) return cluster_idx", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Unified rounding in all python versions . [CODESPLIT] def py3round ( number ) : if abs ( round ( number ) - number ) == 0.5 : return int ( 2.0 * round ( number / 2.0 ) ) return int ( round ( number ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "IP address range validation and expansion . [CODESPLIT] def ip_address_list ( ips ) : # first, try it as a single IP address try : return ip_address ( ips ) except ValueError : pass # then, consider it as an ipaddress.IPv[4|6]Network instance and expand it return list ( ipaddress . ip_network ( u ( ips ) ) . hosts ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create the file with the given content [CODESPLIT] def write_file ( filename , content ) : print 'Generating {0}' . format ( filename ) with open ( filename , 'wb' ) as out_f : out_f . write ( content )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string to a pythonized parameter . [CODESPLIT] def get_truetype ( value ) : if value in [ \"true\" , \"True\" , \"y\" , \"Y\" , \"yes\" ] : return True if value in [ \"false\" , \"False\" , \"n\" , \"N\" , \"no\" ] : return False if value . isdigit ( ) : return int ( value ) return str ( value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns date range for the previous full month . [CODESPLIT] def get_previous_month ( self ) : end = utils . get_month_start ( ) - relativedelta ( days = 1 ) end = utils . to_datetime ( end ) start = utils . get_month_start ( end ) return start , end", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Whether the item is a placeholder or contains a placeholder . [CODESPLIT] def _not_none ( items ) : if not isinstance ( items , ( tuple , list ) ) : items = ( items , ) return all ( item is not _none for item in items )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "abstract method [CODESPLIT] def poke_array ( self , store , name , elemtype , elements , container , visited , _stack ) : raise NotImplementedError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the arithematic mean of the values in the passed list . Assumes a 1D list but will function on the 1st dim of an array ( ! ) . [CODESPLIT] def mean ( inlist ) : sum = 0 for item in inlist : sum = sum + item return sum / float ( len ( inlist ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses numpy . load to open the underlying file [CODESPLIT] def _openResources ( self ) : arr = np . load ( self . _fileName , allow_pickle = ALLOW_PICKLE ) check_is_an_array ( arr ) self . _array = arr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deserializes Java primitive data and objects serialized by ObjectOutputStream from a file - like object . [CODESPLIT] def load ( file_object ) : marshaller = JavaObjectUnmarshaller ( file_object ) marshaller . add_transformer ( DefaultObjectTransformer ( ) ) return marshaller . readObject ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print something on screen when self . verbose == True [CODESPLIT] def _screen ( self , s , newline = False ) : if self . verbose : if newline : print ( s ) else : print ( s , end = ' ' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last n rows in the table [CODESPLIT] def get_last_row ( dbconn , tablename , n = 1 , uuid = None ) : return fetch ( dbconn , tablename , n , uuid , end = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The l2 norm of an array is is defined as : sqrt ( ||x|| ) where ||x|| is the dot product of the vector . [CODESPLIT] def l2_norm ( arr ) : arr = np . asarray ( arr ) return np . sqrt ( np . dot ( arr . ravel ( ) . squeeze ( ) , arr . ravel ( ) . squeeze ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a sort lambda function for the sortedbykey [CODESPLIT] def _sort_lambda ( sortedby = 'cpu_percent' , sortedby_secondary = 'memory_percent' ) : ret = None if sortedby == 'io_counters' : ret = _sort_io_counters elif sortedby == 'cpu_times' : ret = _sort_cpu_times return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets the width of the table that would be printed . : rtype : int [CODESPLIT] def get_table_width ( table ) : columns = transpose_table ( prepare_rows ( table ) ) widths = [ max ( len ( cell ) for cell in column ) for column in columns ] return len ( '+' + '|' . join ( '-' * ( w + 2 ) for w in widths ) + '+' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If the number of columns matches we can concatenate two LabeldMatrices with the + operator . [CODESPLIT] def __add__ ( self , other ) : assert self . matrix . shape [ 1 ] == other . matrix . shape [ 1 ] return LabeledMatrix ( np . concatenate ( [ self . matrix , other . matrix ] , axis = 0 ) , self . labels )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "1 - farthest apart ( same number of words all diff ) . 0 - same [CODESPLIT] def levenshtein_distance_metric ( a , b ) : return ( levenshtein_distance ( a , b ) / ( 2.0 * max ( len ( a ) , len ( b ) , 1 ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates an pysmt Real constant from x . [CODESPLIT] def limitReal ( x , max_denominator = 1000000 ) : f = Fraction ( x ) . limit_denominator ( max_denominator ) return Real ( ( f . numerator , f . denominator ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialize python List with capacity of 10 or user given input . Python List type is a dynamic array so we have to restrict its dynamic nature to make it work like a static array . [CODESPLIT] def __init__ ( self , capacity = 10 ) : super ( ) . __init__ ( ) self . _array = [ None ] * capacity self . _front = 0 self . _rear = 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to easily create the proper json formated string from a list of strs : param cmd_list : list of strings : return : str json formatted [CODESPLIT] def _make_cmd_list ( cmd_list ) : cmd = '' for i in cmd_list : cmd = cmd + '\"' + i + '\",' cmd = cmd [ : - 1 ] return cmd", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a string composed of elements in inlist with each element separated by delimiter . Used by function writedelimited . Use \\ t for tab - delimiting . [CODESPLIT] def linedelimited ( inlist , delimiter ) : outstr = '' for item in inlist : if type ( item ) != StringType : item = str ( item ) outstr = outstr + item + delimiter outstr = outstr [ 0 : - 1 ] return outstr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute a command installed into the active virtualenv . [CODESPLIT] def vsh ( cmd , * args , * * kw ) : args = '\" \"' . join ( i . replace ( '\"' , r'\\\"' ) for i in args ) easy . sh ( '\"%s\" \"%s\"' % ( venv_bin ( cmd ) , args ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "g [CODESPLIT] def _top ( self ) : # Goto top of the list self . top . body . focus_position = 2 if self . compact is False else 0 self . top . keypress ( self . size , \"\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Display both SQLAlchemy and Python help statements [CODESPLIT] def _help ( ) : statement = '%s%s' % ( shelp , phelp % ', ' . join ( cntx_ . keys ( ) ) ) print statement . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Try to get a number out of a string and cast it . [CODESPLIT] def get_number ( s , cast = int ) : import string d = \"\" . join ( x for x in str ( s ) if x in string . digits ) return cast ( d )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "From : http : // stackoverflow . com / questions / 13062300 / convert - a - dict - to - sorted - dict - in - python [CODESPLIT] def format_result ( input ) : items = list ( iteritems ( input ) ) return OrderedDict ( sorted ( items , key = lambda x : x [ 0 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts list to string with comma separated values . For string is no - op . [CODESPLIT] def list_to_csv ( value ) : if isinstance ( value , ( list , tuple , set ) ) : value = \",\" . join ( value ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of the ( name value ) pairs of the enum . [CODESPLIT] def items ( self ) : return [ ( value_descriptor . name , value_descriptor . number ) for value_descriptor in self . _enum_type . values ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace boolean variables by the characters F / T [CODESPLIT] def _check_and_convert_bools ( self ) : replacements = { True : 'T' , False : 'F' , } for key in self . bools : if isinstance ( self [ key ] , bool ) : self [ key ] = replacements [ self [ key ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ajout d un message de log de type INFO [CODESPLIT] def info ( self , text ) : self . logger . info ( \"{}{}\" . format ( self . message_prefix , text ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert file extension to lowercase . [CODESPLIT] def lower_ext ( abspath ) : fname , ext = os . path . splitext ( abspath ) return fname + ext . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write text . An additional attribute terminator with a value of None is added to the logging record to indicate that StreamHandler should not add a newline . [CODESPLIT] def write ( self , text ) : self . logger . log ( self . loglevel , text , extra = { 'terminator' : None } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract text from a given lxml node . [CODESPLIT] def _extract_node_text ( node ) : texts = map ( six . text_type . strip , map ( six . text_type , map ( unescape , node . xpath ( \".//text()\" ) ) ) ) return \" \" . join ( text for text in texts if text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns true if all of the elements in the list are equal . [CODESPLIT] def _check_elements_equal ( lst ) : assert isinstance ( lst , list ) , \"Input value must be a list.\" return not lst or lst . count ( lst [ 0 ] ) == len ( lst )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Try to convert variables into datatypes . [CODESPLIT] def autoconvert ( string ) : for fn in ( boolify , int , float ) : try : return fn ( string ) except ValueError : pass return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if arg is a valid file that already exists on the file system . [CODESPLIT] def is_valid_file ( parser , arg ) : arg = os . path . abspath ( arg ) if not os . path . exists ( arg ) : parser . error ( \"The file %s does not exist!\" % arg ) else : return arg", "target": 1, "target_options": ["no_match", "match"]}
{"input": "decorator to convert a * args method to one taking a iterable [CODESPLIT] def _varargs_to_iterable_method ( func ) : def wrapped ( self , iterable , * * kwargs ) : return func ( self , * iterable , * * kwargs ) return wrapped", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if object is defined [CODESPLIT] def is_defined ( self , objtxt , force_import = False ) : return self . interpreter . is_defined ( objtxt , force_import )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Subclasses may override this method . [CODESPLIT] def _iterPoints ( self , * * kwargs ) : points = self . points count = len ( points ) index = 0 while count : yield points [ index ] count -= 1 index += 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a UUID - based file name which is extremely unlikely to exist already . [CODESPLIT] def random_filename ( path = None ) : filename = uuid4 ( ) . hex if path is not None : filename = os . path . join ( path , filename ) return filename", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks whether an element is present . [CODESPLIT] def is_element_present ( self , strategy , locator ) : return self . driver_adapter . is_element_present ( strategy , locator , root = self . root )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Double click on a given square in the map [CODESPLIT] def OnDoubleClick ( self , event ) : node = HotMapNavigator . findNodeAtPosition ( self . hot_map , event . GetPosition ( ) ) if node : wx . PostEvent ( self , SquareActivationEvent ( node = node , point = event . GetPosition ( ) , map = self ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check to see if the internet is on by pinging a set address . : param address : the IP or address to hit : return : a boolean - true if can be reached false if not . [CODESPLIT] def _internet_on ( address ) : try : urllib2 . urlopen ( address , timeout = 1 ) return True except urllib2 . URLError as err : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a timevalue for interval comparisons [CODESPLIT] def stopwatch_now ( ) : if six . PY2 : now = time . time ( ) else : now = time . monotonic ( ) return now", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets the title on the underlying matplotlib AxesSubplot . [CODESPLIT] def set_title ( self , title , * * kwargs ) : ax = self . get_axes ( ) ax . set_title ( title , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Try to convert variables into datatypes . [CODESPLIT] def autoconvert ( string ) : for fn in ( boolify , int , float ) : try : return fn ( string ) except ValueError : pass return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This method asserts that only one value of the provided list is True . [CODESPLIT] def assert_exactly_one_true ( bool_list ) : assert isinstance ( bool_list , list ) counter = 0 for item in bool_list : if item : counter += 1 return counter == 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make bars in horizontal bar chart thinner [CODESPLIT] def _change_height ( self , ax , new_value ) : for patch in ax . patches : current_height = patch . get_height ( ) diff = current_height - new_value # we change the bar height patch . set_height ( new_value ) # we recenter the bar patch . set_y ( patch . get_y ( ) + diff * .5 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper that returns if parent / item is a directory . [CODESPLIT] def _IsDirectory ( parent , item ) : return tf . io . gfile . isdir ( os . path . join ( parent , item ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set additionnal options as plain text . [CODESPLIT] def set_axis_options ( self , row , column , text ) : subplot = self . get_subplot_at ( row , column ) subplot . set_axis_options ( text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Choose k random elements of array . [CODESPLIT] def downsample ( array , k ) : length = array . shape [ 0 ] indices = random . sample ( xrange ( length ) , k ) return array [ indices ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes an entry [CODESPLIT] def remove ( self , entry ) : try : list = self . cache [ entry . key ] list . remove ( entry ) except : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return possible range for max function . [CODESPLIT] def max_values ( args ) : return Interval ( max ( x . low for x in args ) , max ( x . high for x in args ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Detach from all tracked classes and objects . Restore the original constructors and cleanse the tracking lists . [CODESPLIT] def detach_all ( self ) : self . detach_all_classes ( ) self . objects . clear ( ) self . index . clear ( ) self . _keepalive [ : ] = [ ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a ctypes void pointer to the memory mapped region . [CODESPLIT] def pointer ( self ) : return ctypes . cast ( ctypes . pointer ( ctypes . c_uint8 . from_buffer ( self . mapping , 0 ) ) , ctypes . c_void_p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Stop logging . [CODESPLIT] def stoplog ( self ) : if self . _file_logger : self . logger . removeHandler ( _file_logger ) self . _file_logger = None return 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get a value from a tag ( if it exists ) [CODESPLIT] def _get_minidom_tag_value ( station , tag_name ) : tag = station . getElementsByTagName ( tag_name ) [ 0 ] . firstChild if tag : return tag . nodeValue return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Closes the serial port . [CODESPLIT] def close ( self ) : if self . pyb and self . pyb . serial : self . pyb . serial . close ( ) self . pyb = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Called by remote workers . Useful to populate main module globals () for interactive shells . Retrieves the serialized function . [CODESPLIT] def getFunction ( self ) : return functionFactory ( self . code , self . name , self . defaults , self . globals , self . imports , )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Construct this Dagobah instance from a JSON document . [CODESPLIT] def _construct_from_json ( self , rec ) : self . delete ( ) for required_key in [ 'dagobah_id' , 'created_jobs' ] : setattr ( self , required_key , rec [ required_key ] ) for job_json in rec . get ( 'jobs' , [ ] ) : self . _add_job_from_spec ( job_json ) self . commit ( cascade = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterates over all of the referreds and then iterates over all of the referrers that refer to each one . [CODESPLIT] def benchmark ( store , n = 10000 ) : R = Referrer for referred in store . query ( Referred ) : for _reference in store . query ( R , R . reference == referred ) : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Step over the next statement [CODESPLIT] def do_next ( self , args ) : self . _do_print_from_last_cmd = True self . _interp . step_over ( ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Matches a paren . [CODESPLIT] def match_paren ( self , tokens , item ) : match , = tokens return self . match ( match , item )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flags that a function is linear wrt all args [CODESPLIT] def def_linear ( fun ) : defjvp_argnum ( fun , lambda argnum , g , ans , args , kwargs : fun ( * subval ( args , argnum , g ) , * * kwargs ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn list of keywords into dictionary . [CODESPLIT] def _kw ( keywords ) : r = { } for k , v in keywords : r [ k ] = v return r", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return data as a JSON string . [CODESPLIT] def to_json ( data ) : return json . dumps ( data , default = lambda x : x . __dict__ , sort_keys = True , indent = 4 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like many_until but must consume at least one of these . [CODESPLIT] def many_until1 ( these , term ) : first = [ these ( ) ] these_results , term_result = many_until ( these , term ) return ( first + these_results , term_result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "reinitialize consumer for process in multiprocesing [CODESPLIT] def initialize_worker ( self , process_num = None ) : self . initialize ( self . grid , self . num_of_paths , self . seed )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "translate an array x into a MATLAB cell array [CODESPLIT] def _cell ( x ) : x_no_none = [ i if i is not None else \"\" for i in x ] return array ( x_no_none , dtype = np_object )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the size of a multidimansional array . [CODESPLIT] def array_dim ( arr ) : dim = [ ] while True : try : dim . append ( len ( arr ) ) arr = arr [ 0 ] except TypeError : return dim", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform a named tuple into a dictionary [CODESPLIT] def dictify ( a_named_tuple ) : return dict ( ( s , getattr ( a_named_tuple , s ) ) for s in a_named_tuple . _fields )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialize python List with capacity of 10 or user given input . Python List type is a dynamic array so we have to restrict its dynamic nature to make it work like a static array . [CODESPLIT] def __init__ ( self , capacity = 10 ) : super ( ) . __init__ ( ) self . _array = [ None ] * capacity self . _front = 0 self . _rear = 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last item of an array in a list or an empty list . [CODESPLIT] def last_item ( array ) : if array . size == 0 : # work around for https://github.com/numpy/numpy/issues/5195 return [ ] indexer = ( slice ( - 1 , None ) , ) * array . ndim return np . ravel ( array [ indexer ] ) . tolist ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print a dictionary of attributes in the DOT format [CODESPLIT] def _attrprint ( d , delimiter = ', ' ) : return delimiter . join ( ( '\"%s\"=\"%s\"' % item ) for item in sorted ( d . items ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set foreground - and background colors and intensity . [CODESPLIT] def set_color ( self , fg = None , bg = None , intensify = False , target = sys . stdout ) : raise NotImplementedError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coerce value to an JSON - compatible representation . [CODESPLIT] def _bytes_to_json ( value ) : if isinstance ( value , bytes ) : value = base64 . standard_b64encode ( value ) . decode ( \"ascii\" ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a str if a bytes object is given . [CODESPLIT] def bytes_to_str ( s , encoding = 'utf-8' ) : if six . PY3 and isinstance ( s , bytes ) : return s . decode ( encoding ) return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Scipy norm function [CODESPLIT] def norm ( x , mu , sigma = 1.0 ) : return stats . norm ( loc = mu , scale = sigma ) . pdf ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "shotcut to pull out useful info for interactive use [CODESPLIT] def stats ( self ) : printDebug ( \"Classes.....: %d\" % len ( self . all_classes ) ) printDebug ( \"Properties..: %d\" % len ( self . all_properties ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "rescales a numpy array so that min is 0 and max is 255 [CODESPLIT] def _normalize ( mat : np . ndarray ) : return ( ( mat - mat . min ( ) ) * ( 255 / mat . max ( ) ) ) . astype ( np . uint8 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize a field to a ( min max ) exposure range default is ( 0 255 ) . ( min max ) exposure values . Invert the image if requested . [CODESPLIT] def normalize ( im , invert = False , scale = None , dtype = np . float64 ) : if dtype not in { np . float16 , np . float32 , np . float64 } : raise ValueError ( 'dtype must be numpy.float16, float32, or float64.' ) out = im . astype ( 'float' ) . copy ( ) scale = scale or ( 0.0 , 255.0 ) l , u = ( float ( i ) for i in scale ) out = ( out - l ) / ( u - l ) if invert : out = - out + ( out . max ( ) + out . min ( ) ) return out . astype ( dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Change x ! = y to not ( x == y ) . [CODESPLIT] def ComplementEquivalence ( * args , * * kwargs ) : return ast . Complement ( ast . Equivalence ( * args , * * kwargs ) , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tests if image img in category cat exists [CODESPLIT] def test_for_image ( self , cat , img ) : return self . test_for_category ( cat ) and img in self . items [ cat ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A basic check of if the program is running in interactive mode [CODESPLIT] def isInteractive ( ) : if sys . stdout . isatty ( ) and os . name != 'nt' : #Hopefully everything but ms supports '\\r' try : import threading except ImportError : return False else : return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "last row or column of square A [CODESPLIT] def other_ind ( self ) : return np . full ( self . n_min , self . size - 1 , dtype = np . int )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "computes factorial of n [CODESPLIT] def computeFactorial ( n ) : sleep_walk ( 10 ) ret = 1 for i in range ( n ) : ret = ret * ( i + 1 ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get distance matrix given a matrix . Used in testing . [CODESPLIT] def get_distance_matrix ( x ) : square = nd . sum ( x ** 2.0 , axis = 1 , keepdims = True ) distance_square = square + square . transpose ( ) - ( 2.0 * nd . dot ( x , x . transpose ( ) ) ) return nd . sqrt ( distance_square )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap a string at a line length [CODESPLIT] def wrap ( string , length , indent ) : newline = \"\\n\" + \" \" * indent return newline . join ( ( string [ i : i + length ] for i in range ( 0 , len ( string ) , length ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "inverse hyperbolic sine transformation [CODESPLIT] def inh ( table ) : t = [ ] for i in table : t . append ( np . ndarray . tolist ( np . arcsinh ( i ) ) ) return t", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility to generate enum classes used by annotations . [CODESPLIT] def _Enum ( docstring , * names ) : enums = dict ( zip ( names , range ( len ( names ) ) ) ) reverse = dict ( ( value , key ) for key , value in enums . iteritems ( ) ) enums [ 'reverse_mapping' ] = reverse enums [ '__doc__' ] = docstring return type ( 'Enum' , ( object , ) , enums )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a structured NumPy array into a Table . [CODESPLIT] def from_array ( cls , arr ) : return cls ( ) . with_columns ( [ ( f , arr [ f ] ) for f in arr . dtype . names ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "quit crash [CODESPLIT] def _quit ( self , * args ) : self . logger . warn ( 'Bye!' ) sys . exit ( self . exit ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "IP address range validation and expansion . [CODESPLIT] def ip_address_list ( ips ) : # first, try it as a single IP address try : return ip_address ( ips ) except ValueError : pass # then, consider it as an ipaddress.IPv[4|6]Network instance and expand it return list ( ipaddress . ip_network ( u ( ips ) ) . hosts ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Defines the time after which Exscript fails if it does not receive a prompt from the remote host . [CODESPLIT] def set_timeout ( scope , timeout ) : conn = scope . get ( '__connection__' ) conn . set_timeout ( int ( timeout [ 0 ] ) ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add suffix to a full file name [CODESPLIT] def add_suffix ( fullname , suffix ) : name , ext = os . path . splitext ( fullname ) return name + '_' + suffix + ext", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A small helper function to convert a string to a numeric value if appropriate [CODESPLIT] def _convert_to_float_if_possible ( s ) : try : ret = float ( s ) except ( ValueError , TypeError ) : ret = s return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rotates an image by deg degrees [CODESPLIT] def rotate_img ( im , deg , mode = cv2 . BORDER_CONSTANT , interpolation = cv2 . INTER_AREA ) : r , c ,  * _ = im . shape M = cv2 . getRotationMatrix2D ( ( c // 2 , r // 2 ) , deg , 1 ) return cv2 . warpAffine ( im , M , ( c , r ) , borderMode = mode , flags = cv2 . WARP_FILL_OUTLIERS + interpolation )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the color as current OpenGL color [CODESPLIT] def set ( self ) : glColor4f ( self . r , self . g , self . b , self . a )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Warn deprecated . [CODESPLIT] def warn_deprecated ( message , stacklevel = 2 ) : # pragma: no cover warnings . warn ( message , category = DeprecationWarning , stacklevel = stacklevel )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of dicionaries . See set_order . [CODESPLIT] def get_order ( self ) : return [ dict ( reverse = r [ 0 ] , key = r [ 1 ] ) for r in self . get_model ( ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pad an image to ensure each edge to be multiple to some number . [CODESPLIT] def impad_to_multiple ( img , divisor , pad_val = 0 ) : pad_h = int ( np . ceil ( img . shape [ 0 ] / divisor ) ) * divisor pad_w = int ( np . ceil ( img . shape [ 1 ] / divisor ) ) * divisor return impad ( img , ( pad_h , pad_w ) , pad_val )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A quick and dirty way to get a unique string [CODESPLIT] def uniqueID ( size = 6 , chars = string . ascii_uppercase + string . digits ) : return '' . join ( random . choice ( chars ) for x in xrange ( size ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield one date per day from starting date to ending date . [CODESPLIT] def daterange ( start_date , end_date ) : for n in range ( int ( ( end_date - start_date ) . days ) ) : yield start_date + timedelta ( n )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse http raw respone into python dictionary object . : param str response : http response : returns : response dict : rtype : dict [CODESPLIT] def _parse_response ( self , response ) : response_dict = { } for line in response . splitlines ( ) : key , value = response . split ( \"=\" , 1 ) response_dict [ key ] = value return response_dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert a rfc3339 date representation into a Python datetime [CODESPLIT] def rfc3339_to_datetime ( data ) : try : ts = time . strptime ( data , '%Y-%m-%d' ) return date ( * ts [ : 3 ] ) except ValueError : pass try : dt , _ , tz = data . partition ( 'Z' ) if tz : tz = offset ( tz ) else : tz = offset ( '00:00' ) if '.' in dt and dt . rsplit ( '.' , 1 ) [ - 1 ] . isdigit ( ) : ts = time . strptime ( dt , '%Y-%m-%dT%H:%M:%S.%f' ) else : ts = time . strptime ( dt , '%Y-%m-%dT%H:%M:%S' ) return datetime ( * ts [ : 6 ] , tzinfo = tz ) except ValueError : raise ValueError ( 'date-time {!r} is not a valid rfc3339 date representation' . format ( data ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "! [CODESPLIT] def timedcall ( executable_function , * args ) : time_start = time . clock ( ) result = executable_function ( * args ) time_end = time . clock ( ) return ( time_end - time_start , result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the first lang of Accept - Language Header . [CODESPLIT] def get_first_lang ( ) : request_lang = request . headers . get ( 'Accept-Language' ) . split ( ',' ) if request_lang : lang = locale . normalize ( request_lang [ 0 ] ) . split ( '.' ) [ 0 ] else : lang = False return lang", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a list of Python str to C pointer [CODESPLIT] def from_pystr_to_cstr ( data ) : if not isinstance ( data , list ) : raise NotImplementedError pointers = ( ctypes . c_char_p * len ( data ) ) ( ) if PY3 : data = [ bytes ( d , 'utf-8' ) for d in data ] else : data = [ d . encode ( 'utf-8' ) if isinstance ( d , unicode ) else d # pylint: disable=undefined-variable for d in data ] pointers [ : ] = data return pointers", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the clipboard s text on OS X . [CODESPLIT] def osx_clipboard_get ( ) : p = subprocess . Popen ( [ 'pbpaste' , '-Prefer' , 'ascii' ] , stdout = subprocess . PIPE ) text , stderr = p . communicate ( ) # Text comes in with old Mac \\r line endings. Change them to \\n. text = text . replace ( '\\r' , '\\n' ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Start a Pdb instance at the calling frame with stdout routed to sys . __stdout__ . [CODESPLIT] def set_trace ( ) : # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py pdb . Pdb ( stdout = sys . __stdout__ ) . set_trace ( sys . _getframe ( ) . f_back )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the magnitude of a vector . [CODESPLIT] def mag ( z ) : if isinstance ( z [ 0 ] , np . ndarray ) : return np . array ( list ( map ( np . linalg . norm , z ) ) ) else : return np . linalg . norm ( z )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get width and height of a PDF [CODESPLIT] def dimensions ( path ) : pdf = PdfFileReader ( path ) size = pdf . getPage ( 0 ) . mediaBox return { 'w' : float ( size [ 2 ] ) , 'h' : float ( size [ 3 ] ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the key ( aka database value ) of a human key ( aka Python identifier ) . [CODESPLIT] def get_from_human_key ( self , key ) : if key in self . _identifier_map : return self . _identifier_map [ key ] raise KeyError ( key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "stop publisher [CODESPLIT] def on_stop ( self ) : LOGGER . debug ( \"zeromq.Publisher.on_stop\" ) self . zmqsocket . close ( ) self . zmqcontext . destroy ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strips spaces : param x : : return : [CODESPLIT] def strip_spaces ( x ) : x = x . replace ( b' ' , b'' ) x = x . replace ( b'\\t' , b'' ) return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of indexes of substr . If substr not found list is empty . [CODESPLIT] def get_substring_idxs ( substr , string ) : return [ match . start ( ) for match in re . finditer ( substr , string ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pause the music [CODESPLIT] def pause ( self ) : mixer . music . pause ( ) self . pause_time = self . get_time ( ) self . paused = True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the output shape from an array . [CODESPLIT] def out_shape_from_array ( arr ) : arr = np . asarray ( arr ) if arr . ndim == 1 : return arr . shape else : return ( arr . shape [ 1 ] , )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "itertools . starmap for deferred callables using cooperative multitasking [CODESPLIT] def asyncStarCmap ( asyncCallable , iterable ) : results = [ ] yield coopStar ( asyncCallable , results . append , iterable ) returnValue ( results )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a connection back to the pool [CODESPLIT] def _ReturnConnection ( self ) : if self . conn is not None : if self . connInfo . commitOnEnd is True or self . commitOnEnd is True : self . conn . Commit ( ) Pool ( ) . returnConnection ( self . conn ) self . conn = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the index of an element in the list . [CODESPLIT] def get_list_index ( lst , index_or_name ) : if isinstance ( index_or_name , six . integer_types ) : return index_or_name return lst . index ( index_or_name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the 1 - based index of the last object on this page relative to total objects found ( hits ) . [CODESPLIT] def end_index ( self ) : return ( ( self . number - 1 ) * self . paginator . per_page + len ( self . object_list ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function executes the request with the provided json payload and return the json response [CODESPLIT] def make_post_request ( self , url , auth , json_payload ) : response = requests . post ( url , auth = auth , json = json_payload ) return response . json ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the display length of a string . This can differ from the character length if the string contains wide characters . [CODESPLIT] def display_len ( text ) : text = unicodedata . normalize ( 'NFD' , text ) return sum ( char_width ( char ) for char in text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns unique elements from a list preserving the original order [CODESPLIT] def unique_element ( ll ) : seen = { } result = [ ] for item in ll : if item in seen : continue seen [ item ] = 1 result . append ( item ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convenience function which returns the unit vector aligned with the miller index . [CODESPLIT] def get_mi_vec ( slab ) : mvec = np . cross ( slab . lattice . matrix [ 0 ] , slab . lattice . matrix [ 1 ] ) return mvec / np . linalg . norm ( mvec )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a string with terminal colors . [CODESPLIT] def stringc ( text , color ) : if has_colors : text = str ( text ) return \"\\033[\" + codeCodes [ color ] + \"m\" + text + \"\\033[0m\" else : return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty print a dict as a JSON with colors if pygments is present . [CODESPLIT] def _format_json ( data , theme ) : output = json . dumps ( data , indent = 2 , sort_keys = True ) if pygments and sys . stdout . isatty ( ) : style = get_style_by_name ( theme ) formatter = Terminal256Formatter ( style = style ) return pygments . highlight ( output , JsonLexer ( ) , formatter ) return output", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If output is string then print the string and also time used [CODESPLIT] def timeit ( output ) : b = time . time ( ) yield print output , 'time used: %.3fs' % ( time . time ( ) - b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if connection to the host and port specified in url is successful within the timeout . [CODESPLIT] def wait_for_url ( url , timeout = DEFAULT_TIMEOUT ) : service = ServiceURL ( url , timeout ) return service . wait ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a hash of the contents of a dictionary [CODESPLIT] def dict_hash ( dct ) : dct_s = json . dumps ( dct , sort_keys = True ) try : m = md5 ( dct_s ) except TypeError : m = md5 ( dct_s . encode ( ) ) return m . hexdigest ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty - print a Python o to a stream [ default is sys . stdout ] . [CODESPLIT] def pprint ( o , stream = None , indent = 1 , width = 80 , depth = None ) : printer = PrettyPrinter ( stream = stream , indent = indent , width = width , depth = depth ) printer . pprint ( o )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If pygments are available on the system then returned output is colored . Otherwise unchanged content is returned . [CODESPLIT] def get_highlighted_code ( name , code , type = 'terminal' ) : import logging try : import pygments pygments except ImportError : return code from pygments import highlight from pygments . lexers import guess_lexer_for_filename , ClassNotFound from pygments . formatters import TerminalFormatter try : lexer = guess_lexer_for_filename ( name , code ) formatter = TerminalFormatter ( ) content = highlight ( code , lexer , formatter ) except ClassNotFound : logging . debug ( \"Couldn't guess Lexer, will not use pygments.\" ) content = code return content", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string from snake case to camel case . For example some_var would become someVar . [CODESPLIT] def to_camel_case ( snake_case_string ) : parts = snake_case_string . lstrip ( '_' ) . split ( '_' ) return parts [ 0 ] + '' . join ( [ i . title ( ) for i in parts [ 1 : ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "kill process Args : process - Popen object for process [CODESPLIT] def kill_mprocess ( process ) : if process and proc_alive ( process ) : process . terminate ( ) process . communicate ( ) return not proc_alive ( process )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Detect the encoding of a file . [CODESPLIT] def detect ( filename , include_confidence = False ) : f = open ( filename ) detection = chardet . detect ( f . read ( ) ) f . close ( ) encoding = detection . get ( 'encoding' ) confidence = detection . get ( 'confidence' ) if include_confidence : return ( encoding , confidence ) return encoding", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is the same functionality as int . from_bytes in python 3 [CODESPLIT] def _from_bytes ( bytes , byteorder = \"big\" , signed = False ) : return int . from_bytes ( bytes , byteorder = byteorder , signed = signed )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add one tick to progress bar [CODESPLIT] def tick ( self ) : self . current += 1 if self . current == self . factor : sys . stdout . write ( '+' ) sys . stdout . flush ( ) self . current = 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get input from the user given an input function and an input string [CODESPLIT] def get_input ( input_func , input_str ) : val = input_func ( \"Please enter your {0}: \" . format ( input_str ) ) while not val or not len ( val . strip ( ) ) : val = input_func ( \"You didn't enter a valid {0}, please try again: \" . format ( input_str ) ) return val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the element with the highest probability . [CODESPLIT] def best ( self ) : b = ( - 1e999999 , None ) for k , c in iteritems ( self . counts ) : b = max ( b , ( c , k ) ) return b [ 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deserialize b ( instance of bytes ) to a Python object . [CODESPLIT] def loadb ( b ) : assert isinstance ( b , ( bytes , bytearray ) ) return std_json . loads ( b . decode ( 'utf-8' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a random positive integer ( for a Django PositiveIntegerField ) [CODESPLIT] def positive_integer ( anon , obj , field , val ) : return anon . faker . positive_integer ( field = field )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Directly reads text data from url [CODESPLIT] def url_read_text ( url , verbose = True ) : data = url_read ( url , verbose ) text = data . decode ( 'utf8' ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a list of the data types for each column in * data * . [CODESPLIT] def _get_column_types ( self , data ) : columns = list ( zip_longest ( * data ) ) return [ self . _get_column_type ( column ) for column in columns ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return type string compatible with numpy . [CODESPLIT] def get_var_type ( self , name ) : name = create_string_buffer ( name ) type_ = create_string_buffer ( MAXSTRLEN ) self . library . get_var_type . argtypes = [ c_char_p , c_char_p ] self . library . get_var_type ( name , type_ ) return type_ . value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Loads the images and latent values into Numpy arrays . [CODESPLIT] def _load_data ( filepath ) : with h5py . File ( filepath , \"r\" ) as h5dataset : image_array = np . array ( h5dataset [ \"images\" ] ) # The 'label' data set in the hdf5 file actually contains the float values # and not the class labels. values_array = np . array ( h5dataset [ \"labels\" ] ) return image_array , values_array", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get mnist dataset with features and label as ndarray . Data would be downloaded automatically if it doesn t present at the specific location . [CODESPLIT] def get_mnist ( data_type = \"train\" , location = \"/tmp/mnist\" ) : X , Y = mnist . read_data_sets ( location , data_type ) return X , Y + 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read tag data from file and return as numpy array . [CODESPLIT] def read_numpy ( fh , byteorder , dtype , count , offsetsize ) : dtype = 'b' if dtype [ - 1 ] == 's' else byteorder + dtype [ - 1 ] return fh . read_array ( dtype , count )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function for fast reading from sensor files . [CODESPLIT] def _fast_read ( self , infile ) : infile . seek ( 0 ) return ( int ( infile . read ( ) . decode ( ) . strip ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function for fast reading from sensor files . [CODESPLIT] def _fast_read ( self , infile ) : infile . seek ( 0 ) return ( int ( infile . read ( ) . decode ( ) . strip ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a vtk . vtkPlane [CODESPLIT] def _generate_plane ( normal , origin ) : plane = vtk . vtkPlane ( ) plane . SetNormal ( normal [ 0 ] , normal [ 1 ] , normal [ 2 ] ) plane . SetOrigin ( origin [ 0 ] , origin [ 1 ] , origin [ 2 ] ) return plane", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prints the specified message and exits the program with the specified exit status . [CODESPLIT] def fail ( message = None , exit_status = None ) : print ( 'Error:' , message , file = sys . stderr ) sys . exit ( exit_status or 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "converts a value list into yaml syntax : param name : name of object ( example : phone ) : type name : str : param value : object contents : type value : str list ( str ) list ( list ( str )) : param indentation : indent all by number of spaces : type indentation : int : param indexOfColon : use to position : at the name string ( - 1 for no space ) : type indexOfColon : int : param show_multi_line_character : option to hide | : type show_multi_line_character : boolean : returns : yaml formatted string array of name value pair : rtype : list ( str ) [CODESPLIT] def convert_to_yaml ( name , value , indentation , indexOfColon , show_multi_line_character ) : strings = [ ] if isinstance ( value , list ) : # special case for single item lists: if len ( value ) == 1 and isinstance ( value [ 0 ] , str ) : # value = [\"string\"] should not be converted to # name: #   - string # but to \"name: string\" instead value = value [ 0 ] elif len ( value ) == 1 and isinstance ( value [ 0 ] , list ) and len ( value [ 0 ] ) == 1 and isinstance ( value [ 0 ] [ 0 ] , str ) : # same applies to value = [[\"string\"]] value = value [ 0 ] [ 0 ] if isinstance ( value , str ) : strings . append ( \"%s%s%s: %s\" % ( ' ' * indentation , name , ' ' * ( indexOfColon - len ( name ) ) , indent_multiline_string ( value , indentation + 4 , show_multi_line_character ) ) ) elif isinstance ( value , list ) : strings . append ( \"%s%s%s: \" % ( ' ' * indentation , name , ' ' * ( indexOfColon - len ( name ) ) ) ) for outer in value : # special case for single item sublists if isinstance ( outer , list ) and len ( outer ) == 1 and isinstance ( outer [ 0 ] , str ) : # outer = [\"string\"] should not be converted to # - #   - string # but to \"- string\" instead outer = outer [ 0 ] if isinstance ( outer , str ) : strings . append ( \"%s- %s\" % ( ' ' * ( indentation + 4 ) , indent_multiline_string ( outer , indentation + 8 , show_multi_line_character ) ) ) elif isinstance ( outer , list ) : strings . append ( \"%s- \" % ( ' ' * ( indentation + 4 ) ) ) for inner in outer : if isinstance ( inner , str ) : strings . append ( \"%s- %s\" % ( ' ' * ( indentation + 8 ) , indent_multiline_string ( inner , indentation + 12 , show_multi_line_character ) ) ) return strings", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Any normal python logic which runs a loop . Can take arguments . [CODESPLIT] def main ( idle ) : while True : LOG . debug ( \"Sleeping for {0} seconds.\" . format ( idle ) ) time . sleep ( idle )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Emulate lpop . [CODESPLIT] def rpop ( self , key ) : redis_list = self . _get_list ( key , 'RPOP' ) if self . _encode ( key ) not in self . redis : return None try : value = redis_list . pop ( ) if len ( redis_list ) == 0 : self . delete ( key ) return value except ( IndexError ) : # Redis returns nil if popping from an empty list return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Disable the button if in non - expert mode ; unset its activity flag come - what - may . [CODESPLIT] def disable ( self ) : if not self . _expert : self . config ( state = 'disable' ) self . _active = False", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": see :: meth : RedisMap . __setitem__ [CODESPLIT] def __setitem__ ( self , field , value ) : return self . _client . hset ( self . key_prefix , field , self . _dumps ( value ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Construction from a string raise a TypeError if not possible [CODESPLIT] def construct_from_string ( cls , string ) : if string == cls . name : return cls ( ) raise TypeError ( \"Cannot construct a '{}' from \" \"'{}'\" . format ( cls , string ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "parse the domain from the url [CODESPLIT] def parse_domain ( url ) : domain_match = lib . DOMAIN_REGEX . match ( url ) if domain_match : return domain_match . group ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Join the given iterable with [CODESPLIT] def commajoin_as_strings ( iterable ) : return _ ( u',' ) . join ( ( six . text_type ( i ) for i in iterable ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Implements string formatting along with color specified in colorama . Fore [CODESPLIT] def colorize ( string , color , * args , * * kwargs ) : string = string . format ( * args , * * kwargs ) return color + string + colorama . Fore . RESET", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace accentuated chars in string by their non accentuated equivalent . [CODESPLIT] def unaccentuate ( s ) : return \"\" . join ( c for c in unicodedata . normalize ( \"NFKD\" , s ) if not unicodedata . combining ( c ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip all the accents from the string [CODESPLIT] def strip_accents ( string ) : return u'' . join ( ( character for character in unicodedata . normalize ( 'NFD' , string ) if unicodedata . category ( character ) != 'Mn' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert 3 3 a matrix to 6 element s list ( see Tauxe 1998 ) [CODESPLIT] def a2s ( a ) : s = np . zeros ( ( 6 , ) , 'f' ) # make the a matrix for i in range ( 3 ) : s [ i ] = a [ i ] [ i ] s [ 3 ] = a [ 0 ] [ 1 ] s [ 4 ] = a [ 1 ] [ 2 ] s [ 5 ] = a [ 0 ] [ 2 ] return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a dictionary and a key list remove any data in the dictionary with the given keys . [CODESPLIT] def rm_keys_from_dict ( d , keys ) : # Loop for each key given for key in keys : # Is the key in the dictionary? if key in d : try : d . pop ( key , None ) except KeyError : # Not concerned with an error. Keep going. pass return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function returns a pretty table used to display the port results . [CODESPLIT] def get_table ( ports ) : table = PrettyTable ( [ \"Name\" , \"Port\" , \"Protocol\" , \"Description\" ] ) table . align [ \"Name\" ] = \"l\" table . align [ \"Description\" ] = \"l\" table . padding_width = 1 for port in ports : table . add_row ( port ) return table", "target": 1, "target_options": ["no_match", "match"]}
{"input": "given a filename return the ABFs ID string . [CODESPLIT] def abfIDfromFname ( fname ) : fname = os . path . abspath ( fname ) basename = os . path . basename ( fname ) return os . path . splitext ( basename ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert dict of ascii str / unicode to dict of str if necessary [CODESPLIT] def str_dict ( some_dict ) : return { str ( k ) : str ( v ) for k , v in some_dict . items ( ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper for Zotero . _cleanup [CODESPLIT] def cleanwrap ( func ) : def enc ( self , * args , * * kwargs ) : \"\"\" Send each item to _cleanup() \"\"\" return ( func ( self , item , * * kwargs ) for item in args ) return enc", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Joins two dictionaries . [CODESPLIT] def dict_merge ( set1 , set2 ) : return dict ( list ( set1 . items ( ) ) + list ( set2 . items ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes non - alpha characters and converts spaces to hyphens . Useful for making file names . Source : http : // stackoverflow . com / questions / 5574042 / string - slugification - in - python [CODESPLIT] def slugify ( string ) : string = re . sub ( '[^\\w .-]' , '' , string ) string = string . replace ( \" \" , \"-\" ) return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a Vector as the product of the vector and a real number . [CODESPLIT] def multiply ( self , number ) : return self . from_list ( [ x * number for x in self . to_list ( ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compile and return a Module s code object . [CODESPLIT] def get_code ( module ) : fp = open ( module . path ) try : return compile ( fp . read ( ) , str ( module . name ) , 'exec' ) finally : fp . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Upermutate 1 - D data that is sorted by indices_of_increasing . [CODESPLIT] def unsort_vector ( data , indices_of_increasing ) : return numpy . array ( [ data [ indices_of_increasing . index ( i ) ] for i in range ( len ( data ) ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a dataframe and string - i - fy a column of values . Turn nan / None into and all other values into strings . [CODESPLIT] def stringify_col ( df , col_name ) : df = df . copy ( ) df [ col_name ] = df [ col_name ] . fillna ( \"\" ) df [ col_name ] = df [ col_name ] . astype ( str ) return df", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Does openat read - only then does fdopen to get a file object [CODESPLIT] def fopenat ( base_fd , path ) : return os . fdopen ( openat ( base_fd , path , os . O_RDONLY ) , 'rb' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace any non - word characters with a dash . [CODESPLIT] def dashrepl ( value ) : patt = re . compile ( r'\\W' , re . UNICODE ) return re . sub ( patt , '-' , value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply gzip compression to a response . [CODESPLIT] def _gzip ( self , response ) : bytesio = six . BytesIO ( ) with gzip . GzipFile ( fileobj = bytesio , mode = 'w' ) as gz : gz . write ( response ) return bytesio . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return the key from the request [CODESPLIT] def get ( key , default = None ) : data = get_form ( ) or get_query_string ( ) return data . get ( key , default )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Default locale selector used in abilian applications . [CODESPLIT] def localeselector ( ) : # if a user is logged in, use the locale from the user settings user = getattr ( g , \"user\" , None ) if user is not None : locale = getattr ( user , \"locale\" , None ) if locale : return locale # Otherwise, try to guess the language from the user accept header the browser # transmits.  By default we support en/fr. The best match wins. return request . accept_languages . best_match ( current_app . config [ \"BABEL_ACCEPT_LANGUAGES\" ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses XML from a response . [CODESPLIT] def xml ( cls , res , * args , * * kwargs ) : return parse_xml ( res . text , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an enumerable that iterates through a multi - page API request [CODESPLIT] def _iter_response ( self , url , params = None ) : if params is None : params = { } params [ 'page_number' ] = 1 # Last page lists itself as next page while True : response = self . _request ( url , params ) for item in response [ 'result_data' ] : yield item # Last page lists itself as next page if response [ 'service_meta' ] [ 'next_page_number' ] == params [ 'page_number' ] : break params [ 'page_number' ] += 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extracts list of subwords from file . [CODESPLIT] def load_from_file ( cls , filename_prefix ) : filename = cls . _filename ( filename_prefix ) lines , _ = cls . _read_lines_from_file ( filename ) # Strip wrapping single quotes vocab_list = [ line [ 1 : - 1 ] for line in lines ] return cls ( vocab_list = vocab_list )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pull the value from the cookiejar . [CODESPLIT] def parse_cookies ( self , req , name , field ) : return core . get_value ( req . COOKIES , name , field )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the indices of all the val in m [CODESPLIT] def index ( m , val ) : mm = np . array ( m ) idx_tuple = np . where ( mm == val ) idx = idx_tuple [ 0 ] . tolist ( ) return idx", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a list of the data types for each column in * data * . [CODESPLIT] def _get_column_types ( self , data ) : columns = list ( zip_longest ( * data ) ) return [ self . _get_column_type ( column ) for column in columns ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the type of obj as a string . More descriptive and specific than type ( obj ) and safe for any object unlike __class__ . [CODESPLIT] def typename ( obj ) : if hasattr ( obj , '__class__' ) : return getattr ( obj , '__class__' ) . __name__ else : return type ( obj ) . __name__", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the given command ( with shell = False ) and return a tuple of ( int returncode str output ) . Strip the output of enclosing whitespace . [CODESPLIT] def call_out ( command ) : # start external command process p = subprocess . Popen ( command , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) # get outputs out , _ = p . communicate ( ) return p . returncode , out . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print the given item and all children items [CODESPLIT] def print_item_with_children ( ac , classes , level ) : print_row ( ac . id , ac . name , f\"{ac.allocation:,.2f}\" , level ) print_children_recursively ( classes , ac , level + 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Register callbacks for button press events and selection changed [CODESPLIT] def register_view ( self , view ) : super ( ListViewController , self ) . register_view ( view ) self . tree_view . connect ( 'button_press_event' , self . mouse_click )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rewind the file to the start of the body ( if seekable ) . [CODESPLIT] def rewindbody ( self ) : if not self . seekable : raise IOError , \"unseekable file\" self . fp . seek ( self . startofbody )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Round a float to a precision [CODESPLIT] def round_to_float ( number , precision ) : rounded = Decimal ( str ( floor ( ( number + precision / 2 ) // precision ) ) ) * Decimal ( str ( precision ) ) return float ( rounded )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function for fast reading from sensor files . [CODESPLIT] def _fast_read ( self , infile ) : infile . seek ( 0 ) return ( int ( infile . read ( ) . decode ( ) . strip ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the * cmd * and exit with the proper exit code . [CODESPLIT] def call_and_exit ( self , cmd , shell = True ) : sys . exit ( subprocess . call ( cmd , shell = shell ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read tag data from file and return as numpy array . [CODESPLIT] def read_numpy ( fd , byte_order , dtype , count ) : return numpy . fromfile ( fd , byte_order + dtype [ - 1 ] , count )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to unpickle data from picklefile . [CODESPLIT] def unpickle_file ( picklefile , * * kwargs ) : with open ( picklefile , 'rb' ) as f : return pickle . load ( f , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute the unit tests on an installed copy of unyt . [CODESPLIT] def test ( ) : # pragma: no cover import pytest import os pytest . main ( [ os . path . dirname ( os . path . abspath ( __file__ ) ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts html content to plain text [CODESPLIT] def html_to_text ( content ) : text = None h2t = html2text . HTML2Text ( ) h2t . ignore_links = False text = h2t . handle ( content ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adapts a Numpy array into an ARRAY string to put into the database . [CODESPLIT] def adapt_array ( arr ) : out = io . BytesIO ( ) np . save ( out , arr ) , out . seek ( 0 ) return buffer ( out . read ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Not meant to be used directly use : meth : Instaloader . save_session_to_file . [CODESPLIT] def save_session_to_file ( self , sessionfile ) : pickle . dump ( requests . utils . dict_from_cookiejar ( self . _session . cookies ) , sessionfile )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove instance from instance list [CODESPLIT] def pop ( ) : pid = os . getpid ( ) thread = threading . current_thread ( ) Wdb . _instances . pop ( ( pid , thread ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a copy of the list without duplicates . [CODESPLIT] def unique ( list ) : unique = [ ] [ unique . append ( x ) for x in list if x not in unique ] return unique", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Because standard distinct used on the all fields are very slow and works only with PostgreSQL database this method provides alternative to the standard distinct method . : return : qs with unique objects [CODESPLIT] def fast_distinct ( self ) : return self . model . objects . filter ( pk__in = self . values_list ( 'pk' , flat = True ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convenience method that works with all 2 . x versions of Python to determine whether or not something is stringlike . [CODESPLIT] def isString ( s ) : try : return isinstance ( s , unicode ) or isinstance ( s , basestring ) except NameError : return isinstance ( s , str )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove duplicates from a sequence preserving order [CODESPLIT] def remove_dups ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ajoute la target au plot [CODESPLIT] def plot_target ( target , ax ) : ax . scatter ( target [ 0 ] , target [ 1 ] , target [ 2 ] , c = \"red\" , s = 80 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete an S3 bucket [CODESPLIT] def delete_s3_bucket ( client , resource ) : if dbconfig . get ( 'enable_delete_s3_buckets' , NS_AUDITOR_REQUIRED_TAGS , False ) : client . delete_bucket ( Bucket = resource . id ) return ActionStatus . SUCCEED , resource . metrics ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a object into dictionary with all of its readable attributes . [CODESPLIT] def dict_from_object ( obj : object ) : # If object is a dict instance, no need to convert. return ( obj if isinstance ( obj , dict ) else { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( '_' ) } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform log transform log ( x + 1 ) . Parameters ---------- data : array_like [CODESPLIT] def log_normalize ( data ) : if sp . issparse ( data ) : data = data . copy ( ) data . data = np . log2 ( data . data + 1 ) return data return np . log2 ( data . astype ( np . float64 ) + 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add data to send queue . [CODESPLIT] async def send ( self , data ) : self . writer . write ( data ) await self . writer . drain ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resets the iterator to the start . [CODESPLIT] def reset ( self ) : self . __iterator , self . __saved = itertools . tee ( self . __saved )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes the specified function s MethodWrapper from the added_methods list so we don t re - bind it when making a clone . [CODESPLIT] def RemoveMethod ( self , function ) : self . added_methods = [ dm for dm in self . added_methods if not dm . method is function ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "\\ returns the bytes of the image file on disk [CODESPLIT] def get_local_image ( self , src ) : return ImageUtils . store_image ( self . fetcher , self . article . link_hash , src , self . config )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "rotates a 2d array to a multiple of 90 deg . 0 = default 1 = 90 deg . cw 2 = 180 deg . 3 = 90 deg . ccw [CODESPLIT] def rotateImage ( image , angle ) : image = [ list ( row ) for row in image ] for n in range ( angle % 4 ) : image = list ( zip ( * image [ : : - 1 ] ) ) return image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "rotates a 2d array to a multiple of 90 deg . 0 = default 1 = 90 deg . cw 2 = 180 deg . 3 = 90 deg . ccw [CODESPLIT] def rotateImage ( image , angle ) : image = [ list ( row ) for row in image ] for n in range ( angle % 4 ) : image = list ( zip ( * image [ : : - 1 ] ) ) return image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "round the data [CODESPLIT] def round_data ( filter_data ) : for index , _ in enumerate ( filter_data ) : filter_data [ index ] [ 0 ] = round ( filter_data [ index ] [ 0 ] / 100.0 ) * 100.0 return filter_data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return sha1 for contents of filename . [CODESPLIT] def _sha1_for_file ( filename ) : with open ( filename , \"rb\" ) as fileobj : contents = fileobj . read ( ) return hashlib . sha1 ( contents ) . hexdigest ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Any normal python logic which runs a loop . Can take arguments . [CODESPLIT] def main ( idle ) : while True : LOG . debug ( \"Sleeping for {0} seconds.\" . format ( idle ) ) time . sleep ( idle )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Example of function for token update [CODESPLIT] def update_token_tempfile ( token ) : with open ( tmp , 'w' ) as f : f . write ( json . dumps ( token , indent = 4 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Instanciate a singleton per scope . [CODESPLIT] def singleton_per_scope ( _cls , _scope = None , _renew = False , * args , * * kwargs ) : result = None singletons = SINGLETONS_PER_SCOPES . setdefault ( _scope , { } ) if _renew or _cls not in singletons : singletons [ _cls ] = _cls ( * args , * * kwargs ) result = singletons [ _cls ] return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "For internal compatibility with with the Index API . [CODESPLIT] def sortlevel ( self , level = None , ascending = True , sort_remaining = None ) : return self . sort_values ( return_indexer = True , ascending = ascending )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the default value of param_name . [CODESPLIT] def set_default ( self_ , param_name , value ) : cls = self_ . cls setattr ( cls , param_name , value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility function which converts lists to tuples . [CODESPLIT] def as_tuple ( self , value ) : if isinstance ( value , list ) : value = tuple ( value ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write the given colored string to standard out . [CODESPLIT] def write_color ( string , name , style = 'normal' , when = 'auto' ) : write ( color ( string , name , style , when ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse identifier such as a|c|le|d|li|re|or|AT4G00480 . 1 and return tuple of prefix string ( separated at | ) and suffix ( AGI identifier ) [CODESPLIT] def parse_prefix ( identifier ) : pf , id = ( ) , identifier if \"|\" in identifier : pf , id = tuple ( identifier . split ( '|' ) [ : - 1 ] ) , identifier . split ( '|' ) [ - 1 ] return pf , id", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert string to int or float . [CODESPLIT] def covstr ( s ) : try : ret = int ( s ) except ValueError : ret = float ( s ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete credentials from the SQLAlchemy datastore . [CODESPLIT] def locked_delete ( self ) : filters = { self . key_name : self . key_value } self . session . query ( self . model_class ) . filter_by ( * * filters ) . delete ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Unpacks sqlite rows as returned by fetchall into an array of simple dicts . [CODESPLIT] def sqliteRowsToDicts ( sqliteRows ) : return map ( lambda r : dict ( zip ( r . keys ( ) , r ) ) , sqliteRows )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Softsign op . [CODESPLIT] def Softsign ( a ) : return np . divide ( a , np . add ( np . abs ( a ) , 1 ) ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a total and a progress position output a progress bar to stderr . It is important to not output anything else while using this as it relies soley on the behavior of carriage return ( \\\\ r ) . [CODESPLIT] def progressbar ( total , pos , msg = \"\" ) : width = get_terminal_size ( ) [ 0 ] - 40 rel_pos = int ( float ( pos ) / total * width ) bar = '' . join ( [ \"=\" * rel_pos , \".\" * ( width - rel_pos ) ] ) # Determine how many digits in total (base 10) digits_total = len ( str ( total ) ) fmt_width = \"%0\" + str ( digits_total ) + \"d\" fmt = \"\\r[\" + fmt_width + \"/\" + fmt_width + \"][%s] %s\" progress_stream . write ( fmt % ( pos , total , bar , msg ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Display Bloch sphere and corresponding data sets . [CODESPLIT] def show ( self , title = '' ) : self . render ( title = title ) if self . fig : plt . show ( self . fig )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform column - stacking on a list of 2d data blocks . [CODESPLIT] def column_stack_2d ( data ) : return list ( list ( itt . chain . from_iterable ( _ ) ) for _ in zip ( * data ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "print node and edge statistics of a document graph [CODESPLIT] def info ( docgraph ) : print networkx . info ( docgraph ) , '\\n' node_statistics ( docgraph ) print edge_statistics ( docgraph )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute standard deviation with ddof degrees of freedom [CODESPLIT] def _std ( self , x ) : return np . nanstd ( x . values , ddof = self . _ddof )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Circular standard deviation [CODESPLIT] def circstd ( dts , axis = 2 ) : R = np . abs ( np . exp ( 1.0j * dts ) . mean ( axis = axis ) ) return np . sqrt ( - 2.0 * np . log ( R ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clears the default matplotlib ticks . [CODESPLIT] def clear_matplotlib_ticks ( self , axis = \"both\" ) : ax = self . get_axes ( ) plotting . clear_matplotlib_ticks ( ax = ax , axis = axis )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shuffle the data . [CODESPLIT] def _shuffle ( data , idx ) : shuffle_data = [ ] for idx_k , idx_v in data : shuffle_data . append ( ( idx_k , mx . ndarray . array ( idx_v . asnumpy ( ) [ idx ] , idx_v . context ) ) ) return shuffle_data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Writes the string to stdout [CODESPLIT] def _stdout_raw ( self , s ) : print ( s , end = '' , file = sys . stdout ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A tensorflow variable tranfomed to be constrained in a L2 unit ball . [CODESPLIT] def unit_ball_L2 ( shape ) : x = tf . Variable ( tf . zeros ( shape ) ) return constrain_L2 ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def smooth_array ( array , amount = 1 ) : if amount == 0 : return array # we have to store the old values in a temp array to keep the # smoothing from affecting the smoothing new_array = _n . array ( array ) for n in range ( len ( array ) ) : new_array [ n ] = smooth ( array , n , amount ) return new_array", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Use the S3 SWAG backend . [CODESPLIT] def s3 ( ctx , bucket_name , data_file , region ) : if not ctx . data_file : ctx . data_file = data_file if not ctx . bucket_name : ctx . bucket_name = bucket_name if not ctx . region : ctx . region = region ctx . type = 's3'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sort list elements by name . [CODESPLIT] def sort_by_name ( self ) : super ( JSSObjectList , self ) . sort ( key = lambda k : k . name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function for margin - based loss . Return a distance matrix given a matrix . [CODESPLIT] def get_distance ( F , x ) : n = x . shape [ 0 ] square = F . sum ( x ** 2.0 , axis = 1 , keepdims = True ) distance_square = square + square . transpose ( ) - ( 2.0 * F . dot ( x , x . transpose ( ) ) ) # Adding identity to make sqrt work. return F . sqrt ( distance_square + F . array ( np . identity ( n ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert dict of ascii str / unicode to dict of str if necessary [CODESPLIT] def str_dict ( some_dict ) : return { str ( k ) : str ( v ) for k , v in some_dict . items ( ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Chunk one big list into few small lists . [CODESPLIT] def chunked ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a text into separate words . [CODESPLIT] def tokenize_list ( self , text ) : return [ self . get_record_token ( record ) for record in self . analyze ( text ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper method that escapes parameters to a SQL query . [CODESPLIT] def _escape ( s ) : e = s e = e . replace ( '\\\\' , '\\\\\\\\' ) e = e . replace ( '\\n' , '\\\\n' ) e = e . replace ( '\\r' , '\\\\r' ) e = e . replace ( \"'\" , \"\\\\'\" ) e = e . replace ( '\"' , '\\\\\"' ) return e", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts an ARRAY string stored in the database back into a Numpy array . [CODESPLIT] def convert_array ( array ) : out = io . BytesIO ( array ) out . seek ( 0 ) return np . load ( out )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Executes a ( shell ) command in the background [CODESPLIT] def execute_in_background ( self ) : # http://stackoverflow.com/questions/1605520 args = shlex . split ( self . cmd ) p = Popen ( args ) return p . pid", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Communicate with the child process without closing stdin . [CODESPLIT] def correspond ( text ) : subproc . stdin . write ( text ) subproc . stdin . flush ( ) return drain ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if a file is empty or not . [CODESPLIT] def file_empty ( fp ) : # for python 2 we need to use a homemade peek() if six . PY2 : contents = fp . read ( ) fp . seek ( 0 ) return not bool ( contents ) else : return not fp . peek ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert numpy s datetime64 to datetime [CODESPLIT] def datetime64_to_datetime ( dt ) : dt64 = np . datetime64 ( dt ) ts = ( dt64 - np . datetime64 ( '1970-01-01T00:00:00' ) ) / np . timedelta64 ( 1 , 's' ) return datetime . datetime . utcfromtimestamp ( ts )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is the user a system administrator [CODESPLIT] def is_admin ( self ) : return self . role == self . roles . administrator . value and self . state == State . approved", "target": 1, "target_options": ["no_match", "match"]}
{"input": "DEBUG FUNC modify argv to look like you ran a command [CODESPLIT] def aug_sysargv ( cmdstr ) : import shlex argv = shlex . split ( cmdstr ) sys . argv . extend ( argv )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determines if a list is sorted [CODESPLIT] def issorted ( list_ , op = operator . le ) : return all ( op ( list_ [ ix ] , list_ [ ix + 1 ] ) for ix in range ( len ( list_ ) - 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run a Tensorflow model on the Iris dataset . [CODESPLIT] def main ( argv = None ) : args = parse_arguments ( sys . argv if argv is None else argv ) tf . logging . set_verbosity ( tf . logging . INFO ) learn_runner . run ( experiment_fn = get_experiment_fn ( args ) , output_dir = args . job_dir )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the absolute position of table top [CODESPLIT] def table_top_abs ( self ) : table_height = np . array ( [ 0 , 0 , self . table_full_size [ 2 ] ] ) return string_to_array ( self . floor . get ( \"pos\" ) ) + table_height", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts the given slice key to start and size query parts . [CODESPLIT] def make_slice_strings ( cls , slice_key ) : start = slice_key . start size = slice_key . stop - start return ( str ( start ) , str ( size ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return whether an object is a path . [CODESPLIT] def _is_path ( s ) : if isinstance ( s , string_types ) : try : return op . exists ( s ) except ( OSError , ValueError ) : return False else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Properly handle the potential + Inf db SIR instead of raising a RuntimeWarning . [CODESPLIT] def _safe_db ( num , den ) : if den == 0 : return np . inf return 10 * np . log10 ( num / den )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes in an object and a variable length amount of named attributes and checks to see if the object has each property . If any of the attributes are missing this returns false . [CODESPLIT] def hasattrs ( object , * names ) : for name in names : if not hasattr ( object , name ) : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a spec to a mock . spec can either be an object or a list of strings . Only attributes on the spec can be fetched as attributes from the mock . [CODESPLIT] def mock_add_spec ( self , spec , spec_set = False ) : self . _mock_add_spec ( spec , spec_set ) self . _mock_set_magics ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run application tests [CODESPLIT] def test ( nose_argsuments ) : from nose import run params = [ '__main__' , '-c' , 'nose.ini' ] params . extend ( nose_argsuments ) run ( argv = params )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Hparams for machine translation with ~1 . 1B parameters . [CODESPLIT] def transformer_tpu_1b ( ) : hparams = transformer_tpu ( ) hparams . hidden_size = 2048 hparams . filter_size = 8192 hparams . num_hidden_layers = 8 # smaller batch size to avoid OOM hparams . batch_size = 1024 hparams . activation_dtype = \"bfloat16\" hparams . weight_dtype = \"bfloat16\" # maximize number of parameters relative to computation by not sharing. hparams . shared_embedding_and_softmax_weights = False return hparams", "target": 1, "target_options": ["no_match", "match"]}
{"input": "write the html file contents to disk [CODESPLIT] def _save_file ( self , filename , contents ) : with open ( filename , 'w' ) as f : f . write ( contents )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Get the real or imaginary part of a complex number . [CODESPLIT] def part ( z , s ) : if sage_included : if s == 1 : return np . real ( z ) elif s == - 1 : return np . imag ( z ) elif s == 0 : return z else : if s == 1 : return z . real elif s == - 1 : return z . imag elif s == 0 : return z", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract the content of the zip - file at zip_path into target_folder . [CODESPLIT] def extract_zip ( zip_path , target_folder ) : with zipfile . ZipFile ( zip_path ) as archive : archive . extractall ( target_folder )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Autoconnect slot activated when tbSourceDir is clicked . [CODESPLIT] def on_source_directory_chooser_clicked ( self ) : title = self . tr ( 'Set the source directory for script and scenario' ) self . choose_directory ( self . source_directory , title )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calls the provided callable on the provided attribute of obj if it is defined . [CODESPLIT] def call_on_if_def ( obj , attr_name , callable , default , * args , * * kwargs ) : try : attr = getattr ( obj , attr_name ) except AttributeError : return default else : return callable ( attr , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the folder exisits . If not create the folder [CODESPLIT] def check_create_folder ( filename ) : os . makedirs ( os . path . dirname ( filename ) , exist_ok = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Restoring scrollbar position after main window is visible [CODESPLIT] def restore_scrollbar_position ( self ) : scrollbar_pos = self . get_option ( 'scrollbar_position' , None ) if scrollbar_pos is not None : self . explorer . treewidget . set_scrollbar_position ( scrollbar_pos )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Security check complete . Log the user in . [CODESPLIT] def form_valid ( self , form ) : auth_login ( self . request , form . get_user ( ) ) return HttpResponseRedirect ( self . get_success_url ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalizes list [CODESPLIT] def normalize_array ( lst ) : np_arr = np . array ( lst ) x_normalized = np_arr / np_arr . max ( axis = 0 ) return list ( x_normalized )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts bokehJS timestamp to datetime64 . [CODESPLIT] def convert_timestamp ( timestamp ) : datetime = dt . datetime . utcfromtimestamp ( timestamp / 1000. ) return np . datetime64 ( datetime . replace ( tzinfo = None ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "given a segment ( rectangle ) and an image returns it s corresponding subimage [CODESPLIT] def region_from_segment ( image , segment ) : x , y , w , h = segment return image [ y : y + h , x : x + w ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "sets the aspect ratio of the current zoom level of the imshow image [CODESPLIT] def image_set_aspect ( aspect = 1.0 , axes = \"gca\" ) : if axes is \"gca\" : axes = _pylab . gca ( ) e = axes . get_images ( ) [ 0 ] . get_extent ( ) axes . set_aspect ( abs ( ( e [ 1 ] - e [ 0 ] ) / ( e [ 3 ] - e [ 2 ] ) ) / aspect )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "swap and then flatten axes 0 and 1 [CODESPLIT] def sf01 ( arr ) : s = arr . shape return arr . swapaxes ( 0 , 1 ) . reshape ( s [ 0 ] * s [ 1 ] , * s [ 2 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a re . match object if an empty comment was found on line . [CODESPLIT] def _match_space_at_line ( line ) : regex = re . compile ( r\"^{0}$\" . format ( _MDL_COMMENT ) ) return regex . match ( line )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": type root : TreeNode : rtype : int [CODESPLIT] def min_depth ( self , root ) : if root is None : return 0 if root . left is not None or root . right is not None : return max ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1 return min ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Use the S3 SWAG backend . [CODESPLIT] def s3 ( ctx , bucket_name , data_file , region ) : if not ctx . data_file : ctx . data_file = data_file if not ctx . bucket_name : ctx . bucket_name = bucket_name if not ctx . region : ctx . region = region ctx . type = 's3'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Matches a paren . [CODESPLIT] def match_paren ( self , tokens , item ) : match , = tokens return self . match ( match , item )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return the raw value that this property is holding internally for instance [CODESPLIT] def fval ( self , instance ) : try : val = instance . __dict__ [ self . instance_field_name ] except KeyError as e : #raise AttributeError(str(e)) val = None return val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retries function until it doesn t raise an EINTR error [CODESPLIT] def retry_on_signal ( function ) : while True : try : return function ( ) except EnvironmentError , e : if e . errno != errno . EINTR : raise", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a repr () for a list / tuple [CODESPLIT] def _tuple_repr ( data ) : if len ( data ) == 1 : return \"(%s,)\" % rpr ( data [ 0 ] ) else : return \"(%s)\" % \", \" . join ( [ rpr ( x ) for x in data ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a one - hot encoded array back to string [CODESPLIT] def one_hot2string ( arr , vocab ) : tokens = one_hot2token ( arr ) indexToLetter = _get_index_dict ( vocab ) return [ '' . join ( [ indexToLetter [ x ] for x in row ] ) for row in tokens ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uniformly format a path . [CODESPLIT] def fixpath ( path ) : return os . path . normpath ( os . path . realpath ( os . path . expanduser ( path ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper for iterating numpy array [CODESPLIT] def _npiter ( arr ) : for a in np . nditer ( arr , flags = [ \"refs_ok\" ] ) : c = a . item ( ) if c is not None : yield c", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of indexes of substr . If substr not found list is empty . [CODESPLIT] def get_substring_idxs ( substr , string ) : return [ match . start ( ) for match in re . finditer ( substr , string ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if value is an instance or subclass of the class Type . [CODESPLIT] def is_type ( value ) : if isinstance ( value , type ) : return issubclass ( value , Type ) return isinstance ( value , Type )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run wireshark on a list of packets [CODESPLIT] def wireshark ( pktlist , * args ) : fname = get_temp_file ( ) wrpcap ( fname , pktlist ) subprocess . Popen ( [ conf . prog . wireshark , \"-r\" , fname ] + list ( args ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run Python test cases against Java runtime classes . [CODESPLIT] def test_python_java_rt ( ) : sub_env = { 'PYTHONPATH' : _build_dir ( ) } log . info ( 'Executing Python unit tests (against Java runtime classes)...' ) return jpyutil . _execute_python_scripts ( python_java_rt_tests , env = sub_env )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Note that this code compresses into a buffer held in memory rather than a disk file . This is done through the use of cStringIO . StringIO () . [CODESPLIT] def compressBuffer ( buffer ) : # http://jython.xhaus.com/http-compression-in-python-and-jython/ zbuf = cStringIO . StringIO ( ) zfile = gzip . GzipFile ( mode = 'wb' , fileobj = zbuf , compresslevel = 9 ) zfile . write ( buffer ) zfile . close ( ) return zbuf . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run Python test cases against Java runtime classes . [CODESPLIT] def test_python_java_rt ( ) : sub_env = { 'PYTHONPATH' : _build_dir ( ) } log . info ( 'Executing Python unit tests (against Java runtime classes)...' ) return jpyutil . _execute_python_scripts ( python_java_rt_tests , env = sub_env )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Imports from javascript source file . globals is your globals () [CODESPLIT] def import_js ( path , lib_name , globals ) : with codecs . open ( path_as_local ( path ) , \"r\" , \"utf-8\" ) as f : js = f . read ( ) e = EvalJs ( ) e . execute ( js ) var = e . context [ 'var' ] globals [ lib_name ] = var . to_python ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The full remote import path as used in import statements in . go source files . [CODESPLIT] def import_path ( self ) : return os . path . join ( self . remote_root , self . pkg ) if self . pkg else self . remote_root", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a value or list of values and returns a single result joined by if necessary . [CODESPLIT] def vectorize ( values ) : if isinstance ( values , list ) : return ',' . join ( str ( v ) for v in values ) return values", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update the dev_info data from a dictionary . [CODESPLIT] def update ( self , params ) : dev_info = self . json_state . get ( 'deviceInfo' ) dev_info . update ( { k : params [ k ] for k in params if dev_info . get ( k ) } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Stop the current task process . [CODESPLIT] async def stop ( self ) : # negate pid so that signals apply to process group pgid = - self . process . pid try : os . kill ( pgid , signal . SIGTERM ) await asyncio . sleep ( 1 ) os . kill ( pgid , signal . SIGKILL ) except ( OSError , ProcessLookupError ) : return", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Escape a URL including any / . [CODESPLIT] def escape ( s ) : if not isinstance ( s , bytes ) : s = s . encode ( 'utf-8' ) return quote ( s , safe = '~' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clean up processes after SIGTERM or SIGINT is received . [CODESPLIT] def cleanup_storage ( * args ) : ShardedClusters ( ) . cleanup ( ) ReplicaSets ( ) . cleanup ( ) Servers ( ) . cleanup ( ) sys . exit ( 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a dictionary from a URL params [CODESPLIT] def get_url_args ( url ) : url_data = urllib . parse . urlparse ( url ) arg_dict = urllib . parse . parse_qs ( url_data . query ) return arg_dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Kill all running processes . [CODESPLIT] def kill_all ( self , kill_signal , kill_shell = False ) : for key in self . processes . keys ( ) : self . kill_process ( key , kill_signal , kill_shell )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a UUID . [CODESPLIT] def generate_uuid ( ) : r_uuid = base64 . urlsafe_b64encode ( uuid . uuid4 ( ) . bytes ) return r_uuid . decode ( ) . replace ( '=' , '' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Hack to get IP address from the interface [CODESPLIT] def get_ip_address ( ifname ) : s = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) return socket . inet_ntoa ( fcntl . ioctl ( s . fileno ( ) , 0x8915 , # SIOCGIFADDR struct . pack ( '256s' , ifname [ : 15 ] ) ) [ 20 : 24 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if the input data is a Swagger document [CODESPLIT] def is_valid ( data ) : return bool ( data ) and isinstance ( data , dict ) and bool ( data . get ( \"swagger\" ) ) and isinstance ( data . get ( 'paths' ) , dict )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a property of the device . [CODESPLIT] def getprop ( self , prop_name ) : return self . shell ( [ 'getprop' , prop_name ] , timeout = DEFAULT_GETPROP_TIMEOUT_SEC ) . decode ( 'utf-8' ) . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns json contents as string [CODESPLIT] def open_json ( file_name ) : with open ( file_name , \"r\" ) as json_data : data = json . load ( json_data ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the dot product of two vectors [CODESPLIT] def dot_v2 ( vec1 , vec2 ) : return vec1 . x * vec2 . x + vec1 . y * vec2 . y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generalised logarithm [CODESPLIT] def glog ( x , l = 2 ) : return np . log ( ( x + np . sqrt ( x ** 2 + l ** 2 ) ) / 2 ) / np . log ( l )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the viewable size of the Table as [CODESPLIT] def size ( self ) : width = max ( map ( lambda x : x . size ( ) [ 0 ] , self . sections . itervalues ( ) ) ) height = sum ( map ( lambda x : x . size ( ) [ 1 ] , self . sections . itervalues ( ) ) ) return width , height", "target": 1, "target_options": ["no_match", "match"]}
{"input": "world coords to view coords ; v an eu . Vector2 returns ( float float ) [CODESPLIT] def world_to_view ( v ) : return v . x * config . scale_x , v . y * config . scale_y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Disable virtualenv and venv in the environment . [CODESPLIT] def _disable_venv ( self , env ) : venv = env . pop ( 'VIRTUAL_ENV' , None ) if venv : venv_path , sep , env [ 'PATH' ] = env [ 'PATH' ] . partition ( os . pathsep )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Solution found here : http : // stackoverflow . com / questions / 480214 / how - do - you - remove - duplicates - from - a - list - in - python - whilst - preserving - order [CODESPLIT] def unique_everseen ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Submit the form matching the CSS selector . [CODESPLIT] def submit_by_selector ( self , selector ) : elem = find_element_by_jquery ( world . browser , selector ) elem . submit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a list of ( key value ) pairs and turns it into a dict . [CODESPLIT] def list2dict ( lst ) : dic = { } for k , v in lst : dic [ k ] = v return dic", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a web driver if mobile . [CODESPLIT] def is_webdriver_ios ( webdriver ) : browser = webdriver . capabilities [ 'browserName' ] if ( browser == u ( 'iPhone' ) or browser == u ( 'iPad' ) ) : return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a background thread for httpd and serve forever [CODESPLIT] def start ( self ) : self . _process = threading . Thread ( target = self . _background_runner ) self . _process . start ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Packs a list of triple indexes into a 2D numpy array . [CODESPLIT] def pack_triples_numpy ( triples ) : if len ( triples ) == 0 : return np . array ( [ ] , dtype = np . int64 ) return np . stack ( list ( map ( _transform_triple_numpy , triples ) ) , axis = 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Callback for closing the websocket connection [CODESPLIT] def _ws_on_close ( self , ws : websocket . WebSocketApp ) : self . connected = False self . logger . error ( 'Websocket closed' ) self . _reconnect_websocket ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Makes a classname [CODESPLIT] def classnameify ( s ) : return '' . join ( w if w in ACRONYMS else w . title ( ) for w in s . split ( '_' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show a basic reference about the GUI Console . [CODESPLIT] def page_guiref ( arg_s = None ) : from IPython . core import page page . page ( gui_reference , auto_html = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write the ROI model to a FITS file . [CODESPLIT] def write_fits ( self , fitsfile ) : tab = self . create_table ( ) hdu_data = fits . table_to_hdu ( tab ) hdus = [ fits . PrimaryHDU ( ) , hdu_data ] fits_utils . write_hdus ( hdus , fitsfile )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove text nodes containing only whitespace [CODESPLIT] def cleanup_nodes ( doc ) : for node in doc . documentElement . childNodes : if node . nodeType == Node . TEXT_NODE and node . nodeValue . isspace ( ) : doc . documentElement . removeChild ( node ) return doc", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This method validate the parsing and schema return a boolean [CODESPLIT] def validate ( self , xml_input ) : parsed_xml = etree . parse ( self . _handle_xml ( xml_input ) ) try : return self . xmlschema . validate ( parsed_xml ) except AttributeError : raise CannotValidate ( 'Set XSD to validate the XML' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the top - level element of a document sub - tree containing the YAML serialization of a Python object . [CODESPLIT] def yaml_to_param ( obj , name ) : return from_pyvalue ( u\"yaml:%s\" % name , unicode ( yaml . dump ( obj ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Maxheap version of a heappop . [CODESPLIT] def heappop_max ( heap ) : lastelt = heap . pop ( ) # raises appropriate IndexError if heap is empty if heap : returnitem = heap [ 0 ] heap [ 0 ] = lastelt _siftup_max ( heap , 0 ) return returnitem return lastelt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Stable implementation of the softmax function . [CODESPLIT] def softmax ( xs ) : ys = xs - np . max ( xs ) exps = np . exp ( ys ) return exps / exps . sum ( axis = 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract the content of the zip - file at zip_path into target_folder . [CODESPLIT] def extract_zip ( zip_path , target_folder ) : with zipfile . ZipFile ( zip_path ) as archive : archive . extractall ( target_folder )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a gzipped stream of data yield streams of decompressed data . [CODESPLIT] def load_streams ( chunks ) : chunks = peekable ( chunks ) while chunks : if six . PY3 : dc = zlib . decompressobj ( wbits = zlib . MAX_WBITS | 16 ) else : dc = zlib . decompressobj ( zlib . MAX_WBITS | 16 ) yield load_stream ( dc , chunks ) if dc . unused_data : chunks = peekable ( itertools . chain ( ( dc . unused_data , ) , chunks ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets the median of a list of values Returns a float / int [CODESPLIT] def getMedian ( numericValues ) : theValues = sorted ( numericValues ) if len ( theValues ) % 2 == 1 : return theValues [ ( len ( theValues ) + 1 ) / 2 - 1 ] else : lower = theValues [ len ( theValues ) / 2 - 1 ] upper = theValues [ len ( theValues ) / 2 ] return ( float ( lower + upper ) ) / 2", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take the union of a list of lists . [CODESPLIT] def listunion ( ListOfLists ) : u = [ ] for s in ListOfLists : if s != None : u . extend ( s ) return u", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Will make any functions return an iterable objects by wrapping its result in a list . [CODESPLIT] def force_iterable ( f ) : def wrapper ( * args , * * kwargs ) : r = f ( * args , * * kwargs ) if hasattr ( r , '__iter__' ) : return r else : return [ r ] return wrapper", "target": 1, "target_options": ["no_match", "match"]}
{"input": "merge two dictionaries [CODESPLIT] def dictmerge ( x , y ) : z = x . copy ( ) z . update ( y ) return z", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper for pymongo . update_one () : param db : db connection : param collection : collection to update : param object : the modifications to apply : param match_params : a query that matches the documents to update : return : id of updated document [CODESPLIT] def upsert_single ( db , collection , object , match_params = None ) : return str ( db [ collection ] . update_one ( match_params , { \"$set\" : object } , upsert = True ) . upserted_id )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the name of the newest file given an iterable of file names . [CODESPLIT] def newest_file ( file_iterable ) : return max ( file_iterable , key = lambda fname : os . path . getmtime ( fname ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Moving average over one - dimensional array . [CODESPLIT] def moving_average ( a , n ) : ret = np . cumsum ( a , dtype = float ) ret [ n : ] = ret [ n : ] - ret [ : - n ] return ret [ n - 1 : ] / n", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Go to parent directory [CODESPLIT] def go_to_parent_directory ( self ) : self . chdir ( osp . abspath ( osp . join ( getcwd_or_home ( ) , os . pardir ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Matches a paren . [CODESPLIT] def match_paren ( self , tokens , item ) : match , = tokens return self . match ( match , item )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initializes a rotating logger [CODESPLIT] def init_rotating_logger ( level , logfile , max_files , max_bytes ) : logging . basicConfig ( ) root_logger = logging . getLogger ( ) log_format = \"[%(asctime)s] [%(levelname)s] %(filename)s: %(message)s\" root_logger . setLevel ( level ) handler = RotatingFileHandler ( logfile , maxBytes = max_bytes , backupCount = max_files ) handler . setFormatter ( logging . Formatter ( fmt = log_format , datefmt = date_format ) ) root_logger . addHandler ( handler ) for handler in root_logger . handlers : root_logger . debug ( \"Associated handlers - \" + str ( handler ) ) if isinstance ( handler , logging . StreamHandler ) : root_logger . debug ( \"Removing StreamHandler: \" + str ( handler ) ) root_logger . handlers . remove ( handler )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write text . An additional attribute terminator with a value of None is added to the logging record to indicate that StreamHandler should not add a newline . [CODESPLIT] def write ( self , text ) : self . logger . log ( self . loglevel , text , extra = { 'terminator' : None } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The function is mostly useful for commands that update the database : any result set returned by the query is discarded . [CODESPLIT] def _executemany ( self , cursor , query , parameters ) : try : self . _log ( query ) cursor . executemany ( query , parameters ) except OperationalError as e : # pragma: no cover logging . error ( 'Error connecting to PostgreSQL on %s, e' , self . host , e ) self . close ( ) raise", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a string from a file - like object . [CODESPLIT] def read_string ( buff , byteorder = 'big' ) : length = read_numeric ( USHORT , buff , byteorder ) return buff . read ( length ) . decode ( 'utf-8' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return a normalized version of abmn [CODESPLIT] def _normalize_abmn ( abmn ) : abmn_2d = np . atleast_2d ( abmn ) abmn_normalized = np . hstack ( ( np . sort ( abmn_2d [ : , 0 : 2 ] , axis = 1 ) , np . sort ( abmn_2d [ : , 2 : 4 ] , axis = 1 ) , ) ) return abmn_normalized", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reverse the normalization done to a batch of images . [CODESPLIT] def denorm ( self , arr ) : if type ( arr ) is not np . ndarray : arr = to_np ( arr ) if len ( arr . shape ) == 3 : arr = arr [ None ] return self . transform . denorm ( np . rollaxis ( arr , 1 , 4 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pick an unused port . There is a slight chance that this wont work . [CODESPLIT] def pick_unused_port ( self ) : s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . bind ( ( '127.0.0.1' , 0 ) ) _ , port = s . getsockname ( ) s . close ( ) return port", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine whether indicated file appears to be a gzipped FASTQ . [CODESPLIT] def is_gzipped_fastq ( file_name ) : _ , ext = os . path . splitext ( file_name ) return file_name . endswith ( \".fastq.gz\" ) or file_name . endswith ( \".fq.gz\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If Python 2 replace non - ascii characters and return encoded string . [CODESPLIT] def safe_unicode ( string ) : if not PY3 : uni = string . replace ( u'\\u2019' , \"'\" ) return uni . encode ( 'utf-8' ) return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a temporary filename based on filename . [CODESPLIT] def get_incomplete_path ( filename ) : random_suffix = \"\" . join ( random . choice ( string . ascii_uppercase + string . digits ) for _ in range ( 6 ) ) return filename + \".incomplete\" + random_suffix", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert ISO 8601 time format to datetime format [CODESPLIT] def iso_to_datetime ( date ) : chunks = list ( map ( int , date . split ( 'T' ) [ 0 ] . split ( '-' ) ) ) return datetime . datetime ( chunks [ 0 ] , chunks [ 1 ] , chunks [ 2 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "1x1 convolution [CODESPLIT] def conv1x1 ( in_planes , out_planes , stride = 1 ) : return nn . Conv2d ( in_planes , out_planes , kernel_size = 1 , stride = stride , bias = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Random uniform variates . [CODESPLIT] def runiform ( lower , upper , size = None ) : return np . random . uniform ( lower , upper , size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Overlaping of two intervals [CODESPLIT] def overlap ( intv1 , intv2 ) : return max ( 0 , min ( intv1 [ 1 ] , intv2 [ 1 ] ) - max ( intv1 [ 0 ] , intv2 [ 0 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "All values for this enum : return : list of tuples [CODESPLIT] def items ( cls ) : return [ cls . PRECIPITATION , cls . WIND , cls . TEMPERATURE , cls . PRESSURE ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Logs message to stderr if logging isn t initialized . [CODESPLIT] def log ( logger , level , message ) : if logger . parent . name != 'root' : logger . log ( level , message ) else : print ( message , file = sys . stderr )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param unicode fpath : : param unicode encoding : : rtype : dict | list [CODESPLIT] def load_jsonf ( fpath , encoding ) : with codecs . open ( fpath , encoding = encoding ) as f : return json . load ( f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Receive the content of url parse it as JSON and return the object . [CODESPLIT] def get_jsonparsed_data ( url ) : response = urlopen ( url ) data = response . read ( ) . decode ( 'utf-8' ) return json . loads ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Counts the word frequences in a list of sentences . [CODESPLIT] def count_words ( file ) : c = Counter ( ) with open ( file , 'r' ) as f : for l in f : words = l . strip ( ) . split ( ) c . update ( words ) return c", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The url of this window [CODESPLIT] def url ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . url", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a hdf5 file into a dictionary [CODESPLIT] def h5ToDict ( h5 , readH5pyDataset = True ) : h = h5py . File ( h5 , \"r\" ) ret = unwrapArray ( h , recursive = True , readH5pyDataset = readH5pyDataset ) if readH5pyDataset : h . close ( ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Centre and normalize a given array . [CODESPLIT] def min_max_normalize ( img ) : min_img = img . min ( ) max_img = img . max ( ) return ( img - min_img ) / ( max_img - min_img )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This loads a geojson file into a geojson python dictionary using the json module . Note : to load with a different text encoding use the encoding argument . [CODESPLIT] def _loadfilepath ( self , filepath , * * kwargs ) : with open ( filepath , \"r\" ) as f : data = json . load ( f , * * kwargs ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pull a querystring value from the request . [CODESPLIT] def parse_querystring ( self , req , name , field ) : return core . get_value ( req . args , name , field )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calls the specified Trigger of another Area with the optionally given parameters . [CODESPLIT] def trigger ( self , target : str , trigger : str , parameters : Dict [ str , Any ] = { } ) : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete an object from the redis table [CODESPLIT] def delete_entry ( self , key ) : pipe = self . client . pipeline ( ) pipe . srem ( self . keys_container , key ) pipe . delete ( key ) pipe . execute ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Writes Python object to Skype application stream . [CODESPLIT] def StreamWrite ( stream , * obj ) : stream . Write ( base64 . encodestring ( pickle . dumps ( obj ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert the parameter into a dictionary before calling jsonp if it s not already one [CODESPLIT] def dict_jsonp ( param ) : if not isinstance ( param , dict ) : param = dict ( param ) return jsonp ( param )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a JsonResponse . Make sure you have django installed first . [CODESPLIT] def json_response ( data , status = 200 ) : from django . http import JsonResponse return JsonResponse ( data = data , status = status , safe = isinstance ( data , dict ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split message to list by commas and trim whitespace . [CODESPLIT] def __normalize_list ( self , msg ) : if isinstance ( msg , list ) : msg = \"\" . join ( msg ) return list ( map ( lambda x : x . strip ( ) , msg . split ( \",\" ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Filter the lines from comments and non code lines . [CODESPLIT] def filter_lines_from_comments ( lines ) : for line_nb , raw_line in enumerate ( lines ) : clean_line = remove_comments_from_line ( raw_line ) if clean_line == '' : continue yield line_nb , clean_line , raw_line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes a : py : class : . Series from the chart . [CODESPLIT] def remove_series ( self , series ) : if len ( self . all_series ( ) ) == 1 : raise ValueError ( \"Cannot remove last series from %s\" % str ( self ) ) self . _all_series . remove ( series ) series . _chart = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Highlight a region on the chart between the specified start and end x - co - ordinates . param pyplot plt : matplotlibk pyplot which contains the charts to be highlighted param string start_x : epoch time millis param string end_x : epoch time millis [CODESPLIT] def highlight_region ( plt , start_x , end_x ) : start_x = convert_to_mdate ( start_x ) end_x = convert_to_mdate ( end_x ) plt . axvspan ( start_x , end_x , color = CONSTANTS . HIGHLIGHT_COLOR , alpha = CONSTANTS . HIGHLIGHT_ALPHA )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute boxplot for given pandas Series . [CODESPLIT] def compute_boxplot ( self , series ) : from matplotlib . cbook import boxplot_stats series = series [ series . notnull ( ) ] if len ( series . values ) == 0 : return { } elif not is_numeric_dtype ( series ) : return self . non_numeric_stats ( series ) stats = boxplot_stats ( list ( series . values ) ) [ 0 ] stats [ 'count' ] = len ( series . values ) stats [ 'fliers' ] = \"|\" . join ( map ( str , stats [ 'fliers' ] ) ) return stats", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of unique items ( similar to set functionality ) . [CODESPLIT] def unique ( input_list ) : output = [ ] for item in input_list : if item not in output : output . append ( item ) return output", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list where the duplicates have been removed . [CODESPLIT] def distinct ( l ) : seen = set ( ) seen_add = seen . add return ( _ for _ in l if not ( _ in seen or seen_add ( _ ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function returns a pretty table used to display the port results . [CODESPLIT] def get_table ( ports ) : table = PrettyTable ( [ \"Name\" , \"Port\" , \"Protocol\" , \"Description\" ] ) table . align [ \"Name\" ] = \"l\" table . align [ \"Description\" ] = \"l\" table . padding_width = 1 for port in ports : table . add_row ( port ) return table", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return string representation of object . [CODESPLIT] def __repr__ ( self ) : return str ( self . __class__ ) + '(' + ', ' . join ( [ list . __repr__ ( d ) for d in self . data ] ) + ')'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the string name of an enum value . [CODESPLIT] def EnumValueName ( self , enum , value ) : return self . enum_types_by_name [ enum ] . values_by_number [ value ] . name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replaces occurrences of a match string in a given list of strings and returns a list of new strings . The match string can be a regex expression . [CODESPLIT] def replace_list ( items , match , replacement ) : return [ replace ( item , match , replacement ) for item in items ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def get_unique_indices ( df , axis = 1 ) : return dict ( zip ( df . columns . names , dif . columns . levels ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the subplot at row column position . [CODESPLIT] def get_subplot_at ( self , row , column ) : idx = row * self . columns + column return self . subplots [ idx ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes non - alpha characters and converts spaces to hyphens . Useful for making file names . Source : http : // stackoverflow . com / questions / 5574042 / string - slugification - in - python [CODESPLIT] def slugify ( string ) : string = re . sub ( '[^\\w .-]' , '' , string ) string = string . replace ( \" \" , \"-\" ) return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve the type of the request by fetching it from xenon . proto . xenon_pb2 . [CODESPLIT] def request_type ( self ) : if self . static and not self . uses_request : return getattr ( xenon_pb2 , 'Empty' ) if not self . uses_request : return None return getattr ( xenon_pb2 , self . request_name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resets the iterator to the start . [CODESPLIT] def reset ( self ) : self . __iterator , self . __saved = itertools . tee ( self . __saved )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses CREATE INDEX CONCURRENTLY to create a duplicate index then tries to swap the new index for the original . [CODESPLIT] def cmd_reindex ( ) : db = connect ( args . database ) for idx in args . indexes : pg_reindex ( db , idx )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert iterable object into numpy array [CODESPLIT] def A ( * a ) : return np . array ( a [ 0 ] ) if len ( a ) == 1 else [ np . array ( o ) for o in a ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Attempts to retrieve an item from the queue Q . If Q is empty None is returned . Blocks for timeout seconds in case the queue is empty so don t use this method for speedy retrieval of multiple items ( use get_all_from_queue for that ) . [CODESPLIT] def get_item_from_queue ( Q , timeout = 0.01 ) : try : item = Q . get ( True , 0.01 ) except Queue . Empty : return None return item", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the file at the given path is safe to use as a state file . [CODESPLIT] def check_permission_safety ( path ) : f_stats = os . stat ( path ) return ( f_stats . st_mode & ( stat . S_IRWXG | stat . S_IRWXO ) ) == 0 and f_stats . st_uid == os . getuid ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the size of a multidimansional array . [CODESPLIT] def array_dim ( arr ) : dim = [ ] while True : try : dim . append ( len ( arr ) ) arr = arr [ 0 ] except TypeError : return dim", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a string with terminal colors . [CODESPLIT] def stringc ( text , color ) : if has_colors : text = str ( text ) return \"\\033[\" + codeCodes [ color ] + \"m\" + text + \"\\033[0m\" else : return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Unified rounding in all python versions . [CODESPLIT] def py3round ( number ) : if abs ( round ( number ) - number ) == 0.5 : return int ( 2.0 * round ( number / 2.0 ) ) return int ( round ( number ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create 2D rotation matrix [CODESPLIT] def create_rot2d ( angle ) : ca = math . cos ( angle ) sa = math . sin ( angle ) return np . array ( [ [ ca , - sa ] , [ sa , ca ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if email is valid [CODESPLIT] def is_valid_email ( email ) : pattern = re . compile ( r'[\\w\\.-]+@[\\w\\.-]+[.]\\w+' ) return bool ( pattern . match ( email ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns x rounded to n significant figures . [CODESPLIT] def round_figures ( x , n ) : return round ( x , int ( n - math . ceil ( math . log10 ( abs ( x ) ) ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "When executing a script that contains a jQuery command it s important that the jQuery library has been loaded first . This method will load jQuery if it wasn t already loaded . [CODESPLIT] def safe_execute_script ( driver , script ) : try : driver . execute_script ( script ) except Exception : # The likely reason this fails is because: \"jQuery is not defined\" activate_jquery ( driver ) # It's a good thing we can define it here driver . execute_script ( script )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create 2D rotation matrix [CODESPLIT] def create_rot2d ( angle ) : ca = math . cos ( angle ) sa = math . sin ( angle ) return np . array ( [ [ ca , - sa ] , [ sa , ca ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print security object information for a pdf document [CODESPLIT] def security ( self ) : return { k : v for i in self . pdf . resolvedObjects . items ( ) for k , v in i [ 1 ] . items ( ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call a function after a delay unless another function is set in the meantime . [CODESPLIT] def set ( self , f ) : self . stop ( ) self . _create_timer ( f ) self . start ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the next value in the page . [CODESPLIT] def next ( self ) : item = six . next ( self . _item_iter ) result = self . _item_to_value ( self . _parent , item ) # Since we've successfully got the next value from the # iterator, we update the number of remaining. self . _remaining -= 1 return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute the unit tests on an installed copy of unyt . [CODESPLIT] def test ( ) : # pragma: no cover import pytest import os pytest . main ( [ os . path . dirname ( os . path . abspath ( __file__ ) ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets a dict of this object s properties so that it can be used to send a dump to the client [CODESPLIT] def _to_json ( self ) : return dict ( ( ( k , v ) for k , v in self . __dict__ . iteritems ( ) if k != 'server' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert iterable object into numpy array [CODESPLIT] def A ( * a ) : return np . array ( a [ 0 ] ) if len ( a ) == 1 else [ np . array ( o ) for o in a ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a boto3 . s3 . Object [CODESPLIT] def get_key ( self , key , bucket_name = None ) : if not bucket_name : ( bucket_name , key ) = self . parse_s3_url ( key ) obj = self . get_resource_type ( 's3' ) . Object ( bucket_name , key ) obj . load ( ) return obj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Encode a python boolean ( True / False ) . [CODESPLIT] def _encode_bool ( name , value , dummy0 , dummy1 ) : return b\"\\x08\" + name + ( value and b\"\\x01\" or b\"\\x00\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Save object as json on CNS . [CODESPLIT] def save_json ( object , handle , indent = 2 ) : obj_json = json . dumps ( object , indent = indent , cls = NumpyJSONEncoder ) handle . write ( obj_json )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get max for queryset . [CODESPLIT] def get_max ( qs , field ) : max_field = '%s__max' % field num = qs . aggregate ( Max ( field ) ) [ max_field ] return num if num else 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Just the last entry . [CODESPLIT] def get_last ( self , table = None ) : if table is None : table = self . main_table query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table return self . own_cursor . execute ( query ) . fetchone ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Select rows where the given field is not None . [CODESPLIT] def selectnotnone ( table , field , complement = False ) : return select ( table , field , lambda v : v is not None , complement = complement )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the angle between two points . [CODESPLIT] def angle ( x0 , y0 , x1 , y1 ) : return degrees ( atan2 ( y1 - y0 , x1 - x0 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap text in an ansi escape sequence [CODESPLIT] def ansi ( color , text ) : code = COLOR_CODES [ color ] return '\\033[1;{0}m{1}{2}' . format ( code , text , RESET_TERM )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove prefix ( and space ) from line [CODESPLIT] def uncomment_line ( line , prefix ) : if not prefix : return line if line . startswith ( prefix + ' ' ) : return line [ len ( prefix ) + 1 : ] if line . startswith ( prefix ) : return line [ len ( prefix ) : ] return line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The Content - Type header value for this request . [CODESPLIT] def content_type ( self , data ) : self . _content_type = str ( data ) self . add_header ( 'Content-Type' , str ( data ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add method specific options to CLI parser . Parameters ---------- parser : argparse object Returns ---------- Updated argparse object [CODESPLIT] def cli_parse ( parser ) : parser . add_argument ( '-n' , '--samples' , type = int , required = True , help = 'Number of Samples' ) return parser", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates converts to a masked array [CODESPLIT] def asMaskedArray ( self ) : return ma . masked_array ( data = self . data , mask = self . mask , fill_value = self . fill_value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets the title of the console window . [CODESPLIT] def title ( msg ) : if sys . platform . startswith ( \"win\" ) : ctypes . windll . kernel32 . SetConsoleTitleW ( tounicode ( msg ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses numpy . load to open the underlying file [CODESPLIT] def _openResources ( self ) : arr = np . load ( self . _fileName , allow_pickle = ALLOW_PICKLE ) check_is_an_array ( arr ) self . _array = arr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show a basic reference about the GUI Console . [CODESPLIT] def page_guiref ( arg_s = None ) : from IPython . core import page page . page ( gui_reference , auto_html = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform triple index into a 1 - D numpy array . [CODESPLIT] def _transform_triple_numpy ( x ) : return np . array ( [ x . head , x . relation , x . tail ] , dtype = np . int64 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shuffle the data . [CODESPLIT] def _shuffle ( data , idx ) : shuffle_data = [ ] for idx_k , idx_v in data : shuffle_data . append ( ( idx_k , mx . ndarray . array ( idx_v . asnumpy ( ) [ idx ] , idx_v . context ) ) ) return shuffle_data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Implements string formatting along with color specified in colorama . Fore [CODESPLIT] def colorize ( string , color , * args , * * kwargs ) : string = string . format ( * args , * * kwargs ) return color + string + colorama . Fore . RESET", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Toggle pause mode [CODESPLIT] def toggle_pause ( self ) : self . controller . playing = not self . controller . playing self . music . toggle_pause ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handle interactive exit . [CODESPLIT] def exit ( self ) : if self . confirm_exit : if self . ask_yes_no ( 'Do you really want to exit ([y]/n)?' , 'y' ) : self . ask_exit ( ) else : self . ask_exit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "\\ Asserts that two iterables contain the same values . [CODESPLIT] def expect_all ( a , b ) : assert all ( _a == _b for _a , _b in zip_longest ( a , b ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raises an AssertionError if expected is actual . [CODESPLIT] def assert_is_not ( expected , actual , message = None , extra = None ) : assert expected is not actual , _assert_fail_message ( message , expected , actual , \"is\" , extra )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Upermutate 1 - D data that is sorted by indices_of_increasing . [CODESPLIT] def unsort_vector ( data , indices_of_increasing ) : return numpy . array ( [ data [ indices_of_increasing . index ( i ) ] for i in range ( len ( data ) ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Indent given text using custom spacing default is set to 4 . [CODESPLIT] def indent ( txt , spacing = 4 ) : return prefix ( str ( txt ) , '' . join ( [ ' ' for _ in range ( spacing ) ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load %autoreload magic . [CODESPLIT] def _load_autoreload_magic ( self ) : from IPython . core . getipython import get_ipython try : get_ipython ( ) . run_line_magic ( 'reload_ext' , 'autoreload' ) get_ipython ( ) . run_line_magic ( 'autoreload' , '2' ) except Exception : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the mean value across a list of dictionaries [CODESPLIT] def _mean_dict ( dict_list ) : return { k : np . array ( [ d [ k ] for d in dict_list ] ) . mean ( ) for k in dict_list [ 0 ] . keys ( ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Produces an s3 url for a given blueprint . [CODESPLIT] def stack_template_url ( bucket_name , blueprint , endpoint ) : key_name = stack_template_key_name ( blueprint ) return \"%s/%s/%s\" % ( endpoint , bucket_name , key_name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Maxheap version of a heappop followed by a heappush . [CODESPLIT] def _heapreplace_max ( heap , item ) : returnitem = heap [ 0 ] # raises appropriate IndexError if heap is empty heap [ 0 ] = item _siftup_max ( heap , 0 ) return returnitem", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Represent string / bytes s as base64 omitting newlines [CODESPLIT] def toBase64 ( s ) : if isinstance ( s , str ) : s = s . encode ( \"utf-8\" ) return binascii . b2a_base64 ( s ) [ : - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write a numpy array and its shape to base64 buffers [CODESPLIT] def encode_ndarray ( obj ) : shape = obj . shape if len ( shape ) == 1 : shape = ( 1 , obj . shape [ 0 ] ) if obj . flags . c_contiguous : obj = obj . T elif not obj . flags . f_contiguous : obj = asfortranarray ( obj . T ) else : obj = obj . T try : data = obj . astype ( float64 ) . tobytes ( ) except AttributeError : data = obj . astype ( float64 ) . tostring ( ) data = base64 . b64encode ( data ) . decode ( 'utf-8' ) return data , shape", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Applies the configuration s http headers to all responses [CODESPLIT] def apply_caching ( response ) : for k , v in config . get ( 'HTTP_HEADERS' ) . items ( ) : response . headers [ k ] = v return response", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sends plain text using _send_text () . [CODESPLIT] async def _send_plain_text ( self , request : Request , stack : Stack ) : await self . _send_text ( request , stack , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Circular standard deviation [CODESPLIT] def circstd ( dts , axis = 2 ) : R = np . abs ( np . exp ( 1.0j * dts ) . mean ( axis = axis ) ) return np . sqrt ( - 2.0 * np . log ( R ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Idempotent and None - safe version of strict_bool . [CODESPLIT] def less_strict_bool ( x ) : if x is None : return False elif x is True or x is False : return x else : return strict_bool ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace boolean variables by the characters F / T [CODESPLIT] def _check_and_convert_bools ( self ) : replacements = { True : 'T' , False : 'F' , } for key in self . bools : if isinstance ( self [ key ] , bool ) : self [ key ] = replacements [ self [ key ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wait until all task are executed . [CODESPLIT] async def wait_and_quit ( loop ) : from pylp . lib . tasks import running if running : await asyncio . wait ( map ( lambda runner : runner . future , running ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete an object in DynamoDB . [CODESPLIT] def delete_item ( self , item ) : try : self . dynamodb_client . delete_item ( * * item ) except botocore . exceptions . ClientError as error : handle_constraint_violation ( error )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Constructs a numpy - compatible polygon from a page representation . [CODESPLIT] def polygon_from_points ( points ) : polygon = [ ] for pair in points . split ( \" \" ) : x_y = pair . split ( \",\" ) polygon . append ( [ float ( x_y [ 0 ] ) , float ( x_y [ 1 ] ) ] ) return polygon", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Executes self . function to convert LazyString instance to a real str . [CODESPLIT] def __str__ ( self ) : if not hasattr ( self , '_str' ) : self . _str = self . function ( * self . args , * * self . kwargs ) return self . _str", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a string with comma or space - separated elements into a list . [CODESPLIT] def split_elements ( value ) : l = [ v . strip ( ) for v in value . split ( ',' ) ] if len ( l ) == 1 : l = value . split ( ) return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the top - level element of a document sub - tree containing the YAML serialization of a Python object . [CODESPLIT] def yaml_to_param ( obj , name ) : return from_pyvalue ( u\"yaml:%s\" % name , unicode ( yaml . dump ( obj ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compiles to native Python bytecode and runs program returning the topmost value on the stack . [CODESPLIT] def xeval ( source , optimize = True ) : native = xcompile ( source , optimize = optimize ) return native ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Python2 accumulate implementation taken from https : // docs . python . org / 3 / library / itertools . html#itertools . accumulate [CODESPLIT] def _accumulate ( sequence , func ) : iterator = iter ( sequence ) total = next ( iterator ) yield total for element in iterator : total = func ( total , element ) yield total", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert Matrix attributes which are array - like or buffer to array . [CODESPLIT] def _convert_to_array ( array_like , dtype ) : if isinstance ( array_like , bytes ) : return np . frombuffer ( array_like , dtype = dtype ) return np . asarray ( array_like , dtype = dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "a convenience method for both adding a swagger . json route as well as adding a page showing the html documentation [CODESPLIT] def add_swagger ( app , json_route , html_route ) : app . router . add_route ( 'GET' , json_route , create_swagger_json_handler ( app ) ) add_swagger_api_route ( app , html_route , json_route )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Public function that reads a local file and generates a SHA256 hash digest for it [CODESPLIT] def generate_hash ( filepath ) : fr = FileReader ( filepath ) data = fr . read_bin ( ) return _calculate_sha256 ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert CamelCase to lower_and_underscore . [CODESPLIT] def decamelise ( text ) : s = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Close last created figure alias to plt . close () . [CODESPLIT] def close ( * args , * * kwargs ) : _ , plt , _ = _import_plt ( ) plt . close ( * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the given command ( with shell = False ) and return a tuple of ( int returncode str output ) . Strip the output of enclosing whitespace . [CODESPLIT] def call_out ( command ) : # start external command process p = subprocess . Popen ( command , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) # get outputs out , _ = p . communicate ( ) return p . returncode , out . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper for inserting int64 features into Example proto . [CODESPLIT] def _int64_feature ( value ) : if not isinstance ( value , list ) : value = [ value ] return tf . train . Feature ( int64_list = tf . train . Int64List ( value = value ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert datetime / str to date : param arg : : return : [CODESPLIT] def _datetime_to_date ( arg ) : _arg = parse ( arg ) if isinstance ( _arg , datetime . datetime ) : _arg = _arg . date ( ) return _arg", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace boolean variables by the characters F / T [CODESPLIT] def _check_and_convert_bools ( self ) : replacements = { True : 'T' , False : 'F' , } for key in self . bools : if isinstance ( self [ key ] , bool ) : self [ key ] = replacements [ self [ key ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add executable permissions to the file [CODESPLIT] def add_exec_permission_to ( target_file ) : mode = os . stat ( target_file ) . st_mode os . chmod ( target_file , mode | stat . S_IXUSR )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "date to unix timestamp in milliseconds [CODESPLIT] def date_to_timestamp ( date ) : date_tuple = date . timetuple ( ) timestamp = calendar . timegm ( date_tuple ) * 1000 return timestamp", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract internal data from pd . DataFrame for DMatrix data [CODESPLIT] def _maybe_pandas_data ( data , feature_names , feature_types ) : if not isinstance ( data , DataFrame ) : return data , feature_names , feature_types data_dtypes = data . dtypes if not all ( dtype . name in PANDAS_DTYPE_MAPPER for dtype in data_dtypes ) : bad_fields = [ data . columns [ i ] for i , dtype in enumerate ( data_dtypes ) if dtype . name not in PANDAS_DTYPE_MAPPER ] msg = \"\"\"DataFrame.dtypes for data must be int, float or bool.\n                Did not expect the data types in fields \"\"\" raise ValueError ( msg + ', ' . join ( bad_fields ) ) if feature_names is None : if isinstance ( data . columns , MultiIndex ) : feature_names = [ ' ' . join ( [ str ( x ) for x in i ] ) for i in data . columns ] else : feature_names = data . columns . format ( ) if feature_types is None : feature_types = [ PANDAS_DTYPE_MAPPER [ dtype . name ] for dtype in data_dtypes ] data = data . values . astype ( 'float' ) return data , feature_names , feature_types", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to restore index information after collection . Doesn t use self so we can serialize this . [CODESPLIT] def _update_index_on_df ( df , index_names ) : if index_names : df = df . set_index ( index_names ) # Remove names from unnamed indexes index_names = _denormalize_index_names ( index_names ) df . index . names = index_names return df", "target": 1, "target_options": ["no_match", "match"]}
{"input": "create a filtered indexer that doesn t have any missing indexers [CODESPLIT] def convert_from_missing_indexer_tuple ( indexer , axes ) : def get_indexer ( _i , _idx ) : return ( axes [ _i ] . get_loc ( _idx [ 'key' ] ) if isinstance ( _idx , dict ) else _idx ) return tuple ( get_indexer ( _i , _idx ) for _i , _idx in enumerate ( indexer ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a dtype is a subclass of the numpy datetime types [CODESPLIT] def is_datetime_like ( dtype ) : return ( np . issubdtype ( dtype , np . datetime64 ) or np . issubdtype ( dtype , np . timedelta64 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "quit crash [CODESPLIT] def _quit ( self , * args ) : self . logger . warn ( 'Bye!' ) sys . exit ( self . exit ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a string with comma or space - separated elements into a list . [CODESPLIT] def split_elements ( value ) : l = [ v . strip ( ) for v in value . split ( ',' ) ] if len ( l ) == 1 : l = value . split ( ) return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tries to load an encoded json string back into an object : param json_string : : return : [CODESPLIT] def serialize_json_string ( self , value ) : # Check if the value might be a json string if not isinstance ( value , six . string_types ) : return value # Make sure it starts with a brace if not value . startswith ( '{' ) or value . startswith ( '[' ) : return value # Try to load the string try : return json . loads ( value ) except : return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if a line consists only of a single punctuation character . [CODESPLIT] def is_delimiter ( line ) : return bool ( line ) and line [ 0 ] in punctuation and line [ 0 ] * len ( line ) == line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns true if all of the elements in the list are equal . [CODESPLIT] def _check_elements_equal ( lst ) : assert isinstance ( lst , list ) , \"Input value must be a list.\" return not lst or lst . count ( lst [ 0 ] ) == len ( lst )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks whether all number in the sequence s lie inside the interval formed by l and r . [CODESPLIT] def are_in_interval ( s , l , r , border = 'included' ) : return numpy . all ( [ IntensityRangeStandardization . is_in_interval ( x , l , r , border ) for x in s ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Same order unique list using only a list compression . [CODESPLIT] def uniquify_list ( L ) : return [ e for i , e in enumerate ( L ) if L . index ( e ) == i ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Re - index every document in a named index . [CODESPLIT] def update_index ( index ) : logger . info ( \"Updating search index: '%s'\" , index ) client = get_client ( ) responses = [ ] for model in get_index_models ( index ) : logger . info ( \"Updating search index model: '%s'\" , model . search_doc_type ) objects = model . objects . get_search_queryset ( index ) . iterator ( ) actions = bulk_actions ( objects , index = index , action = \"index\" ) response = helpers . bulk ( client , actions , chunk_size = get_setting ( \"chunk_size\" ) ) responses . append ( response ) return responses", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if email is valid [CODESPLIT] def is_valid_email ( email ) : pattern = re . compile ( r'[\\w\\.-]+@[\\w\\.-]+[.]\\w+' ) return bool ( pattern . match ( email ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param sequence : Any sequence whose elements can be evaluated as booleans . : returns : true if all elements of the sequence satisfy True and x . [CODESPLIT] def All ( sequence ) : return bool ( reduce ( lambda x , y : x and y , sequence , True ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tests if an object is a collection . [CODESPLIT] def is_collection ( obj ) : col = getattr ( obj , '__getitem__' , False ) val = False if ( not col ) else True if isinstance ( obj , basestring ) : val = False return val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a hdf5 file into a dictionary [CODESPLIT] def h5ToDict ( h5 , readH5pyDataset = True ) : h = h5py . File ( h5 , \"r\" ) ret = unwrapArray ( h , recursive = True , readH5pyDataset = readH5pyDataset ) if readH5pyDataset : h . close ( ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether one of the items in the list has multiple lines . [CODESPLIT] def has_multiline_items ( maybe_list : Optional [ Sequence [ str ] ] ) : return maybe_list and any ( is_multiline ( item ) for item in maybe_list )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "One - hot encode labels from input [CODESPLIT] def one_hot_encoding ( input_tensor , num_labels ) : xview = input_tensor . view ( - 1 , 1 ) . to ( torch . long ) onehot = torch . zeros ( xview . size ( 0 ) , num_labels , device = input_tensor . device , dtype = torch . float ) onehot . scatter_ ( 1 , xview , 1 ) return onehot . view ( list ( input_tensor . shape ) + [ - 1 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a numpy dtype determines whether it is a string . Returns True if the dtype is string or unicode . [CODESPLIT] def _isstring ( dtype ) : return dtype . type == numpy . unicode_ or dtype . type == numpy . string_", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete a river by name [CODESPLIT] def delete ( args ) : m = RiverManager ( args . hosts ) m . delete ( args . name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if a string looks like an email address [CODESPLIT] def __validate_email ( self , email ) : e = re . match ( self . EMAIL_ADDRESS_REGEX , email , re . UNICODE ) if e : return email else : error = \"Invalid email address: \" + str ( email ) msg = self . GRIMOIRELAB_INVALID_FORMAT % { 'error' : error } raise InvalidFormatError ( cause = msg )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run once should be called only from loop () [CODESPLIT] def _run_once ( self ) : try : self . do_wait ( ) self . _execute_wakeup_tasks ( ) self . _trigger_timers ( ) except Exception as e : Log . error ( \"Error occured during _run_once(): \" + str ( e ) ) Log . error ( traceback . format_exc ( ) ) self . should_exit = True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return True if callback is a vanilla plain jane function [CODESPLIT] def is_function ( self ) : if self . is_instance ( ) or self . is_class ( ) : return False return isinstance ( self . callback , ( Callable , classmethod ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if string could be a valid python identifier [CODESPLIT] def is_identifier ( string ) : matched = PYTHON_IDENTIFIER_RE . match ( string ) return bool ( matched ) and not keyword . iskeyword ( string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Report whether this RangeSet contains another set . [CODESPLIT] def issuperset ( self , other ) : self . _binary_sanity_check ( other ) return set . issuperset ( self , other )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the maximum length between the example inputs and targets . [CODESPLIT] def _get_example_length ( example ) : length = tf . maximum ( tf . shape ( example [ 0 ] ) [ 0 ] , tf . shape ( example [ 1 ] ) [ 0 ] ) return length", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Send signal to process . [CODESPLIT] def process_kill ( pid , sig = None ) : sig = sig or signal . SIGTERM os . kill ( pid , sig )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Chunk one big list into few small lists . [CODESPLIT] def chunked ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a new IPAString containing only the vowels in the current string . [CODESPLIT] def vowels ( self ) : return IPAString ( ipa_chars = [ c for c in self . ipa_chars if c . is_vowel ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cleanup any necessary opened files [CODESPLIT] def __exit__ ( self , * args ) : if self . _output_file_handle : self . _output_file_handle . close ( ) self . _output_file_handle = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "writes the line and count newlines after the line [CODESPLIT] def write_line ( self , line , count = 1 ) : self . write ( line ) self . write_newlines ( count )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "consider the distance between two mapPoints ignoring all terrain pathing issues [CODESPLIT] def direct2dDistance ( self , point ) : if not isinstance ( point , MapPoint ) : return 0.0 return ( ( self . x - point . x ) ** 2 + ( self . y - point . y ) ** 2 ) ** ( 0.5 ) # simple distance formula", "target": 1, "target_options": ["no_match", "match"]}
{"input": "print the csv [CODESPLIT] def printcsv ( csvdiffs ) : for row in csvdiffs : print ( ',' . join ( [ str ( cell ) for cell in row ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Disable event loop integration with wxPython . [CODESPLIT] def disable_wx ( self ) : if self . _apps . has_key ( GUI_WX ) : self . _apps [ GUI_WX ] . _in_event_loop = False self . clear_inputhook ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Portable cast function . [CODESPLIT] def to_binary ( s , encoding = 'utf8' ) : if PY3 : # pragma: no cover return s if isinstance ( s , binary_type ) else binary_type ( s , encoding = encoding ) return binary_type ( s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show the x - axis tick labels for a subplot . [CODESPLIT] def show_xticklabels ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . show_xticklabels ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pure - Python implementation of itertools . combinations ( l 2 ) . [CODESPLIT] def combinations ( l ) : result = [ ] for x in xrange ( len ( l ) - 1 ) : ls = l [ x + 1 : ] for y in ls : result . append ( ( l [ x ] , y ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Args : xml_str : str DataONE API XML doc . [CODESPLIT] def str_is_well_formed ( xml_str ) : try : str_to_etree ( xml_str ) except xml . etree . ElementTree . ParseError : return False else : return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take the union of a list of lists . [CODESPLIT] def listunion ( ListOfLists ) : u = [ ] for s in ListOfLists : if s != None : u . extend ( s ) return u", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty print an object as YAML . [CODESPLIT] def print_yaml ( o ) : print ( yaml . dump ( o , default_flow_style = False , indent = 4 , encoding = 'utf-8' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Proximal operator to project onto zero [CODESPLIT] def prox_zero ( X , step ) : return np . zeros ( X . shape , dtype = X . dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Temporarily replace sys . argv with current arguments [CODESPLIT] def replace_sys_args ( new_args ) : # Replace sys.argv arguments # for module import old_args = sys . argv sys . argv = new_args try : yield finally : sys . argv = old_args", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator to explicitly mark functions that are exposed in a lib . [CODESPLIT] def export ( defn ) : globals ( ) [ defn . __name__ ] = defn __all__ . append ( defn . __name__ ) return defn", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the first sunday of a month . [CODESPLIT] def first_sunday ( self , year , month ) : date = datetime ( year , month , 1 , 0 ) days_until_sunday = 6 - date . weekday ( ) return date + timedelta ( days = days_until_sunday )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param tup : a list of tuples : param di : a dictionary converted from tup : return : dictionary [CODESPLIT] def _convert ( tup , dictlist ) : di = { } for a , b in tup : di . setdefault ( a , [ ] ) . append ( b ) for key , val in di . items ( ) : dictlist . append ( ( key , val ) ) return dictlist", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Similar to #itertools . chain . from_iterable () . [CODESPLIT] def concat ( cls , iterables ) : def generator ( ) : for it in iterables : for element in it : yield element return cls ( generator ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert an image by adding text [CODESPLIT] def add_text_to_image ( fname , txt , opFilename ) : ft = ImageFont . load ( \"T://user//dev//src//python//_AS_LIB//timR24.pil\" ) #wh = ft.getsize(txt) print ( \"Adding text \" , txt , \" to \" , fname , \" pixels wide to file \" , opFilename ) im = Image . open ( fname ) draw = ImageDraw . Draw ( im ) draw . text ( ( 0 , 0 ) , txt , fill = ( 0 , 0 , 0 ) , font = ft ) del draw im . save ( opFilename )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run manage . py using this component s specific Django settings [CODESPLIT] def managepy ( cmd , extra = None ) : extra = extra . split ( ) if extra else [ ] run_django_cli ( [ 'invoke' , cmd ] + extra )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "must be an iterable ( list array tuple ) [CODESPLIT] def is_iterable ( value ) : return isinstance ( value , np . ndarray ) or isinstance ( value , list ) or isinstance ( value , tuple ) , value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Array of bytes [CODESPLIT] def barray ( iterlines ) : lst = [ line . encode ( 'utf-8' ) for line in iterlines ] arr = numpy . array ( lst ) return arr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts snake_cased_names to CamelCaseNames . [CODESPLIT] def to_camel_case ( snake_case_name ) : bits = snake_case_name . split ( '_' ) return '' . join ( [ bit . capitalize ( ) for bit in bits ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the pythonic string type . [CODESPLIT] def visit_Str ( self , node ) : self . result [ node ] = self . builder . NamedType ( pytype_to_ctype ( str ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return variant standarize function [CODESPLIT] def standardize ( ) : def f ( G , bim ) : G_out = standardize_snps ( G ) return G_out , bim return f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove arduino / examples / all directory . [CODESPLIT] def remove_examples_all ( ) : d = examples_all_dir ( ) if d . exists ( ) : log . debug ( 'remove %s' , d ) d . rmtree ( ) else : log . debug ( 'nothing to remove: %s' , d )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A static value ( does not change at runtime ) which is known at compile time [CODESPLIT] def is_static ( * p ) : return all ( is_CONST ( x ) or is_number ( x ) or is_const ( x ) for x in p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Distance squared to some other point . [CODESPLIT] def dist_sq ( self , other ) : dx = self . x - other . x dy = self . y - other . y return dx ** 2 + dy ** 2", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Memoize access to the cache backend . [CODESPLIT] def cache ( self ) : if self . _cache is None : self . _cache = django_cache . get_cache ( self . cache_name ) return self . _cache", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print QR Code for the provided string [CODESPLIT] def qr ( self , text ) : qr_code = qrcode . QRCode ( version = 4 , box_size = 4 , border = 1 ) qr_code . add_data ( text ) qr_code . make ( fit = True ) qr_img = qr_code . make_image ( ) im = qr_img . _img . convert ( \"RGB\" ) # Convert the RGB image in printable image self . _convert_image ( im )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "updates the scale of all actors in the plotter [CODESPLIT] def update_scale ( self , value ) : self . plotter . set_scale ( self . x_slider_group . value , self . y_slider_group . value , self . z_slider_group . value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return password from pipe if not on TTY else False . [CODESPLIT] def pass_from_pipe ( cls ) : is_pipe = not sys . stdin . isatty ( ) return is_pipe and cls . strip_last_newline ( sys . stdin . read ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Select rows where the given field is a member of the given value . [CODESPLIT] def selectin ( table , field , value , complement = False ) : return select ( table , field , lambda v : v in value , complement = complement )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fill file at [CODESPLIT] def file_writelines_flush_sync ( path , lines ) : fp = open ( path , 'w' ) try : fp . writelines ( lines ) flush_sync_file_object ( fp ) finally : fp . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Temporary helper function to link to the API routes [CODESPLIT] def home ( ) : return dict ( links = dict ( api = '{}{}' . format ( request . url , PREFIX [ 1 : ] ) ) ) , HTTPStatus . OK", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Close all connections . [CODESPLIT] def cleanup ( self , app ) : if hasattr ( self . database . obj , 'close_all' ) : self . database . close_all ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rounds a float value off to the desired precision [CODESPLIT] def _saferound ( value , decimal_places ) : try : f = float ( value ) except ValueError : return '' format = '%%.%df' % decimal_places return format % f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Align the position in the file to the next block of specified size [CODESPLIT] def align_file_position ( f , size ) : align = ( size - 1 ) - ( f . tell ( ) % size ) f . seek ( align , 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "decorator to convert a method taking a iterable to a * args one [CODESPLIT] def _iterable_to_varargs_method ( func ) : def wrapped ( self , * args , * * kwargs ) : return func ( self , args , * * kwargs ) return wrapped", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clean up processes after SIGTERM or SIGINT is received . [CODESPLIT] def cleanup_storage ( * args ) : ShardedClusters ( ) . cleanup ( ) ReplicaSets ( ) . cleanup ( ) Servers ( ) . cleanup ( ) sys . exit ( 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Integrate a Gaussian profile . [CODESPLIT] def gauss_box_model ( x , amplitude = 1.0 , mean = 0.0 , stddev = 1.0 , hpix = 0.5 ) : z = ( x - mean ) / stddev z2 = z + hpix / stddev z1 = z - hpix / stddev return amplitude * ( norm . cdf ( z2 ) - norm . cdf ( z1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function used internally to format string data for output to XML . Escapes back - slashes and quotes and wraps the resulting string in quotes . [CODESPLIT] def string_format_func ( s ) : return u\"\\\"%s\\\"\" % unicode ( s ) . replace ( u\"\\\\\" , u\"\\\\\\\\\" ) . replace ( u\"\\\"\" , u\"\\\\\\\"\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "helper function for parsing FRED date string into datetime [CODESPLIT] def _parse ( self , date_str , format = '%Y-%m-%d' ) : rv = pd . to_datetime ( date_str , format = format ) if hasattr ( rv , 'to_pydatetime' ) : rv = rv . to_pydatetime ( ) return rv", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the month start date a nd end date [CODESPLIT] def get_month_start_end_day ( ) : t = date . today ( ) n = mdays [ t . month ] return ( date ( t . year , t . month , 1 ) , date ( t . year , t . month , n ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts datetimeoffset object into Python s datetime . datetime object [CODESPLIT] def to_pydatetime ( self ) : dt = datetime . datetime . combine ( self . _date . to_pydate ( ) , self . _time . to_pytime ( ) ) from . tz import FixedOffsetTimezone return dt . replace ( tzinfo = _utc ) . astimezone ( FixedOffsetTimezone ( self . _offset ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete index entirely ( removes all documents and mapping ) . [CODESPLIT] def delete_index ( index ) : logger . info ( \"Deleting search index: '%s'\" , index ) client = get_client ( ) return client . indices . delete ( index = index )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete a directory if it s present . If it s not present no - op . [CODESPLIT] def safe_rmtree ( directory ) : if os . path . exists ( directory ) : shutil . rmtree ( directory , True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the length in bytes of a given file object . Necessary because os . fstat only works on real files and not file - like objects . This works on more types of streams primarily StringIO . [CODESPLIT] def file_length ( file_obj ) : file_obj . seek ( 0 , 2 ) length = file_obj . tell ( ) file_obj . seek ( 0 ) return length", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Command line interface for PyBEL . [CODESPLIT] def main ( ctx , connection ) : ctx . obj = Manager ( connection = connection ) ctx . obj . bind ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "image resize function used by quite a few image problems . [CODESPLIT] def resize_by_area ( img , size ) : return tf . to_int64 ( tf . image . resize_images ( img , [ size , size ] , tf . image . ResizeMethod . AREA ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a tuple that contains ( width height ) Pass in a url to an image and find out its size without loading the whole file If the image wxh could not be found the tuple will contain None values [CODESPLIT] def get_image_dimension ( self , url ) : w_h = ( None , None ) try : if url . startswith ( '//' ) : url = 'http:' + url data = requests . get ( url ) . content im = Image . open ( BytesIO ( data ) ) w_h = im . size except Exception : logger . warning ( \"Error getting image size {}\" . format ( url ) , exc_info = True ) return w_h", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Alias for instance method that allows the method to be called in a multiprocessing pool . Needed as multiprocessing does not otherwise work on object instance methods . [CODESPLIT] def _full_analysis_mp_alias ( br_obj , analysis_set , output_directory , unique_name , verbose , quick_plots ) : return ( br_obj , unique_name , br_obj . full_analysis ( analysis_set , output_directory , verbose = verbose , compile_pdf = verbose , quick_plots = quick_plots ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns the rows columns of terminal [CODESPLIT] def _size_36 ( ) : from shutil import get_terminal_size dim = get_terminal_size ( ) if isinstance ( dim , list ) : return dim [ 0 ] , dim [ 1 ] return dim . lines , dim . columns", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the dotproduct of two vectors . [CODESPLIT] def dot_v3 ( v , w ) : return sum ( [ x * y for x , y in zip ( v , w ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a property of the experiment by name . [CODESPLIT] def experiment_property ( prop ) : exp = experiment ( session ) p = getattr ( exp , prop ) return success_response ( field = prop , data = p , request_type = prop )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns an updated copy of the dictionary without modifying the original [CODESPLIT] def copy_and_update ( dictionary , update ) : newdict = dictionary . copy ( ) newdict . update ( update ) return newdict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the week start date and end date [CODESPLIT] def get_week_start_end_day ( ) : t = date . today ( ) wd = t . weekday ( ) return ( t - timedelta ( wd ) , t + timedelta ( 6 - wd ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a section a subsection and some text to the document . [CODESPLIT] def fill_document ( doc ) : with doc . create ( Section ( 'A section' ) ) : doc . append ( 'Some regular text and some ' ) doc . append ( italic ( 'italic text. ' ) ) with doc . create ( Subsection ( 'A subsection' ) ) : doc . append ( 'Also some crazy characters: $&#{}' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def main ( ) : usage = \"\"\"\nUserspace ioctl example\n\n\"\"\" + Fuse . fusage server = FiocFS ( version = \"%prog \" + fuse . __version__ , usage = usage , dash_s_do = 'setsingle' ) server . parse ( errex = 1 ) server . main ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Visible width of a potentially multiline content . [CODESPLIT] def _multiline_width ( multiline_s , line_width_fn = len ) : return max ( map ( line_width_fn , re . split ( \"[\\r\\n]\" , multiline_s ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply the coefficients from a linear fit to an array of x y positions . [CODESPLIT] def apply_fit ( xy , coeffs ) : x_new = coeffs [ 0 ] [ 2 ] + coeffs [ 0 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 0 ] [ 1 ] * xy [ : , 1 ] y_new = coeffs [ 1 ] [ 2 ] + coeffs [ 1 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 1 ] [ 1 ] * xy [ : , 1 ] return x_new , y_new", "target": 1, "target_options": ["no_match", "match"]}
{"input": "View the current version of the CLI . [CODESPLIT] def version ( ) : import pkg_resources version = pkg_resources . require ( PROJECT_NAME ) [ 0 ] . version floyd_logger . info ( version )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute entropy on the string [CODESPLIT] def entropy ( string ) : p , lns = Counter ( string ) , float ( len ( string ) ) return - sum ( count / lns * math . log ( count / lns , 2 ) for count in p . values ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalized Gaussian [CODESPLIT] def gauss_pdf ( x , mu , sigma ) : return 1 / np . sqrt ( 2 * np . pi ) / sigma * np . exp ( - ( x - mu ) ** 2 / 2. / sigma ** 2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a legal python name for the given name for use as a unit key . [CODESPLIT] def unit_key_from_name ( name ) : result = name for old , new in six . iteritems ( UNIT_KEY_REPLACEMENTS ) : result = result . replace ( old , new ) # Collapse redundant underscores and convert to uppercase. result = re . sub ( r'_+' , '_' , result . upper ( ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return grandparent s path string [CODESPLIT] def grandparent_path ( self ) : return os . path . basename ( os . path . join ( self . path , '../..' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve the previous quarter for dt [CODESPLIT] def previous_quarter ( d ) : from django_toolkit . datetime_util import quarter as datetime_quarter return quarter ( ( datetime_quarter ( datetime ( d . year , d . month , d . day ) ) [ 0 ] + timedelta ( days = - 1 ) ) . date ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize dicts and lists [CODESPLIT] def _normalize ( obj ) : if isinstance ( obj , list ) : return [ _normalize ( item ) for item in obj ] elif isinstance ( obj , dict ) : return { k : _normalize ( v ) for k , v in obj . items ( ) if v is not None } elif hasattr ( obj , 'to_python' ) : return obj . to_python ( ) return obj", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def add_todo ( request ) : cur = request . cursor todo = request . json [ \"todo\" ] cur . execute ( \"\"\"INSERT INTO todos (todo) VALUES (?)\"\"\" , ( todo , ) ) last_id = cur . lastrowid cur . connection . commit ( ) return request . Response ( json = { \"id\" : last_id , \"todo\" : todo } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "restore real versions . Inverse of monkey_patch [CODESPLIT] def monkey_restore ( ) : for k , v in originals . items ( ) : setattr ( time_mod , k , v ) global epoch epoch = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return the key from the request [CODESPLIT] def get ( key , default = None ) : data = get_form ( ) or get_query_string ( ) return data . get ( key , default )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts an RGB image to grayscale using matlab s algorithm . [CODESPLIT] def rgb2gray ( img ) : T = np . linalg . inv ( np . array ( [ [ 1.0 , 0.956 , 0.621 ] , [ 1.0 , - 0.272 , - 0.647 ] , [ 1.0 , - 1.106 , 1.703 ] , ] ) ) r_c , g_c , b_c = T [ 0 ] r , g , b = np . rollaxis ( as_float_image ( img ) , axis = - 1 ) return r_c * r + g_c * g + b_c * b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "String hash ( djb2 ) with consistency between py2 / py3 and persistency between runs ( unlike hash ) . [CODESPLIT] def _string_hash ( s ) : h = 5381 for c in s : h = h * 33 + ord ( c ) return h", "target": 1, "target_options": ["no_match", "match"]}
{"input": "* Get the root path for this python package - used in unit testing code * [CODESPLIT] def getpackagepath ( ) : moduleDirectory = os . path . dirname ( __file__ ) packagePath = os . path . dirname ( __file__ ) + \"/../\" return packagePath", "target": 1, "target_options": ["no_match", "match"]}
{"input": "helpful in situations where browser / app may recognize Unicode encoding in the \\ u0b8e type syntax but not actual unicode glyph / code - point [CODESPLIT] def to_unicode_repr ( _letter ) : # Python 2-3 compatible return u\"u'\" + u\"\" . join ( [ u\"\\\\u%04x\" % ord ( l ) for l in _letter ] ) + u\"'\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an interactive function widget for the given function . [CODESPLIT] def widget ( self , f ) : return self . cls ( f , self . opts , * * self . kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Quit and Restart Spyder application . If reset True it allows to reset spyder on restart . [CODESPLIT] def restart ( self , reset = False ) : # Get start path to use in restart script\n spyder_start_directory = get_module_path ( 'spyder' ) restart_script = osp . join ( spyder_start_directory , 'app' , 'restart.py' ) # Get any initial argument passed when spyder was started\n # Note: Variables defined in bootstrap.py and spyder/app/start.py\n env = os . environ . copy ( ) bootstrap_args = env . pop ( 'SPYDER_BOOTSTRAP_ARGS' , None ) spyder_args = env . pop ( 'SPYDER_ARGS' ) # Get current process and python running spyder\n pid = os . getpid ( ) python = sys . executable # Check if started with bootstrap.py\n if bootstrap_args is not None : spyder_args = bootstrap_args is_bootstrap = True else : is_bootstrap = False # Pass variables as environment variables (str) to restarter subprocess\n env [ 'SPYDER_ARGS' ] = spyder_args env [ 'SPYDER_PID' ] = str ( pid ) env [ 'SPYDER_IS_BOOTSTRAP' ] = str ( is_bootstrap ) env [ 'SPYDER_RESET' ] = str ( reset ) if DEV : if os . name == 'nt' : env [ 'PYTHONPATH' ] = ';' . join ( sys . path ) else : env [ 'PYTHONPATH' ] = ':' . join ( sys . path ) # Build the command and popen arguments depending on the OS\n if os . name == 'nt' : # Hide flashing command prompt\n startupinfo = subprocess . STARTUPINFO ( ) startupinfo . dwFlags |= subprocess . STARTF_USESHOWWINDOW shell = False else : startupinfo = None shell = True command = '\"{0}\" \"{1}\"' command = command . format ( python , restart_script ) try : if self . closing ( True ) : subprocess . Popen ( command , shell = shell , env = env , startupinfo = startupinfo ) self . console . quit ( ) except Exception as error : # If there is an error with subprocess, Spyder should not quit and\n # the error can be inspected in the internal console\n print ( error ) # spyder: test-skip\n print ( command )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Whether the item is a placeholder or contains a placeholder . [CODESPLIT] def _not_none ( items ) : if not isinstance ( items , ( tuple , list ) ) : items = ( items , ) return all ( item is not _none for item in items )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert an integer list into a string list . [CODESPLIT] def list_i2str ( ilist ) : slist = [ ] for el in ilist : slist . append ( str ( el ) ) return slist", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Thin wrapper around ElementTree . iterparse [CODESPLIT] def iterparse ( source , events = ( 'end' , ) , remove_comments = True , * * kw ) : return ElementTree . iterparse ( source , events , SourceLineParser ( ) , * * kw )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Allow \\ n . join ( ... ) statements to work in Py2 and Py3 . : param sep : : param joinable : : return : [CODESPLIT] def _py2_and_3_joiner ( sep , joinable ) : if ISPY3 : sep = bytes ( sep , DEFAULT_ENCODING ) joined = sep . join ( joinable ) return joined . decode ( DEFAULT_ENCODING ) if ISPY3 else joined", "target": 1, "target_options": ["no_match", "match"]}
{"input": "I convert strings into integers floats and strings! [CODESPLIT] def type_converter ( text ) : if text . isdigit ( ) : return int ( text ) , int try : return float ( text ) , float except ValueError : return text , STRING_TYPE", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prints as formatted JSON [CODESPLIT] def pprint ( j , no_pretty ) : if not no_pretty : click . echo ( json . dumps ( j , cls = PotionJSONEncoder , sort_keys = True , indent = 4 , separators = ( \",\" , \": \" ) ) ) else : click . echo ( j )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform check_array ( X ) after removing infinite values ( numpy . inf ) from the given distance matrix . [CODESPLIT] def check_precomputed_distance_matrix ( X ) : tmp = X . copy ( ) tmp [ np . isinf ( tmp ) ] = 1 check_array ( tmp )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Makes a classname [CODESPLIT] def classnameify ( s ) : return '' . join ( w if w in ACRONYMS else w . title ( ) for w in s . split ( '_' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set yaxis limits [CODESPLIT] def ylim ( self , low , high ) : self . chart [ 'yAxis' ] [ 0 ] [ 'min' ] = low self . chart [ 'yAxis' ] [ 0 ] [ 'max' ] = high return self", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns date range for the previous full month . [CODESPLIT] def get_previous_month ( self ) : end = utils . get_month_start ( ) - relativedelta ( days = 1 ) end = utils . to_datetime ( end ) start = utils . get_month_start ( end ) return start , end", "target": 1, "target_options": ["no_match", "match"]}
{"input": "takes flags returns indexes of True values [CODESPLIT] def equal ( list1 , list2 ) : return [ item1 == item2 for item1 , item2 in broadcast_zip ( list1 , list2 ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Linspace op . [CODESPLIT] def LinSpace ( start , stop , num ) : return np . linspace ( start , stop , num = num , dtype = np . float32 ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Acquire a lock on the output file prevents collisions between multiple runs . [CODESPLIT] def __enter__ ( self ) : self . fd = open ( self . filename , 'a' ) fcntl . lockf ( self . fd , fcntl . LOCK_EX ) return self . fd", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cosine interpolation [CODESPLIT] def interpolate_logscale_single ( start , end , coefficient ) : return np . exp ( np . log ( start ) + ( np . log ( end ) - np . log ( start ) ) * coefficient )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if key is in adict . The search is case insensitive . [CODESPLIT] def contains_case_insensitive ( adict , akey ) : for key in adict : if key . lower ( ) == akey . lower ( ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "generate a CamelCase string from an underscore_string . [CODESPLIT] def camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = '' for component in components : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def stdoutwriteline ( * args ) : s = \"\" for i in args : s += str ( i ) + \" \" s = s . strip ( ) sys . stdout . write ( str ( s ) + \"\\n\" ) sys . stdout . flush ( ) return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Configure a Domain registry entry . [CODESPLIT] def _config_win32_domain ( self , domain ) : # we call str() on domain to convert it from unicode to ascii self . domain = dns . name . from_text ( str ( domain ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns an RGB matrix scaled by a matplotlib color map [CODESPLIT] def apply_color_map ( name : str , mat : np . ndarray = None ) : def apply_map ( mat ) : return ( cm . get_cmap ( name ) ( _normalize ( mat ) ) [ : , : , : 3 ] * 255 ) . astype ( np . uint8 ) return apply_map if mat is None else apply_map ( mat )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the integer index of * series * in this sequence . [CODESPLIT] def series_index ( self , series ) : for idx , s in enumerate ( self ) : if series is s : return idx raise ValueError ( 'series not in chart data object' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Magnitude of a complex matrix . [CODESPLIT] def magnitude ( X ) : r = np . real ( X ) i = np . imag ( X ) return np . sqrt ( r * r + i * i )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get longitudes from cartesian coordinates . [CODESPLIT] def get_lons_from_cartesian ( x__ , y__ ) : return rad2deg ( arccos ( x__ / sqrt ( x__ ** 2 + y__ ** 2 ) ) ) * sign ( y__ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Item assignment sets the return value and removes any side effect [CODESPLIT] def __setitem__ ( self , _ignored , return_value ) : self . mock . return_value = return_value self . mock . side_effect = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is builtin in python2 but we have to roll our own on py3 . [CODESPLIT] def execfile ( fname , variables ) : with open ( fname ) as f : code = compile ( f . read ( ) , fname , 'exec' ) exec ( code , variables )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Init connection and consumer with openstack mq . [CODESPLIT] def init_mq ( self ) : mq = self . init_connection ( ) self . init_consumer ( mq ) return mq . connection", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the dot source representing the database in a string . [CODESPLIT] def _intermediary_to_dot ( tables , relationships ) : t = '\\n' . join ( t . to_dot ( ) for t in tables ) r = '\\n' . join ( r . to_dot ( ) for r in relationships ) return '{}\\n{}\\n{}\\n}}' . format ( GRAPH_BEGINNING , t , r )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return sanitized Eidos text field for human readability . [CODESPLIT] def _sanitize ( text ) : d = { '-LRB-' : '(' , '-RRB-' : ')' } return re . sub ( '|' . join ( d . keys ( ) ) , lambda m : d [ m . group ( 0 ) ] , text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Array of vector lengths [CODESPLIT] def length ( self ) : return np . sqrt ( np . sum ( self ** 2 , axis = 1 ) ) . view ( np . ndarray )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Downloads an URL and returns a file - like object open for reading compatible with zipping . ZipFile ( it has a seek () method ) . [CODESPLIT] def _download ( url ) : fh = StringIO ( ) for line in get ( url ) : fh . write ( line ) fh . seek ( 0 ) return fh", "target": 1, "target_options": ["no_match", "match"]}
{"input": "1x1 convolution [CODESPLIT] def conv1x1 ( in_planes , out_planes , stride = 1 ) : return nn . Conv2d ( in_planes , out_planes , kernel_size = 1 , stride = stride , bias = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "set our object attributes [CODESPLIT] def set_attrs ( self ) : self . attrs . encoding = self . encoding self . attrs . errors = self . errors", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Customize the lazy field [CODESPLIT] def update ( self , * * kwargs ) : assert not self . called self . kw . update ( kwargs ) return self", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate an empty texture in OpenGL [CODESPLIT] def _genTex2D ( self ) : for face in range ( 6 ) : gl . glTexImage2D ( self . target0 + face , 0 , self . internal_fmt , self . width , self . height , 0 , self . pixel_fmt , gl . GL_UNSIGNED_BYTE , 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a parition of given set into 1 - element subsets . [CODESPLIT] def trivial_partition ( set_ ) : ensure_countable ( set_ ) result = ( ( x , ) for x in set_ ) return _harmonize_subset_types ( set_ , result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the list of distinct values with preserving order . [CODESPLIT] def distinct ( xs ) : # don't use collections.OrderedDict because we do support Python 2.6 seen = set ( ) return [ x for x in xs if x not in seen and not seen . add ( x ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Matches a paren . [CODESPLIT] def match_paren ( self , tokens , item ) : match , = tokens return self . match ( match , item )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set a restore point ( copy the object ) then call the method . : return : obj . do_method ( * args ) [CODESPLIT] def do ( self ) : self . restore_point = self . obj . copy ( ) return self . do_method ( self . obj , * self . args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function that gets relative path to the filename [CODESPLIT] def rel_path ( filename ) : return os . path . join ( os . getcwd ( ) , os . path . dirname ( __file__ ) , filename )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the MachineGuid from HKEY_LOCAL_MACHINE \\ Software \\ Microsoft \\ Cryptography \\ MachineGuid [CODESPLIT] def get_nt_system_uid ( ) : try : import _winreg as winreg except ImportError : import winreg lm = winreg . ConnectRegistry ( None , winreg . HKEY_LOCAL_MACHINE ) try : key = winreg . OpenKey ( lm , r\"Software\\Microsoft\\Cryptography\" ) try : return winreg . QueryValueEx ( key , \"MachineGuid\" ) [ 0 ] finally : key . Close ( ) finally : lm . Close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write helper method [CODESPLIT] def write_to_file ( file_path , contents , encoding = \"utf-8\" ) : with codecs . open ( file_path , \"w\" , encoding ) as f : f . write ( contents )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check features data are not empty [CODESPLIT] def contains_empty ( features ) : if not features : return True for feature in features : if feature . shape [ 0 ] == 0 : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function prints the given String immediately and flushes the output . [CODESPLIT] def printOut ( value , end = '\\n' ) : sys . stdout . write ( value ) sys . stdout . write ( end ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a dictionary of strings from a file [CODESPLIT] def read_dict_from_file ( file_path ) : with open ( file_path ) as file : lines = file . read ( ) . splitlines ( ) obj = { } for line in lines : key , value = line . split ( ':' , maxsplit = 1 ) obj [ key ] = eval ( value ) return obj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert list of key value lists to dict [CODESPLIT] def list_of_lists_to_dict ( l ) : d = { } for key , val in l : d . setdefault ( key , [ ] ) . append ( val ) return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This loads a geojson file into a geojson python dictionary using the json module . Note : to load with a different text encoding use the encoding argument . [CODESPLIT] def _loadfilepath ( self , filepath , * * kwargs ) : with open ( filepath , \"r\" ) as f : data = json . load ( f , * * kwargs ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Disable the button if in non - expert mode ; unset its activity flag come - what - may . [CODESPLIT] def disable ( self ) : if not self . _expert : self . config ( state = 'disable' ) self . _active = False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function for fast reading from sensor files . [CODESPLIT] def _fast_read ( self , infile ) : infile . seek ( 0 ) return ( int ( infile . read ( ) . decode ( ) . strip ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Send data to specified socket . [CODESPLIT] def send ( socket , data , num_bytes = 20 ) : pickled_data = pickle . dumps ( data , - 1 ) length = str ( len ( pickled_data ) ) . zfill ( num_bytes ) socket . sendall ( length . encode ( ) ) socket . sendall ( pickled_data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the clipboard s text on OS X . [CODESPLIT] def osx_clipboard_get ( ) : p = subprocess . Popen ( [ 'pbpaste' , '-Prefer' , 'ascii' ] , stdout = subprocess . PIPE ) text , stderr = p . communicate ( ) # Text comes in with old Mac \\r line endings. Change them to \\n. text = text . replace ( '\\r' , '\\n' ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show the received object as precise as possible . [CODESPLIT] def _repr ( obj ) : vals = \", \" . join ( \"{}={!r}\" . format ( name , getattr ( obj , name ) ) for name in obj . _attribs ) if vals : t = \"{}(name={}, {})\" . format ( obj . __class__ . __name__ , obj . name , vals ) else : t = \"{}(name={})\" . format ( obj . __class__ . __name__ , obj . name ) return t", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Display the first and last n elements of a DataFrame . [CODESPLIT] def head_and_tail_print ( self , n = 5 ) : from IPython import display display . display ( display . HTML ( self . _head_and_tail_table ( n ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert to snake case . [CODESPLIT] def to_snake_case ( text ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates an InvalidArgumentError . [CODESPLIT] def __init__ ( self , node_def , op , message ) : super ( InvalidArgumentError , self ) . __init__ ( node_def , op , message , INVALID_ARGUMENT )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the unique elements of a collection even if those elements are unhashable and unsortable like dicts and sets [CODESPLIT] def unique ( seq ) : cleaned = [ ] for each in seq : if each not in cleaned : cleaned . append ( each ) return cleaned", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert to lowercase and strip spaces [CODESPLIT] def lowstrip ( term ) : term = re . sub ( '\\s+' , ' ' , term ) term = term . lower ( ) return term", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the a new dict with underscores instead of hyphens in keys . [CODESPLIT] def dict_keys_without_hyphens ( a_dict ) : return dict ( ( key . replace ( '-' , '_' ) , val ) for key , val in a_dict . items ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If item is not in lst add item to list at its sorted position [CODESPLIT] def insort_no_dup ( lst , item ) : import bisect ix = bisect . bisect_left ( lst , item ) if lst [ ix ] != item : lst [ ix : ix ] = [ item ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A non - optimal implementation of a regex filter [CODESPLIT] def subn_filter ( s , find , replace , count = 0 ) : return re . gsub ( find , replace , count , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the current time . [CODESPLIT] def now_time ( str = False ) : if str : return datetime . datetime . now ( ) . strftime ( \"%Y-%m-%d %H:%M:%S\" ) return datetime . datetime . now ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Entry point for the jupytext script [CODESPLIT] def jupytext_cli ( args = None ) : try : jupytext ( args ) except ( ValueError , TypeError , IOError ) as err : sys . stderr . write ( '[jupytext] Error: ' + str ( err ) + '\\n' ) exit ( 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a percentile range from an array of values . [CODESPLIT] def ci ( a , which = 95 , axis = None ) : p = 50 - which / 2 , 50 + which / 2 return percentiles ( a , p , axis )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the kind ( type ) of the attribute [CODESPLIT] def get_kind ( self , value ) : if isinstance ( value , float ) : return 'f' elif isinstance ( value , int ) : return 'i' else : raise ValueError ( \"Only integer or floating point values can be stored.\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "\\ returns the bytes of the image file on disk [CODESPLIT] def get_local_image ( self , src ) : return ImageUtils . store_image ( self . fetcher , self . article . link_hash , src , self . config )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "given an Nxm matrix containing boundary info between simplices compute indidence info matrix not very reusable ; should probably not be in this lib [CODESPLIT] def incidence ( boundary ) : return GroupBy ( boundary ) . split ( np . arange ( boundary . size ) // boundary . shape [ 1 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Select rows where the given field is not None . [CODESPLIT] def selectnotnone ( table , field , complement = False ) : return select ( table , field , lambda v : v is not None , complement = complement )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a string with comma or space - separated elements into a list . [CODESPLIT] def split_elements ( value ) : l = [ v . strip ( ) for v in value . split ( ',' ) ] if len ( l ) == 1 : l = value . split ( ) return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse datetime . [CODESPLIT] def parse_datetime ( dt_str ) : date_format = \"%Y-%m-%dT%H:%M:%S %z\" dt_str = dt_str . replace ( \"Z\" , \" +0000\" ) return datetime . datetime . strptime ( dt_str , date_format )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is a workaround where Collections are no longer iterable when using JPype . [CODESPLIT] def _listify ( collection ) : new_list = [ ] for index in range ( len ( collection ) ) : new_list . append ( collection [ index ] ) return new_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "yields a connected socket [CODESPLIT] def connected_socket ( address , timeout = 3 ) : sock = socket . create_connection ( address , timeout ) yield sock sock . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Order - preserving sorting function . [CODESPLIT] def csort ( objs , key ) : idxs = dict ( ( obj , i ) for ( i , obj ) in enumerate ( objs ) ) return sorted ( objs , key = lambda obj : ( key ( obj ) , idxs [ obj ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if a given string is an url [CODESPLIT] def is_valid_url ( url ) : pieces = urlparse ( url ) return all ( [ pieces . scheme , pieces . netloc ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split data into chunks of num chars each [CODESPLIT] def group ( data , num ) : return [ data [ i : i + num ] for i in range ( 0 , len ( data ) , num ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "manipulate json data on the fly [CODESPLIT] def set_json_item ( key , value ) : data = get_json ( ) data [ key ] = value request = get_request ( ) request [ \"BODY\" ] = json . dumps ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Saves the case as an Excel spreadsheet . [CODESPLIT] def save_excel ( self , fd ) : from pylon . io . excel import ExcelWriter ExcelWriter ( self ) . write ( fd )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract a ZIP archive to a directory [CODESPLIT] def unzip_file_to_dir ( path_to_zip , output_directory ) : z = ZipFile ( path_to_zip , 'r' ) z . extractall ( output_directory ) z . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cleanup cache tables . [CODESPLIT] def teardown ( self ) : for table_spec in reversed ( self . _table_specs ) : with self . _conn : table_spec . teardown ( self . _conn )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show intro to IPython help [CODESPLIT] def show_intro ( self ) : from IPython . core . usage import interactive_usage self . main . help . show_rich_text ( interactive_usage )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the string is only composed of hex characters . [CODESPLIT] def is_hex_string ( string ) : pattern = re . compile ( r'[A-Fa-f0-9]+' ) if isinstance ( string , six . binary_type ) : string = str ( string ) return pattern . match ( string ) is not None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse a float value node in the AST . [CODESPLIT] def parse_float_literal ( ast , _variables = None ) : if isinstance ( ast , ( FloatValueNode , IntValueNode ) ) : return float ( ast . value ) return INVALID", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert cartesian to lon lat . [CODESPLIT] def xyz2lonlat ( x , y , z ) : lon = xu . rad2deg ( xu . arctan2 ( y , x ) ) lat = xu . rad2deg ( xu . arctan2 ( z , xu . sqrt ( x ** 2 + y ** 2 ) ) ) return lon , lat", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a lowercased string with non alphabetic chars removed . [CODESPLIT] def _to_lower_alpha_only ( s ) : s = re . sub ( r'\\n' , ' ' , s . lower ( ) ) return re . sub ( r'[^a-z\\s]' , '' , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Suppress warning about untrusted SSL certificate . [CODESPLIT] def disable_insecure_request_warning ( ) : import requests from requests . packages . urllib3 . exceptions import InsecureRequestWarning requests . packages . urllib3 . disable_warnings ( InsecureRequestWarning )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "One more defense for GUI apps that call sys . excepthook . [CODESPLIT] def excepthook ( self , etype , value , tb ) : self . showtraceback ( ( etype , value , tb ) , tb_offset = 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Implements the if operator with support for multiple elseif - s . [CODESPLIT] def if_ ( * args ) : for i in range ( 0 , len ( args ) - 1 , 2 ) : if args [ i ] : return args [ i + 1 ] if len ( args ) % 2 : return args [ - 1 ] else : return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a character delimited version of the provided list as a Python string [CODESPLIT] def delimited ( items , character = '|' ) : return '|' . join ( items ) if type ( items ) in ( list , tuple , set ) else items", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Formats the given time into HH : MM : SS [CODESPLIT] def format_time ( time ) : h , r = divmod ( time / 1000 , 3600 ) m , s = divmod ( r , 60 ) return \"%02d:%02d:%02d\" % ( h , m , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the current time . [CODESPLIT] def now_time ( str = False ) : if str : return datetime . datetime . now ( ) . strftime ( \"%Y-%m-%d %H:%M:%S\" ) return datetime . datetime . now ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return time in milliseconds from start_time [CODESPLIT] def timespan ( start_time ) : timespan = datetime . datetime . now ( ) - start_time timespan_ms = timespan . total_seconds ( ) * 1000 return timespan_ms", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize time in arbitrary timezone to UTC naive object . [CODESPLIT] def normalize_time ( timestamp ) : offset = timestamp . utcoffset ( ) if offset is None : return timestamp return timestamp . replace ( tzinfo = None ) - offset", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function should be called instead of direct spio . loadmat as it cures the problem of not properly recovering python dictionaries from mat files . It calls the function check keys to cure all entries which are still mat - objects [CODESPLIT] def loadmat ( filename ) : data = sploadmat ( filename , struct_as_record = False , squeeze_me = True ) return _check_keys ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flush tornado iostream write buffer and prevent further writes . [CODESPLIT] def flush_on_close ( self , stream ) : assert get_thread_ident ( ) == self . ioloop_thread_id # Prevent futher writes stream . KATCPServer_closing = True # Write empty message to get future that resolves when buffer is flushed return stream . write ( '\\n' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts the table to a dict . [CODESPLIT] def to_dict ( self ) : return { \"name\" : self . table_name , \"kind\" : self . table_kind , \"data\" : [ r . to_dict ( ) for r in self ] }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform check_array ( X ) after removing infinite values ( numpy . inf ) from the given distance matrix . [CODESPLIT] def check_precomputed_distance_matrix ( X ) : tmp = X . copy ( ) tmp [ np . isinf ( tmp ) ] = 1 check_array ( tmp )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse bytes and return a namedtuple . [CODESPLIT] def unpack ( self , s ) : return self . _create ( super ( NamedStruct , self ) . unpack ( s ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param val_list : a list of strings : return : a list of upper - cased strings [CODESPLIT] def _upper ( val_list ) : res = [ ] for ele in val_list : res . append ( ele . upper ( ) ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Log memory usage before and after a method . [CODESPLIT] def memory_usage ( method ) : def wrapper ( * args , * * kwargs ) : logging . info ( 'Memory before method %s is %s.' , method . __name__ , runtime . memory_usage ( ) . current ( ) ) result = method ( * args , * * kwargs ) logging . info ( 'Memory after method %s is %s' , method . __name__ , runtime . memory_usage ( ) . current ( ) ) return result return wrapper", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets the median of a list of values Returns a float / int [CODESPLIT] def getMedian ( numericValues ) : theValues = sorted ( numericValues ) if len ( theValues ) % 2 == 1 : return theValues [ ( len ( theValues ) + 1 ) / 2 - 1 ] else : lower = theValues [ len ( theValues ) / 2 - 1 ] upper = theValues [ len ( theValues ) / 2 ] return ( float ( lower + upper ) ) / 2", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retries function until it doesn t raise an EINTR error [CODESPLIT] def retry_on_signal ( function ) : while True : try : return function ( ) except EnvironmentError , e : if e . errno != errno . EINTR : raise", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check that the page title matches the given one . [CODESPLIT] def page_title ( step , title ) : with AssertContextManager ( step ) : assert_equals ( world . browser . title , title )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The recommended development HTTP server . Note that this server performs additional buffering and will not honour chunked encoding breaks . [CODESPLIT] def serve ( application , host = '127.0.0.1' , port = 8080 , threads = 4 , * * kw ) : # Bind and start the server; this is a blocking process. serve_ ( application , host = host , port = int ( port ) , threads = int ( threads ) , * * kw )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show a basic reference about the GUI Console . [CODESPLIT] def page_guiref ( arg_s = None ) : from IPython . core import page page . page ( gui_reference , auto_html = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply a migration to the SQL server [CODESPLIT] def run_migration ( connection , queries , engine ) : # Execute query with connection . cursor ( ) as cursorMig : # Parse statements queries = parse_statements ( queries , engine ) for query in queries : cursorMig . execute ( query ) connection . commit ( ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The title of this window [CODESPLIT] def title ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . title", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Upload to neo4j . [CODESPLIT] def neo ( graph : BELGraph , connection : str , password : str ) : import py2neo neo_graph = py2neo . Graph ( connection , password = password ) to_neo4j ( graph , neo_graph )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Writes a dictionary to a yaml file : param dictionary : the dictionary to be written : param path : the absolute path of the target yaml file : param kwargs : optional additional parameters for dumper [CODESPLIT] def write_dict_to_yaml ( dictionary , path , * * kwargs ) : with open ( path , 'w' ) as f : yaml . dump ( dictionary , f , indent = 4 , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Note that this code compresses into a buffer held in memory rather than a disk file . This is done through the use of cStringIO . StringIO () . [CODESPLIT] def compressBuffer ( buffer ) : # http://jython.xhaus.com/http-compression-in-python-and-jython/ zbuf = cStringIO . StringIO ( ) zfile = gzip . GzipFile ( mode = 'wb' , fileobj = zbuf , compresslevel = 9 ) zfile . write ( buffer ) zfile . close ( ) return zbuf . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "str to bytes ( py3k ) [CODESPLIT] def to_bytes ( value ) : vtype = type ( value ) if vtype == bytes or vtype == type ( None ) : return value try : return vtype . encode ( value ) except UnicodeEncodeError : pass return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Do all elements of x have a type from types? [CODESPLIT] def _valid_other_type ( x , types ) : return all ( any ( isinstance ( el , t ) for t in types ) for el in np . ravel ( x ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test whether or not a psycopg2 - pgevents trigger is installed for a table . [CODESPLIT] def trigger_installed ( connection : connection , table : str , schema : str = 'public' ) : installed = False log ( 'Checking if {}.{} trigger installed...' . format ( schema , table ) , logger_name = _LOGGER_NAME ) statement = SELECT_TRIGGER_STATEMENT . format ( table = table , schema = schema ) result = execute ( connection , statement ) if result : installed = True log ( '...{}installed' . format ( '' if installed else 'NOT ' ) , logger_name = _LOGGER_NAME ) return installed", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A magic method to implement shallow copy behavior . [CODESPLIT] def __copy__ ( self ) : return self . __class__ . load ( self . dump ( ) , context = self . context )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "http : // stackoverflow . com / questions / 5098580 / implementing - argmax - in - python [CODESPLIT] def argmax ( l , f = None ) : if f : l = [ f ( i ) for i in l ] return max ( enumerate ( l ) , key = lambda x : x [ 1 ] ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the depth of the longest branch of the tree [CODESPLIT] def maxDepth ( self , currentDepth = 0 ) : if not any ( ( self . left , self . right ) ) : return currentDepth result = 0 for child in ( self . left , self . right ) : if child : result = max ( result , child . maxDepth ( currentDepth + 1 ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Writes the string to stdout [CODESPLIT] def _stdout_raw ( self , s ) : print ( s , end = '' , file = sys . stdout ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip apostrophe and s from the end of a string . [CODESPLIT] def unapostrophe ( text ) : text = re . sub ( r'[%s]s?$' % '' . join ( APOSTROPHES ) , '' , text ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the argument is a readable file - like object . [CODESPLIT] def _is_readable ( self , obj ) : try : read = getattr ( obj , 'read' ) except AttributeError : return False else : return is_method ( read , max_arity = 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a csv and returns a List of Dicts with keys given by header row . [CODESPLIT] def csv_to_dicts ( file , header = None ) : with open ( file ) as csvfile : return [ row for row in csv . DictReader ( csvfile , fieldnames = header ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Are we being asked to look up a list of things instead of a single thing? We check for the __iter__ attribute so that this can cover types that don t have to be known by this module such as NumPy arrays . [CODESPLIT] def is_iterable ( obj ) : return ( hasattr ( obj , \"__iter__\" ) and not isinstance ( obj , str ) and not isinstance ( obj , tuple ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a comma separated option into a list . [CODESPLIT] def split_comma_argument ( comma_sep_str ) : terms = [ ] for term in comma_sep_str . split ( ',' ) : if term : terms . append ( term ) return terms", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fill the matrix with the given RGB color [CODESPLIT] def fillScreen ( self , color = None ) : md . fill_rect ( self . set , 0 , 0 , self . width , self . height , color )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "swap and then flatten axes 0 and 1 [CODESPLIT] def sf01 ( arr ) : s = arr . shape return arr . swapaxes ( 0 , 1 ) . reshape ( s [ 0 ] * s [ 1 ] , * s [ 2 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts parameter matrices into an array . [CODESPLIT] def __unroll ( self , rolled ) : return np . array ( np . concatenate ( [ matrix . flatten ( ) for matrix in rolled ] , axis = 1 ) ) . reshape ( - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Downgrade database . [CODESPLIT] def downgrade ( ) : op . drop_table ( 'transaction' ) if op . _proxy . migration_context . dialect . supports_sequences : op . execute ( DropSequence ( Sequence ( 'transaction_id_seq' ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Performs a parallel mapping of the given iterable reporting a progress bar as values get returned . Yields objects as soon as they re computed but does not guarantee that they ll be in the correct order . [CODESPLIT] def iparallel_progbar ( mapper , iterable , nprocs = None , starmap = False , flatmap = False , shuffle = False , verbose = True , verbose_flatmap = None , max_cache = - 1 , * * kwargs ) : results = _parallel_progbar_launch ( mapper , iterable , nprocs , starmap , flatmap , shuffle , verbose , verbose_flatmap , max_cache , * * kwargs ) return ( x for i , x in results )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Makes a classname [CODESPLIT] def classnameify ( s ) : return '' . join ( w if w in ACRONYMS else w . title ( ) for w in s . split ( '_' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Entry point for the jupytext script [CODESPLIT] def jupytext_cli ( args = None ) : try : jupytext ( args ) except ( ValueError , TypeError , IOError ) as err : sys . stderr . write ( '[jupytext] Error: ' + str ( err ) + '\\n' ) exit ( 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Unignores all channels in this server from being processed . [CODESPLIT] async def unignore_all ( self , ctx ) : channels = [ c for c in ctx . message . server . channels if c . type is discord . ChannelType . text ] await ctx . invoke ( self . unignore , * channels )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get target size for a cropped image and do the resizing if we got anything usable . [CODESPLIT] def resize ( self ) : resized_size = self . get_resized_size ( ) if not resized_size : return self . image = self . image . resize ( resized_size , Image . ANTIALIAS )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "kwarg values always have defaults [CODESPLIT] def test_kwargs_are_optional ( self ) : with patch ( \"sys.exit\" ) as mock_exit : cli = MicroCLITestCase . T ( \"script_name f3\" . split ( ) ) . run ( ) # kwargs are optional mock_exit . assert_called_with ( 4 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "extract features in a sentence [CODESPLIT] def sent2features ( sentence , template ) : return [ word2features ( sentence , i , template ) for i in range ( len ( sentence ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Selectively log an accepted request . [CODESPLIT] def log_request ( self , code = '-' , size = '-' ) : if self . server . logRequests : BaseHTTPServer . BaseHTTPRequestHandler . log_request ( self , code , size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is largely copied from bokeh . sphinxext . bokeh_plot . run [CODESPLIT] def get_code_language ( self ) : js_source = self . get_js_source ( ) if self . options . get ( \"include_html\" , False ) : resources = get_sphinx_resources ( include_bokehjs_api = True ) html_source = BJS_HTML . render ( css_files = resources . css_files , js_files = resources . js_files , bjs_script = js_source ) return [ html_source , \"html\" ] else : return [ js_source , \"javascript\" ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Random uniform op . [CODESPLIT] def RandomShuffle ( a , seed ) : if seed : np . random . seed ( seed ) r = a . copy ( ) np . random . shuffle ( r ) return r ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param timeperiod : as string in YYYYMMDD00 format : return string in YYYYMM0000 format [CODESPLIT] def day_to_month ( timeperiod ) : t = datetime . strptime ( timeperiod , SYNERGY_DAILY_PATTERN ) return t . strftime ( SYNERGY_MONTHLY_PATTERN )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Bytes are encoded as a long followed by that many bytes of data . [CODESPLIT] def read_bytes ( fo , writer_schema = None , reader_schema = None ) : size = read_long ( fo ) return fo . read ( size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a Python 2 function as lambda ( x y ) : x + y In the Python 3 format : lambda x y : x + y [CODESPLIT] def lambda_tuple_converter ( func ) : if func is not None and func . __code__ . co_argcount == 1 : return lambda * args : func ( args [ 0 ] if len ( args ) == 1 else args ) else : return func", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Push a new value into heap . [CODESPLIT] def push ( h , x ) : h . push ( x ) up ( h , h . size ( ) - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert string column into datetime column [CODESPLIT] def convert_str_to_datetime ( df , * , column : str , format : str ) : df [ column ] = pd . to_datetime ( df [ column ] , format = format ) return df", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Communicate with the child process without closing stdin . [CODESPLIT] def correspond ( text ) : subproc . stdin . write ( text ) subproc . stdin . flush ( ) return drain ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the file - like object is readable . [CODESPLIT] def is_readable ( fp , size = 1 ) : read_size = len ( fp . read ( size ) ) fp . seek ( - read_size , 1 ) return read_size == size", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove commas from a float [CODESPLIT] def clean_float ( v ) : if v is None or not str ( v ) . strip ( ) : return None return float ( str ( v ) . replace ( ',' , '' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Similar to print but prints to stderr . [CODESPLIT] def print_err ( * args , end = '\\n' ) : print ( * args , end = end , file = sys . stderr ) sys . stderr . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert to timestamp . [CODESPLIT] async def iso ( self , source ) : from datetime import datetime unix_timestamp = int ( source ) return datetime . fromtimestamp ( unix_timestamp ) . isoformat ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if arg is a valid file that already exists on the file system . [CODESPLIT] def is_valid_folder ( parser , arg ) : arg = os . path . abspath ( arg ) if not os . path . isdir ( arg ) : parser . error ( \"The folder %s does not exist!\" % arg ) else : return arg", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if obj is number . [CODESPLIT] def is_number ( obj ) : return isinstance ( obj , ( int , float , np . int_ , np . float_ ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Copy [CODESPLIT] def getBuffer ( x ) : b = bytes ( x ) return ( c_ubyte * len ( b ) ) . from_buffer_copy ( bytes ( x ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator to make sure that user is root . [CODESPLIT] def require_root ( fn ) : @ wraps ( fn ) def xex ( * args , * * kwargs ) : assert os . geteuid ( ) == 0 , \"You have to be root to run function '%s'.\" % fn . __name__ return fn ( * args , * * kwargs ) return xex", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if obj is a sequence but not a string or bytes . [CODESPLIT] def is_sequence ( obj ) : return isinstance ( obj , Sequence ) and not ( isinstance ( obj , str ) or BinaryClass . is_valid_type ( obj ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A function that works for both Python 2 . x and Python 3 . x . It asks the user for input and returns it as a string . [CODESPLIT] def input_int_default ( question = \"\" , default = 0 ) : answer = input_string ( question ) if answer == \"\" or answer == \"yes\" : return default else : return int ( answer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if a Path or string is a file on the file system . [CODESPLIT] def is_file ( path ) : try : return path . expanduser ( ) . absolute ( ) . is_file ( ) except AttributeError : return os . path . isfile ( os . path . abspath ( os . path . expanduser ( str ( path ) ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets the config data value for the specified dictionary key [CODESPLIT] def setConfigKey ( key , value ) : configFile = ConfigurationManager . _configFile ( ) return JsonDataManager ( configFile ) . setKey ( key , value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a UUID . [CODESPLIT] def generate_uuid ( ) : r_uuid = base64 . urlsafe_b64encode ( uuid . uuid4 ( ) . bytes ) return r_uuid . decode ( ) . replace ( '=' , '' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an appropriate positive infinity for this dtype . [CODESPLIT] def get_neg_infinity ( dtype ) : if issubclass ( dtype . type , ( np . floating , np . integer ) ) : return - np . inf if issubclass ( dtype . type , np . complexfloating ) : return - np . inf - 1j * np . inf return NINF", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Temporary helper function to link to the API routes [CODESPLIT] def home ( ) : return dict ( links = dict ( api = '{}{}' . format ( request . url , PREFIX [ 1 : ] ) ) ) , HTTPStatus . OK", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip # markers at the front of a block of comment text . [CODESPLIT] def strip_comment_marker ( text ) : lines = [ ] for line in text . splitlines ( ) : lines . append ( line . lstrip ( '#' ) ) text = textwrap . dedent ( '\\n' . join ( lines ) ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse a tool definition into a cwl2wdl style dictionary . [CODESPLIT] def _tool_to_dict ( tool ) : out = { \"name\" : _id_to_name ( tool . tool [ \"id\" ] ) , \"baseCommand\" : \" \" . join ( tool . tool [ \"baseCommand\" ] ) , \"arguments\" : [ ] , \"inputs\" : [ _input_to_dict ( i ) for i in tool . tool [ \"inputs\" ] ] , \"outputs\" : [ _output_to_dict ( o ) for o in tool . tool [ \"outputs\" ] ] , \"requirements\" : _requirements_to_dict ( tool . requirements + tool . hints ) , \"stdin\" : None , \"stdout\" : None } return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pop - up menu and wx . EVT_CLOSE closing event [CODESPLIT] def on_close ( self , evt ) : self . stop ( ) # DoseWatcher if evt . EventObject is not self : # Avoid deadlocks self . Close ( ) # wx.Frame evt . Skip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Close the db and release memory [CODESPLIT] def close ( self ) : if self . db is not None : self . db . commit ( ) self . db . close ( ) self . db = None return", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Bytes are encoded as a long followed by that many bytes of data . [CODESPLIT] def read_bytes ( fo , writer_schema = None , reader_schema = None ) : size = read_long ( fo ) return fo . read ( size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Appends tzinfo and assumes UTC if datetime object has no tzinfo already . [CODESPLIT] def make_aware ( dt ) : return dt if dt . tzinfo else dt . replace ( tzinfo = timezone . utc )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calcuate median datetime from datetime list [CODESPLIT] def median_date ( dt_list ) : #dt_list_sort = sorted(dt_list) idx = len ( dt_list ) / 2 if len ( dt_list ) % 2 == 0 : md = mean_date ( [ dt_list [ idx - 1 ] , dt_list [ idx ] ] ) else : md = dt_list [ idx ] return md", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts python datetime to epoch microseconds . [CODESPLIT] def _DateToEpoch ( date ) : tz_zero = datetime . datetime . utcfromtimestamp ( 0 ) diff_sec = int ( ( date - tz_zero ) . total_seconds ( ) ) return diff_sec * 1000000", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shot noise corruption to images . [CODESPLIT] def shot_noise ( x , severity = 1 ) : c = [ 60 , 25 , 12 , 5 , 3 ] [ severity - 1 ] x = np . array ( x ) / 255. x_clip = np . clip ( np . random . poisson ( x * c ) / float ( c ) , 0 , 1 ) * 255 return around_and_astype ( x_clip )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show / hide system console window attached to current process . Return it s previous state . Availability : Windows [CODESPLIT] def set_attached_console_visible ( state ) : flag = { True : SW_SHOW , False : SW_HIDE } return bool ( ShowWindow ( console_window_handle , flag [ state ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Implements string formatting along with color specified in colorama . Fore [CODESPLIT] def colorize ( string , color , * args , * * kwargs ) : string = string . format ( * args , * * kwargs ) return color + string + colorama . Fore . RESET", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shot noise corruption to images . [CODESPLIT] def shot_noise ( x , severity = 1 ) : c = [ 60 , 25 , 12 , 5 , 3 ] [ severity - 1 ] x = np . array ( x ) / 255. x_clip = np . clip ( np . random . poisson ( x * c ) / float ( c ) , 0 , 1 ) * 255 return around_and_astype ( x_clip )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Saves a representation of the case in the Graphviz DOT language . [CODESPLIT] def save_dot ( self , fd ) : from pylon . io import DotWriter DotWriter ( self ) . write ( fd )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a vector of the masked data . [CODESPLIT] def mask_and_flatten ( self ) : self . _check_for_mask ( ) return self . get_data ( smoothed = True , masked = True , safe_copy = False ) [ self . get_mask_indices ( ) ] , self . get_mask_indices ( ) , self . mask . shape", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determines the height and width of the console window [CODESPLIT] def size ( ) : try : assert os != 'nt' and sys . stdout . isatty ( ) rows , columns = os . popen ( 'stty size' , 'r' ) . read ( ) . split ( ) except ( AssertionError , AttributeError , ValueError ) : # in case of failure, use dimensions of a full screen 13\" laptop rows , columns = DEFAULT_HEIGHT , DEFAULT_WIDTH return int ( rows ) , int ( columns )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a name which includes the module name and function name . [CODESPLIT] def get_func_name ( func ) : func_name = getattr ( func , '__name__' , func . __class__ . __name__ ) module_name = func . __module__ if module_name is not None : module_name = func . __module__ return '{}.{}' . format ( module_name , func_name ) return func_name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes dict keys which have have self as value . [CODESPLIT] def _remove_dict_keys_with_value ( dict_ , val ) : return { k : v for k , v in dict_ . items ( ) if v is not val }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn an arbitrary object into a unicode string . If complex ( dict / list / tuple ) will be json - encoded . [CODESPLIT] def obj_to_string ( obj , top = True ) : obj = prepare_for_json_encoding ( obj ) if type ( obj ) == six . text_type : return obj return json . dumps ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the angle between two vectors [CODESPLIT] def angle ( vec1 , vec2 ) : dot_vec = dot ( vec1 , vec2 ) mag1 = vec1 . length ( ) mag2 = vec2 . length ( ) result = dot_vec / ( mag1 * mag2 ) return math . acos ( result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def get_enum_documentation ( class_name , module_name , enum_class_object ) : documentation = \"\"\".. _{module_name}.{class_name}:\n\n``enum {class_name}``\n+++++++{plus}++\n\n**module:** ``{module_name}``\"\"\" . format ( module_name = module_name , class_name = class_name , plus = '+' * len ( class_name ) , ) if enum_class_object . __doc__ and enum_class_object . __doc__ . strip ( ) : documentation += '\\n\\n{}' . format ( _clean_literals ( inspect . cleandoc ( enum_class_object . __doc__ ) ) ) documentation += '\\n\\nConstant Values:\\n' for e in enum_class_object : documentation += '\\n- ``{}`` (``{}``)' . format ( e . name , repr ( e . value ) . lstrip ( 'u' ) ) return documentation", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is builtin in python2 but we have to roll our own on py3 . [CODESPLIT] def execfile ( fname , variables ) : with open ( fname ) as f : code = compile ( f . read ( ) , fname , 'exec' ) exec ( code , variables )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Draw a set of lines [CODESPLIT] def polyline ( self , arr ) : for i in range ( 0 , len ( arr ) - 1 ) : self . line ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] , arr [ i + 1 ] [ 0 ] , arr [ i + 1 ] [ 1 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transpose the columns into rows remove all of the rows that are empty after the first cell then transpose back . The result is that columns that have a header but no data in the body are removed assuming the header is the first row . [CODESPLIT] def drop_empty ( rows ) : return zip ( * [ col for col in zip ( * rows ) if bool ( filter ( bool , col [ 1 : ] ) ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a copy of dct without keys keys [CODESPLIT] def _delete_keys ( dct , keys ) : c = deepcopy ( dct ) assert isinstance ( keys , list ) for k in keys : c . pop ( k ) return c", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Center all lines of the text . It is assumed that all lines width is smaller then B { width } because the line width will not be checked . Args : text ( str ) : Text to wrap . width ( int ) : Maximum number of characters per line . Returns : str : Centered text . [CODESPLIT] def center_text ( text , width = 80 ) : centered = [ ] for line in text . splitlines ( ) : centered . append ( line . center ( width ) ) return \"\\n\" . join ( centered )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Performs a secondary index query . [CODESPLIT] def get_index ( self , bucket , index , startkey , endkey = None , return_terms = None , max_results = None , continuation = None , timeout = None , term_regex = None ) : raise NotImplementedError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Re - index every document in a named index . [CODESPLIT] def update_index ( index ) : logger . info ( \"Updating search index: '%s'\" , index ) client = get_client ( ) responses = [ ] for model in get_index_models ( index ) : logger . info ( \"Updating search index model: '%s'\" , model . search_doc_type ) objects = model . objects . get_search_queryset ( index ) . iterator ( ) actions = bulk_actions ( objects , index = index , action = \"index\" ) response = helpers . bulk ( client , actions , chunk_size = get_setting ( \"chunk_size\" ) ) responses . append ( response ) return responses", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert to timestamp . [CODESPLIT] async def iso ( self , source ) : from datetime import datetime unix_timestamp = int ( source ) return datetime . fromtimestamp ( unix_timestamp ) . isoformat ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a grayscale image to BGR image . [CODESPLIT] def gray2bgr ( img ) : img = img [ ... , None ] if img . ndim == 2 else img out_img = cv2 . cvtColor ( img , cv2 . COLOR_GRAY2BGR ) return out_img", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Hex encode a binary string [CODESPLIT] def hex_escape ( bin_str ) : printable = string . ascii_letters + string . digits + string . punctuation + ' ' return '' . join ( ch if ch in printable else r'0x{0:02x}' . format ( ord ( ch ) ) for ch in bin_str )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This method asserts that only one value of the provided list is True . [CODESPLIT] def assert_exactly_one_true ( bool_list ) : assert isinstance ( bool_list , list ) counter = 0 for item in bool_list : if item : counter += 1 return counter == 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "When the with statement ends . [CODESPLIT] def __exit__ ( self , type , value , traceback ) : if not self . asarfile : return self . asarfile . close ( ) self . asarfile = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if a line consists only of a single punctuation character . [CODESPLIT] def is_delimiter ( line ) : return bool ( line ) and line [ 0 ] in punctuation and line [ 0 ] * len ( line ) == line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert notebook to python script [CODESPLIT] def nb_to_python ( nb_path ) : exporter = python . PythonExporter ( ) output , resources = exporter . from_filename ( nb_path ) return output", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks whether the re module can compile the given regular expression . [CODESPLIT] def is_valid_regex ( string ) : try : re . compile ( string ) is_valid = True except re . error : is_valid = False return is_valid", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def resize ( self , width , height ) : self . _buffer = QtGui . QImage ( width , height , QtGui . QImage . Format_RGB32 ) QtGui . QWidget . resize ( self , width , height )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the location of the static data directory . [CODESPLIT] def staticdir ( ) : root = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( root , \"static\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the location of the static data directory . [CODESPLIT] def staticdir ( ) : root = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( root , \"static\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a flatten version of the nested argument [CODESPLIT] def flatten ( nested ) : flat_return = list ( ) def __inner_flat ( nested , flat ) : for i in nested : __inner_flat ( i , flat ) if isinstance ( i , list ) else flat . append ( i ) return flat __inner_flat ( nested , flat_return ) return flat_return", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Private method for converting a single PNG image to a PDF . [CODESPLIT] def _convert ( self , image , output = None ) : with Image . open ( image ) as im : width , height = im . size co = CanvasObjects ( ) co . add ( CanvasImg ( image , 1.0 , w = width , h = height ) ) return WatermarkDraw ( co , tempdir = self . tempdir , pagesize = ( width , height ) ) . write ( output )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the pythonic string type . [CODESPLIT] def visit_Str ( self , node ) : self . result [ node ] = self . builder . NamedType ( pytype_to_ctype ( str ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the error rate based on dense predictions and 1 - hot labels . [CODESPLIT] def error_rate ( predictions , labels ) : return 100.0 - ( 100.0 * np . sum ( np . argmax ( predictions , 1 ) == np . argmax ( labels , 1 ) ) / predictions . shape [ 0 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Computes the RMS energy of frames [CODESPLIT] def RMS_energy ( frames ) : f = frames . flatten ( ) return N . sqrt ( N . mean ( f * f ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list of literal values . [CODESPLIT] def INIT_LIST_EXPR ( self , cursor ) : values = [ self . parse_cursor ( child ) for child in list ( cursor . get_children ( ) ) ] return values", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert Matrix attributes which are array - like or buffer to array . [CODESPLIT] def _convert_to_array ( array_like , dtype ) : if isinstance ( array_like , bytes ) : return np . frombuffer ( array_like , dtype = dtype ) return np . asarray ( array_like , dtype = dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks whether the remote file exists . [CODESPLIT] def remote_file_exists ( self , url ) : status = requests . head ( url ) . status_code if status != 200 : raise RemoteFileDoesntExist", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coroutine called by MapAsync . It s wrapping the call of run_in_executor to run the synchronous function as thread [CODESPLIT] async def _thread_coro ( self , * args ) : return await self . _loop . run_in_executor ( self . _executor , self . _function , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function that returns the node data of the node with the name supplied [CODESPLIT] def get_the_node_dict ( G , name ) : for node in G . nodes ( data = True ) : if node [ 0 ] == name : return node [ 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The url of this window [CODESPLIT] def url ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . url", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a copy of seq without duplicates . [CODESPLIT] def uniq ( seq ) : seen = set ( ) return [ x for x in seq if str ( x ) not in seen and not seen . add ( str ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns this programs current memory usage in bytes [CODESPLIT] def current_memory_usage ( ) : import psutil proc = psutil . Process ( os . getpid ( ) ) #meminfo = proc.get_memory_info() meminfo = proc . memory_info ( ) rss = meminfo [ 0 ] # Resident Set Size / Mem Usage vms = meminfo [ 1 ] # Virtual Memory Size / VM Size  # NOQA return rss", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the first day of the current week . [CODESPLIT] def snap_to_beginning_of_week ( day , weekday_start = \"Sunday\" ) : delta_days = ( ( day . weekday ( ) + 1 ) % 7 ) if weekday_start is \"Sunday\" else day . weekday ( ) return day - timedelta ( days = delta_days )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple function to convert naive : std : datetime . datetime object containing local time to a naive : std : datetime . datetime object with UTC time . [CODESPLIT] def datetime_local_to_utc ( local ) : timestamp = time . mktime ( local . timetuple ( ) ) return datetime . datetime . utcfromtimestamp ( timestamp )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "parse the domain from the url [CODESPLIT] def parse_domain ( url ) : domain_match = lib . DOMAIN_REGEX . match ( url ) if domain_match : return domain_match . group ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a ( probably ) unique ID to identify a system . Used to differentiate votes . [CODESPLIT] def get_system_uid ( ) : try : if os . name == 'nt' : return get_nt_system_uid ( ) if sys . platform == 'darwin' : return get_osx_system_uid ( ) except Exception : return get_mac_uid ( ) else : return get_mac_uid ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transpose the columns into rows remove all of the rows that are empty after the first cell then transpose back . The result is that columns that have a header but no data in the body are removed assuming the header is the first row . [CODESPLIT] def drop_empty ( rows ) : return zip ( * [ col for col in zip ( * rows ) if bool ( filter ( bool , col [ 1 : ] ) ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get the current month s last day : param year : default to current year : param month : default to current month : return : month s last day [CODESPLIT] def last_day ( year = _year , month = _month ) : last_day = calendar . monthrange ( year , month ) [ 1 ] return datetime . date ( year = year , month = month , day = last_day )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the magnitude of a vector . [CODESPLIT] def mag ( z ) : if isinstance ( z [ 0 ] , np . ndarray ) : return np . array ( list ( map ( np . linalg . norm , z ) ) ) else : return np . linalg . norm ( z )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get size of longest value in specific column [CODESPLIT] def _longest_val_in_column ( self , col ) : try : # +2 is for implicit separator return max ( [ len ( x [ col ] ) for x in self . table if x [ col ] ] ) + 2 except KeyError : logger . error ( \"there is no column %r\" , col ) raise", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a json string representing the python object obj . [CODESPLIT] def to_json ( obj ) : i = StringIO . StringIO ( ) w = Writer ( i , encoding = 'UTF-8' ) w . write_value ( obj ) return i . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": type root : TreeNode : rtype : int [CODESPLIT] def min_depth ( self , root ) : if root is None : return 0 if root . left is not None or root . right is not None : return max ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1 return min ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Encodes a whole batch of input arrays without learning . [CODESPLIT] def encode_batch ( self , inputBatch ) : X = inputBatch encode = self . encode Y = np . array ( [ encode ( x ) for x in X ] ) return Y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a text into separate words . [CODESPLIT] def tokenize_list ( self , text ) : return [ self . get_record_token ( record ) for record in self . analyze ( text ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Portable cast function . [CODESPLIT] def to_binary ( s , encoding = 'utf8' ) : if PY3 : # pragma: no cover return s if isinstance ( s , binary_type ) else binary_type ( s , encoding = encoding ) return binary_type ( s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of keys for the sparse matrix . [CODESPLIT] def get_sparse_matrix_keys ( session , key_table ) : return session . query ( key_table ) . order_by ( key_table . name ) . all ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "helper function for parsing FRED date string into datetime [CODESPLIT] def _parse ( self , date_str , format = '%Y-%m-%d' ) : rv = pd . to_datetime ( date_str , format = format ) if hasattr ( rv , 'to_pydatetime' ) : rv = rv . to_pydatetime ( ) return rv", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper to open a : class : h5py . File from disk gracefully handling a few corner cases [CODESPLIT] def open_hdf5 ( filename , mode = 'r' ) : if isinstance ( filename , ( h5py . Group , h5py . Dataset ) ) : return filename if isinstance ( filename , FILE_LIKE ) : return h5py . File ( filename . name , mode ) return h5py . File ( filename , mode )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper to open a : class : h5py . File from disk gracefully handling a few corner cases [CODESPLIT] def open_hdf5 ( filename , mode = 'r' ) : if isinstance ( filename , ( h5py . Group , h5py . Dataset ) ) : return filename if isinstance ( filename , FILE_LIKE ) : return h5py . File ( filename . name , mode ) return h5py . File ( filename , mode )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Produces a nicer graph I m not sure if this is correct [CODESPLIT] def scaled_fft ( fft , scale = 1.0 ) : data = np . zeros ( len ( fft ) ) for i , v in enumerate ( fft ) : data [ i ] = scale * ( i * v ) / NUM_SAMPLES return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extends with class or function [CODESPLIT] def extend_with ( func ) : if not func . __name__ in ArgParseInator . _plugins : ArgParseInator . _plugins [ func . __name__ ] = func", "target": 1, "target_options": ["no_match", "match"]}
{"input": "round the data [CODESPLIT] def round_data ( filter_data ) : for index , _ in enumerate ( filter_data ) : filter_data [ index ] [ 0 ] = round ( filter_data [ index ] [ 0 ] / 100.0 ) * 100.0 return filter_data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the billing cycle prior to this one . May return None [CODESPLIT] def get_previous ( self ) : return BillingCycle . objects . filter ( date_range__lt = self . date_range ) . order_by ( 'date_range' ) . last ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the index of the closest in xarr to value val [CODESPLIT] def closest ( xarr , val ) : idx_closest = np . argmin ( np . abs ( np . array ( xarr ) - val ) ) return idx_closest", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The function compares strings ignoring case [CODESPLIT] def is_equal_strings_ignore_case ( first , second ) : if first and second : return first . upper ( ) == second . upper ( ) else : return not ( first or second )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is the current OS a Windows? [CODESPLIT] def _platform_is_windows ( platform = sys . platform ) : matched = platform in ( 'cygwin' , 'win32' , 'win64' ) if matched : error_msg = \"Windows isn't supported yet\" raise OSError ( error_msg ) return matched", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns the unit tangent vector of the segment at t ( centered at the origin and expressed as a complex number ) . [CODESPLIT] def unit_tangent ( self , t ) : dseg = self . derivative ( t ) return dseg / abs ( dseg )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get longitudes from cartesian coordinates . [CODESPLIT] def get_lons_from_cartesian ( x__ , y__ ) : return rad2deg ( arccos ( x__ / sqrt ( x__ ** 2 + y__ ** 2 ) ) ) * sign ( y__ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform a O ( 1 ) memory hash of an iterable of arbitrary length . [CODESPLIT] def hash_iterable ( it ) : hash_value = hash ( type ( it ) ) for value in it : hash_value = hash ( ( hash_value , value ) ) return hash_value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handle many to many relationships [CODESPLIT] def handle_m2m ( self , sender , instance , * * kwargs ) : self . handle_save ( instance . __class__ , instance )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate random id numbers . [CODESPLIT] def generate_random_id ( size = 6 , chars = string . ascii_uppercase + string . digits ) : return \"\" . join ( random . choice ( chars ) for x in range ( size ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Scroll both categories Canvas and scrolling container [CODESPLIT] def _set_scroll_v ( self , * args ) : self . _canvas_categories . yview ( * args ) self . _canvas_scroll . yview ( * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The title of this window [CODESPLIT] def title ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . title", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the attribute name identifier [CODESPLIT] def get_attribute_name_id ( attr ) : return attr . value . id if isinstance ( attr . value , ast . Name ) else None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Estimates the memory of the supplied array in bytes [CODESPLIT] def array_bytes ( array ) : return np . product ( array . shape ) * np . dtype ( array . dtype ) . itemsize", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reopen the tough connection . [CODESPLIT] def reopen ( self ) : try : self . _con . reopen ( ) except Exception : if self . _transcation : self . _transaction = False try : self . _con . query ( 'rollback' ) except Exception : pass else : self . _transaction = False self . _closed = False self . _setsession ( ) self . _usage = 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Native connection object . [CODESPLIT] def native_conn ( self ) : if self . __native is None : self . __native = self . _get_connection ( ) return self . __native", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the given code line by line with printing as list of lines and return variable ans . [CODESPLIT] def runcode ( code ) : for line in code : print ( '# ' + line ) exec ( line , globals ( ) ) print ( '# return ans' ) return ans", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a US format date and return epoch . [CODESPLIT] def AmericanDateToEpoch ( self , date_str ) : try : epoch = time . strptime ( date_str , \"%m/%d/%Y\" ) return int ( calendar . timegm ( epoch ) ) * 1000000 except ValueError : return 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieves and removes the first task from the heap . [CODESPLIT] def PopTask ( self ) : try : _ , task = heapq . heappop ( self . _heap ) except IndexError : return None self . _task_identifiers . remove ( task . identifier ) return task", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the a new dict with underscores instead of hyphens in keys . [CODESPLIT] def dict_keys_without_hyphens ( a_dict ) : return dict ( ( key . replace ( '-' , '_' ) , val ) for key , val in a_dict . items ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns whether this is a ( non - quantized ) integer type . [CODESPLIT] def is_integer ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'is_integer' ) : return dtype . is_integer return np . issubdtype ( np . dtype ( dtype ) , np . integer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find a value for key in any of the objects given as args [CODESPLIT] def _find_value ( key , * args ) : for arg in args : v = _get_value ( arg , key ) if v is not None : return v", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if the given type is a builtin one . [CODESPLIT] def is_builtin_type ( tp ) : return hasattr ( __builtins__ , tp . __name__ ) and tp is getattr ( __builtins__ , tp . __name__ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets the width of the table that would be printed . : rtype : int [CODESPLIT] def get_table_width ( table ) : columns = transpose_table ( prepare_rows ( table ) ) widths = [ max ( len ( cell ) for cell in column ) for column in columns ] return len ( '+' + '|' . join ( '-' * ( w + 2 ) for w in widths ) + '+' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the modified time of a file [CODESPLIT] def set_time ( filename , mod_time ) : log . debug ( 'Setting modified time to %s' , mod_time ) mtime = calendar . timegm ( mod_time . utctimetuple ( ) ) # utctimetuple discards microseconds, so restore it (for consistency)\n mtime += mod_time . microsecond / 1000000 atime = os . stat ( filename ) . st_atime os . utime ( filename , ( atime , mtime ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Display the contents of a URL in an IPython notebook . : param target : the target url . : type target : string [CODESPLIT] def display_iframe_url ( target , * * kwargs ) : txt = iframe_url ( target , * * kwargs ) display ( HTML ( txt ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return unmatched part of re . Match object . [CODESPLIT] def unmatched ( match ) : start , end = match . span ( 0 ) return match . string [ : start ] + match . string [ end : ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "htmlify string [CODESPLIT] def safe_quotes ( text , escape_single_quotes = False ) : if isinstance ( text , str ) : safe_text = text . replace ( '\"' , \"&quot;\" ) if escape_single_quotes : safe_text = safe_text . replace ( \"'\" , \"&#92;'\" ) return safe_text . replace ( 'True' , 'true' ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks whether the remote file exists . [CODESPLIT] def remote_file_exists ( self , url ) : status = requests . head ( url ) . status_code if status != 200 : raise RemoteFileDoesntExist", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If pair is in search_list return the index . Otherwise return - 1 [CODESPLIT] def is_in ( self , search_list , pair ) : index = - 1 for nr , i in enumerate ( search_list ) : if ( np . all ( i == pair ) ) : return nr return index", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Imputes data set containing Nan values [CODESPLIT] def impute_data ( self , x ) : imp = Imputer ( missing_values = 'NaN' , strategy = 'mean' , axis = 0 ) return imp . fit_transform ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This will indent each new tag in the body by given number of spaces . [CODESPLIT] def layout ( self , indent = '    ' ) : self . __indent ( self . head , indent ) self . __indent ( self . meta , indent ) self . __indent ( self . stylesheet , indent ) self . __indent ( self . header , indent ) self . __indent ( self . body , indent , initial = 3 ) self . __indent ( self . footer , indent ) self . __indent ( self . body_pre_docinfo , indent , initial = 3 ) self . __indent ( self . docinfo , indent )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create an instance from a dictionary . [CODESPLIT] def from_dict ( cls , d ) : return cls ( * * { k : v for k , v in d . items ( ) if k in cls . ENTRIES } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs a shell command returns console output . [CODESPLIT] def _run_cmd_get_output ( cmd ) : process = subprocess . Popen ( cmd . split ( ) , stdout = subprocess . PIPE ) out , err = process . communicate ( ) return out or err", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform a O ( 1 ) memory hash of an iterable of arbitrary length . [CODESPLIT] def hash_iterable ( it ) : hash_value = hash ( type ( it ) ) for value in it : hash_value = hash ( ( hash_value , value ) ) return hash_value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validate input data . [CODESPLIT] def _validate_input_data ( self , data , request ) : validator = self . _get_input_validator ( request ) if isinstance ( data , ( list , tuple ) ) : return map ( validator . validate , data ) else : return validator . validate ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of all non - overlapping matches of pattern in string . [CODESPLIT] def finditer ( self , string , pos = 0 , endpos = sys . maxint ) : scanner = self . scanner ( string , pos , endpos ) return iter ( scanner . search , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterates through each image in the given directory . ( not recursive ) : param dir_path : Directory path where images files are present : return : Iterator to iterate through image files [CODESPLIT] def each_img ( dir_path ) : for fname in os . listdir ( dir_path ) : if fname . endswith ( '.jpg' ) or fname . endswith ( '.png' ) or fname . endswith ( '.bmp' ) : yield fname", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine whether we re in an interactive shell . Sets interactivity off if appropriate . cf http : // stackoverflow . com / questions / 24861351 / how - to - detect - if - python - script - is - being - run - as - a - background - process [CODESPLIT] def determine_interactive ( self ) : try : if not sys . stdout . isatty ( ) or os . getpgrp ( ) != os . tcgetpgrp ( sys . stdout . fileno ( ) ) : self . interactive = 0 return False except Exception : self . interactive = 0 return False if self . interactive == 0 : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print in color . [CODESPLIT] def printc ( cls , txt , color = colors . red ) : print ( cls . color_txt ( txt , color ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coerces JSON string to boolean [CODESPLIT] def from_json ( value , * * kwargs ) : if isinstance ( value , string_types ) : value = value . upper ( ) if value in ( 'TRUE' , 'Y' , 'YES' , 'ON' ) : return True if value in ( 'FALSE' , 'N' , 'NO' , 'OFF' ) : return False if isinstance ( value , int ) : return value raise ValueError ( 'Could not load boolean from JSON: {}' . format ( value ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param unicode fpath : : param unicode encoding : : rtype : dict | list [CODESPLIT] def load_jsonf ( fpath , encoding ) : with codecs . open ( fpath , encoding = encoding ) as f : return json . load ( f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param unicode fpath : : param unicode encoding : : rtype : dict | list [CODESPLIT] def load_jsonf ( fpath , encoding ) : with codecs . open ( fpath , encoding = encoding ) as f : return json . load ( f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap a function as a method . [CODESPLIT] def method ( func ) : attr = abc . abstractmethod ( func ) attr . __imethod__ = True return attr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Enable or disable automatic rate - limit handling . [CODESPLIT] def wait_on_rate_limit ( self , value ) : check_type ( value , bool , may_be_none = False ) self . _wait_on_rate_limit = value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine whether or not obj is iterable but not a string ( eg a list set tuple etc ) . [CODESPLIT] def is_iterable_but_not_string ( obj ) : return hasattr ( obj , '__iter__' ) and not isinstance ( obj , str ) and not isinstance ( obj , bytes )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Assign x and y to an object that has properties x and y . [CODESPLIT] def assign_to ( self , obj ) : obj . x = self . x obj . y = self . y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Kill the browser . [CODESPLIT] def kill ( self ) : if self . process : self . process . kill ( ) self . process . wait ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Recursively find size of a tree . Slow . [CODESPLIT] def size ( self ) : if self is NULL : return 0 return 1 + self . left . size ( ) + self . right . size ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "gradient of f w . r . t to y ( [ N x 1 ] ) [CODESPLIT] def fgrad_y ( self , y , return_precalc = False ) : d = self . d mpsi = self . psi # vectorized version S = ( mpsi [ : , 1 ] * ( y [ : , : , None ] + mpsi [ : , 2 ] ) ) . T R = np . tanh ( S ) D = 1 - ( R ** 2 ) GRAD = ( d + ( mpsi [ : , 0 : 1 ] [ : , : , None ] * mpsi [ : , 1 : 2 ] [ : , : , None ] * D ) . sum ( axis = 0 ) ) . T if return_precalc : return GRAD , S , R , D return GRAD", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the indent size in spaces at the start of a line of text . [CODESPLIT] def indentsize ( line ) : expline = string . expandtabs ( line ) return len ( expline ) - len ( string . lstrip ( expline ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a list a certain size [CODESPLIT] def _crop_list_to_size ( l , size ) : for x in range ( size - len ( l ) ) : l . append ( False ) for x in range ( len ( l ) - size ) : l . pop ( ) return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform a named tuple into a dictionary [CODESPLIT] def dictify ( a_named_tuple ) : return dict ( ( s , getattr ( a_named_tuple , s ) ) for s in a_named_tuple . _fields )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test the multiprocess [CODESPLIT] def test3 ( ) : import time p = MVisionProcess ( ) p . start ( ) time . sleep ( 5 ) p . stop ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "exactly like s but doesn t return variable names or file positions ( useful for logging ) [CODESPLIT] def ss ( * args , * * kwargs ) : if not args : raise ValueError ( \"you didn't pass any arguments to print out\" ) with Reflect . context ( args , * * kwargs ) as r : instance = V_CLASS ( r , stream , * * kwargs ) return instance . value ( ) . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "helper function for quick base conversions from integers to strings [CODESPLIT] def int2str ( num , radix = 10 , alphabet = BASE85 ) : return NumConv ( radix , alphabet ) . int2str ( num )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Changes a column name in a DataFrame Parameters : df - DataFrame DataFrame to operate on col_name - string Name of column to change new_col_name - string New name of column [CODESPLIT] def col_rename ( df , col_name , new_col_name ) : col_list = list ( df . columns ) for index , value in enumerate ( col_list ) : if value == col_name : col_list [ index ] = new_col_name break df . columns = col_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "stupid windows . converts the backslash to forwardslash for consistency [CODESPLIT] def __unixify ( self , s ) : return os . path . normpath ( s ) . replace ( os . sep , \"/\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Lock connection from being used else where [CODESPLIT] def lock ( self , block = True ) : self . _locked = True return self . _lock . acquire ( block )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write text . An additional attribute terminator with a value of None is added to the logging record to indicate that StreamHandler should not add a newline . [CODESPLIT] def write ( self , text ) : self . logger . log ( self . loglevel , text , extra = { 'terminator' : None } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "helper function for quick base conversions from strings to integers [CODESPLIT] def str2int ( num , radix = 10 , alphabet = BASE85 ) : return NumConv ( radix , alphabet ) . str2int ( num )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set y limits for plot . [CODESPLIT] def set_ylim ( self , xlims , dx , xscale , reverse = False ) : self . _set_axis_limits ( 'y' , xlims , dx , xscale , reverse ) return", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Invoke this command on a remote Python . [CODESPLIT] def check_dependencies_remote ( args ) : cmd = [ args . python , '-m' , 'depends' , args . requirement ] env = dict ( PYTHONPATH = os . path . dirname ( __file__ ) ) return subprocess . check_call ( cmd , env = env )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A Bark logging handler logging output to a named file . At intervals specified by the when the file will be rotated under control of backupCount . [CODESPLIT] def timed_rotating_file_handler ( name , logname , filename , when = 'h' , interval = 1 , backupCount = 0 , encoding = None , delay = False , utc = False ) : return wrap_log_handler ( logging . handlers . TimedRotatingFileHandler ( filename , when = when , interval = interval , backupCount = backupCount , encoding = encoding , delay = delay , utc = utc ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Count the number of null values in a column [CODESPLIT] def count_nulls ( self , field ) : try : n = self . df [ field ] . isnull ( ) . sum ( ) except KeyError : self . warning ( \"Can not find column\" , field ) return except Exception as e : self . err ( e , \"Can not count nulls\" ) return self . ok ( \"Found\" , n , \"nulls in column\" , field )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a function that checks whether a scalar or array is of a given kind ( e . g . float int datetime timedelta ) . [CODESPLIT] def make_kind_check ( python_types , numpy_kind ) : def check ( value ) : if hasattr ( value , 'dtype' ) : return value . dtype . kind == numpy_kind return isinstance ( value , python_types ) return check", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Conver a path string to a list of path elements . [CODESPLIT] def path_to_list ( pathstr ) : return [ elem for elem in pathstr . split ( os . path . pathsep ) if elem ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the channels of a colorbar . [CODESPLIT] def colorbar ( height , length , colormap ) : cbar = np . tile ( np . arange ( length ) * 1.0 / ( length - 1 ) , ( height , 1 ) ) cbar = ( cbar * ( colormap . values . max ( ) - colormap . values . min ( ) ) + colormap . values . min ( ) ) return colormap . colorize ( cbar )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check that value is in values [CODESPLIT] def isin ( value , values ) : for i , v in enumerate ( value ) : if v not in np . array ( values ) [ : , i ] : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return whether two objects are equal via recursion using : func : numpy . array_equal for comparing numpy arays . [CODESPLIT] def numpy_aware_eq ( a , b ) : if isinstance ( a , np . ndarray ) or isinstance ( b , np . ndarray ) : return np . array_equal ( a , b ) if ( ( isinstance ( a , Iterable ) and isinstance ( b , Iterable ) ) and not isinstance ( a , str ) and not isinstance ( b , str ) ) : if len ( a ) != len ( b ) : return False return all ( numpy_aware_eq ( x , y ) for x , y in zip ( a , b ) ) return a == b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ensures that the argument is a list that either is empty or contains only strings : param arr : list : return : [CODESPLIT] def all_strings ( arr ) : if not isinstance ( [ ] , list ) : raise TypeError ( \"non-list value found where list is expected\" ) return all ( isinstance ( x , str ) for x in arr )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A Python decorator for printing out the execution time for a function . [CODESPLIT] def timeit ( method ) : def timed ( * args , * * kw ) : time_start = time . time ( ) result = method ( * args , * * kw ) time_end = time . time ( ) print ( 'timeit: %r %2.2f sec (%r, %r) ' % ( method . __name__ , time_end - time_start , str ( args ) [ : 20 ] , kw ) ) return result return timed", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove the value found at key from the queue [CODESPLIT] def remove ( self , key ) : item = self . item_finder . pop ( key ) item [ - 1 ] = None self . removed_count += 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a datetime . timedelta object return the delta in milliseconds [CODESPLIT] def datetime_delta_to_ms ( delta ) : delta_ms = delta . days * 24 * 60 * 60 * 1000 delta_ms += delta . seconds * 1000 delta_ms += delta . microseconds / 1000 delta_ms = int ( delta_ms ) return delta_ms", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decorator to ensure API calls are made and return expected data . [CODESPLIT] def api_test ( method = 'GET' , * * response_kwargs ) : method = method . lower ( ) def api_test_factory ( fn ) : @ functools . wraps ( fn ) @ mock . patch ( 'requests.{}' . format ( method ) ) def execute_test ( method_func , * args , * * kwargs ) : method_func . return_value = MockResponse ( * * response_kwargs ) expected_url , response = fn ( * args , * * kwargs ) method_func . assert_called_once ( ) assert_valid_api_call ( method_func , expected_url ) assert isinstance ( response , JSONAPIParser ) assert response . json_data is method_func . return_value . data return execute_test return api_test_factory", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like get_object_or_404 but doesn t throw an exception . [CODESPLIT] def get_object_or_none ( model , * args , * * kwargs ) : try : return model . _default_manager . get ( * args , * * kwargs ) except model . DoesNotExist : return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Matrix inversion op . [CODESPLIT] def MatrixInverse ( a , adj ) : return np . linalg . inv ( a if not adj else _adjoint ( a ) ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write value to the target [CODESPLIT] def write ( self , value ) : self . get_collection ( ) . update_one ( { '_id' : self . _document_id } , { '$set' : { self . _path : value } } , upsert = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Abstraction over executemany method [CODESPLIT] def store_many ( self , sql , values ) : cursor = self . get_cursor ( ) cursor . executemany ( sql , values ) self . conn . commit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the id of the last written row in table [CODESPLIT] def get_last_id ( self , cur , table = 'reaction' ) : cur . execute ( \"SELECT seq FROM sqlite_sequence WHERE name='{0}'\" . format ( table ) ) result = cur . fetchone ( ) if result is not None : id = result [ 0 ] else : id = 0 return id", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a node for a participant . [CODESPLIT] def create_node ( self , network , participant ) : return self . models . MCMCPAgent ( network = network , participant = participant )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return whether an edge exists . [CODESPLIT] def has_edge ( self , edge ) : u , v = edge return ( u , v ) in self . edge_properties", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if var is a list or a tuple ( but not a string! ) [CODESPLIT] def is_a_sequence ( var , allow_none = False ) : return isinstance ( var , ( list , tuple ) ) or ( var is None and allow_none )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is an object iterable like a list ( and not a string ) ? [CODESPLIT] def listlike ( obj ) : return hasattr ( obj , \"__iter__\" ) and not issubclass ( type ( obj ) , str ) and not issubclass ( type ( obj ) , unicode )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "delete all the eggs in the directory specified [CODESPLIT] def delete_all_eggs ( self ) : path_to_delete = os . path . join ( self . egg_directory , \"lib\" , \"python\" ) if os . path . exists ( path_to_delete ) : shutil . rmtree ( path_to_delete )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gaussian pdf . : param x : free variable . : param mu : mean of the distribution . : param sig : standard deviation of the distribution . : return : sympy . Expr for a Gaussian pdf . [CODESPLIT] def Gaussian ( x , mu , sig ) : return sympy . exp ( - ( x - mu ) ** 2 / ( 2 * sig ** 2 ) ) / sympy . sqrt ( 2 * sympy . pi * sig ** 2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "rescales a numpy array so that min is 0 and max is 255 [CODESPLIT] def _normalize ( mat : np . ndarray ) : return ( ( mat - mat . min ( ) ) * ( 255 / mat . max ( ) ) ) . astype ( np . uint8 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "equivalent to scipy . preprocessing . normalize on sparse matrices but lets avoid another depedency just for a small utility function [CODESPLIT] def normalize ( X ) : X = coo_matrix ( X ) X . data = X . data / sqrt ( bincount ( X . row , X . data ** 2 ) ) [ X . row ] return X", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Has a 50 / 50 chance of calling a function [CODESPLIT] def sometimesish ( fn ) : def wrapped ( * args , * * kwargs ) : if random . randint ( 1 , 2 ) == 1 : return fn ( * args , * * kwargs ) return wrapped", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the opposite of input condition . [CODESPLIT] def _not ( condition = None , * * kwargs ) : result = True if condition is not None : result = not run ( condition , * * kwargs ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "I check to see if a method on a TestCase has been disabled via nose s convention for disabling a TestCase . This makes it so that users can mix nose s parameterized tests with green as a runner . [CODESPLIT] def isTestCaseDisabled ( test_case_class , method_name ) : test_method = getattr ( test_case_class , method_name ) return getattr ( test_method , \"__test__\" , 'not nose' ) is False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Array of vector lengths [CODESPLIT] def length ( self ) : return np . sqrt ( np . sum ( self ** 2 , axis = 1 ) ) . view ( np . ndarray )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raises an AssertionError if expected is actual . [CODESPLIT] def assert_is_not ( expected , actual , message = None , extra = None ) : assert expected is not actual , _assert_fail_message ( message , expected , actual , \"is\" , extra )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns numpy array of natural logarithms of values . [CODESPLIT] def to_distribution_values ( self , values ) : with warnings . catch_warnings ( ) : warnings . simplefilter ( \"ignore\" ) # avoid RuntimeWarning: divide by zero encountered in log return numpy . log ( values )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param str s : string with tabs : param str replace : e . g . 4 spaces : rtype : str [CODESPLIT] def replace_tab_indent ( s , replace = \"    \" ) : prefix = get_indent_prefix ( s ) return prefix . replace ( \"\\t\" , replace ) + s [ len ( prefix ) : ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a json string representing the python object obj . [CODESPLIT] def to_json ( obj ) : i = StringIO . StringIO ( ) w = Writer ( i , encoding = 'UTF-8' ) w . write_value ( obj ) return i . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper to draw lines connecting a set of nodes that are scaled for the Screen . [CODESPLIT] def _draw_lines_internal ( self , coords , colour , bg ) : for i , ( x , y ) in enumerate ( coords ) : if i == 0 : self . _screen . move ( x , y ) else : self . _screen . draw ( x , y , colour = colour , bg = bg , thin = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Draw a vertical line up to a given length . [CODESPLIT] def vline ( self , x , y , height , color ) : self . rect ( x , y , 1 , height , color , fill = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds execute permission to file . : param filename : : return : [CODESPLIT] def chmod_add_excute ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert RGB arrays from mask canvas object back to boolean mask . [CODESPLIT] def _rgbtomask ( self , obj ) : dat = obj . get_image ( ) . get_data ( ) # RGB arrays return dat . sum ( axis = 2 ) . astype ( np . bool )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates Camera . aspect to match the viewport s aspect ratio . [CODESPLIT] def match_aspect_to_viewport ( self ) : viewport = self . viewport self . aspect = float ( viewport . width ) / viewport . height", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap the text on the given line length . [CODESPLIT] def normalize_text ( text , line_len = 80 , indent = \"\" ) : return \"\\n\" . join ( textwrap . wrap ( text , width = line_len , initial_indent = indent , subsequent_indent = indent ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a random string from 0 - 9 : param n : length of the string : return : the random string [CODESPLIT] def random_numbers ( n ) : return '' . join ( random . SystemRandom ( ) . choice ( string . digits ) for _ in range ( n ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a object into dictionary with all of its readable attributes . [CODESPLIT] def dict_from_object ( obj : object ) : # If object is a dict instance, no need to convert. return ( obj if isinstance ( obj , dict ) else { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( '_' ) } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Version of load_result for multiple input files that will be loaded concurrently . [CODESPLIT] def load_results ( result_files , options , run_set_id = None , columns = None , columns_relevant_for_diff = set ( ) ) : return parallel . map ( load_result , result_files , itertools . repeat ( options ) , itertools . repeat ( run_set_id ) , itertools . repeat ( columns ) , itertools . repeat ( columns_relevant_for_diff ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": type root : TreeNode : rtype : int [CODESPLIT] def min_depth ( self , root ) : if root is None : return 0 if root . left is not None or root . right is not None : return max ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1 return min ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple directory walker [CODESPLIT] def get_files ( dir_name ) : return [ ( os . path . join ( '.' , d ) , [ os . path . join ( d , f ) for f in files ] ) for d , _ , files in os . walk ( dir_name ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the indices of all the val in m [CODESPLIT] def index ( m , val ) : mm = np . array ( m ) idx_tuple = np . where ( mm == val ) idx = idx_tuple [ 0 ] . tolist ( ) return idx", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Unpickle a pstats . Stats object [CODESPLIT] def unpickle_stats ( stats ) : stats = cPickle . loads ( stats ) stats . stream = True return stats", "target": 1, "target_options": ["no_match", "match"]}
{"input": "itertools . starmap for deferred callables using cooperative multitasking [CODESPLIT] def asyncStarCmap ( asyncCallable , iterable ) : results = [ ] yield coopStar ( asyncCallable , results . append , iterable ) returnValue ( results )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove and return the item at index . [CODESPLIT] def pop ( self , index = - 1 ) : value = self . _list . pop ( index ) del self . _dict [ value ] return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the non - sequence features from the provided example . [CODESPLIT] def get_example_features ( example ) : return ( example . features . feature if isinstance ( example , tf . train . Example ) else example . context . feature )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty print format some XML so it s readable . [CODESPLIT] def pp_xml ( body ) : pretty = xml . dom . minidom . parseString ( body ) return pretty . toprettyxml ( indent = \"  \" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print list of strings to the predefined stdout . [CODESPLIT] def print_out ( self , * lst ) : self . print2file ( self . stdout , True , True , * lst )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get system root directory ( application installed root directory ) [CODESPLIT] def get_system_root_directory ( ) : root = os . path . dirname ( __file__ ) root = os . path . dirname ( root ) root = os . path . abspath ( root ) return root", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like print_exc () but return a string . Backport for Python 2 . 3 . [CODESPLIT] def format_exc ( limit = None ) : try : etype , value , tb = sys . exc_info ( ) return '' . join ( traceback . format_exception ( etype , value , tb , limit ) ) finally : etype = value = tb = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get terminal width [CODESPLIT] def get_width ( ) : # Get terminal size ws = struct . pack ( \"HHHH\" , 0 , 0 , 0 , 0 ) ws = fcntl . ioctl ( sys . stdout . fileno ( ) , termios . TIOCGWINSZ , ws ) lines , columns , x , y = struct . unpack ( \"HHHH\" , ws ) width = min ( columns * 39 // 40 , columns - 2 ) return width", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieves and removes the first task from the heap . [CODESPLIT] def PopTask ( self ) : try : _ , task = heapq . heappop ( self . _heap ) except IndexError : return None self . _task_identifiers . remove ( task . identifier ) return task", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Linspace op . [CODESPLIT] def LinSpace ( start , stop , num ) : return np . linspace ( start , stop , num = num , dtype = np . float32 ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adjust the bounding box as specified by user . Returns the adjusted bounding box . [CODESPLIT] def adjust_bounding_box ( bbox ) : for i in range ( 0 , 4 ) : if i in bounding_box : bbox [ i ] = bounding_box [ i ] else : bbox [ i ] += delta_bounding_box [ i ] return bbox", "target": 1, "target_options": ["no_match", "match"]}
{"input": "read a simple text file from a private location to get username and password [CODESPLIT] def read_credentials ( fname ) : with open ( fname , 'r' ) as f : username = f . readline ( ) . strip ( '\\n' ) password = f . readline ( ) . strip ( '\\n' ) return username , password", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pre - order depth - first [CODESPLIT] def walk_tree ( root ) : yield root for child in root . children : for el in walk_tree ( child ) : yield el", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A basic check of if the program is running in interactive mode [CODESPLIT] def isInteractive ( ) : if sys . stdout . isatty ( ) and os . name != 'nt' : #Hopefully everything but ms supports '\\r' try : import threading except ImportError : return False else : return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the memory byte size of a Numpy array as an integer . [CODESPLIT] def bytesize ( arr ) : byte_size = np . prod ( arr . shape ) * np . dtype ( arr . dtype ) . itemsize return byte_size", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get a set of keys from redis [CODESPLIT] def get ( self , key ) : res = self . connection . get ( key ) print ( res ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Dynamically import the python module with the ngram defined as a dictionary . Since bigger ngrams are large files its wasteful to always statically import them if they re not used . [CODESPLIT] def _load_ngram ( name ) : module = importlib . import_module ( 'lantern.analysis.english_ngrams.{}' . format ( name ) ) return getattr ( module , name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper parse action to convert tokens to upper case . [CODESPLIT] def upcaseTokens ( s , l , t ) : return [ tt . upper ( ) for tt in map ( _ustr , t ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a copy of the list without duplicates . [CODESPLIT] def unique ( list ) : unique = [ ] [ unique . append ( x ) for x in list if x not in unique ] return unique", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove the last NoteContainer in the Bar . [CODESPLIT] def remove_last_entry ( self ) : self . current_beat -= 1.0 / self . bar [ - 1 ] [ 1 ] self . bar = self . bar [ : - 1 ] return self . current_beat", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes non - alpha characters and converts spaces to hyphens . Useful for making file names . Source : http : // stackoverflow . com / questions / 5574042 / string - slugification - in - python [CODESPLIT] def slugify ( string ) : string = re . sub ( '[^\\w .-]' , '' , string ) string = string . replace ( \" \" , \"-\" ) return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip all the accents from the string [CODESPLIT] def strip_accents ( string ) : return u'' . join ( ( character for character in unicodedata . normalize ( 'NFD' , string ) if unicodedata . category ( character ) != 'Mn' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a list possibly nested to any level return it flattened . [CODESPLIT] def flatten ( lis ) : new_lis = [ ] for item in lis : if isinstance ( item , collections . Sequence ) and not isinstance ( item , basestring ) : new_lis . extend ( flatten ( item ) ) else : new_lis . append ( item ) return new_lis", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reverse the range [CODESPLIT] def negate ( self ) : self . from_value , self . to_value = self . to_value , self . from_value self . include_lower , self . include_upper = self . include_upper , self . include_lower", "target": 1, "target_options": ["no_match", "match"]}
{"input": "helper to clean up an input string [CODESPLIT] def clean ( some_string , uppercase = False ) : if uppercase : return some_string . strip ( ) . upper ( ) else : return some_string . strip ( ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update only one property in the dict [CODESPLIT] def set_property ( self , key , value ) : self . properties [ key ] = value self . sync_properties ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "For Python3 compatibility of generator . [CODESPLIT] def __next__ ( self , reward , ask_id , lbl ) : return self . next ( reward , ask_id , lbl )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize the data to be in the [ 0 1 ] range . [CODESPLIT] def normalize ( data ) : out_data = data . copy ( ) for i , sample in enumerate ( out_data ) : out_data [ i ] /= sum ( out_data [ i ] ) return out_data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalizes list [CODESPLIT] def normalize_array ( lst ) : np_arr = np . array ( lst ) x_normalized = np_arr / np_arr . max ( axis = 0 ) return list ( x_normalized )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "DOES NOT WORK WELL WITH MOPIDY Hack from https : // www . daniweb . com / software - development / python / code / 260268 / restart - your - python - program to support updating the settings since mopidy is not able to do that yet Restarts the current program Note : this function does not return . Any cleanup action ( like saving data ) must be done before calling this function [CODESPLIT] def restart_program ( ) : python = sys . executable os . execl ( python , python , * sys . argv )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the flattened version of a 2D list . List - correlate to the a . flat () method of NumPy arrays . [CODESPLIT] def flat ( l ) : newl = [ ] for i in range ( len ( l ) ) : for j in range ( len ( l [ i ] ) ) : newl . append ( l [ i ] [ j ] ) return newl", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Attempt to restart the bot . [CODESPLIT] def do_restart ( self , line ) : self . bot . _frame = 0 self . bot . _namespace . clear ( ) self . bot . _namespace . update ( self . bot . _initial_namespace )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the billing cycle prior to this one . May return None [CODESPLIT] def get_previous ( self ) : return BillingCycle . objects . filter ( date_range__lt = self . date_range ) . order_by ( 'date_range' ) . last ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Round to sig figs [CODESPLIT] def round_to_n ( x , n ) : return round ( x , - int ( np . floor ( np . log10 ( x ) ) ) + ( n - 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple method for handling exceptions raised by PyBankID . [CODESPLIT] def handle_exception ( error ) : response = jsonify ( error . to_dict ( ) ) response . status_code = error . status_code return response", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run manage . py using this component s specific Django settings [CODESPLIT] def managepy ( cmd , extra = None ) : extra = extra . split ( ) if extra else [ ] run_django_cli ( [ 'invoke' , cmd ] + extra )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Start the Django dev server . [CODESPLIT] def server ( port ) : args = [ 'python' , 'manage.py' , 'runserver' ] if port : args . append ( port ) run . main ( args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert snake case to camel case [CODESPLIT] def camel_case ( self , snake_case ) : components = snake_case . split ( '_' ) return components [ 0 ] + \"\" . join ( x . title ( ) for x in components [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create symlink that overwrites any existing target . [CODESPLIT] def replacing_symlink ( source , link_name ) : with make_tmp_name ( link_name ) as tmp_link_name : os . symlink ( source , tmp_link_name ) replace_file_or_dir ( link_name , tmp_link_name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the lib dir under the home installation scheme [CODESPLIT] def home_lib ( home ) : if hasattr ( sys , 'pypy_version_info' ) : lib = 'site-packages' else : lib = os . path . join ( 'lib' , 'python' ) return os . path . join ( home , lib )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "quit crash [CODESPLIT] def _quit ( self , * args ) : self . logger . warn ( 'Bye!' ) sys . exit ( self . exit ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raise a new exception using the preserved traceback of the last one . [CODESPLIT] def _re_raise_as ( NewExc , * args , * * kw ) : etype , val , tb = sys . exc_info ( ) raise NewExc ( * args , * * kw ) , None , tb", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A basic check of if the program is running in interactive mode [CODESPLIT] def isInteractive ( ) : if sys . stdout . isatty ( ) and os . name != 'nt' : #Hopefully everything but ms supports '\\r' try : import threading except ImportError : return False else : return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compile and return a Module s code object . [CODESPLIT] def get_code ( module ) : fp = open ( module . path ) try : return compile ( fp . read ( ) , str ( module . name ) , 'exec' ) finally : fp . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Select rows where the given field is not None . [CODESPLIT] def selectnotnone ( table , field , complement = False ) : return select ( table , field , lambda v : v is not None , complement = complement )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Send data to the child process through . [CODESPLIT] def send ( self , data ) : self . stdin . write ( data ) self . stdin . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shutdown the service with a reason . [CODESPLIT] def stop ( self , reason = None ) : self . logger . info ( 'stopping' ) self . loop . stop ( pyev . EVBREAK_ALL )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update tabstop width after font or indentation changed [CODESPLIT] def _updateTabStopWidth ( self ) : self . setTabStopWidth ( self . fontMetrics ( ) . width ( ' ' * self . _indenter . width ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the a new dict with underscores instead of hyphens in keys . [CODESPLIT] def dict_keys_without_hyphens ( a_dict ) : return dict ( ( key . replace ( '-' , '_' ) , val ) for key , val in a_dict . items ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "replace nan in a by val and returns the replaced array and the nan position [CODESPLIT] def _replace_nan ( a , val ) : mask = isnull ( a ) return where_method ( val , mask , a ) , mask", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper for inserting int64 features into Example proto . [CODESPLIT] def _int64_feature ( value ) : if not isinstance ( value , list ) : value = [ value ] return tf . train . Feature ( int64_list = tf . train . Int64List ( value = value ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Install or upgrade setuptools and EasyInstall [CODESPLIT] def main ( argv , version = DEFAULT_VERSION ) : tarball = download_setuptools ( ) _install ( tarball , _build_install_args ( argv ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Formats a list of elements using the given line style [CODESPLIT] def format_line ( data , linestyle ) : return linestyle . begin + linestyle . sep . join ( data ) + linestyle . end", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialize the cycle with some iterable . [CODESPLIT] def __init__ ( self , iterable ) : self . _values = [ ] self . _iterable = iterable self . _initialized = False self . _depleted = False self . _offset = 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "given a list of 4 - element tuples transforms it into a numpy array [CODESPLIT] def segments_to_numpy ( segments ) : segments = numpy . array ( segments , dtype = SEGMENT_DATATYPE , ndmin = 2 ) # each segment in a row segments = segments if SEGMENTS_DIRECTION == 0 else numpy . transpose ( segments ) return segments", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the index of an element in the list . [CODESPLIT] def get_list_index ( lst , index_or_name ) : if isinstance ( index_or_name , six . integer_types ) : return index_or_name return lst . index ( index_or_name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the offsets values of x y z as a numpy array [CODESPLIT] def offsets ( self ) : return np . array ( [ self . x_offset , self . y_offset , self . z_offset ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Earth orientation as a rotating matrix [CODESPLIT] def earth_orientation ( date ) : x_p , y_p , s_prime = np . deg2rad ( _earth_orientation ( date ) ) return rot3 ( - s_prime ) @ rot2 ( x_p ) @ rot1 ( y_p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the given code line by line with printing as list of lines and return variable ans . [CODESPLIT] def runcode ( code ) : for line in code : print ( '# ' + line ) exec ( line , globals ( ) ) print ( '# return ans' ) return ans", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Debug a single doctest docstring in argument src [CODESPLIT] def debug_src ( src , pm = False , globs = None ) : testsrc = script_from_examples ( src ) debug_script ( testsrc , pm , globs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transforms the regular socket . socket to an ssl . SSLSocket for secure connections . Any arguments are passed to ssl . wrap_socket : http : // docs . python . org / dev / library / ssl . html#ssl . wrap_socket [CODESPLIT] def enable_ssl ( self , * args , * * kwargs ) : if self . handshake_sent : raise SSLError ( 'can only enable SSL before handshake' ) self . secure = True self . sock = ssl . wrap_socket ( self . sock , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Upermutate 1 - D data that is sorted by indices_of_increasing . [CODESPLIT] def unsort_vector ( data , indices_of_increasing ) : return numpy . array ( [ data [ indices_of_increasing . index ( i ) ] for i in range ( len ( data ) ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Saves the case as an Excel spreadsheet . [CODESPLIT] def save_excel ( self , fd ) : from pylon . io . excel import ExcelWriter ExcelWriter ( self ) . write ( fd )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list of rows sorted by start and end date . [CODESPLIT] def _rows_sort ( self , rows ) : return sorted ( rows , key = lambda row : ( row [ self . _key_start_date ] , row [ self . _key_end_date ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of dictionaries which are sorted for only unique entries . [CODESPLIT] def unique_list_dicts ( dlist , key ) : return list ( dict ( ( val [ key ] , val ) for val in dlist ) . values ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Method to convert the repository list to a search results page and write it to a HTML file . [CODESPLIT] def to_html ( self , write_to ) : page_html = self . get_html ( ) with open ( write_to , \"wb\" ) as writefile : writefile . write ( page_html . encode ( \"utf-8\" ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sort the data . [CODESPLIT] def sort_data ( x , y ) : xy = sorted ( zip ( x , y ) ) x , y = zip ( * xy ) return x , y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a text into separate words . [CODESPLIT] def tokenize_list ( self , text ) : return [ self . get_record_token ( record ) for record in self . analyze ( text ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Matches a paren . [CODESPLIT] def match_paren ( self , tokens , item ) : match , = tokens return self . match ( match , item )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like a bulk : meth : forceput . [CODESPLIT] def forceupdate ( self , * args , * * kw ) : self . _update ( False , self . _ON_DUP_OVERWRITE , * args , * * kw )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set limits for the x - axis . [CODESPLIT] def set_xlimits ( self , min = None , max = None ) : self . limits [ 'xmin' ] = min self . limits [ 'xmax' ] = max", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show the received object as precise as possible . [CODESPLIT] def _repr ( obj ) : vals = \", \" . join ( \"{}={!r}\" . format ( name , getattr ( obj , name ) ) for name in obj . _attribs ) if vals : t = \"{}(name={}, {})\" . format ( obj . __class__ . __name__ , obj . name , vals ) else : t = \"{}(name={})\" . format ( obj . __class__ . __name__ , obj . name ) return t", "target": 1, "target_options": ["no_match", "match"]}
{"input": "An iterable of column names for a particular table or view . [CODESPLIT] def column_names ( self , table ) : table_info = self . execute ( u'PRAGMA table_info(%s)' % quote ( table ) ) return ( column [ 'name' ] for column in table_info )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Context manager to temporarily disable certificate validation in the standard SSL library . [CODESPLIT] def disable_cert_validation ( ) : current_context = ssl . _create_default_https_context ssl . _create_default_https_context = ssl . _create_unverified_context try : yield finally : ssl . _create_default_https_context = current_context", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read text from stdin and print a helpful message for ttys . [CODESPLIT] def read_stdin ( ) : if sys . stdin . isatty ( ) and sys . stdout . isatty ( ) : print ( '\\nReading from stdin until end of file (Ctrl + D)...' ) return sys . stdin . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Lookup country for IP address . [CODESPLIT] def get_geoip ( ip ) : reader = geolite2 . reader ( ) ip_data = reader . get ( ip ) or { } return ip_data . get ( 'country' , { } ) . get ( 'iso_code' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert \\ r \\ n and \\ r to \\ n chars . Strip any leading or trailing whitespace on each line . Remove blank lines . [CODESPLIT] def fix_line_breaks ( s ) : l = s . splitlines ( ) x = [ i . strip ( ) for i in l ] x = [ i for i in x if i ] # remove blank lines return \"\\n\" . join ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Called by remote workers . Useful to populate main module globals () for interactive shells . Retrieves the serialized function . [CODESPLIT] def getFunction ( self ) : return functionFactory ( self . code , self . name , self . defaults , self . globals , self . imports , )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split message to list by commas and trim whitespace . [CODESPLIT] def __normalize_list ( self , msg ) : if isinstance ( msg , list ) : msg = \"\" . join ( msg ) return list ( map ( lambda x : x . strip ( ) , msg . split ( \",\" ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn a list to list of list [CODESPLIT] def splitBy ( data , num ) : return [ data [ i : i + num ] for i in range ( 0 , len ( data ) , num ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add suffix to a full file name [CODESPLIT] def add_suffix ( fullname , suffix ) : name , ext = os . path . splitext ( fullname ) return name + '_' + suffix + ext", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert bytes to a list of bits [CODESPLIT] def bytes_to_bits ( bytes_ ) : res = [ ] for x in bytes_ : if not isinstance ( x , int ) : x = ord ( x ) res += byte_to_bits ( x ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a comma separated string to a list [CODESPLIT] def _str_to_list ( s ) : _list = s . split ( \",\" ) return list ( map ( lambda i : i . lstrip ( ) , _list ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sum reduction op . [CODESPLIT] def Sum ( a , axis , keep_dims ) : return np . sum ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert from whatever is given to a list of scalars for the lookup_field . [CODESPLIT] def coerce ( self , value ) : if isinstance ( value , dict ) : value = [ value ] if not isiterable_notstring ( value ) : value = [ value ] return [ coerce_single_instance ( self . lookup_field , v ) for v in value ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Starts a TensorFlow server and joins the serving thread . [CODESPLIT] def run_std_server ( self ) : config = tf . estimator . RunConfig ( ) server = tf . train . Server ( config . cluster_spec , job_name = config . task_type , task_index = config . task_id , protocol = config . protocol ) server . join ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a map of letter use in a word . [CODESPLIT] def _letter_map ( word ) : lmap = { } for letter in word : try : lmap [ letter ] += 1 except KeyError : lmap [ letter ] = 1 return lmap", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format a duration in seconds . [CODESPLIT] def fmt_duration ( secs ) : return ' ' . join ( fmt . human_duration ( secs , 0 , precision = 2 , short = True ) . strip ( ) . split ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "converts Synergy Timestamp for session to UTC zone seconds since epoch [CODESPLIT] def session_to_epoch ( timestamp ) : utc_timetuple = datetime . strptime ( timestamp , SYNERGY_SESSION_PATTERN ) . replace ( tzinfo = None ) . utctimetuple ( ) return calendar . timegm ( utc_timetuple )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieves the root key . [CODESPLIT] def GetRootKey ( self ) : regf_key = self . _regf_file . get_root_key ( ) if not regf_key : return None return REGFWinRegistryKey ( regf_key , key_path = self . _key_path_prefix )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Puts the two whole widgets in the correct position depending on compound . [CODESPLIT] def _grid_widgets ( self ) : scrollbar_column = 0 if self . __compound is tk . LEFT else 2 self . listbox . grid ( row = 0 , column = 1 , sticky = \"nswe\" ) self . scrollbar . grid ( row = 0 , column = scrollbar_column , sticky = \"ns\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Search into instance attributes properties and return values of no - args methods . [CODESPLIT] def instance_contains ( container , item ) : return item in ( member for _ , member in inspect . getmembers ( container ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the absolute position of table top [CODESPLIT] def table_top_abs ( self ) : table_height = np . array ( [ 0 , 0 , self . table_full_size [ 2 ] ] ) return string_to_array ( self . floor . get ( \"pos\" ) ) + table_height", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a text and drops all non - printable and non - ascii characters and also any whitespace characters that aren t space . [CODESPLIT] def drop_bad_characters ( text ) : # Strip all non-ascii and non-printable characters text = '' . join ( [ c for c in text if c in ALLOWED_CHARS ] ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a list of Token into a list of Token asuming size == 1 [CODESPLIT] def append_position_to_token_list ( token_list ) : return [ PositionToken ( value . content , value . gd , index , index + 1 ) for ( index , value ) in enumerate ( token_list ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call the given callback if or when the connected deferred succeeds . [CODESPLIT] def on_success ( self , fn , * args , * * kwargs ) : self . _callbacks . append ( ( fn , args , kwargs ) ) result = self . _resulted_in if result is not _NOTHING_YET : self . _succeed ( result = result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Matrix inversion op . [CODESPLIT] def MatrixInverse ( a , adj ) : return np . linalg . inv ( a if not adj else _adjoint ( a ) ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pull comma separated string values out of a text file and converts them to float list [CODESPLIT] def string_to_float_list ( string_var ) : try : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ', ' ) ] except : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ',' ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates the Jaccard similarity between two sets of nodes . Called by mroc . [CODESPLIT] def jaccard ( c_1 , c_2 ) : nom = np . intersect1d ( c_1 , c_2 ) . size denom = np . union1d ( c_1 , c_2 ) . size return nom / denom", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Assert that text has n errors of type check . [CODESPLIT] def assert_error ( text , check , n = 1 ) : assert_error . description = \"No {} error for '{}'\" . format ( check , text ) assert ( check in [ error [ 0 ] for error in lint ( text ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handle the + operator . [CODESPLIT] def __add__ ( self , other ) : return self . _handle_type ( other ) ( self . value + other . value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a UUID . [CODESPLIT] def generate_uuid ( ) : r_uuid = base64 . urlsafe_b64encode ( uuid . uuid4 ( ) . bytes ) return r_uuid . decode ( ) . replace ( '=' , '' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Install venv + deps . [CODESPLIT] def venv ( ) : try : import virtualenv # NOQA except ImportError : sh ( \"%s -m pip install virtualenv\" % PYTHON ) if not os . path . isdir ( \"venv\" ) : sh ( \"%s -m virtualenv venv\" % PYTHON ) sh ( \"venv\\\\Scripts\\\\pip install -r %s\" % ( REQUIREMENTS_TXT ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert an ARF timestamp to a datetime . datetime object ( naive local time ) [CODESPLIT] def timestamp_to_datetime ( timestamp ) : from datetime import datetime , timedelta obj = datetime . fromtimestamp ( timestamp [ 0 ] ) return obj + timedelta ( microseconds = int ( timestamp [ 1 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return the underlying numpy array [CODESPLIT] def array ( self ) : return np . arange ( self . start , self . stop , self . step )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Colorize text with given color . [CODESPLIT] def _write_color_colorama ( fp , text , color ) : foreground , background , style = get_win_color ( color ) colorama . set_console ( foreground = foreground , background = background , style = style ) fp . write ( text ) colorama . reset_console ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shortcut to create md5 hash : param s : : return : [CODESPLIT] def md5_string ( s ) : m = hashlib . md5 ( ) m . update ( s ) return str ( m . hexdigest ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A functional form of the astype method . [CODESPLIT] def astype ( array , y ) : if isinstance ( y , autograd . core . Node ) : return array . astype ( numpy . array ( y . value ) . dtype ) return array . astype ( numpy . array ( y ) . dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Joins two dictionaries . [CODESPLIT] def dict_merge ( set1 , set2 ) : return dict ( list ( set1 . items ( ) ) + list ( set2 . items ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Move the cursor up a number of lines . [CODESPLIT] def move_up ( lines = 1 , file = sys . stdout ) : move . up ( lines ) . write ( file = file )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert record array to a dictionaries [CODESPLIT] def to_dicts ( recarray ) : for rec in recarray : yield dict ( zip ( recarray . dtype . names , rec . tolist ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get object from string reference . [CODESPLIT] def get_obj ( ref ) : oid = int ( ref ) return server . id2ref . get ( oid ) or server . id2obj [ oid ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a path to its canonical case - normalized absolute version . [CODESPLIT] def normalize_path ( path ) : return os . path . normcase ( os . path . realpath ( os . path . expanduser ( path ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Enable event loop integration with Gtk3 ( gir bindings ) . [CODESPLIT] def enable_gtk3 ( self , app = None ) : from pydev_ipython . inputhookgtk3 import create_inputhook_gtk3 self . set_inputhook ( create_inputhook_gtk3 ( self . _stdin_file ) ) self . _current_gui = GUI_GTK", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If creating a symlink from link to a target determine if target is a directory ( relative to dirname ( link )) . [CODESPLIT] def _is_target_a_directory ( link , rel_target ) : target = os . path . join ( os . path . dirname ( link ) , rel_target ) return os . path . isdir ( target )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Performs a join using the union join function . [CODESPLIT] def merge ( left , right , how = 'inner' , key = None , left_key = None , right_key = None , left_as = 'left' , right_as = 'right' ) : return join ( left , right , how , key , left_key , right_key , join_fn = make_union_join ( left_as , right_as ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterates over the result set and converts each row to a dictionary [CODESPLIT] def _fetch_all_as_dict ( self , cursor ) : desc = cursor . description return [ dict ( zip ( [ col [ 0 ] for col in desc ] , row ) ) for row in cursor . fetchall ( ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add widgets / spacing to dialog vertical layout [CODESPLIT] def add_widgets ( self , * widgets_or_spacings ) : layout = self . layout ( ) for widget_or_spacing in widgets_or_spacings : if isinstance ( widget_or_spacing , int ) : layout . addSpacing ( widget_or_spacing ) else : layout . addWidget ( widget_or_spacing )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": rtype : numpy matrix [CODESPLIT] def load_data ( filename ) : data = pandas . read_csv ( filename , header = None , delimiter = '\\t' , skiprows = 9 ) return data . as_matrix ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the Serial Number String from the HID device . [CODESPLIT] def get_serial_number_string ( self ) : self . _check_device_status ( ) str_p = ffi . new ( \"wchar_t[]\" , 255 ) rv = hidapi . hid_get_serial_number_string ( self . _device , str_p , 255 ) if rv == - 1 : raise IOError ( \"Failed to read serial number string from HID \" \"device: {0}\" . format ( self . _get_last_error_string ( ) ) ) return ffi . string ( str_p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a main config value or default if it does not exist . [CODESPLIT] def _get_config_or_default ( self , key , default , as_type = lambda x : x ) : if self . main_config . has_option ( self . main_section , key ) : return as_type ( self . main_config . get ( self . main_section , key ) ) return default", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the local variables in the caller s frame . [CODESPLIT] def caller_locals ( ) : import inspect frame = inspect . currentframe ( ) try : return frame . f_back . f_back . f_locals finally : del frame", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a tuple of numbers . e . g . vertices normals or teture coords . [CODESPLIT] def readTuple ( self , line , n = 3 ) : numbers = [ num for num in line . split ( ' ' ) if num ] return [ float ( num ) for num in numbers [ 1 : n + 1 ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Display productpage with normal user and test user buttons [CODESPLIT] def index ( ) : global productpage table = json2html . convert ( json = json . dumps ( productpage ) , table_attributes = \"class=\\\"table table-condensed table-bordered table-hover\\\"\" ) return render_template ( 'index.html' , serviceTable = table )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Log out the active user [CODESPLIT] def logout ( ) : flogin . logout_user ( ) next = flask . request . args . get ( 'next' ) return flask . redirect ( next or flask . url_for ( \"user\" ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an instance of RedisSet . [CODESPLIT] def get_instance ( key , expire = None ) : global _instances try : instance = _instances [ key ] except KeyError : instance = RedisSet ( key , _redis , expire = expire ) _instances [ key ] = instance return instance", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Serialises a protobuf object as json [CODESPLIT] def toJson ( protoObject , indent = None ) : # Using the internal method because this way we can reformat the JSON js = json_format . MessageToDict ( protoObject , False ) return json . dumps ( js , indent = indent )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes all . py files . [CODESPLIT] def clean_py_files ( path ) : for dirname , subdirlist , filelist in os . walk ( path ) : for f in filelist : if f . endswith ( 'py' ) : os . remove ( os . path . join ( dirname , f ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Locate the command s man page . [CODESPLIT] def locate ( command , on ) : location = find_page_location ( command , on ) click . echo ( location )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pop the heap value from the heap . [CODESPLIT] def pop ( h ) : n = h . size ( ) - 1 h . swap ( 0 , n ) down ( h , 0 , n ) return h . pop ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Alternate name for filter so as to not collide with the built - in python filter operator . [CODESPLIT] def filter_ ( stream_spec , filter_name , * args , * * kwargs ) : return filter ( stream_spec , filter_name , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a list of sentences in french and preprocesses them . [CODESPLIT] def preprocess_french ( trans , fr_nlp , remove_brackets_content = True ) : if remove_brackets_content : trans = pangloss . remove_content_in_brackets ( trans , \"[]\" ) # Not sure why I have to split and rejoin, but that fixes a Spacy token # error. trans = fr_nlp ( \" \" . join ( trans . split ( ) [ : ] ) ) #trans = fr_nlp(trans) trans = \" \" . join ( [ token . lower_ for token in trans if not token . is_punct ] ) return trans", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the the number of columns required to display a string [CODESPLIT] def _visual_width ( line ) : return len ( re . sub ( colorama . ansitowin32 . AnsiToWin32 . ANSI_CSI_RE , \"\" , line ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This removes newlines and multiple spaces from a string . [CODESPLIT] def normalize_value ( text ) : result = text . replace ( '\\n' , ' ' ) result = re . subn ( '[ ]{2,}' , ' ' , result ) [ 0 ] return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize s into ASCII and replace non - word characters with delimiter . [CODESPLIT] def slugify ( s , delimiter = '-' ) : s = unicodedata . normalize ( 'NFKD' , to_unicode ( s ) ) . encode ( 'ascii' , 'ignore' ) . decode ( 'ascii' ) return RE_SLUG . sub ( delimiter , s ) . strip ( delimiter ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a new Gtk . StatusIcon . [CODESPLIT] def _create_statusicon ( self ) : statusicon = Gtk . StatusIcon ( ) statusicon . set_from_gicon ( self . _icons . get_gicon ( 'media' ) ) statusicon . set_tooltip_text ( _ ( \"udiskie\" ) ) return statusicon", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove duplicated elements in a list . Args : lista : List with elements to clean duplicates . [CODESPLIT] def remove_list_duplicates ( lista , unique = False ) : result = [ ] allready = [ ] for elem in lista : if elem not in result : result . append ( elem ) else : allready . append ( elem ) if unique : for elem in allready : result = list ( filter ( ( elem ) . __ne__ , result ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This will rearrange the array a [ n ] from lowest to highest and rearrange the rest of a [ i ] s in the same way . It is dumb and slow . [CODESPLIT] def sort_matrix ( a , n = 0 ) : a = _n . array ( a ) return a [ : , a [ n , : ] . argsort ( ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform re . sub with the patterns in the given dict Args : dict_ : { pattern : repl } source : str [CODESPLIT] def substitute ( dict_ , source ) : d_esc = ( re . escape ( k ) for k in dict_ . keys ( ) ) pattern = re . compile ( '|' . join ( d_esc ) ) return pattern . sub ( lambda x : dict_ [ x . group ( ) ] , source )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if the user is rooted . [CODESPLIT] def _is_root ( ) : import os import ctypes try : return os . geteuid ( ) == 0 except AttributeError : return ctypes . windll . shell32 . IsUserAnAdmin ( ) != 0 return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resets a user s password [CODESPLIT] def reset_password ( app , appbuilder , username , password ) : _appbuilder = import_application ( app , appbuilder ) user = _appbuilder . sm . find_user ( username = username ) if not user : click . echo ( \"User {0} not found.\" . format ( username ) ) else : _appbuilder . sm . reset_password ( user . id , password ) click . echo ( click . style ( \"User {0} reseted.\" . format ( username ) , fg = \"green\" ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A very thin wrapper around textwrap . fill to consistently wrap documentation text for display in a command line environment . The text is wrapped to 99 characters with an indentation depth of 4 spaces . Each line is wrapped independently in order to preserve manually added line breaks . [CODESPLIT] def format_doc_text ( text ) : return '\\n' . join ( textwrap . fill ( line , width = 99 , initial_indent = '    ' , subsequent_indent = '    ' ) for line in inspect . cleandoc ( text ) . splitlines ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "reads the zip file determines compression and unzips recursively until source files are extracted [CODESPLIT] def extract_all ( zipfile , dest_folder ) : z = ZipFile ( zipfile ) print ( z ) z . extract ( dest_folder )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a response object for the request . Can be overridden to return different responses . [CODESPLIT] def create_response ( self , request , content , content_type ) : return HttpResponse ( content = content , content_type = content_type )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Choose the most common item from the list or the first item if all items are unique . [CODESPLIT] def mostCommonItem ( lst ) : # This elegant solution from: http://stackoverflow.com/a/1518632/1760218 lst = [ l for l in lst if l ] if lst : return max ( set ( lst ) , key = lst . count ) else : return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test that a and b are close and match in shape . [CODESPLIT] def allclose ( a , b ) : from numpy import allclose return ( a . shape == b . shape ) and allclose ( a , b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a reversed iterable over the items in the dictionary . Items are iterated over in their reverse sort order . [CODESPLIT] def __reversed__ ( self ) : _dict = self . _dict return iter ( ( key , _dict [ key ] ) for key in reversed ( self . _list ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add optparse or argparse option depending on CmdHelper initialization . [CODESPLIT] def add_option ( self , * args , * * kwargs ) : if self . parseTool == 'argparse' : if args and args [ 0 ] == '' : # no short option args = args [ 1 : ] return self . parser . add_argument ( * args , * * kwargs ) else : return self . parser . add_option ( * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a python string to c array . [CODESPLIT] def c_array ( ctype , values ) : if isinstance ( values , np . ndarray ) and values . dtype . itemsize == ctypes . sizeof ( ctype ) : return ( ctype * len ( values ) ) . from_buffer_copy ( values ) return ( ctype * len ( values ) ) ( * values )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if specified URL is cached . [CODESPLIT] def is_cached ( self , url ) : try : return True if url in self . cache else False except TypeError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Populate axis limits GUI with current plot values . [CODESPLIT] def set_xlimits_widgets ( self , set_min = True , set_max = True ) : xmin , xmax = self . tab_plot . ax . get_xlim ( ) if set_min : self . w . x_lo . set_text ( '{0}' . format ( xmin ) ) if set_max : self . w . x_hi . set_text ( '{0}' . format ( xmax ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how long you should cache results for cacheable queries [CODESPLIT] def ttl ( self ) : ret = 3600 cn = self . get_process ( ) if \"ttl\" in cn : ret = cn [ \"ttl\" ] return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Advance the iterator without returning the old head . [CODESPLIT] def _fill ( self ) : try : self . _head = self . _iterable . next ( ) except StopIteration : self . _head = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string from snake case to camel case with the first letter capitalized . For example some_var would become SomeVar . [CODESPLIT] def to_capitalized_camel_case ( snake_case_string ) : parts = snake_case_string . split ( '_' ) return '' . join ( [ i . title ( ) for i in parts ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Solves a linear equation system with a matrix of shape ( n n ) and an array of shape ( n ... ) . The output has the same shape as the second argument . [CODESPLIT] def solve ( A , x ) : # https://stackoverflow.com/a/48387507/353337 x = numpy . asarray ( x ) return numpy . linalg . solve ( A , x . reshape ( x . shape [ 0 ] , - 1 ) ) . reshape ( x . shape )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a histogram for the data to the axes . [CODESPLIT] def _histplot_op ( ax , data , * * kwargs ) : bins = get_bins ( data ) ax . hist ( data , bins = bins , align = \"left\" , density = True , * * kwargs ) return ax", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert from file : // url to file path [CODESPLIT] def from_file_url ( url ) : if url . startswith ( 'file://' ) : url = url [ len ( 'file://' ) : ] . replace ( '/' , os . path . sep ) return url", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Stops the status update thread . [CODESPLIT] def _StopStatusUpdateThread ( self ) : self . _status_update_active = False if self . _status_update_thread . isAlive ( ) : self . _status_update_thread . join ( ) self . _status_update_thread = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Executes self . function to convert LazyString instance to a real str . [CODESPLIT] def __str__ ( self ) : if not hasattr ( self , '_str' ) : self . _str = self . function ( * self . args , * * self . kwargs ) return self . _str", "target": 1, "target_options": ["no_match", "match"]}
{"input": "detect if a model has a given field has [CODESPLIT] def has_field ( mc , field_name ) : try : mc . _meta . get_field ( field_name ) except FieldDoesNotExist : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determines if a system process identifer exists in process table . [CODESPLIT] def pid_exists ( pid ) : try : os . kill ( pid , 0 ) except OSError as exc : return exc . errno == errno . EPERM else : return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Weeks start are fixes at Monday for now . [CODESPLIT] def weekly ( date = datetime . date . today ( ) ) : return date - datetime . timedelta ( days = date . weekday ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Qt slot when the window is closed . [CODESPLIT] def closeEvent ( self , e ) : if self . _closed : return res = self . emit ( 'close' ) # Discard the close event if False is returned by one of the callback # functions. if False in res : # pragma: no cover e . ignore ( ) return super ( GUI , self ) . closeEvent ( e ) self . _closed = True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Similar to print but prints to stderr . [CODESPLIT] def print_err ( * args , end = '\\n' ) : print ( * args , end = end , file = sys . stderr ) sys . stderr . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Search into instance attributes properties and return values of no - args methods . [CODESPLIT] def instance_contains ( container , item ) : return item in ( member for _ , member in inspect . getmembers ( container ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns first and last element of numpy array or sparse matrix . [CODESPLIT] def _first_and_last_element ( arr ) : if isinstance ( arr , np . ndarray ) or hasattr ( arr , 'data' ) : # numpy array or sparse matrix with .data attribute data = arr . data if sparse . issparse ( arr ) else arr return data . flat [ 0 ] , data . flat [ - 1 ] else : # Sparse matrices without .data attribute. Only dok_matrix at # the time of writing, in this case indexing is fast return arr [ 0 , 0 ] , arr [ - 1 , - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the string is only composed of hex characters . [CODESPLIT] def is_hex_string ( string ) : pattern = re . compile ( r'[A-Fa-f0-9]+' ) if isinstance ( string , six . binary_type ) : string = str ( string ) return pattern . match ( string ) is not None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap the text on the given line length . [CODESPLIT] def normalize_text ( text , line_len = 80 , indent = \"\" ) : return \"\\n\" . join ( textwrap . wrap ( text , width = line_len , initial_indent = indent , subsequent_indent = indent ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "%D . [CODESPLIT] def percent_d ( data , period ) : p_k = percent_k ( data , period ) percent_d = sma ( p_k , 3 ) return percent_d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yaml either have automatically converted it to a datetime object or it is a string that will be validated later . [CODESPLIT] def is_timestamp ( obj ) : return isinstance ( obj , datetime . datetime ) or is_string ( obj ) or is_int ( obj ) or is_float ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a character delimited version of the provided list as a Python string [CODESPLIT] def delimited ( items , character = '|' ) : return '|' . join ( items ) if type ( items ) in ( list , tuple , set ) else items", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if given filename is an image . [CODESPLIT] def is_image ( filename ) : # note: isfile() also accepts symlinks return os . path . isfile ( filename ) and filename . lower ( ) . endswith ( ImageExts )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the median of a list . [CODESPLIT] def median ( data ) : data . sort ( ) num_values = len ( data ) half = num_values // 2 if num_values % 2 : return data [ half ] return 0.5 * ( data [ half - 1 ] + data [ half ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Saves the case as an Excel spreadsheet . [CODESPLIT] def save_excel ( self , fd ) : from pylon . io . excel import ExcelWriter ExcelWriter ( self ) . write ( fd )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds passed value to node s globals [CODESPLIT] def set_global ( node : Node , key : str , value : Any ) : node . node_globals [ key ] = value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compare items in 2 arrays . Returns sum ( abs ( a ( i ) - b ( i ))) [CODESPLIT] def compare ( a , b ) : s = 0 for i in range ( len ( a ) ) : s = s + abs ( a [ i ] - b [ i ] ) return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute a normal python statement in user namespace . [CODESPLIT] def ex ( self , cmd ) : with self . builtin_trap : exec cmd in self . user_global_ns , self . user_ns", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a sort lambda function for the sortedbykey [CODESPLIT] def _sort_lambda ( sortedby = 'cpu_percent' , sortedby_secondary = 'memory_percent' ) : ret = None if sortedby == 'io_counters' : ret = _sort_io_counters elif sortedby == 'cpu_times' : ret = _sort_cpu_times return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sample a colormap from matplotlib [CODESPLIT] def sample_colormap ( cmap_name , n_samples ) : colors = [ ] colormap = cm . cmap_d [ cmap_name ] for i in np . linspace ( 0 , 1 , n_samples ) : colors . append ( colormap ( i ) ) return colors", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Implements string formatting along with color specified in colorama . Fore [CODESPLIT] def colorize ( string , color , * args , * * kwargs ) : string = string . format ( * args , * * kwargs ) return color + string + colorama . Fore . RESET", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check match between two strings ignoring case and spaces / underscores . Parameters ---------- a : str b : str Returns ------- bool [CODESPLIT] def matchfieldnames ( field_a , field_b ) : normalised_a = field_a . replace ( ' ' , '_' ) . lower ( ) normalised_b = field_b . replace ( ' ' , '_' ) . lower ( ) return normalised_a == normalised_b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a list of dictionaries which each give a constraint for a certain section of the dimension . [CODESPLIT] def constraint_range_dict ( self , * args , * * kwargs ) : bins = self . bins ( * args , * * kwargs ) return [ { self . name + '__gte' : a , self . name + '__lt' : b } for a , b in zip ( bins [ : - 1 ] , bins [ 1 : ] ) ] space = self . space ( * args , * * kwargs ) resolution = space [ 1 ] - space [ 0 ] return [ { self . name + '__gte' : s , self . name + '__lt' : s + resolution } for s in space ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract text from pdfs using pdfminer . [CODESPLIT] def extract_pdfminer ( self , filename , * * kwargs ) : stdout , _ = self . run ( [ 'pdf2txt.py' , filename ] ) return stdout", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pdf evaluated at the peak . [CODESPLIT] def _pdf_at_peak ( self ) : return ( self . peak - self . low ) / ( self . high - self . low )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": return : list (( option value ) ... ) pairs of all items in the given section [CODESPLIT] def items ( self , section_name ) : return [ ( k , v ) for k , v in super ( GitConfigParser , self ) . items ( section_name ) if k != '__name__' ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates an email address Source : Himanshu Shankar ( https : // github . com / iamhssingh ) Parameters ---------- email : str [CODESPLIT] def validate_email ( email ) : from django . core . validators import validate_email from django . core . exceptions import ValidationError try : validate_email ( email ) return True except ValidationError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Zoom the center of image x by a factor of z + 1 while retaining the original image size and proportion . [CODESPLIT] def zoom_cv ( x , z ) : if z == 0 : return x r , c ,  * _ = x . shape M = cv2 . getRotationMatrix2D ( ( c / 2 , r / 2 ) , 0 , z + 1. ) return cv2 . warpAffine ( x , M , ( c , r ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "glm link function this is useful for going from mu to the linear prediction [CODESPLIT] def link ( self , mu , dist ) : return np . log ( mu ) - np . log ( dist . levels - mu )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts markdown content to text [CODESPLIT] def md_to_text ( content ) : text = None html = markdown . markdown ( content ) if html : text = html_to_text ( content ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "From : http : // stackoverflow . com / questions / 13062300 / convert - a - dict - to - sorted - dict - in - python [CODESPLIT] def format_result ( input ) : items = list ( iteritems ( input ) ) return OrderedDict ( sorted ( items , key = lambda x : x [ 0 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Kill the browser . [CODESPLIT] def kill ( self ) : if self . process : self . process . kill ( ) self . process . wait ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Makes a package name [CODESPLIT] def packagenameify ( s ) : return '' . join ( w if w in ACRONYMS else w . title ( ) for w in s . split ( '.' ) [ - 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert json string representation into class instance . [CODESPLIT] def from_json_str ( cls , json_str ) : return cls . from_json ( json . loads ( json_str , cls = JsonDecoder ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the next scheduled time by creating a crontab object with a cron string [CODESPLIT] def get_next_scheduled_time ( cron_string ) : itr = croniter . croniter ( cron_string , datetime . utcnow ( ) ) return itr . get_next ( datetime )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pop - up menu and wx . EVT_CLOSE closing event [CODESPLIT] def on_close ( self , evt ) : self . stop ( ) # DoseWatcher if evt . EventObject is not self : # Avoid deadlocks self . Close ( ) # wx.Frame evt . Skip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the mean absolute error . [CODESPLIT] def _mean_absolute_error ( y , y_pred , w ) : return np . average ( np . abs ( y_pred - y ) , weights = w )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses a YAML source into a Python object . [CODESPLIT] def Parse ( text ) : precondition . AssertType ( text , Text ) if compatibility . PY2 : text = text . encode ( \"utf-8\" ) return yaml . safe_load ( text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A wrapper for the user - defined handle . [CODESPLIT] def _monitor_callback_wrapper ( callback ) : def callback_handle ( name , array , _ ) : \"\"\" ctypes function \"\"\" callback ( name , array ) return callback_handle", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract the content of the zip - file at zip_path into target_folder . [CODESPLIT] def extract_zip ( zip_path , target_folder ) : with zipfile . ZipFile ( zip_path ) as archive : archive . extractall ( target_folder )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a ctypes int pointer array to a numpy array . [CODESPLIT] def cint32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int32 ) ) : return np . fromiter ( cptr , dtype = np . int32 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a ctypes float pointer array to a numpy array . [CODESPLIT] def cfloat32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_float ) ) : return np . fromiter ( cptr , dtype = np . float32 , count = length ) else : raise RuntimeError ( 'Expected float pointer' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if object is defined [CODESPLIT] def is_defined ( self , objtxt , force_import = False ) : return self . interpreter . is_defined ( objtxt , force_import )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate indexes to change from col - major to row - major ordering [CODESPLIT] def _idx_col2rowm ( d ) : if 0 == len ( d ) : return 1 if 1 == len ( d ) : return np . arange ( d [ 0 ] ) # order='F' indicates column-major ordering idx = np . array ( np . arange ( np . prod ( d ) ) ) . reshape ( d , order = 'F' ) . T return idx . flatten ( order = 'F' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if the class is a date type . [CODESPLIT] def is_date_type ( cls ) : if not isinstance ( cls , type ) : return False return issubclass ( cls , date ) and not issubclass ( cls , datetime )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like isin but checks whether this expression s value ( s ) are not contained in the passed values . See isin docs for full usage . [CODESPLIT] def notin ( arg , values ) : op = ops . NotContains ( arg , values ) return op . to_expr ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check lowercase key item . [CODESPLIT] def __contains__ ( self , key ) : assert isinstance ( key , basestring ) return dict . __contains__ ( self , key . lower ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the modified time for a file as a datetime instance [CODESPLIT] def get_time ( filename ) : ts = os . stat ( filename ) . st_mtime return datetime . datetime . utcfromtimestamp ( ts )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a password is valid [CODESPLIT] def is_password_valid ( password ) : pattern = re . compile ( r\"^.{4,75}$\" ) return bool ( pattern . match ( password ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses CREATE INDEX CONCURRENTLY to create a duplicate index then tries to swap the new index for the original . [CODESPLIT] def cmd_reindex ( ) : db = connect ( args . database ) for idx in args . indexes : pg_reindex ( db , idx )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extend the list by appending all the items in the given list . [CODESPLIT] def extend ( self , iterable ) : return super ( Collection , self ) . extend ( self . _ensure_iterable_is_valid ( iterable ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return whether num is a power of two [CODESPLIT] def is_power_of_2 ( num ) : log = math . log2 ( num ) return int ( log ) == float ( log )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a percentile range from an array of values . [CODESPLIT] def ci ( a , which = 95 , axis = None ) : p = 50 - which / 2 , 50 + which / 2 return percentiles ( a , p , axis )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if contents of the files are the same [CODESPLIT] def cmp_contents ( filename1 , filename2 ) : with open_readable ( filename1 , 'rb' ) as fobj : contents1 = fobj . read ( ) with open_readable ( filename2 , 'rb' ) as fobj : contents2 = fobj . read ( ) return contents1 == contents2", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transforation matrix from rotation matrix and translation vector . [CODESPLIT] def transform_from_rot_trans ( R , t ) : R = R . reshape ( 3 , 3 ) t = t . reshape ( 3 , 1 ) return np . vstack ( ( np . hstack ( [ R , t ] ) , [ 0 , 0 , 0 , 1 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if Glances is running in client mode . [CODESPLIT] def is_client ( self ) : return ( self . args . client or self . args . browser ) and not self . args . server", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given two data points [ X Y ] linearly interpolate those at x . [CODESPLIT] def _linear_interpolation ( x , X , Y ) : return ( Y [ 1 ] * ( x - X [ 0 ] ) + Y [ 0 ] * ( X [ 1 ] - x ) ) / ( X [ 1 ] - X [ 0 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check a string is utf - 8 encoded [CODESPLIT] def _is_utf_8 ( txt ) : assert isinstance ( txt , six . binary_type ) try : _ = six . text_type ( txt , 'utf-8' ) except ( TypeError , UnicodeEncodeError ) : return False else : return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialize Log Analytics data client for use with CLI . [CODESPLIT] def loganalytics_data_plane_client ( cli_ctx , _ ) : from . vendored_sdks . loganalytics import LogAnalyticsDataClient from azure . cli . core . _profile import Profile profile = Profile ( cli_ctx = cli_ctx ) cred , _ , _ = profile . get_login_credentials ( resource = \"https://api.loganalytics.io\" ) return LogAnalyticsDataClient ( cred )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a boolean list where each elements is whether that element in the column is in the compare_list . [CODESPLIT] def isin ( self , column , compare_list ) : return [ x in compare_list for x in self . _data [ self . _columns . index ( column ) ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Writes a DOT graphviz file of the domain structure and returns the filename [CODESPLIT] def to_dotfile ( self ) : domain = self . get_domain ( ) filename = \"%s.dot\" % ( self . __class__ . __name__ ) nx . write_dot ( domain , filename ) return filename", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether the provided value is a valid enum constant . [CODESPLIT] def check ( self , var ) : if not isinstance ( var , _str_type ) : return False return _enum_mangle ( var ) in self . _consts", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds a padding to the given image as background of specified color [CODESPLIT] def add_bg ( img , padding , color = COL_WHITE ) : img = gray3 ( img ) h , w , d = img . shape new_img = np . ones ( ( h + 2 * padding , w + 2 * padding , d ) ) * color [ : d ] new_img = new_img . astype ( np . uint8 ) set_img_box ( new_img , ( padding , padding , w , h ) , img ) return new_img", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Search into instance attributes properties and return values of no - args methods . [CODESPLIT] def instance_contains ( container , item ) : return item in ( member for _ , member in inspect . getmembers ( container ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check the syntax of the given URL . [CODESPLIT] def url_syntax_check ( url ) : # pragma: no cover if url and isinstance ( url , str ) : # The given URL is not empty nor None. # and # * The given URL is a string. # We silently load the configuration. load_config ( True ) return Check ( url ) . is_url_valid ( ) # We return None, there is nothing to check. return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip # markers at the front of a block of comment text . [CODESPLIT] def strip_comment_marker ( text ) : lines = [ ] for line in text . splitlines ( ) : lines . append ( line . lstrip ( '#' ) ) text = textwrap . dedent ( '\\n' . join ( lines ) ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resets all assigned data for the current message . [CODESPLIT] def _clear ( self ) : self . _finished = False self . _measurement = None self . _message = None self . _message_body = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clear not used counters [CODESPLIT] def trim ( self ) : for key , value in list ( iteritems ( self . counters ) ) : if value . empty ( ) : del self . counters [ key ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Construct the adjacency matrix of the tree : param tree : : return : [CODESPLIT] def adjacency ( tree ) : dd = ids ( tree ) N = len ( dd ) A = np . zeros ( ( N , N ) ) def _adj ( node ) : if np . isscalar ( node ) : return elif isinstance ( node , tuple ) and len ( node ) == 2 : A [ dd [ node ] , dd [ node [ 0 ] ] ] = 1 A [ dd [ node [ 0 ] ] , dd [ node ] ] = 1 _adj ( node [ 0 ] ) A [ dd [ node ] , dd [ node [ 1 ] ] ] = 1 A [ dd [ node [ 1 ] ] , dd [ node ] ] = 1 _adj ( node [ 1 ] ) _adj ( tree ) return A", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns system clipboard contents . [CODESPLIT] def paste ( cmd = paste_cmd , stdout = PIPE ) : return Popen ( cmd , stdout = stdout ) . communicate ( ) [ 0 ] . decode ( 'utf-8' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Construct the adjacency matrix of the tree : param tree : : return : [CODESPLIT] def adjacency ( tree ) : dd = ids ( tree ) N = len ( dd ) A = np . zeros ( ( N , N ) ) def _adj ( node ) : if np . isscalar ( node ) : return elif isinstance ( node , tuple ) and len ( node ) == 2 : A [ dd [ node ] , dd [ node [ 0 ] ] ] = 1 A [ dd [ node [ 0 ] ] , dd [ node ] ] = 1 _adj ( node [ 0 ] ) A [ dd [ node ] , dd [ node [ 1 ] ] ] = 1 A [ dd [ node [ 1 ] ] , dd [ node ] ] = 1 _adj ( node [ 1 ] ) _adj ( tree ) return A", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clones object with optionally overridden fields [CODESPLIT] def clone ( src , * * kwargs ) : obj = object . __new__ ( type ( src ) ) obj . __dict__ . update ( src . __dict__ ) obj . __dict__ . update ( kwargs ) return obj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Usage : containment activate [CODESPLIT] def activate ( ) : # This is derived from the clone cli = CommandLineInterface ( ) cli . ensure_config ( ) cli . write_dockerfile ( ) cli . build ( ) cli . run ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply a function in parallel to each element of the input [CODESPLIT] def apply ( f , obj , * args , * * kwargs ) : return vectorize ( f ) ( obj , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate random string of given length [CODESPLIT] def generate_hash ( self , length = 30 ) : import random , string chars = string . ascii_letters + string . digits ran = random . SystemRandom ( ) . choice hash = '' . join ( ran ( chars ) for i in range ( length ) ) return hash", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply a function in parallel to each element of the input [CODESPLIT] def apply ( f , obj , * args , * * kwargs ) : return vectorize ( f ) ( obj , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the angle between vector x and y [CODESPLIT] def angle_between_vectors ( x , y ) : dp = dot_product ( x , y ) if dp == 0 : return 0 xm = magnitude ( x ) ym = magnitude ( y ) return math . acos ( dp / ( xm * ym ) ) * ( 180. / math . pi )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether one of the items in the list has multiple lines . [CODESPLIT] def has_multiline_items ( maybe_list : Optional [ Sequence [ str ] ] ) : return maybe_list and any ( is_multiline ( item ) for item in maybe_list )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit the shell session . [CODESPLIT] def do_exit ( self , arg ) : if self . current : self . current . close ( ) self . resource_manager . close ( ) del self . resource_manager return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Segmented min op . [CODESPLIT] def SegmentMin ( a , ids ) : func = lambda idxs : np . amin ( a [ idxs ] , axis = 0 ) return seg_map ( func , a , ids ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generates a random ID of given length [CODESPLIT] def random_id ( length ) : def char ( ) : \"\"\"Generate single random char\"\"\" return random . choice ( string . ascii_letters + string . digits ) return \"\" . join ( char ( ) for _ in range ( length ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Join helper [CODESPLIT] def _join ( verb ) : data = pd . merge ( verb . x , verb . y , * * verb . kwargs ) # Preserve x groups if isinstance ( verb . x , GroupedDataFrame ) : data . plydata_groups = list ( verb . x . plydata_groups ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete credentials from the SQLAlchemy datastore . [CODESPLIT] def locked_delete ( self ) : filters = { self . key_name : self . key_value } self . session . query ( self . model_class ) . filter_by ( * * filters ) . delete ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Formats Python code to conform to the PEP 8 style guide . [CODESPLIT] def rpc_fix_code ( self , source , directory ) : source = get_source ( source ) return fix_code ( source , directory )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Computes average length of words [CODESPLIT] def get_average_length_of_string ( strings ) : if not strings : return 0 return sum ( len ( word ) for word in strings ) / len ( strings )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the arithematic mean of the values in the passed list . Assumes a 1D list but will function on the 1st dim of an array ( ! ) . [CODESPLIT] def mean ( inlist ) : sum = 0 for item in inlist : sum = sum + item return sum / float ( len ( inlist ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create lambda alias with env name and points it to $LATEST . [CODESPLIT] def create_alias ( self ) : LOG . info ( 'Creating alias %s' , self . env ) try : self . lambda_client . create_alias ( FunctionName = self . app_name , Name = self . env , FunctionVersion = '$LATEST' , Description = 'Alias for {}' . format ( self . env ) ) except boto3 . exceptions . botocore . exceptions . ClientError as error : LOG . debug ( 'Create alias error: %s' , error ) LOG . info ( \"Alias creation failed. Retrying...\" ) raise", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Support change columns . [CODESPLIT] def alter_change_column ( self , table , column , field ) : return self . _update_column ( table , column , lambda a , b : b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates an AWS Chalice project for deployment to AWS Lambda . [CODESPLIT] def create_aws_lambda ( ctx , bucket , region_name , aws_access_key_id , aws_secret_access_key ) : from canari . commands . create_aws_lambda import create_aws_lambda create_aws_lambda ( ctx . project , bucket , region_name , aws_access_key_id , aws_secret_access_key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "List all RDS thingys . [CODESPLIT] def list_rds ( region , filter_by_kwargs ) : conn = boto . rds . connect_to_region ( region ) instances = conn . get_all_dbinstances ( ) return lookup ( instances , filter_by = filter_by_kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract a ALZIP archive . [CODESPLIT] def extract_alzip ( archive , compression , cmd , verbosity , interactive , outdir ) : return [ cmd , '-d' , outdir , archive ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a list of tuples describing a table into a HTML string [CODESPLIT] def html ( header_rows ) : name = 'table%d' % next ( tablecounter ) return HtmlTable ( [ map ( str , row ) for row in header_rows ] , name ) . render ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn bytes into base64 [CODESPLIT] def bytes_base64 ( x ) : if six . PY2 : return base64 . encodestring ( x ) . replace ( '\\n' , '' ) return base64 . encodebytes ( bytes_encode ( x ) ) . replace ( b'\\n' , b'' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Callback for comboboxes : notifies us that a combobox for the given item and column has changed [CODESPLIT] def _updateItemComboBoxIndex ( self , item , column , num ) : item . _combobox_current_index [ column ] = num item . _combobox_current_value [ column ] = item . _combobox_option_list [ column ] [ num ] [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "pops multiple keys off a dict like object [CODESPLIT] def multi_pop ( d , * args ) : retval = { } for key in args : if key in d : retval [ key ] = d . pop ( key ) return retval", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Called when a new DropDownItem gets selected . [CODESPLIT] def onchange ( self , value ) : log . debug ( 'combo box. selected %s' % value ) self . select_by_value ( value ) return ( value , )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return checker . [CODESPLIT] def cpp_checker ( code , working_directory ) : return gcc_checker ( code , '.cpp' , [ os . getenv ( 'CXX' , 'g++' ) , '-std=c++0x' ] + INCLUDE_FLAGS , working_directory = working_directory )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Copy [CODESPLIT] def getBuffer ( x ) : b = bytes ( x ) return ( c_ubyte * len ( b ) ) . from_buffer_copy ( bytes ( x ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compose all given tuples together . [CODESPLIT] def compose_all ( tups ) : from . import ast # I weep for humanity return functools . reduce ( lambda x , y : x . compose ( y ) , map ( ast . make_tuple , tups ) , ast . make_tuple ( { } ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is the same functionality as int . from_bytes in python 3 [CODESPLIT] def _from_bytes ( bytes , byteorder = \"big\" , signed = False ) : return int . from_bytes ( bytes , byteorder = byteorder , signed = signed )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a ConfigParser to a dictionary . [CODESPLIT] def config_parser_to_dict ( config_parser ) : response = { } for section in config_parser . sections ( ) : for option in config_parser . options ( section ) : response . setdefault ( section , { } ) [ option ] = config_parser . get ( section , option ) return response", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads an array from bytestring with big - endian data . [CODESPLIT] def be_array_from_bytes ( fmt , data ) : arr = array . array ( str ( fmt ) , data ) return fix_byteorder ( arr )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Inputs [ a b c ] returns { a : 0 b : 1 c : 2 } . [CODESPLIT] def list_string_to_dict ( string ) : dictionary = { } for idx , c in enumerate ( string ) : dictionary . update ( { c : idx } ) return dictionary", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns seconds since 0h00 . [CODESPLIT] def time2seconds ( t ) : return t . hour * 3600 + t . minute * 60 + t . second + float ( t . microsecond ) / 1e6", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Natural log of scipy norm function truncated at zero [CODESPLIT] def ln_norm ( x , mu , sigma = 1.0 ) : return np . log ( stats . norm ( loc = mu , scale = sigma ) . pdf ( x ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pull comma separated string values out of a text file and converts them to float list [CODESPLIT] def string_to_float_list ( string_var ) : try : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ', ' ) ] except : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ',' ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shortcut to create md5 hash : param s : : return : [CODESPLIT] def md5_string ( s ) : m = hashlib . md5 ( ) m . update ( s ) return str ( m . hexdigest ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convolve 2d gaussian . [CODESPLIT] def convolve_gaussian_2d ( image , gaussian_kernel_1d ) : result = scipy . ndimage . filters . correlate1d ( image , gaussian_kernel_1d , axis = 0 ) result = scipy . ndimage . filters . correlate1d ( result , gaussian_kernel_1d , axis = 1 ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns inverse of transformation . [CODESPLIT] def inverse ( self ) : invr = np . linalg . inv ( self . affine_matrix ) return SymmOp ( invr )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get the covarince between two points implied by Vario2d [CODESPLIT] def covariance ( self , pt0 , pt1 ) : x = np . array ( [ pt0 [ 0 ] , pt1 [ 0 ] ] ) y = np . array ( [ pt0 [ 1 ] , pt1 [ 1 ] ] ) names = [ \"n1\" , \"n2\" ] return self . covariance_matrix ( x , y , names = names ) . x [ 0 , 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prints the specified message and exits the program with the specified exit status . [CODESPLIT] def fail ( message = None , exit_status = None ) : print ( 'Error:' , message , file = sys . stderr ) sys . exit ( exit_status or 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Build the script s argument parser . [CODESPLIT] def build_parser ( ) : parser = argparse . ArgumentParser ( description = \"The IOTile task supervisor\" ) parser . add_argument ( '-c' , '--config' , help = \"config json with options\" ) parser . add_argument ( '-v' , '--verbose' , action = \"count\" , default = 0 , help = \"Increase logging verbosity\" ) return parser", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Send a command string to gdb . [CODESPLIT] def ExecuteRaw ( self , position , command ) : self . EnsureGdbPosition ( position [ 0 ] , None , None ) return gdb . execute ( command , to_string = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "In case the experiment enforces a quorum listen for notifications before creating Partipant objects . [CODESPLIT] def subscribe_to_quorum_channel ( self ) : from dallinger . experiment_server . sockets import chat_backend self . log ( \"Bot subscribing to quorum channel.\" ) chat_backend . subscribe ( self , \"quorum\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A function to generate the latex representation of sympy expressions . [CODESPLIT] def print_latex ( o ) : if can_print_latex ( o ) : s = latex ( o , mode = 'plain' ) s = s . replace ( '\\\\dag' , '\\\\dagger' ) s = s . strip ( '$' ) return '$$%s$$' % s # Fallback to the string printer return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "String hash ( djb2 ) with consistency between py2 / py3 and persistency between runs ( unlike hash ) . [CODESPLIT] def _string_hash ( s ) : h = 5381 for c in s : h = h * 33 + ord ( c ) return h", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add an object to Javascript . [CODESPLIT] def add_to_js ( self , name , var ) : frame = self . page ( ) . mainFrame ( ) frame . addToJavaScriptWindowObject ( name , var )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a datetime object representing the last time the file was modified [CODESPLIT] def get_mod_time ( self , path ) : conn = self . get_conn ( ) ftp_mdtm = conn . sendcmd ( 'MDTM ' + path ) time_val = ftp_mdtm [ 4 : ] # time_val optionally has microseconds try : return datetime . datetime . strptime ( time_val , \"%Y%m%d%H%M%S.%f\" ) except ValueError : return datetime . datetime . strptime ( time_val , '%Y%m%d%H%M%S' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the products from a query response as a Pandas DataFrame with the values in their appropriate Python types . [CODESPLIT] def to_dataframe ( products ) : try : import pandas as pd except ImportError : raise ImportError ( \"to_dataframe requires the optional dependency Pandas.\" ) return pd . DataFrame . from_dict ( products , orient = 'index' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "DOES NOT WORK WELL WITH MOPIDY Hack from https : // www . daniweb . com / software - development / python / code / 260268 / restart - your - python - program to support updating the settings since mopidy is not able to do that yet Restarts the current program Note : this function does not return . Any cleanup action ( like saving data ) must be done before calling this function [CODESPLIT] def restart_program ( ) : python = sys . executable os . execl ( python , python , * sys . argv )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets a new value to map element [CODESPLIT] def set_as_object ( self , value ) : self . clear ( ) map = MapConverter . to_map ( value ) self . append ( map )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates font style widget [CODESPLIT] def _update_font_style ( self , font_style ) : toggle_state = font_style & wx . FONTSTYLE_ITALIC == wx . FONTSTYLE_ITALIC self . ToggleTool ( wx . FONTFLAG_ITALIC , toggle_state )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transforma una string con elementos separados por sep en una lista . [CODESPLIT] def string_to_list ( string , sep = \",\" , filter_empty = False ) : return [ value . strip ( ) for value in string . split ( sep ) if ( not filter_empty or value ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a histogram for the data to the axes . [CODESPLIT] def _histplot_op ( ax , data , * * kwargs ) : bins = get_bins ( data ) ax . hist ( data , bins = bins , align = \"left\" , density = True , * * kwargs ) return ax", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Construct a single page PDF from the provided page in memory [CODESPLIT] def _single_page_pdf ( page ) : pdf = Pdf . new ( ) pdf . pages . append ( page ) bio = BytesIO ( ) pdf . save ( bio ) bio . seek ( 0 ) return bio . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize the length of a vector to one [CODESPLIT] def norm_vec ( vector ) : assert len ( vector ) == 3 v = np . array ( vector ) return v / np . sqrt ( np . sum ( v ** 2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Starts the web server . [CODESPLIT] def start ( ) : global app bottle . run ( app , host = conf . WebHost , port = conf . WebPort , debug = conf . WebAutoReload , reloader = conf . WebAutoReload , quiet = conf . WebQuiet )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Attempt to setattr but catch AttributeErrors . [CODESPLIT] def safe_setattr ( obj , name , value ) : try : setattr ( obj , name , value ) return True except AttributeError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper funcation that converts text - based get response to tab separated values for additional manipulation . [CODESPLIT] def _tab ( content ) : response = _data_frame ( content ) . to_csv ( index = False , sep = '\\t' ) return response", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert CamelCase to lower_and_underscore . [CODESPLIT] def decamelise ( text ) : s = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a ctypes int pointer array to a numpy array . [CODESPLIT] def cint32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int32 ) ) : return np . fromiter ( cptr , dtype = np . int32 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a ctypes double pointer array to a numpy array . [CODESPLIT] def cfloat64_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_double ) ) : return np . fromiter ( cptr , dtype = np . float64 , count = length ) else : raise RuntimeError ( 'Expected double pointer' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert Matrix attributes which are array - like or buffer to array . [CODESPLIT] def _convert_to_array ( array_like , dtype ) : if isinstance ( array_like , bytes ) : return np . frombuffer ( array_like , dtype = dtype ) return np . asarray ( array_like , dtype = dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shape a list of lists into the appropriate shape and data type [CODESPLIT] def shape_list ( l , shape , dtype ) : return np . array ( l , dtype = dtype ) . reshape ( shape )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert snake_case to camel_case . [CODESPLIT] def to_identifier ( s ) : if s . startswith ( 'GPS' ) : s = 'Gps' + s [ 3 : ] return '' . join ( [ i . capitalize ( ) for i in s . split ( '_' ) ] ) if '_' in s else s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip whitespace from string columns . [CODESPLIT] def strip_columns ( tab ) : for colname in tab . colnames : if tab [ colname ] . dtype . kind in [ 'S' , 'U' ] : tab [ colname ] = np . core . defchararray . strip ( tab [ colname ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param unicode fpath : : param unicode encoding : : rtype : dict | list [CODESPLIT] def load_jsonf ( fpath , encoding ) : with codecs . open ( fpath , encoding = encoding ) as f : return json . load ( f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert ISO 8601 time format to datetime format [CODESPLIT] def iso_to_datetime ( date ) : chunks = list ( map ( int , date . split ( 'T' ) [ 0 ] . split ( '-' ) ) ) return datetime . datetime ( chunks [ 0 ] , chunks [ 1 ] , chunks [ 2 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a stringified representation of this object . [CODESPLIT] def __repr__ ( self ) : return str ( { 'name' : self . _name , 'watts' : self . _watts , 'type' : self . _output_type , 'id' : self . _integration_id } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Weeks start are fixes at Monday for now . [CODESPLIT] def weekly ( date = datetime . date . today ( ) ) : return date - datetime . timedelta ( days = date . weekday ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Makes a classname [CODESPLIT] def classnameify ( s ) : return '' . join ( w if w in ACRONYMS else w . title ( ) for w in s . split ( '_' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a : py : class : datetime . datetime instance representing the current time . [CODESPLIT] def now ( self ) : if self . use_utc : return datetime . datetime . utcnow ( ) else : return datetime . datetime . now ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate indexes to change from col - major to row - major ordering [CODESPLIT] def _idx_col2rowm ( d ) : if 0 == len ( d ) : return 1 if 1 == len ( d ) : return np . arange ( d [ 0 ] ) # order='F' indicates column-major ordering idx = np . array ( np . arange ( np . prod ( d ) ) ) . reshape ( d , order = 'F' ) . T return idx . flatten ( order = 'F' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return start and end date of the current week . [CODESPLIT] def this_week ( ) : since = TODAY + delta ( weekday = MONDAY ( - 1 ) ) until = since + delta ( weeks = 1 ) return Date ( since ) , Date ( until )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set single pixel to HSV tuple [CODESPLIT] def setHSV ( self , pixel , hsv ) : color = conversions . hsv2rgb ( hsv ) self . _set_base ( pixel , color )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse ISO8601 timestamps given by github API . [CODESPLIT] def parse_timestamp ( timestamp ) : dt = dateutil . parser . parse ( timestamp ) return dt . astimezone ( dateutil . tz . tzutc ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add one tick to progress bar [CODESPLIT] def tick ( self ) : self . current += 1 if self . current == self . factor : sys . stdout . write ( '+' ) sys . stdout . flush ( ) self . current = 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Provide a command prompt . [CODESPLIT] def input ( self , prompt , default = None , show_default = True ) : return click . prompt ( prompt , default = default , show_default = show_default )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets a naive datetime from a datetime . [CODESPLIT] def get_naive ( dt ) : if not dt . tzinfo : return dt if hasattr ( dt , \"asdatetime\" ) : return dt . asdatetime ( ) return dt . replace ( tzinfo = None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Increment the date by a certain number and return date object . as the specific string format . [CODESPLIT] def inc_date ( date_obj , num , date_fmt ) : return ( date_obj + timedelta ( days = num ) ) . strftime ( date_fmt )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "move cursor down [CODESPLIT] def select_down ( self ) : r , c = self . _index self . _select_index ( r + 1 , c )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param dt : pythone datetime . datetime : return : 1999 - 02 - 01 string type [CODESPLIT] def QA_util_datetime_to_strdate ( dt ) : strdate = \"%04d-%02d-%02d\" % ( dt . year , dt . month , dt . day ) return strdate", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Round the number to the specified number of significant figures [CODESPLIT] def round_sig ( x , sig ) : return round ( x , sig - int ( floor ( log10 ( abs ( x ) ) ) ) - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse an int robustly ignoring commas and other cruft . [CODESPLIT] def robust_int ( v ) : if isinstance ( v , int ) : return v if isinstance ( v , float ) : return int ( v ) v = str ( v ) . replace ( ',' , '' ) if not v : return None return int ( v )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a datetime object of a given timestamp ( in local tz ) . [CODESPLIT] def fromtimestamp ( cls , timestamp ) : d = cls . utcfromtimestamp ( timestamp ) return d . astimezone ( localtz ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert bytes and non - string into Python 3 str [CODESPLIT] def to_str ( s ) : if isinstance ( s , bytes ) : s = s . decode ( 'utf-8' ) elif not isinstance ( s , str ) : s = str ( s ) return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "this day last year [CODESPLIT] def today ( year = None ) : return datetime . date ( int ( year ) , _date . month , _date . day ) if year else _date", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Appends a PDF to a pyPDF writer . Legacy interface . [CODESPLIT] def append_pdf ( input_pdf : bytes , output_writer : PdfFileWriter ) : append_memory_pdf_to_writer ( input_pdf = input_pdf , writer = output_writer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add executable permissions to the file [CODESPLIT] def add_exec_permission_to ( target_file ) : mode = os . stat ( target_file ) . st_mode os . chmod ( target_file , mode | stat . S_IXUSR )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the default value for this key . Default only used when no value is provided by the user via arg config or env . [CODESPLIT] def set_default ( self , key , value ) : k = self . _real_key ( key . lower ( ) ) self . _defaults [ k ] = value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yaml either have automatically converted it to a datetime object or it is a string that will be validated later . [CODESPLIT] def is_timestamp ( obj ) : return isinstance ( obj , datetime . datetime ) or is_string ( obj ) or is_int ( obj ) or is_float ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Close last created figure alias to plt . close () . [CODESPLIT] def close ( * args , * * kwargs ) : _ , plt , _ = _import_plt ( ) plt . close ( * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Go up in stack and return True if top frame [CODESPLIT] def up ( self ) : if self . frame : self . frame = self . frame . f_back return self . frame is None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if an array is a square matrix . [CODESPLIT] def is_square_matrix ( mat ) : mat = np . array ( mat ) if mat . ndim != 2 : return False shape = mat . shape return shape [ 0 ] == shape [ 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is this a call with exactly 1 argument where that argument is positional? [CODESPLIT] def _is_one_arg_pos_call ( call ) : return isinstance ( call , astroid . Call ) and len ( call . args ) == 1 and not call . keywords", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return sanitized Eidos text field for human readability . [CODESPLIT] def _sanitize ( text ) : d = { '-LRB-' : '(' , '-RRB-' : ')' } return re . sub ( '|' . join ( d . keys ( ) ) , lambda m : d [ m . group ( 0 ) ] , text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deserialize the object from a JSON string . [CODESPLIT] def from_json ( cls , json_str ) : d = json . loads ( json_str ) return cls . from_dict ( d )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check lowercase key item . [CODESPLIT] def __contains__ ( self , key ) : assert isinstance ( key , basestring ) return dict . __contains__ ( self , key . lower ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Properly close pooled database connections [CODESPLIT] def dispose_orm ( ) : log . debug ( \"Disposing DB connection pool (PID %s)\" , os . getpid ( ) ) global engine global Session if Session : Session . remove ( ) Session = None if engine : engine . dispose ( ) engine = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "test if object is a list or tuple [CODESPLIT] def is_iter_non_string ( obj ) : if isinstance ( obj , list ) or isinstance ( obj , tuple ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If block = False ( the default ) die hard and fast if another process has already grabbed the lock for this file . [CODESPLIT] def lock_file ( f , block = False ) : try : flags = fcntl . LOCK_EX if not block : flags |= fcntl . LOCK_NB fcntl . flock ( f . fileno ( ) , flags ) except IOError as e : if e . errno in ( errno . EACCES , errno . EAGAIN ) : raise SystemExit ( \"ERROR: %s is locked by another process.\" % f . name ) raise", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Indicates whether or not the given row contains valid data . [CODESPLIT] def is_valid_row ( cls , row ) : for k in row . keys ( ) : if row [ k ] is None : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if a given string is an url [CODESPLIT] def is_valid_url ( url ) : pieces = urlparse ( url ) return all ( [ pieces . scheme , pieces . netloc ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Recursively iterate through values in nested lists . [CODESPLIT] def empty_tree ( input_list ) : for item in input_list : if not isinstance ( item , list ) or not empty_tree ( item ) : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Verify if a given table name is valid for rows [CODESPLIT] def _valid_table_name ( name ) : if name [ 0 ] not in \"_\" + string . ascii_letters or not set ( name ) . issubset ( \"_\" + string . ascii_letters + string . digits ) : return False else : return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "http : // www . swharden . com / blog / 2009 - 01 - 21 - signal - filtering - with - python / #comment - 16801 [CODESPLIT] def fft_bandpassfilter ( data , fs , lowcut , highcut ) : fft = np . fft . fft ( data ) # n = len(data) # timestep = 1.0 / fs # freq = np.fft.fftfreq(n, d=timestep) bp = fft . copy ( ) # Zero out fft coefficients # bp[10:-10] = 0 # Normalise # bp *= real(fft.dot(fft))/real(bp.dot(bp)) bp *= fft . dot ( fft ) / bp . dot ( bp ) # must multipy by 2 to get the correct amplitude ibp = 12 * np . fft . ifft ( bp ) return ibp", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return set of common words between two word sets . [CODESPLIT] def has_common ( self , other ) : if not isinstance ( other , WordSet ) : raise ValueError ( 'Can compare only WordSets' ) return self . term_set & other . term_set", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes dict keys which have have self as value . [CODESPLIT] def _remove_dict_keys_with_value ( dict_ , val ) : return { k : v for k , v in dict_ . items ( ) if v is not val }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "shows JSON indented representation of d [CODESPLIT] def pretty_dict_str ( d , indent = 2 ) : b = StringIO ( ) write_pretty_dict_str ( b , d , indent = indent ) return b . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the file size of a given file [CODESPLIT] def get_file_size ( filename ) : if os . path . isfile ( filename ) : return convert_size ( os . path . getsize ( filename ) ) return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "pops multiple keys off a dict like object [CODESPLIT] def multi_pop ( d , * args ) : retval = { } for key in args : if key in d : retval [ key ] = d . pop ( key ) return retval", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove null items from a dictionary [CODESPLIT] def purge_dict ( idict ) : odict = { } for key , val in idict . items ( ) : if is_null ( val ) : continue odict [ key ] = val return odict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Time execution of callable and emit metric then return result . [CODESPLIT] def timeit ( self , metric , func , * args , * * kwargs ) : return metrics . timeit ( metric , func , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call request and retry up to max_attempts times ( or none if self . max_attempts = 1 ) [CODESPLIT] def _call_retry ( self , force_retry ) : last_exception = None for i in range ( self . max_attempts ) : try : log . info ( \"Calling %s %s\" % ( self . method , self . url ) ) response = self . requests_method ( self . url , data = self . data , params = self . params , headers = self . headers , timeout = ( self . connect_timeout , self . read_timeout ) , verify = self . verify_ssl , ) if response is None : log . warn ( \"Got response None\" ) if self . _method_is_safe_to_retry ( ) : delay = 0.5 + i * 0.5 log . info ( \"Waiting %s sec and Retrying since call is a %s\" % ( delay , self . method ) ) time . sleep ( delay ) continue else : raise PyMacaronCoreException ( \"Call %s %s returned empty response\" % ( self . method , self . url ) ) return response except Exception as e : last_exception = e retry = force_retry if isinstance ( e , ReadTimeout ) : # Log enough to help debugging... log . warn ( \"Got a ReadTimeout calling %s %s\" % ( self . method , self . url ) ) log . warn ( \"Exception was: %s\" % str ( e ) ) resp = e . response if not resp : log . info ( \"Requests error has no response.\" ) # TODO: retry=True? Is it really safe? else : b = resp . content log . info ( \"Requests has a response with content: \" + pprint . pformat ( b ) ) if self . _method_is_safe_to_retry ( ) : # It is safe to retry log . info ( \"Retrying since call is a %s\" % self . method ) retry = True elif isinstance ( e , ConnectTimeout ) : log . warn ( \"Got a ConnectTimeout calling %s %s\" % ( self . method , self . url ) ) log . warn ( \"Exception was: %s\" % str ( e ) ) # ConnectTimeouts are safe to retry whatever the call... retry = True if retry : continue else : raise e # max_attempts has been reached: propagate the last received Exception if not last_exception : last_exception = Exception ( \"Reached max-attempts (%s). Giving up calling %s %s\" % ( self . max_attempts , self . method , self . url ) ) raise last_exception", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Callback for closing the websocket connection [CODESPLIT] def _ws_on_close ( self , ws : websocket . WebSocketApp ) : self . connected = False self . logger . error ( 'Websocket closed' ) self . _reconnect_websocket ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the adjacency matrix of a bipartite graph whose biadjacency matrix is A . [CODESPLIT] def to_bipartite_matrix ( A ) : m , n = A . shape return four_blocks ( zeros ( m , m ) , A , A . T , zeros ( n , n ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if string could be a valid python identifier [CODESPLIT] def is_identifier ( string ) : matched = PYTHON_IDENTIFIER_RE . match ( string ) return bool ( matched ) and not keyword . iskeyword ( string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert string to int float or bool . [CODESPLIT] def convert_string ( string ) : if is_int ( string ) : return int ( string ) elif is_float ( string ) : return float ( string ) elif convert_bool ( string ) [ 0 ] : return convert_bool ( string ) [ 1 ] elif string == 'None' : return None else : return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the serialization format for the given mimetype [CODESPLIT] def get_serialize_format ( self , mimetype ) : format = self . formats . get ( mimetype , None ) if format is None : format = formats . get ( mimetype , None ) return format", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate equality between two ( Comparable ) objects . [CODESPLIT] def equal ( obj1 , obj2 ) : Comparable . log ( obj1 , obj2 , '==' ) equality = obj1 . equality ( obj2 ) Comparable . log ( obj1 , obj2 , '==' , result = equality ) return equality", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Because standard distinct used on the all fields are very slow and works only with PostgreSQL database this method provides alternative to the standard distinct method . : return : qs with unique objects [CODESPLIT] def fast_distinct ( self ) : return self . model . objects . filter ( pk__in = self . values_list ( 'pk' , flat = True ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if a file is located within the given directory . [CODESPLIT] def contained_in ( filename , directory ) : filename = os . path . normcase ( os . path . abspath ( filename ) ) directory = os . path . normcase ( os . path . abspath ( directory ) ) return os . path . commonprefix ( [ filename , directory ] ) == directory", "target": 1, "target_options": ["no_match", "match"]}
{"input": "It renders template defined in upy_context s page passed in arguments [CODESPLIT] def tree_render ( request , upy_context , vars_dictionary ) : page = upy_context [ 'PAGE' ] return render_to_response ( page . template . file_name , vars_dictionary , context_instance = RequestContext ( request ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the exectuable bit on the given filename [CODESPLIT] def set_executable ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Copy docstring from existing object to the decorated callable . [CODESPLIT] def see_doc ( obj_with_doc ) : def decorator ( fn ) : fn . __doc__ = obj_with_doc . __doc__ return fn return decorator", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Close all files but the current one [CODESPLIT] def close_all_but_this ( self ) : self . close_all_right ( ) for i in range ( 0 , self . get_stack_count ( ) - 1 ) : self . close_file ( 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is to support iterators over a file - like object . [CODESPLIT] def next ( self ) : # File-like object. result = self . readline ( ) if result == self . _empty_buffer : raise StopIteration return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Downsample x by factor using striding . [CODESPLIT] def downsample_with_striding ( array , factor ) : return array [ tuple ( np . s_ [ : : f ] for f in factor ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "implementation of safe dumper using Ordered Dict Yaml Dumper [CODESPLIT] def safe_dump ( data , stream = None , * * kwds ) : return yaml . dump ( data , stream = stream , Dumper = ODYD , * * kwds )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Nested lists to single - level list does not split strings [CODESPLIT] def flatten_list ( l ) : return list ( chain . from_iterable ( repeat ( x , 1 ) if isinstance ( x , str ) else x for x in l ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "React to a docstring event and append contracts to it . [CODESPLIT] def process_docstring ( app , what , name , obj , options , lines ) : # pylint: disable=unused-argument # pylint: disable=too-many-arguments lines . extend ( _format_contracts ( what = what , obj = obj ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Encode a list for the DynamoDB format [CODESPLIT] def encode_list ( dynamizer , value ) : encoded_list = [ ] dict ( map ( dynamizer . raw_encode , value ) ) for v in value : encoded_type , encoded_value = dynamizer . raw_encode ( v ) encoded_list . append ( { encoded_type : encoded_value , } ) return 'L' , encoded_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a datetime to a millisecond accuracy timestamp [CODESPLIT] def datetime_to_ms ( dt ) : seconds = calendar . timegm ( dt . utctimetuple ( ) ) return seconds * 1000 + int ( dt . microsecond / 1000 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Intersect dictionaries d1 and d2 by key * and * value . [CODESPLIT] def intersect ( d1 , d2 ) : return dict ( ( k , d1 [ k ] ) for k in d1 if k in d2 and d1 [ k ] == d2 [ k ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if a string is an integer . If the string value is an integer return True otherwise return False . Args : string : a string to test . [CODESPLIT] def is_int ( string ) : try : a = float ( string ) b = int ( a ) except ValueError : return False else : return a == b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the average color from the list of colors where each color is a 3 - tuple of ( r g b ) values . [CODESPLIT] def get_average_color ( colors ) : c = reduce ( color_reducer , colors ) total = len ( colors ) return tuple ( v / total for v in c )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the * bipartite * ( rectangular ) distance matrix between the observations in the first and the second list . [CODESPLIT] def distance_matrix ( trains1 , trains2 , cos , tau ) : return dissimilarity_matrix ( trains1 , trains2 , cos , tau , \"distance\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the SSE to the cluster center [CODESPLIT] def _cal_dist2center ( X , center ) : dmemb2cen = scipy . spatial . distance . cdist ( X , center . reshape ( 1 , X . shape [ 1 ] ) , metric = 'seuclidean' ) return ( np . sum ( dmemb2cen ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an enum from a name Args : enum_name ( str ) : name of the enum Returns : Enum [CODESPLIT] def get_enum_from_name ( self , enum_name ) : return next ( ( e for e in self . enums if e . name == enum_name ) , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a confusion matrix returns the accuracy . Accuracy Definition : http : // research . ics . aalto . fi / events / eyechallenge2005 / evaluation . shtml [CODESPLIT] def accuracy ( conf_matrix ) : total , correct = 0.0 , 0.0 for true_response , guess_dict in conf_matrix . items ( ) : for guess , count in guess_dict . items ( ) : if true_response == guess : correct += count total += count return correct / total", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a confusion matrix returns the accuracy . Accuracy Definition : http : // research . ics . aalto . fi / events / eyechallenge2005 / evaluation . shtml [CODESPLIT] def accuracy ( conf_matrix ) : total , correct = 0.0 , 0.0 for true_response , guess_dict in conf_matrix . items ( ) : for guess , count in guess_dict . items ( ) : if true_response == guess : correct += count total += count return correct / total", "target": 1, "target_options": ["no_match", "match"]}
{"input": "An enum is encoded by a int representing the zero - based position of the symbol in the schema . [CODESPLIT] def write_enum ( fo , datum , schema ) : index = schema [ 'symbols' ] . index ( datum ) write_int ( fo , index )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Confusion matrix plot [CODESPLIT] def confusion_matrix ( self ) : return plot . confusion_matrix ( self . y_true , self . y_pred , self . target_names , ax = _gen_ax ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Native connection object . [CODESPLIT] def native_conn ( self ) : if self . __native is None : self . __native = self . _get_connection ( ) return self . __native", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for raising the correct exception under Python 3 while still being able to raise the same common exception class in Python 2 . 7 . [CODESPLIT] def raise_os_error ( _errno , path = None ) : msg = \"%s: '%s'\" % ( strerror ( _errno ) , path ) if path else strerror ( _errno ) raise OSError ( _errno , msg )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calls a function . If an error of the given exception type with interrupted system call ( EINTR ) occurs calls the function again . [CODESPLIT] def eintr_retry ( exc_type , f , * args , * * kwargs ) : while True : try : return f ( * args , * * kwargs ) except exc_type as exc : if exc . errno != EINTR : raise else : break", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs the function asynchronously taking care of exceptions . [CODESPLIT] def asynchronous ( function , event ) : thread = Thread ( target = synchronous , args = ( function , event ) ) thread . daemon = True thread . start ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Try to get a number out of a string and cast it . [CODESPLIT] def get_number ( s , cast = int ) : import string d = \"\" . join ( x for x in str ( s ) if x in string . digits ) return cast ( d )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Measured similarity between two points in a multi - dimensional space . [CODESPLIT] def tanimoto_coefficient ( a , b ) : return sum ( map ( lambda ( x , y ) : float ( x ) * float ( y ) , zip ( a , b ) ) ) / sum ( [ - sum ( map ( lambda ( x , y ) : float ( x ) * float ( y ) , zip ( a , b ) ) ) , sum ( map ( lambda x : float ( x ) ** 2 , a ) ) , sum ( map ( lambda x : float ( x ) ** 2 , b ) ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "update () extends rather than replaces existing key lists . [CODESPLIT] def update ( self , other_dict ) : for key , value in iter_multi_items ( other_dict ) : MultiDict . add ( self , key , value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "update () extends rather than replaces existing key lists . [CODESPLIT] def update ( self , other_dict ) : for key , value in iter_multi_items ( other_dict ) : MultiDict . add ( self , key , value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the element with the highest probability . [CODESPLIT] def best ( self ) : b = ( - 1e999999 , None ) for k , c in iteritems ( self . counts ) : b = max ( b , ( c , k ) ) return b [ 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert from whatever is given to a list of scalars for the lookup_field . [CODESPLIT] def coerce ( self , value ) : if isinstance ( value , dict ) : value = [ value ] if not isiterable_notstring ( value ) : value = [ value ] return [ coerce_single_instance ( self . lookup_field , v ) for v in value ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds execute permission to file . : param filename : : return : [CODESPLIT] def chmod_add_excute ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Makes the list have unique items only and maintains the order [CODESPLIT] def unique ( _list ) : ret = [ ] for item in _list : if item not in ret : ret . append ( item ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fill file at [CODESPLIT] def file_writelines_flush_sync ( path , lines ) : fp = open ( path , 'w' ) try : fp . writelines ( lines ) flush_sync_file_object ( fp ) finally : fp . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get zero - indexed line from an open file - like . [CODESPLIT] def get_lines ( handle , line ) : for i , l in enumerate ( handle ) : if i == line : return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the modified time for a file as a datetime instance [CODESPLIT] def get_time ( filename ) : ts = os . stat ( filename ) . st_mtime return datetime . datetime . utcfromtimestamp ( ts )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create the file with the given content [CODESPLIT] def write_file ( filename , content ) : print 'Generating {0}' . format ( filename ) with open ( filename , 'wb' ) as out_f : out_f . write ( content )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes the write permissions for the given file for owner groups and others . [CODESPLIT] def make_file_read_only ( file_path ) : old_permissions = os . stat ( file_path ) . st_mode os . chmod ( file_path , old_permissions & ~ WRITE_PERMISSIONS )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a file and close it . Returns the file source . [CODESPLIT] def file_read ( filename ) : fobj = open ( filename , 'r' ) source = fobj . read ( ) fobj . close ( ) return source", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Random normal variates . [CODESPLIT] def rnormal ( mu , tau , size = None ) : return np . random . normal ( mu , 1. / np . sqrt ( tau ) , size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fill an array from a list [CODESPLIT] def _fill_array_from_list ( the_list , the_array ) : for i , val in enumerate ( the_list ) : the_array [ i ] = val return the_array", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Will make any functions return an iterable objects by wrapping its result in a list . [CODESPLIT] def force_iterable ( f ) : def wrapper ( * args , * * kwargs ) : r = f ( * args , * * kwargs ) if hasattr ( r , '__iter__' ) : return r else : return [ r ] return wrapper", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert 3 3 a matrix to 6 element s list ( see Tauxe 1998 ) [CODESPLIT] def a2s ( a ) : s = np . zeros ( ( 6 , ) , 'f' ) # make the a matrix for i in range ( 3 ) : s [ i ] = a [ i ] [ i ] s [ 3 ] = a [ 0 ] [ 1 ] s [ 4 ] = a [ 1 ] [ 2 ] s [ 5 ] = a [ 0 ] [ 2 ] return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Collect digits from a string [CODESPLIT] def str2int ( string_with_int ) : return int ( \"\" . join ( [ char for char in string_with_int if char in string . digits ] ) or 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Filter the dict * d * to remove keys not in * keys * . [CODESPLIT] def filter_dict_by_key ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate all matches found within a string for a regex and yield each match as a string [CODESPLIT] def iter_finds ( regex_obj , s ) : if isinstance ( regex_obj , str ) : for m in re . finditer ( regex_obj , s ) : yield m . group ( ) else : for m in regex_obj . finditer ( s ) : yield m . group ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Combine the outer and inner keys of nested dictionaries into a single ordering . [CODESPLIT] def flattened_nested_key_indices ( nested_dict ) : outer_keys , inner_keys = collect_nested_keys ( nested_dict ) combined_keys = list ( sorted ( set ( outer_keys + inner_keys ) ) ) return { k : i for ( i , k ) in enumerate ( combined_keys ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a generator that spits an iteratable into n - sized chunks . The last chunk may have less than n elements . [CODESPLIT] def split_every ( n , iterable ) : items = iter ( iterable ) return itertools . takewhile ( bool , ( list ( itertools . islice ( items , n ) ) for _ in itertools . count ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This strategy uses an exponential approximation for cut - off frequency calculation found by matching the one - pole Laplace lowpass filter and mirroring the resulting filter to get a highpass . [CODESPLIT] def highpass ( cutoff ) : R = thub ( exp ( cutoff - pi ) , 2 ) return ( 1 - R ) / ( 1 + R * z ** - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of all parsed comments in a file . Mostly for testing & interactive use . [CODESPLIT] def parse_comments_for_file ( filename ) : return [ parse_comment ( strip_stars ( comment ) , next_line ) for comment , next_line in get_doc_comments ( read_file ( filename ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialize an API . [CODESPLIT] def initialize_api ( flask_app ) : if not flask_restplus : return api = flask_restplus . Api ( version = \"1.0\" , title = \"My Example API\" ) api . add_resource ( HelloWorld , \"/hello\" ) blueprint = flask . Blueprint ( \"api\" , __name__ , url_prefix = \"/api\" ) api . init_app ( blueprint ) flask_app . register_blueprint ( blueprint )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns OK then waits approximately 1 second and restarts container [CODESPLIT] async def restart ( request ) : def wait_and_restart ( ) : log . info ( 'Restarting server' ) sleep ( 1 ) os . system ( 'kill 1' ) Thread ( target = wait_and_restart ) . start ( ) return web . json_response ( { \"message\" : \"restarting\" } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to create a Lambda Failure Response [CODESPLIT] def lambda_failure_response ( * args ) : response_data = jsonify ( ServiceErrorResponses . _LAMBDA_FAILURE ) return make_response ( response_data , ServiceErrorResponses . HTTP_STATUS_CODE_502 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a ctypes void pointer to the memory mapped region . [CODESPLIT] def pointer ( self ) : return ctypes . cast ( ctypes . pointer ( ctypes . c_uint8 . from_buffer ( self . mapping , 0 ) ) , ctypes . c_void_p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "cv2 Image of current window screen [CODESPLIT] def screen_cv2 ( self ) : pil_image = self . screen . convert ( 'RGB' ) cv2_image = np . array ( pil_image ) pil_image . close ( ) # Convert RGB to BGR \n cv2_image = cv2_image [ : , : , : : - 1 ] return cv2_image", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turns a werkzeug . MultiDict or django . MultiValueDict into a dict with list values : param d : a MultiDict or MultiValueDict instance : return : a dict instance [CODESPLIT] def multidict_to_dict ( d ) : return dict ( ( k , v [ 0 ] if len ( v ) == 1 else v ) for k , v in iterlists ( d ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Join helper [CODESPLIT] def _join ( verb ) : data = pd . merge ( verb . x , verb . y , * * verb . kwargs ) # Preserve x groups if isinstance ( verb . x , GroupedDataFrame ) : data . plydata_groups = list ( verb . x . plydata_groups ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper to print a prepared query . Useful to debug a POST query . [CODESPLIT] def pretty_print_post ( req ) : print ( ( '{}\\n{}\\n{}\\n\\n{}' . format ( '-----------START-----------' , req . method + ' ' + req . url , '\\n' . join ( '{}: {}' . format ( k , v ) for k , v in list ( req . headers . items ( ) ) ) , req . body , ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def get_unique_indices ( df , axis = 1 ) : return dict ( zip ( df . columns . names , dif . columns . levels ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Request that the Outstation perform a cold restart . Command syntax is : restart [CODESPLIT] def do_restart ( self , line ) : self . application . master . Restart ( opendnp3 . RestartType . COLD , restart_callback )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Change a date string from the format 2018 - 08 - 15T23 : 55 : 17 into a datetime object [CODESPLIT] def convert_time_string ( date_str ) : dt , _ , _ = date_str . partition ( \".\" ) dt = datetime . strptime ( dt , \"%Y-%m-%dT%H:%M:%S\" ) return dt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "MIME type of the asset . [CODESPLIT] def mimetype ( self ) : return ( self . environment . mimetypes . get ( self . format_extension ) or self . compiler_mimetype or 'application/octet-stream' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a US format date and return epoch . [CODESPLIT] def AmericanDateToEpoch ( self , date_str ) : try : epoch = time . strptime ( date_str , \"%m/%d/%Y\" ) return int ( calendar . timegm ( epoch ) ) * 1000000 except ValueError : return 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the default WSGI handler for the runner . [CODESPLIT] def get_handler ( self , * args , * * options ) : handler = get_internal_wsgi_application ( ) from django . contrib . staticfiles . handlers import StaticFilesHandler return StaticFilesHandler ( handler )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a date into a datetime [CODESPLIT] def date_to_datetime ( x ) : if not isinstance ( x , datetime ) and isinstance ( x , date ) : return datetime . combine ( x , time ( ) ) return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a multi - dimensional array and returns a 1 dimensional array with the same contents . [CODESPLIT] def flatten_array ( grid ) : grid = [ grid [ i ] [ j ] for i in range ( len ( grid ) ) for j in range ( len ( grid [ i ] ) ) ] while type ( grid [ 0 ] ) is list : grid = flatten_array ( grid ) return grid", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Copy the lib items into our font . [CODESPLIT] def setLib ( self , lib ) : for name , item in lib . items ( ) : self . font . lib [ name ] = item", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert an OrderedDict containing C values to a 1D array . [CODESPLIT] def C_dict2array ( C ) : return np . hstack ( [ np . asarray ( C [ k ] ) . ravel ( ) for k in C_keys ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Count how many levels are in a dict : scalar list etc = 0 {} = 0 { a : 1 } = 1 { a : { b : 1 }} = 2 etc ... [CODESPLIT] def count_levels ( value ) : if not isinstance ( value , dict ) or len ( value ) == 0 : return 0 elif len ( value ) == 0 : return 0 #An emptu dict has 0 else : nextval = list ( value . values ( ) ) [ 0 ] return 1 + count_levels ( nextval )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a function that checks that each element in a list is of a specific type . [CODESPLIT] def list_of ( cls ) : return lambda l : isinstance ( l , list ) and all ( isinstance ( x , cls ) for x in l )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like pretty but print to stdout . [CODESPLIT] def pprint ( obj , verbose = False , max_width = 79 , newline = '\\n' ) : printer = RepresentationPrinter ( sys . stdout , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) sys . stdout . write ( newline ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Modified form of the g format specifier . [CODESPLIT] def format_float ( value ) : # not used string = \"{:g}\" . format ( value ) . replace ( \"e+\" , \"e\" ) string = re . sub ( \"e(-?)0*(\\d+)\" , r\"e\\1\\2\" , string ) return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty Prints seconds as Hours : Minutes : Seconds . MilliSeconds [CODESPLIT] def pprint ( self , seconds ) : return ( \"%d:%02d:%02d.%03d\" , reduce ( lambda ll , b : divmod ( ll [ 0 ] , b ) + ll [ 1 : ] , [ ( seconds * 1000 , ) , 1000 , 60 , 60 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deletes the named entry in the cache . : param name : the name . : return : true if it is deleted . [CODESPLIT] def delete ( self , name ) : if name in self . _cache : del self . _cache [ name ] self . writeCache ( ) # TODO clean files return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format a byte sized value . [CODESPLIT] def fmt_sz ( intval ) : try : return fmt . human_size ( intval ) except ( ValueError , TypeError ) : return \"N/A\" . rjust ( len ( fmt . human_size ( 0 ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes the tlink for the given tlink identifier [CODESPLIT] def remove_this_tlink ( self , tlink_id ) : for tlink in self . get_tlinks ( ) : if tlink . get_id ( ) == tlink_id : self . node . remove ( tlink . get_node ( ) ) break", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert quaternion array to rotation matrix . [CODESPLIT] def rotation_from_quaternion ( q_wxyz ) : q_xyzw = np . array ( [ q_wxyz [ 1 ] , q_wxyz [ 2 ] , q_wxyz [ 3 ] , q_wxyz [ 0 ] ] ) R = transformations . quaternion_matrix ( q_xyzw ) [ : 3 , : 3 ] return R", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes the venv by name [CODESPLIT] def rm ( venv_name ) : inenv = InenvManager ( ) venv = inenv . get_venv ( venv_name ) click . confirm ( \"Delete dir {}\" . format ( venv . path ) ) shutil . rmtree ( venv . path )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a Stripe API timestamp response ( unix epoch ) to a native datetime . [CODESPLIT] def convert_tstamp ( response ) : if response is None : # Allow passing None to convert_tstamp() return response # Overrides the set timezone to UTC - I think... tz = timezone . utc if settings . USE_TZ else None return datetime . datetime . fromtimestamp ( response , tz )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clear not used counters [CODESPLIT] def trim ( self ) : for key , value in list ( iteritems ( self . counters ) ) : if value . empty ( ) : del self . counters [ key ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Connect to FTP server login and return an ftplib . FTP instance . [CODESPLIT] def connect ( ) : ftp_class = ftplib . FTP if not SSL else ftplib . FTP_TLS ftp = ftp_class ( timeout = TIMEOUT ) ftp . connect ( HOST , PORT ) ftp . login ( USER , PASSWORD ) if SSL : ftp . prot_p ( ) # secure data connection return ftp", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete a file safely . If it s not present no - op . [CODESPLIT] def safe_delete ( filename ) : try : os . unlink ( filename ) except OSError as e : if e . errno != errno . ENOENT : raise", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove an object from the bin folder . [CODESPLIT] def remove_from_lib ( self , name ) : self . __remove_path ( os . path . join ( self . root_dir , \"lib\" , name ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return manhattan distance between two lists of numbers . [CODESPLIT] def _manhattan_distance ( vec_a , vec_b ) : if len ( vec_a ) != len ( vec_b ) : raise ValueError ( 'len(vec_a) must equal len(vec_b)' ) return sum ( map ( lambda a , b : abs ( a - b ) , vec_a , vec_b ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove a file from an AWS S3 bucket . [CODESPLIT] def remove_file_from_s3 ( awsclient , bucket , key ) : client_s3 = awsclient . get_client ( 's3' ) response = client_s3 . delete_object ( Bucket = bucket , Key = key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": type s : str : rtype : int [CODESPLIT] def first_unique_char ( s ) : if ( len ( s ) == 1 ) : return 0 ban = [ ] for i in range ( len ( s ) ) : if all ( s [ i ] != s [ k ] for k in range ( i + 1 , len ( s ) ) ) == True and s [ i ] not in ban : return i else : ban . append ( s [ i ] ) return - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes an object / rabalist from registery . This is useful if you want to allow the garbage collector to free the memory taken by the objects you ve already loaded . Be careful might cause some discrepenties in your scripts . For objects cascades to free the registeries of related rabalists also [CODESPLIT] def removeFromRegistery ( obj ) : if isRabaObject ( obj ) : _unregisterRabaObjectInstance ( obj ) elif isRabaList ( obj ) : _unregisterRabaListInstance ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute a normal python statement in user namespace . [CODESPLIT] def ex ( self , cmd ) : with self . builtin_trap : exec cmd in self . user_global_ns , self . user_ns", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a user exists [CODESPLIT] def user_exists ( username ) : try : pwd . getpwnam ( username ) user_exists = True except KeyError : user_exists = False return user_exists", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function to delete objects from a shelve Args : file_name : Shelve storage file name save_key : The name of the key the item is stored in file_location : The location of the file derive from the os module [CODESPLIT] def delete_object_from_file ( file_name , save_key , file_location ) : file = __os . path . join ( file_location , file_name ) shelve_store = __shelve . open ( file ) del shelve_store [ save_key ] shelve_store . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Computes the unnormalized PDF of the normal distribution . [CODESPLIT] def EvalGaussianPdf ( x , mu , sigma ) : return scipy . stats . norm . pdf ( x , mu , sigma )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if val is of integer type . [CODESPLIT] def is_int_type ( val ) : try : # Python 2 return isinstance ( val , ( int , long ) ) except NameError : # Python 3 return isinstance ( val , int )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get from a list with an optional default value . [CODESPLIT] def list_get ( l , idx , default = None ) : try : if l [ idx ] : return l [ idx ] else : return default except IndexError : return default", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list of names of columns that are string type . [CODESPLIT] def _get_str_columns ( sf ) : return [ name for name in sf . column_names ( ) if sf [ name ] . dtype == str ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check that matrix is square . [CODESPLIT] def isSquare ( matrix ) : try : try : dim1 , dim2 = matrix . shape except AttributeError : dim1 , dim2 = _np . array ( matrix ) . shape except ValueError : return False if dim1 == dim2 : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Search twitter API [CODESPLIT] def search_for_tweets_about ( user_id , params ) : url = \"https://api.twitter.com/1.1/search/tweets.json\" response = make_twitter_request ( url , user_id , params ) return process_tweets ( response . json ( ) [ \"statuses\" ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the headers of this DataFrame . [CODESPLIT] def getHeaders ( self ) : headers = self . _impl . getHeaders ( ) return tuple ( headers . getIndex ( i ) for i in range ( self . _impl . getNumCols ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the local variables in the caller s frame . [CODESPLIT] def caller_locals ( ) : import inspect frame = inspect . currentframe ( ) try : return frame . f_back . f_back . f_locals finally : del frame", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Similar to : attr : . Guild . me except it may return the : class : . ClientUser in private message contexts . [CODESPLIT] def me ( self ) : return self . guild . me if self . guild is not None else self . bot . user", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns this programs current memory usage in bytes [CODESPLIT] def current_memory_usage ( ) : import psutil proc = psutil . Process ( os . getpid ( ) ) #meminfo = proc.get_memory_info() meminfo = proc . memory_info ( ) rss = meminfo [ 0 ] # Resident Set Size / Mem Usage vms = meminfo [ 1 ] # Virtual Memory Size / VM Size  # NOQA return rss", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get information about a member of a chat . [CODESPLIT] def get_chat_member ( self , user_id ) : return self . bot . api_call ( \"getChatMember\" , chat_id = str ( self . id ) , user_id = str ( user_id ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Debug a single doctest docstring in argument src [CODESPLIT] def debug_src ( src , pm = False , globs = None ) : testsrc = script_from_examples ( src ) debug_script ( testsrc , pm , globs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the encoding type . [CODESPLIT] def get_encoding ( binary ) : try : from chardet import detect except ImportError : LOGGER . error ( \"Please install the 'chardet' module\" ) sys . exit ( 1 ) encoding = detect ( binary ) . get ( 'encoding' ) return 'iso-8859-1' if encoding == 'CP949' else encoding", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Intended to be used going into post mortem routines . If sys . last_traceback is set we will return that and assume that this is what post - mortem will want . If sys . last_traceback has not been set then perhaps we * about * to raise an error and are fielding an exception . So assume that sys . exc_info () [ 2 ] is where we want to look . [CODESPLIT] def get_last_or_frame_exception ( ) : try : if inspect . istraceback ( sys . last_traceback ) : # We do have a traceback so prefer that. return sys . last_type , sys . last_value , sys . last_traceback except AttributeError : pass return sys . exc_info ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def confirm_credential_display ( force = False ) : if force : return True msg = \"\"\"\n    [WARNING] Your credential is about to be displayed on screen.\n    If this is really what you want, type 'y' and press enter.\"\"\" result = click . confirm ( text = msg ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "consider the distance between two mapPoints ignoring all terrain pathing issues [CODESPLIT] def direct2dDistance ( self , point ) : if not isinstance ( point , MapPoint ) : return 0.0 return ( ( self . x - point . x ) ** 2 + ( self . y - point . y ) ** 2 ) ** ( 0.5 ) # simple distance formula", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clones object with optionally overridden fields [CODESPLIT] def clone ( src , * * kwargs ) : obj = object . __new__ ( type ( src ) ) obj . __dict__ . update ( src . __dict__ ) obj . __dict__ . update ( kwargs ) return obj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Finds parent folder of file [CODESPLIT] def get_parent_folder_name ( file_path ) : return os . path . split ( os . path . split ( os . path . abspath ( file_path ) ) [ 0 ] ) [ - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if ( event node ) is a start event for tagname . [CODESPLIT] def _is_start ( event , node , tagName ) : # pylint: disable=invalid-name return event == pulldom . START_ELEMENT and node . tagName == tagName", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the index of a geometry in a list of geometries avoiding expensive equality checks of in operator . [CODESPLIT] def find_geom ( geom , geoms ) : for i , g in enumerate ( geoms ) : if g is geom : return i", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def _index2n ( self , index ) : n_float = np . sqrt ( index + 1 ) - 1 n_int = int ( n_float ) if n_int == n_float : n = n_int else : n = n_int + 1 return n", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the leftmost index of an element in a list using binary search . [CODESPLIT] def bisect_index ( a , x ) : i = bisect . bisect_left ( a , x ) if i != len ( a ) and a [ i ] == x : return i raise ValueError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return peak memory usage in MB [CODESPLIT] def peak_memory_usage ( ) : if sys . platform . startswith ( 'win' ) : p = psutil . Process ( ) return p . memory_info ( ) . peak_wset / 1024 / 1024 mem = resource . getrusage ( resource . RUSAGE_SELF ) . ru_maxrss factor_mb = 1 / 1024 if sys . platform == 'darwin' : factor_mb = 1 / ( 1024 * 1024 ) return mem * factor_mb", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a string argument to a subclass of basestring . [CODESPLIT] def to_basestring ( value ) : if isinstance ( value , _BASESTRING_TYPES ) : return value assert isinstance ( value , bytes ) return value . decode ( \"utf-8\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string of bytes into an integer as per X9 . 62 . [CODESPLIT] def string_to_int ( s ) : result = 0 for c in s : if not isinstance ( c , int ) : c = ord ( c ) result = 256 * result + c return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Output all sections of the page . [CODESPLIT] def Output ( self ) : self . Open ( ) self . Header ( ) self . Body ( ) self . Footer ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load graph as defined by a DOT file . The file is assumed to be in DOT format . It will be loaded parsed and a Dot class will be returned representing the graph . [CODESPLIT] def graph_from_dot_file ( path ) : fd = file ( path , 'rb' ) data = fd . read ( ) fd . close ( ) return graph_from_dot_data ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the attribute of namespace corresponding to value . [CODESPLIT] def _lookup_enum_in_ns ( namespace , value ) : for attribute in dir ( namespace ) : if getattr ( namespace , attribute ) == value : return attribute", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the dot product of two vectors [CODESPLIT] def dot_v2 ( vec1 , vec2 ) : return vec1 . x * vec2 . x + vec1 . y * vec2 . y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return unix SECOND timestamp of num mondays ago [CODESPLIT] def prevmonday ( num ) : today = get_today ( ) lastmonday = today - timedelta ( days = today . weekday ( ) , weeks = num ) return lastmonday", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Draw collection [CODESPLIT] def draw ( self , mode = \"triangles\" ) : gl . glDepthMask ( 0 ) Collection . draw ( self , mode ) gl . glDepthMask ( 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get an SArray that contains the last n elements in the SArray . [CODESPLIT] def tail ( self , n = 10 ) : with cython_context ( ) : return SArray ( _proxy = self . __proxy__ . tail ( n ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove duplicates from list while preserving order . [CODESPLIT] def purge_duplicates ( list_in ) : _list = [ ] for item in list_in : if item not in _list : _list . append ( item ) return _list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper to get bins for histplot . [CODESPLIT] def _histplot_bins ( column , bins = 100 ) : col_min = np . min ( column ) col_max = np . max ( column ) return range ( col_min , col_max + 2 , max ( ( col_max - col_min ) // bins , 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize and compare XML documents for equality . The document may or may not be a DataONE type . [CODESPLIT] def are_equal_xml ( a_xml , b_xml ) : a_dom = xml . dom . minidom . parseString ( a_xml ) b_dom = xml . dom . minidom . parseString ( b_xml ) return are_equal_elements ( a_dom . documentElement , b_dom . documentElement )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convenience wrapper for database SELECT and fetch all . [CODESPLIT] def fetch ( table , cols = \"*\" , where = ( ) , group = \"\" , order = ( ) , limit = ( ) , * * kwargs ) : return select ( table , cols , where , group , order , limit , * * kwargs ) . fetchall ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deletes whole Solr index . Use with care . [CODESPLIT] def deleteAll ( self ) : for core in self . endpoints : self . _send_solr_command ( self . endpoints [ core ] , \"{\\\"delete\\\": { \\\"query\\\" : \\\"*:*\\\"}}\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return current free memory on the machine for windows . [CODESPLIT] def get_free_memory_win ( ) : stat = MEMORYSTATUSEX ( ) ctypes . windll . kernel32 . GlobalMemoryStatusEx ( ctypes . byref ( stat ) ) return int ( stat . ullAvailPhys / 1024 / 1024 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove problem characters from string [CODESPLIT] def remove_bad ( string ) : remove = [ ':' , ',' , '(' , ')' , ' ' , '|' , ';' , '\\'' ] for c in remove : string = string . replace ( c , '_' ) return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Looks at the files in a git root directory and grabs the last modified timestamp [CODESPLIT] def get_last_modified_timestamp ( self ) : cmd = \"find . -print0 | xargs -0 stat -f '%T@ %p' | sort -n | tail -1 | cut -f2- -d' '\" ps = subprocess . Popen ( cmd , shell = True , stdout = subprocess . PIPE , stderr = subprocess . STDOUT ) output = ps . communicate ( ) [ 0 ] print output", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a model s verbose name to the model class . This allows us to use the models verbose name in steps . [CODESPLIT] def get_model ( name ) : model = MODELS . get ( name . lower ( ) , None ) assert model , \"Could not locate model by name '%s'\" % name return model", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get width and height of a PDF [CODESPLIT] def dimensions ( self ) : size = self . pdf . getPage ( 0 ) . mediaBox return { 'w' : float ( size [ 2 ] ) , 'h' : float ( size [ 3 ] ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Debug a single doctest docstring in argument src [CODESPLIT] def debug_src ( src , pm = False , globs = None ) : testsrc = script_from_examples ( src ) debug_script ( testsrc , pm , globs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns 0 to 1 rgb from a hex list or tuple [CODESPLIT] def hex_to_rgb ( h ) : h = h . lstrip ( '#' ) return tuple ( int ( h [ i : i + 2 ] , 16 ) / 255. for i in ( 0 , 2 , 4 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes the extension from a filename [CODESPLIT] def remove_ext ( fname ) : bn = os . path . basename ( fname ) return os . path . splitext ( bn ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cumulative distribution function . [CODESPLIT] def _cdf ( self , xloc , dist , base , cache ) : return evaluation . evaluate_forward ( dist , base ** xloc , cache = cache )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return IPython s guess for the default encoding for bytes as text . [CODESPLIT] def getdefaultencoding ( ) : enc = get_stream_enc ( sys . stdin ) if not enc or enc == 'ascii' : try : # There are reports of getpreferredencoding raising errors # in some cases, which may well be fixed, but let's be conservative here. enc = locale . getpreferredencoding ( ) except Exception : pass return enc or sys . getdefaultencoding ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the total size of all elements in objects . [CODESPLIT] def get_size ( objects ) : res = 0 for o in objects : try : res += _getsizeof ( o ) except AttributeError : print ( \"IGNORING: type=%s; o=%s\" % ( str ( type ( o ) ) , str ( o ) ) ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the event loop . [CODESPLIT] def run ( self ) : self . signal_init ( ) self . listen_init ( ) self . logger . info ( 'starting' ) self . loop . start ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a date object and return the first day of the month . [CODESPLIT] def monthly ( date = datetime . date . today ( ) ) : return datetime . date ( date . year , date . month , 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve the previous quarter for dt [CODESPLIT] def previous_quarter ( d ) : from django_toolkit . datetime_util import quarter as datetime_quarter return quarter ( ( datetime_quarter ( datetime ( d . year , d . month , d . day ) ) [ 0 ] + timedelta ( days = - 1 ) ) . date ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return first occurrence matching f otherwise None [CODESPLIT] def findfirst ( f , coll ) : result = list ( dropwhile ( f , coll ) ) return result [ 0 ] if result else None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "I check to see if a method on a TestCase has been disabled via nose s convention for disabling a TestCase . This makes it so that users can mix nose s parameterized tests with green as a runner . [CODESPLIT] def isTestCaseDisabled ( test_case_class , method_name ) : test_method = getattr ( test_case_class , method_name ) return getattr ( test_method , \"__test__\" , 'not nose' ) is False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the index of elem in the reversed iterator . [CODESPLIT] def index ( self , elem ) : return _coconut . len ( self . _iter ) - self . _iter . index ( elem ) - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Change a date string from the format 2018 - 08 - 15T23 : 55 : 17 into a datetime object [CODESPLIT] def convert_time_string ( date_str ) : dt , _ , _ = date_str . partition ( \".\" ) dt = datetime . strptime ( dt , \"%Y-%m-%dT%H:%M:%S\" ) return dt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "searchs a value in a dicionary and returns the key of the first occurrence [CODESPLIT] def get_key_by_value ( dictionary , search_value ) : for key , value in dictionary . iteritems ( ) : if value == search_value : return ugettext ( key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string to a genomic range [CODESPLIT] def string_to_genomic_range ( rstring ) : m = re . match ( '([^:]+):(\\d+)-(\\d+)' , rstring ) if not m : sys . stderr . write ( \"ERROR: problem with range string \" + rstring + \"\\n\" ) return GenomicRange ( m . group ( 1 ) , int ( m . group ( 2 ) ) , int ( m . group ( 3 ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert to datetime to UTC offset . [CODESPLIT] def convert_2_utc ( self , datetime_ , timezone ) : datetime_ = self . tz_mapper [ timezone ] . localize ( datetime_ ) return datetime_ . astimezone ( pytz . UTC )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if we are in a tty . [CODESPLIT] def intty ( cls ) : # XXX: temporary hack until we can detect if we are in a pipe or not return True if hasattr ( sys . stdout , 'isatty' ) and sys . stdout . isatty ( ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the code for a given notebook [CODESPLIT] def code_from_ipynb ( nb , markdown = False ) : code = PREAMBLE for cell in nb [ 'cells' ] : if cell [ 'cell_type' ] == 'code' : # transform the input to executable Python code += '' . join ( cell [ 'source' ] ) if cell [ 'cell_type' ] == 'markdown' : code += '\\n# ' + '# ' . join ( cell [ 'source' ] ) # We want a blank newline after each cell's output. # And the last line of source doesn't have a newline usually. code += '\\n\\n' return code", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a unique ID that is somewhat guaranteed to be unique among all instances running at the same time . [CODESPLIT] def generate_unique_host_id ( ) : host = \".\" . join ( reversed ( socket . gethostname ( ) . split ( \".\" ) ) ) pid = os . getpid ( ) return \"%s.%d\" % ( host , pid )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "function to get return code of a url [CODESPLIT] def get_url_nofollow ( url ) : try : response = urlopen ( url ) code = response . getcode ( ) return code except HTTPError as e : return e . code except : return 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get mnist dataset with features and label as ndarray . Data would be downloaded automatically if it doesn t present at the specific location . [CODESPLIT] def get_mnist ( data_type = \"train\" , location = \"/tmp/mnist\" ) : X , Y = mnist . read_data_sets ( location , data_type ) return X , Y + 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return indices of inputs to the node with the given index . [CODESPLIT] def get_inputs_from_cm ( index , cm ) : return tuple ( i for i in range ( cm . shape [ 0 ] ) if cm [ i ] [ index ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Open a file . [CODESPLIT] def open_file ( file , mode ) : if hasattr ( file , \"read\" ) : return file if hasattr ( file , \"open\" ) : return file . open ( mode ) return open ( file , mode )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fill NaNs with the previous value the next value or if all are NaN then 1 . 0 [CODESPLIT] def clean_dataframe ( df ) : df = df . fillna ( method = 'ffill' ) df = df . fillna ( 0.0 ) return df", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calls a function with the given arguments inside Gtk s main loop . Example :: gcall ( lbl . set_text foo ) [CODESPLIT] def gcall ( func , * args , * * kwargs ) : def idle ( ) : with gdk . lock : return bool ( func ( * args , * * kwargs ) ) return gobject . idle_add ( idle )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function for running binary search on a sorted list . [CODESPLIT] def binSearch ( arr , val ) : i = bisect_left ( arr , val ) if i != len ( arr ) and arr [ i ] == val : return i return - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "takes flags returns indexes of True values [CODESPLIT] def equal ( list1 , list2 ) : return [ item1 == item2 for item1 , item2 in broadcast_zip ( list1 , list2 ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Re - index every document in a named index . [CODESPLIT] def update_index ( index ) : logger . info ( \"Updating search index: '%s'\" , index ) client = get_client ( ) responses = [ ] for model in get_index_models ( index ) : logger . info ( \"Updating search index model: '%s'\" , model . search_doc_type ) objects = model . objects . get_search_queryset ( index ) . iterator ( ) actions = bulk_actions ( objects , index = index , action = \"index\" ) response = helpers . bulk ( client , actions , chunk_size = get_setting ( \"chunk_size\" ) ) responses . append ( response ) return responses", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If pair is in search_list return the index . Otherwise return - 1 [CODESPLIT] def is_in ( self , search_list , pair ) : index = - 1 for nr , i in enumerate ( search_list ) : if ( np . all ( i == pair ) ) : return nr return index", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Returns all local minima from an image . Parameters ---------- img : array_like The image . min_distance : integer The minimal distance between the minimas in voxels . If it is less only the lower minima is returned . Returns ------- indices : sequence List of all minima indices . values : sequence List of all minima values . [CODESPLIT] def local_minima ( img , min_distance = 4 ) : # @TODO: Write a unittest for this. fits = numpy . asarray ( img ) minfits = minimum_filter ( fits , size = min_distance ) # default mode is reflect minima_mask = fits == minfits good_indices = numpy . transpose ( minima_mask . nonzero ( ) ) good_fits = fits [ minima_mask ] order = good_fits . argsort ( ) return good_indices [ order ] , good_fits [ order ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "generic plotting method overplotting any existing plot [CODESPLIT] def oplot ( self , x , y , * * kw ) : self . panel . oplot ( x , y , * * kw )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the name of the newest file given an iterable of file names . [CODESPLIT] def newest_file ( file_iterable ) : return max ( file_iterable , key = lambda fname : os . path . getmtime ( fname ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the next line including the newline or on EOF . [CODESPLIT] def readline ( self ) : self . lineno += 1 if self . _buffer : return self . _buffer . pop ( ) else : return self . input . readline ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Union any overlapping intervals in the given set . [CODESPLIT] def union_overlapping ( intervals ) : disjoint_intervals = [ ] for interval in intervals : if disjoint_intervals and disjoint_intervals [ - 1 ] . overlaps ( interval ) : disjoint_intervals [ - 1 ] = disjoint_intervals [ - 1 ] . union ( interval ) else : disjoint_intervals . append ( interval ) return disjoint_intervals", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute init tasks for all components ( virtualenv pip ) . [CODESPLIT] def init ( ) : print ( yellow ( \"# Setting up environment...\\n\" , True ) ) virtualenv . init ( ) virtualenv . update_requirements ( ) print ( green ( \"\\n# DONE.\" , True ) ) print ( green ( \"Type \" ) + green ( \"activate\" , True ) + green ( \" to enable your virtual environment.\" ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function for running binary search on a sorted list . [CODESPLIT] def binSearch ( arr , val ) : i = bisect_left ( arr , val ) if i != len ( arr ) and arr [ i ] == val : return i return - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Number of requests before GitHub imposes a ratelimit . [CODESPLIT] def ratelimit_remaining ( self ) : json = self . _json ( self . _get ( self . _github_url + '/rate_limit' ) , 200 ) core = json . get ( 'resources' , { } ) . get ( 'core' , { } ) self . _remaining = core . get ( 'remaining' , 0 ) return self . _remaining", "target": 1, "target_options": ["no_match", "match"]}
{"input": "x is a 2D sparse matrix with it s first shape equal to 1 . [CODESPLIT] def is_sparse_vector ( x ) : return sp . issparse ( x ) and len ( x . shape ) == 2 and x . shape [ 0 ] == 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return manhattan distance between two lists of numbers . [CODESPLIT] def _manhattan_distance ( vec_a , vec_b ) : if len ( vec_a ) != len ( vec_b ) : raise ValueError ( 'len(vec_a) must equal len(vec_b)' ) return sum ( map ( lambda a , b : abs ( a - b ) , vec_a , vec_b ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply the coefficients from a linear fit to an array of x y positions . [CODESPLIT] def apply_fit ( xy , coeffs ) : x_new = coeffs [ 0 ] [ 2 ] + coeffs [ 0 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 0 ] [ 1 ] * xy [ : , 1 ] y_new = coeffs [ 1 ] [ 2 ] + coeffs [ 1 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 1 ] [ 1 ] * xy [ : , 1 ] return x_new , y_new", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Go to parent directory [CODESPLIT] def go_to_parent_directory ( self ) : self . chdir ( osp . abspath ( osp . join ( getcwd_or_home ( ) , os . pardir ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pads an input string to a given block size . : param s : string : returns : The padded string . [CODESPLIT] def old_pad ( s ) : if len ( s ) % OLD_BLOCK_SIZE == 0 : return s return Padding . appendPadding ( s , blocksize = OLD_BLOCK_SIZE )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a sentence into list of words . [CODESPLIT] def split_into_words ( s ) : s = re . sub ( r\"\\W+\" , \" \" , s ) s = re . sub ( r\"[_0-9]+\" , \" \" , s ) return s . split ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert file extension to lowercase . [CODESPLIT] def lower_ext ( abspath ) : fname , ext = os . path . splitext ( abspath ) return fname + ext . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if a given string is an url [CODESPLIT] def is_valid_url ( url ) : pieces = urlparse ( url ) return all ( [ pieces . scheme , pieces . netloc ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find rightmost value less than x [CODESPLIT] def find_lt ( a , x ) : i = bisect . bisect_left ( a , x ) if i : return a [ i - 1 ] raise ValueError", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": returns : True if one or more range in the list overlaps with another : rtype : bool [CODESPLIT] def has_overlaps ( self ) : sorted_list = sorted ( self ) for i in range ( 0 , len ( sorted_list ) - 1 ) : if sorted_list [ i ] . overlaps ( sorted_list [ i + 1 ] ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update the progressbar . [CODESPLIT] def __call__ ( self , _ ) : if self . iter % self . step == 0 : self . pbar . update ( self . step ) self . iter += 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is this attribute present? [CODESPLIT] def has_attribute ( module_name , attribute_name ) : init_file = '%s/__init__.py' % module_name return any ( [ attribute_name in init_line for init_line in open ( init_file ) . readlines ( ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A generator that combines two iterables . [CODESPLIT] def combine ( self , a , b ) : for l in ( a , b ) : for x in l : yield x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Login user for protected API calls . [CODESPLIT] def login ( self , username , password = None , token = None ) : self . session . basic_auth ( username , password )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply weights and concatenate outputs from a FeatureUnion [CODESPLIT] def feature_union_concat ( Xs , nsamples , weights ) : if any ( x is FIT_FAILURE for x in Xs ) : return FIT_FAILURE Xs = [ X if w is None else X * w for X , w in zip ( Xs , weights ) if X is not None ] if not Xs : return np . zeros ( ( nsamples , 0 ) ) if any ( sparse . issparse ( f ) for f in Xs ) : return sparse . hstack ( Xs ) . tocsr ( ) return np . hstack ( Xs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Instantiate the object from a protocol buffer . [CODESPLIT] def from_pb ( cls , pb ) : obj = cls . _from_pb ( pb ) obj . _pb = pb return obj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get longitudes from cartesian coordinates . [CODESPLIT] def get_lons_from_cartesian ( x__ , y__ ) : return rad2deg ( arccos ( x__ / sqrt ( x__ ** 2 + y__ ** 2 ) ) ) * sign ( y__ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Short Time Fourier Transform for real data keeping the full FFT block . [CODESPLIT] def stft ( func = None , * * kwparams ) : from numpy . fft import fft , ifft ifft_r = lambda * args : ifft ( * args ) . real return stft . base ( transform = fft , inverse_transform = ifft_r ) ( func , * * kwparams )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes input from user . Works for Python 2 and 3 . [CODESPLIT] def _stdin_ ( p ) : _v = sys . version [ 0 ] return input ( p ) if _v is '3' else raw_input ( p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes input from user . Works for Python 2 and 3 . [CODESPLIT] def _stdin_ ( p ) : _v = sys . version [ 0 ] return input ( p ) if _v is '3' else raw_input ( p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like many_until but must consume at least one of these . [CODESPLIT] def many_until1 ( these , term ) : first = [ these ( ) ] these_results , term_result = many_until ( these , term ) return ( first + these_results , term_result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns Gaussian smoothed image . [CODESPLIT] def smooth_gaussian ( image , sigma = 1 ) : return scipy . ndimage . filters . gaussian_filter ( image , sigma = sigma , mode = \"nearest\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Init a uniform noise variable . [CODESPLIT] def uniform_noise ( points ) : return np . random . rand ( 1 ) * np . random . uniform ( points , 1 ) + random . sample ( [ 2 , - 2 ] , 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add Builders and construction variables for SGI MIPS C ++ to an Environment . [CODESPLIT] def generate ( env ) : cplusplus . generate ( env ) env [ 'CXX' ] = 'CC' env [ 'CXXFLAGS' ] = SCons . Util . CLVar ( '-LANG:std' ) env [ 'SHCXX' ] = '$CXX' env [ 'SHOBJSUFFIX' ] = '.o' env [ 'STATIC_AND_SHARED_OBJECTS_ARE_THE_SAME' ] = 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert to datetime to UTC offset . [CODESPLIT] def convert_2_utc ( self , datetime_ , timezone ) : datetime_ = self . tz_mapper [ timezone ] . localize ( datetime_ ) return datetime_ . astimezone ( pytz . UTC )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a str of decimal with two digits after a decimal mark . [CODESPLIT] def money ( min = 0 , max = 10 ) : value = random . choice ( range ( min * 100 , max * 100 ) ) return \"%1.2f\" % ( float ( value ) / 100 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list with no repeated elements . [CODESPLIT] def get_uniques ( l ) : result = [ ] for i in l : if i not in result : result . append ( i ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A quick and dirty way to get a unique string [CODESPLIT] def uniqueID ( size = 6 , chars = string . ascii_uppercase + string . digits ) : return '' . join ( random . choice ( chars ) for x in xrange ( size ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Combine the outer and inner keys of nested dictionaries into a single ordering . [CODESPLIT] def flattened_nested_key_indices ( nested_dict ) : outer_keys , inner_keys = collect_nested_keys ( nested_dict ) combined_keys = list ( sorted ( set ( outer_keys + inner_keys ) ) ) return { k : i for ( i , k ) in enumerate ( combined_keys ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Move a column to the first in order . [CODESPLIT] def move_to_start ( self , column_label ) : self . _columns . move_to_end ( column_label , last = False ) return self", "target": 1, "target_options": ["no_match", "match"]}
{"input": "List APIs in account . [CODESPLIT] def list_apis ( awsclient ) : client_api = awsclient . get_client ( 'apigateway' ) apis = client_api . get_rest_apis ( ) [ 'items' ] for api in apis : print ( json2table ( api ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalizes list [CODESPLIT] def normalize_array ( lst ) : np_arr = np . array ( lst ) x_normalized = np_arr / np_arr . max ( axis = 0 ) return list ( x_normalized )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the list of file changed in the current branch compared to master [CODESPLIT] def files_changed ( ) : with chdir ( get_root ( ) ) : result = run_command ( 'git diff --name-only master...' , capture = 'out' ) changed_files = result . stdout . splitlines ( ) # Remove empty lines return [ f for f in changed_files if f ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print dicttree in Json - like format . keys are sorted [CODESPLIT] def prettyprint ( d ) : print ( json . dumps ( d , sort_keys = True , indent = 4 , separators = ( \",\" , \": \" ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the name from a column - like SQLAlchemy expression . [CODESPLIT] def _get_name ( column_like ) : if isinstance ( column_like , Column ) : return column_like . name elif isinstance ( column_like , Cast ) : return column_like . clause . name", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reloads the configuration from the file and environment variables . Useful if using os . environ instead of this class set_env method or if the underlying configuration file is changed externally . [CODESPLIT] def _reload ( self , force = False ) : self . _config_map = dict ( ) self . _registered_env_keys = set ( ) self . __reload_sources ( force ) self . __load_environment_keys ( ) self . verify ( ) self . _clear_memoization ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns ( width height ) for the given variable [CODESPLIT] def get_grid_spatial_dimensions ( self , variable ) : data = self . open_dataset ( self . service ) . variables [ variable . variable ] dimensions = list ( data . dimensions ) return data . shape [ dimensions . index ( variable . x_dimension ) ] , data . shape [ dimensions . index ( variable . y_dimension ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the unit tests . [CODESPLIT] def test ( ) : import unittest tests = unittest . TestLoader ( ) . discover ( 'tests' ) unittest . TextTestRunner ( verbosity = 2 ) . run ( tests )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the list of distinct values with preserving order . [CODESPLIT] def distinct ( xs ) : # don't use collections.OrderedDict because we do support Python 2.6 seen = set ( ) return [ x for x in xs if x not in seen and not seen . add ( x ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Integer dots per inch for the width of this image . Defaults to 72 when not present in the file as is often the case . [CODESPLIT] def horz_dpi ( self ) : pHYs = self . _chunks . pHYs if pHYs is None : return 72 return self . _dpi ( pHYs . units_specifier , pHYs . horz_px_per_unit )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the file extension for an abi3 - compliant Extension () [CODESPLIT] def get_abi3_suffix ( ) : for suffix , _ , _ in ( s for s in imp . get_suffixes ( ) if s [ 2 ] == imp . C_EXTENSION ) : if '.abi3' in suffix : # Unix return suffix elif suffix == '.pyd' : # Windows return suffix", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sum reduction op . [CODESPLIT] def Sum ( a , axis , keep_dims ) : return np . sum ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve a function from a library / DLL and set the data types . [CODESPLIT] def get_winfunc ( libname , funcname , restype = None , argtypes = ( ) , _libcache = { } ) : if libname not in _libcache : _libcache [ libname ] = windll . LoadLibrary ( libname ) func = getattr ( _libcache [ libname ] , funcname ) func . argtypes = argtypes func . restype = restype return func", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a gid given a group name . [CODESPLIT] def _get_gid ( name ) : if getgrnam is None or name is None : return None try : result = getgrnam ( name ) except KeyError : result = None if result is not None : return result [ 2 ] return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a JSSObject for the element with ID id_ [CODESPLIT] def retrieve_by_id ( self , id_ ) : items_with_id = [ item for item in self if item . id == int ( id_ ) ] if len ( items_with_id ) == 1 : return items_with_id [ 0 ] . retrieve ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the integer index of * series * in this sequence . [CODESPLIT] def series_index ( self , series ) : for idx , s in enumerate ( self ) : if series is s : return idx raise ValueError ( 'series not in chart data object' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn an SQLAlchemy model into a dict of field names and values . [CODESPLIT] def object_as_dict ( obj ) : return { c . key : getattr ( obj , c . key ) for c in inspect ( obj ) . mapper . column_attrs }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a JSSObject for the element with ID id_ [CODESPLIT] def retrieve_by_id ( self , id_ ) : items_with_id = [ item for item in self if item . id == int ( id_ ) ] if len ( items_with_id ) == 1 : return items_with_id [ 0 ] . retrieve ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of indexes of substr . If substr not found list is empty . [CODESPLIT] def get_substring_idxs ( substr , string ) : return [ match . start ( ) for match in re . finditer ( substr , string ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve requested URL [CODESPLIT] def _get_url ( url ) : try : data = HTTP_SESSION . get ( url , stream = True ) data . raise_for_status ( ) except requests . exceptions . RequestException as exc : raise FetcherException ( exc ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the id of the last written row in table [CODESPLIT] def get_last_id ( self , cur , table = 'reaction' ) : cur . execute ( \"SELECT seq FROM sqlite_sequence WHERE name='{0}'\" . format ( table ) ) result = cur . fetchone ( ) if result is not None : id = result [ 0 ] else : id = 0 return id", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip apostrophe and s from the end of a string . [CODESPLIT] def unapostrophe ( text ) : text = re . sub ( r'[%s]s?$' % '' . join ( APOSTROPHES ) , '' , text ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get an SArray that contains the last n elements in the SArray . [CODESPLIT] def tail ( self , n = 10 ) : with cython_context ( ) : return SArray ( _proxy = self . __proxy__ . tail ( n ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This way can delete file immediately [CODESPLIT] def open_as_pillow ( filename ) : with __sys_open ( filename , 'rb' ) as f : data = BytesIO ( f . read ( ) ) return Image . open ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the names of all callable attributes of an object [CODESPLIT] def get_methods ( * objs ) : return set ( attr for obj in objs for attr in dir ( obj ) if not attr . startswith ( '_' ) and callable ( getattr ( obj , attr ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "detect if a model has a given field has [CODESPLIT] def has_field ( mc , field_name ) : try : mc . _meta . get_field ( field_name ) except FieldDoesNotExist : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the given command ( with shell = False ) and return a tuple of ( int returncode str output ) . Strip the output of enclosing whitespace . [CODESPLIT] def call_out ( command ) : # start external command process p = subprocess . Popen ( command , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) # get outputs out , _ = p . communicate ( ) return p . returncode , out . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check for existence of key in dict return value or raise error [CODESPLIT] def _check_conversion ( key , valid_dict ) : if key not in valid_dict and key not in valid_dict . values ( ) : # Only show users the nice string values keys = [ v for v in valid_dict . keys ( ) if isinstance ( v , string_types ) ] raise ValueError ( 'value must be one of %s, not %s' % ( keys , key ) ) return valid_dict [ key ] if key in valid_dict else key", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list of PIDs currently running on the system . [CODESPLIT] def get_pid_list ( ) : pids = [ int ( x ) for x in os . listdir ( '/proc' ) if x . isdigit ( ) ] return pids", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a file exists [CODESPLIT] def file_found ( filename , force ) : if os . path . exists ( filename ) and not force : logger . info ( \"Found %s; skipping...\" % filename ) return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if the given string starts with one of the prefixes in the given list otherwise return False . [CODESPLIT] def starts_with_prefix_in_list ( text , prefixes ) : for prefix in prefixes : if text . startswith ( prefix ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simply logs a warning if the desired enum value is not found . [CODESPLIT] def from_string ( cls , string ) : # find enum value for attr in dir ( cls ) : value = getattr ( cls , attr ) if value == string : return value # if not found, log warning and return the value passed in logger . warning ( \"{} is not a valid enum value for {}.\" . format ( string , cls . __name__ ) ) return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function for conversion of various data types into numeric representation . [CODESPLIT] def _to_numeric ( val ) : if isinstance ( val , ( int , float , datetime . datetime , datetime . timedelta ) ) : return val return float ( val )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a WAV file and returns the data and sample rate [CODESPLIT] def readwav ( filename ) : from scipy . io . wavfile import read as readwav samplerate , signal = readwav ( filename ) return signal , samplerate", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of dictionaries which are sorted for only unique entries . [CODESPLIT] def unique_list_dicts ( dlist , key ) : return list ( dict ( ( val [ key ] , val ) for val in dlist ) . values ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "given a segment ( rectangle ) and an image returns it s corresponding subimage [CODESPLIT] def region_from_segment ( image , segment ) : x , y , w , h = segment return image [ y : y + h , x : x + w ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Directly reads text data from url [CODESPLIT] def url_read_text ( url , verbose = True ) : data = url_read ( url , verbose ) text = data . decode ( 'utf8' ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the arithematic mean of the values in the passed list . Assumes a 1D list but will function on the 1st dim of an array ( ! ) . [CODESPLIT] def mean ( inlist ) : sum = 0 for item in inlist : sum = sum + item return sum / float ( len ( inlist ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ends an indentation block leaving an empty line afterwards [CODESPLIT] def end_block ( self ) : self . current_indent -= 1 # If we did not add a new line automatically yet, now it's the time! if not self . auto_added_line : self . writeln ( ) self . auto_added_line = True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "For a given value the function finds the nearest value in the array and returns its index . [CODESPLIT] def find_nearest_index ( arr , value ) : arr = np . array ( arr ) index = ( abs ( arr - value ) ) . argmin ( ) return index", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ends an indentation block leaving an empty line afterwards [CODESPLIT] def end_block ( self ) : self . current_indent -= 1 # If we did not add a new line automatically yet, now it's the time! if not self . auto_added_line : self . writeln ( ) self . auto_added_line = True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the column mapped by db_field name [CODESPLIT] def _get_column_by_db_name ( cls , name ) : return cls . _columns . get ( cls . _db_map . get ( name , name ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialize python List with capacity of 10 or user given input . Python List type is a dynamic array so we have to restrict its dynamic nature to make it work like a static array . [CODESPLIT] def __init__ ( self , capacity = 10 ) : super ( ) . __init__ ( ) self . _array = [ None ] * capacity self . _front = 0 self . _rear = 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns date range for the previous full month . [CODESPLIT] def get_previous_month ( self ) : end = utils . get_month_start ( ) - relativedelta ( days = 1 ) end = utils . to_datetime ( end ) start = utils . get_month_start ( end ) return start , end", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute a normal python statement in user namespace . [CODESPLIT] def ex ( self , cmd ) : with self . builtin_trap : exec cmd in self . user_global_ns , self . user_ns", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns unique elements from a list preserving the original order [CODESPLIT] def unique_element ( ll ) : seen = { } result = [ ] for item in ll : if item in seen : continue seen [ item ] = 1 result . append ( item ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds self as child of parent then adds parent . [CODESPLIT] def add_parent ( self , parent ) : parent . add_child ( self ) self . parent = parent return parent", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds noise to Y [CODESPLIT] def add_noise ( Y , sigma ) : return Y + np . random . normal ( 0 , sigma , Y . shape )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Class method that returns all defined arguments within the class . Returns : A dictionary containing all action defined arguments ( if any ) . [CODESPLIT] def props ( cls ) : return { k : v for ( k , v ) in inspect . getmembers ( cls ) if type ( v ) is Argument }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks whether all number in the sequence s lie inside the interval formed by l and r . [CODESPLIT] def are_in_interval ( s , l , r , border = 'included' ) : return numpy . all ( [ IntensityRangeStandardization . is_in_interval ( x , l , r , border ) for x in s ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieves a list of member - like objects ( members or properties ) that are publically exposed . [CODESPLIT] def get_public_members ( obj ) : return { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( \"_\" ) and not hasattr ( getattr ( obj , attr ) , '__call__' ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Encodes Unicode strings to byte strings if necessary . [CODESPLIT] def b ( s ) : return s if isinstance ( s , bytes ) else s . encode ( locale . getpreferredencoding ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute the user function . [CODESPLIT] def __call__ ( self , args ) : window , ij = args return self . user_func ( srcs , window , ij , global_args ) , window", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Directly reads text data from url [CODESPLIT] def url_read_text ( url , verbose = True ) : data = url_read ( url , verbose ) text = data . decode ( 'utf8' ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Draw a networkx graph with Pygraphviz . [CODESPLIT] def draw_graph ( G : nx . DiGraph , filename : str ) : A = to_agraph ( G ) A . graph_attr [ \"rankdir\" ] = \"LR\" A . draw ( filename , prog = \"dot\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if number is integer or not . [CODESPLIT] def check_int ( integer ) : if not isinstance ( integer , str ) : return False if integer [ 0 ] in ( '-' , '+' ) : return integer [ 1 : ] . isdigit ( ) return integer . isdigit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Recursively loop through a directory to find all python script files . When one is found it is analyzed for import statements : param path : string : return : generator [CODESPLIT] def search_script_directory ( self , path ) : for subdir , dirs , files in os . walk ( path ) : for file_name in files : if file_name . endswith ( \".py\" ) : self . search_script_file ( subdir , file_name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a shell - escaped version of the string s . [CODESPLIT] def quote ( self , s ) : if six . PY2 : from pipes import quote else : from shlex import quote return quote ( s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse ISO8601 timestamps given by github API . [CODESPLIT] def parse_timestamp ( timestamp ) : dt = dateutil . parser . parse ( timestamp ) return dt . astimezone ( dateutil . tz . tzutc ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r End the table header which will appear on every page . [CODESPLIT] def end_table_header ( self ) : if self . header : msg = \"Table already has a header\" raise TableError ( msg ) self . header = True self . append ( Command ( r'endhead' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterate through tree leaves first [CODESPLIT] def __iter__ ( self ) : for node in chain ( * imap ( iter , self . children ) ) : yield node yield self", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if the string is a mathematical symbol . [CODESPLIT] def is_symbol ( string ) : return ( is_int ( string ) or is_float ( string ) or is_constant ( string ) or is_unary ( string ) or is_binary ( string ) or ( string == '(' ) or ( string == ')' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Output data in excel - compatible tab - delimited format [CODESPLIT] def tab ( self , output ) : import csv csvwriter = csv . writer ( self . outfile , dialect = csv . excel_tab ) csvwriter . writerows ( output )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Skip the next time frame [CODESPLIT] def _skip_frame ( self ) : for line in self . _f : if line == 'ITEM: ATOMS\\n' : break for i in range ( self . num_atoms ) : next ( self . _f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make bars in horizontal bar chart thinner [CODESPLIT] def _change_height ( self , ax , new_value ) : for patch in ax . patches : current_height = patch . get_height ( ) diff = current_height - new_value # we change the bar height patch . set_height ( new_value ) # we recenter the bar patch . set_y ( patch . get_y ( ) + diff * .5 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "iterator for JSON - per - line in a file pattern [CODESPLIT] def json_iter ( path ) : with open ( path , 'r' ) as f : for line in f . readlines ( ) : yield json . loads ( line )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap itertools . groupby to make life easier . [CODESPLIT] def group_by ( iterable , key_func ) : groups = ( list ( sub ) for key , sub in groupby ( iterable , key_func ) ) return zip ( groups , groups )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Round to sig figs [CODESPLIT] def round_to_n ( x , n ) : return round ( x , - int ( np . floor ( np . log10 ( x ) ) ) + ( n - 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a float returns a rounded int . Should give the same result on both Py2 / 3 [CODESPLIT] def intround ( value ) : return int ( decimal . Decimal . from_float ( value ) . to_integral_value ( decimal . ROUND_HALF_EVEN ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resets the iterator to the start . [CODESPLIT] def reset ( self ) : self . __iterator , self . __saved = itertools . tee ( self . __saved )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Start web application [CODESPLIT] def web ( host , port ) : from . webserver . web import get_app get_app ( ) . run ( host = host , port = port )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to turn a string representation of true into boolean True . [CODESPLIT] def strToBool ( val ) : if isinstance ( val , str ) : val = val . lower ( ) return val in [ 'true' , 'on' , 'yes' , True ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Advance the iterator without returning the old head . [CODESPLIT] def _fill ( self ) : try : self . _head = self . _iterable . next ( ) except StopIteration : self . _head = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Thin wrapper around ElementTree . iterparse [CODESPLIT] def iterparse ( source , events = ( 'end' , ) , remove_comments = True , * * kw ) : return ElementTree . iterparse ( source , events , SourceLineParser ( ) , * * kw )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": return : generator of tuples ( isLastFlag item ) [CODESPLIT] def iter_with_last ( iterable ) : # Ensure it's an iterator and get the first field iterable = iter ( iterable ) prev = next ( iterable ) for item in iterable : # Lag by one item so I know I'm not at the end yield False , prev prev = item # Last item yield True , prev", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the help text ( signature + docstring ) for a command ( function ) . [CODESPLIT] def help_for_command ( command ) : help_text = pydoc . text . document ( command ) # remove backspaces return re . subn ( '.\\\\x08' , '' , help_text ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Render a template into a response . [CODESPLIT] def render_template ( template_name , * * context ) : tmpl = jinja_env . get_template ( template_name ) context [ \"url_for\" ] = url_for return Response ( tmpl . render ( context ) , mimetype = \"text/html\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is builtin in python2 but we have to roll our own on py3 . [CODESPLIT] def execfile ( fname , variables ) : with open ( fname ) as f : code = compile ( f . read ( ) , fname , 'exec' ) exec ( code , variables )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gaussian model m is [ psill range nugget ] [CODESPLIT] def gaussian_variogram_model ( m , d ) : psill = float ( m [ 0 ] ) range_ = float ( m [ 1 ] ) nugget = float ( m [ 2 ] ) return psill * ( 1. - np . exp ( - d ** 2. / ( range_ * 4. / 7. ) ** 2. ) ) + nugget", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list consisting of the cumulative sum of the items in the passed list . [CODESPLIT] def lcumsum ( inlist ) : newlist = copy . deepcopy ( inlist ) for i in range ( 1 , len ( newlist ) ) : newlist [ i ] = newlist [ i ] + newlist [ i - 1 ] return newlist", "target": 1, "target_options": ["no_match", "match"]}
{"input": "helper function used for joins builds left and right join list for join function [CODESPLIT] def get_join_cols ( by_entry ) : left_cols = [ ] right_cols = [ ] for col in by_entry : if isinstance ( col , str ) : left_cols . append ( col ) right_cols . append ( col ) else : left_cols . append ( col [ 0 ] ) right_cols . append ( col [ 1 ] ) return left_cols , right_cols", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return string as a comment [CODESPLIT] def _comment ( string ) : lines = [ line . strip ( ) for line in string . splitlines ( ) ] return \"# \" + ( \"%s# \" % linesep ) . join ( lines )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Merge all the strings . Put space between them . [CODESPLIT] def join ( mapping , bind , values ) : return [ ' ' . join ( [ six . text_type ( v ) for v in values if v is not None ] ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Serializer for consistency [CODESPLIT] def json_dumps ( self , obj ) : return json . dumps ( obj , sort_keys = True , indent = 4 , separators = ( ',' , ': ' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Kill the browser . [CODESPLIT] def kill ( self ) : if self . process : self . process . kill ( ) self . process . wait ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a json string representing the python object obj . [CODESPLIT] def to_json ( obj ) : i = StringIO . StringIO ( ) w = Writer ( i , encoding = 'UTF-8' ) w . write_value ( obj ) return i . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a JSSObject for the element with ID id_ [CODESPLIT] def retrieve_by_id ( self , id_ ) : items_with_id = [ item for item in self if item . id == int ( id_ ) ] if len ( items_with_id ) == 1 : return items_with_id [ 0 ] . retrieve ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse a JSON file First remove comments and then use the json module package Comments look like : // ... or / * ... * / [CODESPLIT] def parse_json ( filename ) : # Regular expression for comments comment_re = re . compile ( '(^)?[^\\S\\n]*/(?:\\*(.*?)\\*/[^\\S\\n]*|/[^\\n]*)($)?' , re . DOTALL | re . MULTILINE ) with open ( filename ) as f : content = '' . join ( f . readlines ( ) ) ## Looking for comments match = comment_re . search ( content ) while match : # single line comment content = content [ : match . start ( ) ] + content [ match . end ( ) : ] match = comment_re . search ( content ) # Return json file return json . loads ( content )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deserialize b ( instance of bytes ) to a Python object . [CODESPLIT] def loadb ( b ) : assert isinstance ( b , ( bytes , bytearray ) ) return std_json . loads ( b . decode ( 'utf-8' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is to support iterators over a file - like object . [CODESPLIT] def next ( self ) : # File-like object. result = self . readline ( ) if result == self . _empty_buffer : raise StopIteration return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coerce value to an JSON - compatible representation . [CODESPLIT] def _time_to_json ( value ) : if isinstance ( value , datetime . time ) : value = value . isoformat ( ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Setup pins [CODESPLIT] def setup ( ) : print ( \"Simple drive\" ) board . set_pin_mode ( L_CTRL_1 , Constants . OUTPUT ) board . set_pin_mode ( L_CTRL_2 , Constants . OUTPUT ) board . set_pin_mode ( PWM_L , Constants . PWM ) board . set_pin_mode ( R_CTRL_1 , Constants . OUTPUT ) board . set_pin_mode ( R_CTRL_2 , Constants . OUTPUT ) board . set_pin_mode ( PWM_R , Constants . PWM )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if the json_element passed is present for the task specified . [CODESPLIT] def task_property_present_predicate ( service , task , prop ) : try : response = get_service_task ( service , task ) except Exception as e : pass return ( response is not None ) and ( prop in response )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validate payload against schema returning an error list . [CODESPLIT] def validate ( payload , schema ) : v = jsonschema . Draft4Validator ( schema , format_checker = jsonschema . FormatChecker ( ) ) error_list = [ ] for error in v . iter_errors ( payload ) : message = error . message location = '/' + '/' . join ( [ str ( c ) for c in error . absolute_path ] ) error_list . append ( message + ' at ' + location ) return error_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Init a noise variable . [CODESPLIT] def normal_noise ( points ) : return np . random . rand ( 1 ) * np . random . randn ( points , 1 ) + random . sample ( [ 2 , - 2 ] , 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Moves the text cursor to given line . [CODESPLIT] def go_to_line ( self , line ) : cursor = self . textCursor ( ) cursor . setPosition ( self . document ( ) . findBlockByNumber ( line - 1 ) . position ( ) ) self . setTextCursor ( cursor ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Colorize text with given color . [CODESPLIT] def _write_color_ansi ( fp , text , color ) : fp . write ( esc_ansicolor ( color ) ) fp . write ( text ) fp . write ( AnsiReset )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Drops the trailing zeros in a float that is printed . [CODESPLIT] def drop_trailing_zeros ( num ) : txt = '%f' % ( num ) txt = txt . rstrip ( '0' ) if txt . endswith ( '.' ) : txt = txt [ : - 1 ] return txt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Weeks start are fixes at Monday for now . [CODESPLIT] def weekly ( date = datetime . date . today ( ) ) : return date - datetime . timedelta ( days = date . weekday ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find and kill child processes of a process . [CODESPLIT] def kill_process_children ( pid ) : if sys . platform == \"darwin\" : kill_process_children_osx ( pid ) elif sys . platform == \"linux\" : kill_process_children_unix ( pid ) else : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Kill the process group associated with the given process . ( posix ) [CODESPLIT] def kill_process ( process ) : logger = logging . getLogger ( 'xenon' ) logger . info ( 'Terminating Xenon-GRPC server.' ) os . kill ( process . pid , signal . SIGINT ) process . wait ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Install Postgres on remote [CODESPLIT] def install_postgres ( user = None , dbname = None , password = None ) : execute ( pydiploy . django . install_postgres_server , user = user , dbname = dbname , password = password )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The l2 norm of an array is is defined as : sqrt ( ||x|| ) where ||x|| is the dot product of the vector . [CODESPLIT] def l2_norm ( arr ) : arr = np . asarray ( arr ) return np . sqrt ( np . dot ( arr . ravel ( ) . squeeze ( ) , arr . ravel ( ) . squeeze ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pad the text . [CODESPLIT] def _pad ( self , text ) : top_bottom = ( \"\\n\" * self . _padding ) + \" \" right_left = \" \" * self . _padding * self . PAD_WIDTH return top_bottom + right_left + text + right_left + top_bottom", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap an AST Call node to lambda expression node . call : ast . Call node [CODESPLIT] def make_lambda ( call ) : empty_args = ast . arguments ( args = [ ] , vararg = None , kwarg = None , defaults = [ ] ) return ast . Lambda ( args = empty_args , body = call )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse an int robustly ignoring commas and other cruft . [CODESPLIT] def robust_int ( v ) : if isinstance ( v , int ) : return v if isinstance ( v , float ) : return int ( v ) v = str ( v ) . replace ( ',' , '' ) if not v : return None return int ( v )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets tail [CODESPLIT] def get_tail ( self ) : node = self . head last_node = self . head while node is not None : last_node = node node = node . next_node return last_node", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds an accuracy op to the model [CODESPLIT] def AddAccuracy ( model , softmax , label ) : accuracy = brew . accuracy ( model , [ softmax , label ] , \"accuracy\" ) return accuracy", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the 1 - based index of the last item on this page . [CODESPLIT] def end_index ( self ) : paginator = self . paginator # Special case for the last page because there can be orphans. if self . number == paginator . num_pages : return paginator . count return ( self . number - 1 ) * paginator . per_page + paginator . first_page", "target": 1, "target_options": ["no_match", "match"]}
{"input": "append item and print it to stdout [CODESPLIT] def append ( self , item ) : print ( item ) super ( MyList , self ) . append ( item )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert cartesian to lon lat . [CODESPLIT] def xyz2lonlat ( x , y , z ) : lon = xu . rad2deg ( xu . arctan2 ( y , x ) ) lat = xu . rad2deg ( xu . arctan2 ( z , xu . sqrt ( x ** 2 + y ** 2 ) ) ) return lon , lat", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert an image by applying a contour [CODESPLIT] def filter_contour ( imageFile , opFile ) : im = Image . open ( imageFile ) im1 = im . filter ( ImageFilter . CONTOUR ) im1 . save ( opFile )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "apply a function to all non - dict values in a dictionary [CODESPLIT] def dictapply ( d , fn ) : for k , v in d . items ( ) : if isinstance ( v , dict ) : v = dictapply ( v , fn ) else : d [ k ] = fn ( v ) return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Predicts a probabilities / value / label for the sample x . [CODESPLIT] def tree_predict ( x , root , proba = False , regression = False ) : if isinstance ( root , Leaf ) : if proba : return root . probabilities elif regression : return root . mean else : return root . most_frequent if root . question . match ( x ) : return tree_predict ( x , root . true_branch , proba = proba , regression = regression ) else : return tree_predict ( x , root . false_branch , proba = proba , regression = regression )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Minimise an ( x y z ) coordinate . [CODESPLIT] def minimise_xyz ( xyz ) : x , y , z = xyz m = max ( min ( x , y ) , min ( max ( x , y ) , z ) ) return ( x - m , y - m , z - m )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shut down a specific process . [CODESPLIT] def stop ( pid ) : if psutil . pid_exists ( pid ) : try : p = psutil . Process ( pid ) p . kill ( ) except Exception : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "variance of the values must have 2 or more entries . [CODESPLIT] def variance ( arr ) : avg = average ( arr ) return sum ( [ ( float ( x ) - avg ) ** 2 for x in arr ] ) / float ( len ( arr ) - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "get element by name [CODESPLIT] def get_by ( self , name ) : return next ( ( item for item in self if item . name == name ) , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Used everywhere to decide if some exception type should be displayed or hidden as the casue of an error [CODESPLIT] def should_be_hidden_as_cause ( exc ) : # reduced traceback in case of HasWrongType (instance_of checks) from valid8 . validation_lib . types import HasWrongType , IsWrongType return isinstance ( exc , ( HasWrongType , IsWrongType ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates the distance between two points on earth . [CODESPLIT] def _calculate_distance ( latlon1 , latlon2 ) : lat1 , lon1 = latlon1 lat2 , lon2 = latlon2 dlon = lon2 - lon1 dlat = lat2 - lat1 R = 6371 # radius of the earth in kilometers a = np . sin ( dlat / 2 ) ** 2 + np . cos ( lat1 ) * np . cos ( lat2 ) * ( np . sin ( dlon / 2 ) ) ** 2 c = 2 * np . pi * R * np . arctan2 ( np . sqrt ( a ) , np . sqrt ( 1 - a ) ) / 180 return c", "target": 1, "target_options": ["no_match", "match"]}
{"input": "All values for this enum : return : list of tuples [CODESPLIT] def items ( cls ) : return [ cls . PRECIPITATION , cls . WIND , cls . TEMPERATURE , cls . PRESSURE ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a list of JSON values to a list of models [CODESPLIT] def from_json_list ( cls , api_client , data ) : return [ cls . from_json ( api_client , item ) for item in data ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the eigvals of mat and then find the center eigval difference . [CODESPLIT] def center_eigenvalue_diff ( mat ) : N = len ( mat ) evals = np . sort ( la . eigvals ( mat ) ) diff = np . abs ( evals [ N / 2 ] - evals [ N / 2 - 1 ] ) return diff", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get all the prime factor of given integer [CODESPLIT] def getPrimeFactors ( n ) : lo = [ 1 ] n2 = n // 2 k = 2 for k in range ( 2 , n2 + 1 ) : if ( n // k ) * k == n : lo . append ( k ) return lo + [ n , ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Square of the euclidean distance [CODESPLIT] def euclidean ( c1 , c2 ) : diffs = ( ( i - j ) for i , j in zip ( c1 , c2 ) ) return sum ( x * x for x in diffs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "numpy . ndarray dumper . [CODESPLIT] def dump_nparray ( self , obj , class_name = numpy_ndarray_class_name ) : return { \"$\" + class_name : self . _json_convert ( obj . tolist ( ) ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Actually calls the callable with the namespace parsed from the command line . [CODESPLIT] def _call ( callable_obj , arg_names , namespace ) : arguments = { arg_name : getattr ( namespace , arg_name ) for arg_name in arg_names } return callable_obj ( * * arguments )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Evaluates a piece of Javascript in the context of the current page and returns its value . [CODESPLIT] def eval_script ( self , expr ) : ret = self . conn . issue_command ( \"Evaluate\" , expr ) return json . loads ( \"[%s]\" % ret ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "main entry point for the jardiff CLI [CODESPLIT] def main ( args = sys . argv ) : parser = create_optparser ( args [ 0 ] ) return cli ( parser . parse_args ( args [ 1 : ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "generate a CamelCase string from an underscore_string . [CODESPLIT] def camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = '' for component in components : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes underscores and capitalizes the neighbouring character [CODESPLIT] def mixedcase ( path ) : words = path . split ( '_' ) return words [ 0 ] + '' . join ( word . title ( ) for word in words [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes underscores and capitalizes the neighbouring character [CODESPLIT] def mixedcase ( path ) : words = path . split ( '_' ) return words [ 0 ] + '' . join ( word . title ( ) for word in words [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the leftmost index of an element in a list using binary search . [CODESPLIT] def bisect_index ( a , x ) : i = bisect . bisect_left ( a , x ) if i != len ( a ) and a [ i ] == x : return i raise ValueError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert datetime / str to date : param arg : : return : [CODESPLIT] def _datetime_to_date ( arg ) : _arg = parse ( arg ) if isinstance ( _arg , datetime . datetime ) : _arg = _arg . date ( ) return _arg", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Enable the download log filter . [CODESPLIT] def __enter__ ( self ) : self . logger = logging . getLogger ( 'pip.download' ) self . logger . addFilter ( self )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Same to log but this one centralizes the message first . [CODESPLIT] def clog ( color ) : logger = log ( color ) return lambda msg : logger ( centralize ( msg ) . rstrip ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize the index in case it is a numpy integer or boolean array . [CODESPLIT] def _normalize_numpy_indices ( i ) : if isinstance ( i , np . ndarray ) : if i . dtype == bool : i = tuple ( j . tolist ( ) for j in i . nonzero ( ) ) elif i . dtype == int : i = i . tolist ( ) return i", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format a message in the log [CODESPLIT] def format ( self , record , * args , * * kwargs ) : return logging . Formatter . format ( self , record , * args , * * kwargs ) . replace ( '\\n' , '\\n' + ' ' * 8 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a value from MSSQL and converts it to a value that s safe for JSON / Google Cloud Storage / BigQuery . [CODESPLIT] def convert_types ( cls , value ) : if isinstance ( value , decimal . Decimal ) : return float ( value ) else : return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return list of Logger classes . [CODESPLIT] def _get_loggers ( ) : from . . import loader modules = loader . get_package_modules ( 'logger' ) return list ( loader . get_plugins ( modules , [ _Logger ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "print the message to the predefined log file without newline [CODESPLIT] def log_no_newline ( self , msg ) : self . print2file ( self . logfile , False , False , msg )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility function which converts lists to tuples . [CODESPLIT] def as_tuple ( self , value ) : if isinstance ( value , list ) : value = tuple ( value ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Checks if l is a 2D numpy array of bools [CODESPLIT] def is_bool_matrix ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 2 and ( l . dtype == bool ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets the pd dataframe index of all dataframes in the system to index [CODESPLIT] def set_index ( self , index ) : for df in self . get_DataFrame ( data = True , with_population = False ) : df . index = index", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Move the turtle forward . [CODESPLIT] def forward ( self , step ) : x = self . pos_x + math . cos ( math . radians ( self . rotation ) ) * step y = self . pos_y + math . sin ( math . radians ( self . rotation ) ) * step prev_brush_state = self . brush_on self . brush_on = True self . move ( x , y ) self . brush_on = prev_brush_state", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Draw a set of lines [CODESPLIT] def polyline ( self , arr ) : for i in range ( 0 , len ( arr ) - 1 ) : self . line ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] , arr [ i + 1 ] [ 0 ] , arr [ i + 1 ] [ 1 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a JavaRDD of Object by unpickling [CODESPLIT] def _to_java_object_rdd ( rdd ) : rdd = rdd . _reserialize ( AutoBatchedSerializer ( PickleSerializer ( ) ) ) return rdd . ctx . _jvm . org . apache . spark . mllib . api . python . SerDe . pythonToJava ( rdd . _jrdd , True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a spec to a mock . spec can either be an object or a list of strings . Only attributes on the spec can be fetched as attributes from the mock . [CODESPLIT] def mock_add_spec ( self , spec , spec_set = False ) : self . _mock_add_spec ( spec , spec_set ) self . _mock_set_magics ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def screen ( self , width , height , colorDepth ) : screenEvent = ScreenEvent ( ) screenEvent . width . value = width screenEvent . height . value = height screenEvent . colorDepth . value = colorDepth self . rec ( screenEvent )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extracts the subject line from an EmailMessage object . [CODESPLIT] def get_subject ( self , msg ) : text , encoding = decode_header ( msg [ 'subject' ] ) [ - 1 ] try : text = text . decode ( encoding ) # If it's already decoded, ignore error except AttributeError : pass return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if given value is a list tries to convert if it is not . [CODESPLIT] def to_list ( var ) : if var is None : return [ ] if isinstance ( var , str ) : var = var . split ( '\\n' ) elif not isinstance ( var , list ) : try : var = list ( var ) except TypeError : raise ValueError ( \"{} cannot be converted to the list.\" . format ( var ) ) return var", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterative flatten . [CODESPLIT] def iflatten ( L ) : for sublist in L : if hasattr ( sublist , '__iter__' ) : for item in iflatten ( sublist ) : yield item else : yield sublist", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert bytes and non - string into Python 3 str [CODESPLIT] def to_str ( s ) : if isinstance ( s , bytes ) : s = s . decode ( 'utf-8' ) elif not isinstance ( s , str ) : s = str ( s ) return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run blocking code in a different thread and wait for the result . [CODESPLIT] def wait_run_in_executor ( func , * args , * * kwargs ) : loop = asyncio . get_event_loop ( ) future = loop . run_in_executor ( None , functools . partial ( func , * args , * * kwargs ) ) yield from asyncio . wait ( [ future ] ) return future . result ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a new image by copying the image on a * color * background . [CODESPLIT] def copy_image_on_background ( image , color = WHITE ) : background = Image . new ( \"RGB\" , image . size , color ) background . paste ( image , mask = image . split ( ) [ 3 ] ) return background", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Makes the given dictionary symmetric . Values are assumed to be unique . [CODESPLIT] def make_symmetric ( dict ) : for key , value in list ( dict . items ( ) ) : dict [ value ] = key return dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reformat a date string to standard format . [CODESPLIT] def std_datestr ( self , datestr ) : return date . strftime ( self . str2date ( datestr ) , self . std_dateformat )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert list of key value lists to dict [CODESPLIT] def list_of_lists_to_dict ( l ) : d = { } for key , val in l : d . setdefault ( key , [ ] ) . append ( val ) return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a file exists [CODESPLIT] def file_found ( filename , force ) : if os . path . exists ( filename ) and not force : logger . info ( \"Found %s; skipping...\" % filename ) return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param list_of_points : : return : list_of_points with None s removed [CODESPLIT] def filter_none ( list_of_points ) : remove_elementnone = filter ( lambda p : p is not None , list_of_points ) remove_sublistnone = filter ( lambda p : not contains_none ( p ) , remove_elementnone ) return list ( remove_sublistnone )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates the returned positional object [CODESPLIT] def _validate_pos ( df ) : assert isinstance ( df , pd . DataFrame ) assert [ \"seqname\" , \"position\" , \"strand\" ] == df . columns . tolist ( ) assert df . position . dtype == np . dtype ( \"int64\" ) assert df . strand . dtype == np . dtype ( \"O\" ) assert df . seqname . dtype == np . dtype ( \"O\" ) return df", "target": 1, "target_options": ["no_match", "match"]}
{"input": "transpose matrix [CODESPLIT] def transpose ( table ) : t = [ ] for i in range ( 0 , len ( table [ 0 ] ) ) : t . append ( [ row [ i ] for row in table ] ) return t", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets a new value to map element [CODESPLIT] def set_as_object ( self , value ) : self . clear ( ) map = MapConverter . to_map ( value ) self . append ( map )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ensure val is Nx ( n_col ) usually Nx3 [CODESPLIT] def _check_color_dim ( val ) : val = np . atleast_2d ( val ) if val . shape [ 1 ] not in ( 3 , 4 ) : raise RuntimeError ( 'Value must have second dimension of size 3 or 4' ) return val , val . shape [ 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Matches a paren . [CODESPLIT] def match_paren ( self , tokens , item ) : match , = tokens return self . match ( match , item )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Does this filename match any of the patterns? [CODESPLIT] def file_matches ( filename , patterns ) : return any ( fnmatch . fnmatch ( filename , pat ) for pat in patterns )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "is_valid_image_extension . [CODESPLIT] def is_valid_image_extension ( file_path ) : valid_extensions = [ '.jpeg' , '.jpg' , '.gif' , '.png' ] _ , extension = os . path . splitext ( file_path ) return extension . lower ( ) in valid_extensions", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets the title on the underlying matplotlib AxesSubplot . [CODESPLIT] def set_title ( self , title , * * kwargs ) : ax = self . get_axes ( ) ax . set_title ( title , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "test if object is a list or tuple [CODESPLIT] def is_iter_non_string ( obj ) : if isinstance ( obj , list ) or isinstance ( obj , tuple ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strips a figure into multiple figures with a trace on each of them [CODESPLIT] def strip_figures ( figure ) : fig = [ ] for trace in figure [ 'data' ] : fig . append ( dict ( data = [ trace ] , layout = figure [ 'layout' ] ) ) return fig", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raises the supplied figure number or figure window . [CODESPLIT] def raise_figure_window ( f = 0 ) : if _fun . is_a_number ( f ) : f = _pylab . figure ( f ) f . canvas . manager . window . raise_ ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for matplotlib imshow [CODESPLIT] def extent ( self ) : return ( self . intervals [ 1 ] . pix1 - 0.5 , self . intervals [ 1 ] . pix2 - 0.5 , self . intervals [ 0 ] . pix1 - 0.5 , self . intervals [ 0 ] . pix2 - 0.5 , )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set y - axis limits of a subplot . [CODESPLIT] def set_ylimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_ylimits ( min , max )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list with all roots . Needs Numpy . [CODESPLIT] def roots ( self ) : import numpy as np return np . roots ( list ( self . values ( ) ) [ : : - 1 ] ) . tolist ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Copy an array to the shared memory . [CODESPLIT] def copy ( a ) : shared = anonymousmemmap ( a . shape , dtype = a . dtype ) shared [ : ] = a [ : ] return shared", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determines whether the passed value is a string safe for 2 / 3 . [CODESPLIT] def is_string ( val ) : try : basestring except NameError : return isinstance ( val , str ) return isinstance ( val , basestring )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call method with nparams positional parameters all non - specified defaults are passed None . [CODESPLIT] def with_defaults ( method , nparams , defaults = None ) : args = [ None ] * nparams if not defaults else defaults + max ( nparams - len ( defaults ) , 0 ) * [ None ] return method ( * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if given nicknames are equal in the server s case mapping . [CODESPLIT] def is_same_nick ( self , left , right ) : return self . normalize ( left ) == self . normalize ( right )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns file type for given file field . Args : field ( str ) : File field [CODESPLIT] def _file_type ( self , field ) : type = mimetypes . guess_type ( self . _files [ field ] ) [ 0 ] return type . encode ( \"utf-8\" ) if isinstance ( type , unicode ) else str ( type )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if the given thing represents a date [CODESPLIT] def is_date ( thing ) : # known date types date_types = ( datetime . datetime , datetime . date , DateTime ) return isinstance ( thing , date_types )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates one element of the collection [CODESPLIT] def update_one ( self , query , doc ) : if self . table is None : self . build_table ( ) if u\"$set\" in doc : doc = doc [ u\"$set\" ] allcond = self . parse_query ( query ) try : result = self . table . update ( doc , allcond ) except : # TODO: check table.update result # check what pymongo does in that case result = None return UpdateResult ( raw_result = result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return start and end date of this month . [CODESPLIT] def last_month ( ) : since = TODAY + delta ( day = 1 , months = - 1 ) until = since + delta ( months = 1 ) return Date ( since ) , Date ( until )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if the image is a sequenced image . [CODESPLIT] def _is_image_sequenced ( image ) : try : image . seek ( 1 ) image . seek ( 0 ) result = True except EOFError : result = False return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Erases n lines from the screen and moves the cursor up to follow [CODESPLIT] def erase_lines ( n = 1 ) : for _ in range ( n ) : print ( codes . cursor [ \"up\" ] , end = \"\" ) print ( codes . cursor [ \"eol\" ] , end = \"\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns whether a path names an existing directory we can list and read files from . [CODESPLIT] def is_readable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . R_OK ) and os . access ( path , os . X_OK )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Min reduction op . [CODESPLIT] def Min ( a , axis , keep_dims ) : return np . amin ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check for app updates and print / log them . [CODESPLIT] def check_update ( ) : logging . info ( 'Check for app updates.' ) try : update = updater . check_for_app_updates ( ) except Exception : logging . exception ( 'Check for updates failed.' ) return if update : print ( \"!!! UPDATE AVAILABLE !!!\\n\" \"\" + static_data . PROJECT_URL + \"\\n\\n\" ) logging . info ( \"Update available: \" + static_data . PROJECT_URL ) else : logging . info ( \"No update available.\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load proxy list from configured proxy source [CODESPLIT] def load ( self ) : self . _list = self . _source . load ( ) self . _list_iter = itertools . cycle ( self . _list )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if created today . [CODESPLIT] def created_today ( self ) : if self . datetime . date ( ) == datetime . today ( ) . date ( ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "kill process Args : process - Popen object for process [CODESPLIT] def kill_mprocess ( process ) : if process and proc_alive ( process ) : process . terminate ( ) process . communicate ( ) return not proc_alive ( process )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Try to convert variables into datatypes . [CODESPLIT] def autoconvert ( string ) : for fn in ( boolify , int , float ) : try : return fn ( string ) except ValueError : pass return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Try to convert variables into datatypes . [CODESPLIT] def autoconvert ( string ) : for fn in ( boolify , int , float ) : try : return fn ( string ) except ValueError : pass return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns type of the data for the given FeatureType . [CODESPLIT] def type ( self ) : if self is FeatureType . TIMESTAMP : return list if self is FeatureType . BBOX : return BBox return dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Equivalent of unix chmod + w path [CODESPLIT] def chmod_plus_w ( path ) : path_mode = os . stat ( path ) . st_mode path_mode &= int ( '777' , 8 ) path_mode |= stat . S_IWRITE os . chmod ( path , path_mode )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Same as : meth : random . choice but also supports : class : set type to be passed as sequence . [CODESPLIT] def random_choice ( sequence ) : return random . choice ( tuple ( sequence ) if isinstance ( sequence , set ) else sequence )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn an SQLAlchemy model into a dict of field names and values . [CODESPLIT] def object_as_dict ( obj ) : return { c . key : getattr ( obj , c . key ) for c in inspect ( obj ) . mapper . column_attrs }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load an object from a module by name [CODESPLIT] def load_object_by_name ( object_name ) : mod_name , attr = object_name . rsplit ( '.' , 1 ) mod = import_module ( mod_name ) return getattr ( mod , attr )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "White out the progress bar . [CODESPLIT] def erase ( self ) : with self . _at_last_line ( ) : self . stream . write ( self . _term . clear_eol ) self . stream . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform a named tuple into a dictionary [CODESPLIT] def dictify ( a_named_tuple ) : return dict ( ( s , getattr ( a_named_tuple , s ) ) for s in a_named_tuple . _fields )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clears the input and output buffers [CODESPLIT] def __clear_buffers ( self ) : try : self . _port . reset_input_buffer ( ) self . _port . reset_output_buffer ( ) except AttributeError : #pySerial 2.7 self . _port . flushInput ( ) self . _port . flushOutput ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raises the supplied figure number or figure window . [CODESPLIT] def raise_figure_window ( f = 0 ) : if _fun . is_a_number ( f ) : f = _pylab . figure ( f ) f . canvas . manager . window . raise_ ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes the write permissions for the given file for owner groups and others . [CODESPLIT] def make_file_read_only ( file_path ) : old_permissions = os . stat ( file_path ) . st_mode os . chmod ( file_path , old_permissions & ~ WRITE_PERMISSIONS )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Scipy norm function [CODESPLIT] def norm ( x , mu , sigma = 1.0 ) : return stats . norm ( loc = mu , scale = sigma ) . pdf ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Callback to go to the next tab . Called by the accel key . [CODESPLIT] def accel_next ( self , * args ) : if self . get_notebook ( ) . get_current_page ( ) + 1 == self . get_notebook ( ) . get_n_pages ( ) : self . get_notebook ( ) . set_current_page ( 0 ) else : self . get_notebook ( ) . next_page ( ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Close all connections . [CODESPLIT] def cleanup ( self , app ) : if hasattr ( self . database . obj , 'close_all' ) : self . database . close_all ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize dicts and lists [CODESPLIT] def _normalize ( obj ) : if isinstance ( obj , list ) : return [ _normalize ( item ) for item in obj ] elif isinstance ( obj , dict ) : return { k : _normalize ( v ) for k , v in obj . items ( ) if v is not None } elif hasattr ( obj , 'to_python' ) : return obj . to_python ( ) return obj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns n - th row of Pascal s triangle [CODESPLIT] def pascal_row ( n ) : result = [ 1 ] x , numerator = 1 , n for denominator in range ( 1 , n // 2 + 1 ) : x *= numerator x /= denominator result . append ( x ) numerator -= 1 if n & 1 == 0 : result . extend ( reversed ( result [ : - 1 ] ) ) else : result . extend ( reversed ( result ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Place this container s canvas onto the parent container s canvas . [CODESPLIT] def place ( self ) : self . place_children ( ) self . canvas . append ( self . parent . canvas , float ( self . left ) , float ( self . top ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run application tests [CODESPLIT] def test ( nose_argsuments ) : from nose import run params = [ '__main__' , '-c' , 'nose.ini' ] params . extend ( nose_argsuments ) run ( argv = params )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a ctypes float pointer array to a numpy array . [CODESPLIT] def cfloat32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_float ) ) : return np . fromiter ( cptr , dtype = np . float32 , count = length ) else : raise RuntimeError ( 'Expected float pointer' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a character delimited version of the provided list as a Python string [CODESPLIT] def delimited ( items , character = '|' ) : return '|' . join ( items ) if type ( items ) in ( list , tuple , set ) else items", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert string to int or float . [CODESPLIT] def covstr ( s ) : try : ret = int ( s ) except ValueError : ret = float ( s ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Command line interface for PyBEL . [CODESPLIT] def main ( ctx , connection ) : ctx . obj = Manager ( connection = connection ) ctx . obj . bind ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the Webserver / SocketIO and app [CODESPLIT] def run ( context , port ) : global ctx ctx = context app . run ( port = port )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Array of vector lengths [CODESPLIT] def length ( self ) : return np . sqrt ( np . sum ( self ** 2 , axis = 1 ) ) . view ( np . ndarray )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the total number of unmasked regular pixels in a masks . [CODESPLIT] def total_regular_pixels_from_mask ( mask ) : total_regular_pixels = 0 for y in range ( mask . shape [ 0 ] ) : for x in range ( mask . shape [ 1 ] ) : if not mask [ y , x ] : total_regular_pixels += 1 return total_regular_pixels", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Max reduction op . [CODESPLIT] def Max ( a , axis , keep_dims ) : return np . amax ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get line count of file [CODESPLIT] def line_count ( fn ) : with open ( fn ) as f : for i , l in enumerate ( f ) : pass return i + 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dictionary of words and word counts in a string . [CODESPLIT] def wordfreq ( text , is_filename = False ) : if is_filename : with open ( text ) as f : text = f . read ( ) freqs = { } for word in text . split ( ) : lword = word . lower ( ) freqs [ lword ] = freqs . get ( lword , 0 ) + 1 return freqs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of entries in a table by counting them . [CODESPLIT] def count_rows ( self , table_name ) : self . table_must_exist ( table_name ) query = \"SELECT COUNT (*) FROM `%s`\" % table_name . lower ( ) self . own_cursor . execute ( query ) return int ( self . own_cursor . fetchone ( ) [ 0 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "read the lines from a file into a list [CODESPLIT] def get_list_from_file ( file_name ) : with open ( file_name , mode = 'r' , encoding = 'utf-8' ) as f1 : lst = f1 . readlines ( ) return lst", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a temprorary file and writes the text into it [CODESPLIT] def make_temp ( text ) : import tempfile ( handle , path ) = tempfile . mkstemp ( text = True ) os . close ( handle ) afile = File ( path ) afile . write ( text ) return afile", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call this method from a function that defines a literal shader string as the body argument . Dresses up a shader string in three ways : 1 ) Insert #version at the top 2 ) Insert #line number declaration 3 ) un - indents The line number information can help debug glsl compile errors . The version string needs to be the very first characters in the shader which can be distracting requiring backslashes or other tricks . The unindenting allows you to type the shader code at a pleasing indent level in your python method while still creating an unindented GLSL string at the end . [CODESPLIT] def shader_string ( body , glsl_version = '450 core' ) : line_count = len ( body . split ( '\\n' ) ) line_number = inspect . currentframe ( ) . f_back . f_lineno + 1 - line_count return \"\"\"\\\n#version %s\n%s\n\"\"\" % ( glsl_version , shader_substring ( body , stack_frame = 2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Has a 50 / 50 chance of calling a function [CODESPLIT] def sometimesish ( fn ) : def wrapped ( * args , * * kwargs ) : if random . randint ( 1 , 2 ) == 1 : return fn ( * args , * * kwargs ) return wrapped", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute average gradient norm of an image [CODESPLIT] def average_gradient ( data , * kwargs ) : return np . average ( np . array ( np . gradient ( data ) ) ** 2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve path to locally installed conda Perl or first in PATH . [CODESPLIT] def perl_cmd ( ) : perl = which ( os . path . join ( get_bcbio_bin ( ) , \"perl\" ) ) if perl : return perl else : return which ( \"perl\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Put curly brackets round an indented text [CODESPLIT] def dumped ( text , level , indent = 2 ) : return indented ( \"{\\n%s\\n}\" % indented ( text , level + 1 , indent ) or \"None\" , level , indent ) + \"\\n\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pad a matrix with zeros on all sides . [CODESPLIT] def zero_pad ( m , n = 1 ) : return np . pad ( m , ( n , n ) , mode = 'constant' , constant_values = [ 0 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Chunk one big list into few small lists . [CODESPLIT] def chunked ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": return : a data frame with names and distinct counts and fractions for all columns in the database [CODESPLIT] def dcounts ( self ) : print ( \"WARNING: Distinct value count for all tables can take a long time...\" , file = sys . stderr ) sys . stderr . flush ( ) data = [ ] for t in self . tables ( ) : for c in t . columns ( ) : data . append ( [ t . name ( ) , c . name ( ) , c . dcount ( ) , t . size ( ) , c . dcount ( ) / float ( t . size ( ) ) ] ) df = pd . DataFrame ( data , columns = [ \"table\" , \"column\" , \"distinct\" , \"size\" , \"fraction\" ] ) return df", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a new dict with any empty items removed . [CODESPLIT] def _remove_empty_items ( d , required ) : new_dict = { } for k , v in d . items ( ) : if k in required : new_dict [ k ] = v elif isinstance ( v , int ) or v : # \"if v\" would suppress emitting int(0) new_dict [ k ] = v return new_dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "An interactive way to set the pan position . The location ( data_x data_y ) will be centered in the window . [CODESPLIT] def ms_panset ( self , viewer , event , data_x , data_y , msg = True ) : if self . canpan and ( event . state == 'down' ) : self . _panset ( viewer , data_x , data_y , msg = msg ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "disassemble Python byte - code file ( . pyc ) [CODESPLIT] def disassemble_file ( filename , outstream = None ) : filename = check_object_path ( filename ) ( version , timestamp , magic_int , co , is_pypy , source_size ) = load_module ( filename ) if type ( co ) == list : for con in co : disco ( version , con , outstream ) else : disco ( version , co , outstream , is_pypy = is_pypy ) co = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses dynamic programming to infer the location of spaces in a string without spaces . [CODESPLIT] def split ( s ) : l = [ _split ( x ) for x in _SPLIT_RE . split ( s ) ] return [ item for sublist in l for item in sublist ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Expands all environment variables in a settings dictionary . [CODESPLIT] def expandvars_dict ( settings ) : return dict ( ( key , os . path . expandvars ( value ) ) for key , value in settings . iteritems ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Bernstein polynomial . [CODESPLIT] def Bernstein ( n , k ) : coeff = binom ( n , k ) def _bpoly ( x ) : return coeff * x ** k * ( 1 - x ) ** ( n - k ) return _bpoly", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Instantiate the object from a protocol buffer . [CODESPLIT] def from_pb ( cls , pb ) : obj = cls . _from_pb ( pb ) obj . _pb = pb return obj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets the width of the table that would be printed . : rtype : int [CODESPLIT] def get_table_width ( table ) : columns = transpose_table ( prepare_rows ( table ) ) widths = [ max ( len ( cell ) for cell in column ) for column in columns ] return len ( '+' + '|' . join ( '-' * ( w + 2 ) for w in widths ) + '+' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Any normal python logic which runs a loop . Can take arguments . [CODESPLIT] def main ( idle ) : while True : LOG . debug ( \"Sleeping for {0} seconds.\" . format ( idle ) ) time . sleep ( idle )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts query strings into native Python objects [CODESPLIT] def urlencoded ( body , charset = 'ascii' , * * kwargs ) : return parse_query_string ( text ( body , charset = charset ) , False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "de - serialize a JSON - RPC Response / error [CODESPLIT] def _parse_single_response ( cls , response_data ) : if not isinstance ( response_data , dict ) : raise errors . RPCInvalidRequest ( \"No valid RPC-package.\" ) if \"id\" not in response_data : raise errors . RPCInvalidRequest ( \"\"\"Invalid Response, \"id\" missing.\"\"\" ) request_id = response_data [ 'id' ] if \"jsonrpc\" not in response_data : raise errors . RPCInvalidRequest ( \"\"\"Invalid Response, \"jsonrpc\" missing.\"\"\" , request_id ) if not isinstance ( response_data [ \"jsonrpc\" ] , ( str , unicode ) ) : raise errors . RPCInvalidRequest ( \"\"\"Invalid Response, \"jsonrpc\" must be a string.\"\"\" ) if response_data [ \"jsonrpc\" ] != \"2.0\" : raise errors . RPCInvalidRequest ( \"\"\"Invalid jsonrpc version.\"\"\" , request_id ) error = response_data . get ( 'error' , None ) result = response_data . get ( 'result' , None ) if error and result : raise errors . RPCInvalidRequest ( \"\"\"Invalid Response, only \"result\" OR \"error\" allowed.\"\"\" , request_id ) if error : if not isinstance ( error , dict ) : raise errors . RPCInvalidRequest ( \"Invalid Response, invalid error-object.\" , request_id ) if not ( \"code\" in error and \"message\" in error ) : raise errors . RPCInvalidRequest ( \"Invalid Response, invalid error-object.\" , request_id ) error_data = error . get ( \"data\" , None ) if error [ 'code' ] in errors . ERROR_CODE_CLASS_MAP : raise errors . ERROR_CODE_CLASS_MAP [ error [ 'code' ] ] ( error_data , request_id ) else : error_object = errors . RPCFault ( error_data , request_id ) error_object . error_code = error [ 'code' ] error_object . message = error [ 'message' ] raise error_object return result , request_id", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clear not used counters [CODESPLIT] def trim ( self ) : for key , value in list ( iteritems ( self . counters ) ) : if value . empty ( ) : del self . counters [ key ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "delete all the eggs in the directory specified [CODESPLIT] def delete_all_eggs ( self ) : path_to_delete = os . path . join ( self . egg_directory , \"lib\" , \"python\" ) if os . path . exists ( path_to_delete ) : shutil . rmtree ( path_to_delete )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return grandparent s path string [CODESPLIT] def grandparent_path ( self ) : return os . path . basename ( os . path . join ( self . path , '../..' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the default stream encoding if not found . [CODESPLIT] def get_best_encoding ( stream ) : rv = getattr ( stream , 'encoding' , None ) or sys . getdefaultencoding ( ) if is_ascii_encoding ( rv ) : return 'utf-8' return rv", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if the given extension is one of the watched extensions [CODESPLIT] def watched_extension ( extension ) : for ext in hamlpy . VALID_EXTENSIONS : if extension . endswith ( '.' + ext ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pause for this many seconds [CODESPLIT] def seconds ( num ) : now = pytime . time ( ) end = now + num until ( end )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "given a segment ( rectangle ) and an image returns it s corresponding subimage [CODESPLIT] def region_from_segment ( image , segment ) : x , y , w , h = segment return image [ y : y + h , x : x + w ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Unpickles the classifier used [CODESPLIT] def load ( self , filename = 'classifier.dump' ) : ifile = open ( filename , 'r+' ) self . classifier = pickle . load ( ifile ) ifile . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if an element from a list is in a string . [CODESPLIT] def isin ( elems , line ) : found = False for e in elems : if e in line . lower ( ) : found = True break return found", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts datetimeoffset object into Python s datetime . datetime object [CODESPLIT] def to_pydatetime ( self ) : dt = datetime . datetime . combine ( self . _date . to_pydate ( ) , self . _time . to_pytime ( ) ) from . tz import FixedOffsetTimezone return dt . replace ( tzinfo = _utc ) . astimezone ( FixedOffsetTimezone ( self . _offset ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handle resource management within an executable file . [CODESPLIT] def bundle_dir ( ) : if frozen ( ) : directory = sys . _MEIPASS else : directory = os . path . dirname ( os . path . abspath ( stack ( ) [ 1 ] [ 1 ] ) ) if os . path . exists ( directory ) : return directory", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a matplotlib colormap . [CODESPLIT] def add_matplotlib_cmap ( cm , name = None ) : global cmaps cmap = matplotlib_to_ginga_cmap ( cm , name = name ) cmaps [ cmap . name ] = cmap", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decision Tree [CODESPLIT] def human__decision_tree ( ) : # build data N = 1000000 M = 3 X = np . zeros ( ( N , M ) ) X . shape y = np . zeros ( N ) X [ 0 , 0 ] = 1 y [ 0 ] = 8 X [ 1 , 1 ] = 1 y [ 1 ] = 8 X [ 2 , 0 : 2 ] = 1 y [ 2 ] = 4 # fit model xor_model = sklearn . tree . DecisionTreeRegressor ( max_depth = 2 ) xor_model . fit ( X , y ) return xor_model", "target": 1, "target_options": ["no_match", "match"]}
{"input": "----- Brief ----- This functions computes the Fast Fourier Transform of a signal returning the frequency and magnitude values . [CODESPLIT] def plotfft ( s , fmax , doplot = False ) : fs = abs ( numpy . fft . fft ( s ) ) f = numpy . linspace ( 0 , fmax / 2 , len ( s ) / 2 ) if doplot : plot ( list ( f [ 1 : int ( len ( s ) / 2 ) ] ) , list ( fs [ 1 : int ( len ( s ) / 2 ) ] ) ) return f [ 1 : int ( len ( s ) / 2 ) ] . copy ( ) , fs [ 1 : int ( len ( s ) / 2 ) ] . copy ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "computes factorial of n [CODESPLIT] def computeFactorial ( n ) : sleep_walk ( 10 ) ret = 1 for i in range ( n ) : ret = ret * ( i + 1 ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return string as a comment [CODESPLIT] def _comment ( string ) : lines = [ line . strip ( ) for line in string . splitlines ( ) ] return \"# \" + ( \"%s# \" % linesep ) . join ( lines )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs SQL against the project s database . [CODESPLIT] def psql ( sql , show = True ) : out = postgres ( 'psql -c \"%s\"' % sql ) if show : print_command ( sql ) return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Download a file from url to filename . [CODESPLIT] def download_url ( url , filename , headers ) : ensure_dirs ( filename ) response = requests . get ( url , headers = headers , stream = True ) if response . status_code == 200 : with open ( filename , 'wb' ) as f : for chunk in response . iter_content ( 16 * 1024 ) : f . write ( chunk )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns all rows from a cursor as a dict ( rather than a headerless table ) [CODESPLIT] def dictfetchall ( cursor ) : desc = cursor . description return [ dict ( zip ( [ col [ 0 ] for col in desc ] , row ) ) for row in cursor . fetchall ( ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r A function to support exiting from exit hooks . [CODESPLIT] def exit ( exit_code = 0 ) : core . processExitHooks ( ) if state . isExitHooked and not hasattr ( sys , 'exitfunc' ) : # The function is called from the exit hook sys . stderr . flush ( ) sys . stdout . flush ( ) os . _exit ( exit_code ) #pylint: disable=W0212 sys . exit ( exit_code )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Destroy the SQLStepQueue tables in the database [CODESPLIT] def destroy ( self ) : with self . _db_conn ( ) as conn : for table_name in self . _tables : conn . execute ( 'DROP TABLE IF EXISTS %s' % table_name ) return self", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Performs an automatic prediction for the specified machine and returns the predicted values . [CODESPLIT] def _do_auto_predict ( machine , X , * args ) : if auto_predict and hasattr ( machine , \"predict\" ) : return machine . predict ( X )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Can edit this object [CODESPLIT] def has_edit_permission ( self , request ) : return request . user . is_authenticated and request . user . is_active and request . user . is_staff", "target": 1, "target_options": ["no_match", "match"]}
{"input": "shows JSON indented representation of d [CODESPLIT] def pretty_dict_str ( d , indent = 2 ) : b = StringIO ( ) write_pretty_dict_str ( b , d , indent = indent ) return b . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a prettier version of obj [CODESPLIT] def _get_pretty_string ( obj ) : sio = StringIO ( ) pprint . pprint ( obj , stream = sio ) return sio . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a prettier version of obj [CODESPLIT] def _get_pretty_string ( obj ) : sio = StringIO ( ) pprint . pprint ( obj , stream = sio ) return sio . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Directly send utf8 bytes to stdout [CODESPLIT] def imp_print ( self , text , end ) : sys . stdout . write ( ( text + end ) . encode ( \"utf-8\" ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param sequence : Any sequence whose elements can be evaluated as booleans . : returns : true if all elements of the sequence satisfy True and x . [CODESPLIT] def All ( sequence ) : return bool ( reduce ( lambda x , y : x and y , sequence , True ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return only the part of the row which should be printed . [CODESPLIT] def _get_printable_columns ( columns , row ) : if not columns : return row # Extract the column values, in the order specified. return tuple ( row [ c ] for c in columns )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "print just one that returns what you give it instead of None [CODESPLIT] def print ( * a ) : try : _print ( * a ) return a [ 0 ] if len ( a ) == 1 else a except : _print ( * a )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "quit crash [CODESPLIT] def _quit ( self , * args ) : self . logger . warn ( 'Bye!' ) sys . exit ( self . exit ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If output is string then print the string and also time used [CODESPLIT] def timeit ( output ) : b = time . time ( ) yield print output , 'time used: %.3fs' % ( time . time ( ) - b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Formats timestamp to human readable format [CODESPLIT] def format_time ( timestamp ) : format_string = '%Y_%m_%d_%Hh%Mm%Ss' formatted_time = datetime . datetime . fromtimestamp ( timestamp ) . strftime ( format_string ) return formatted_time", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print msg to stdout and option log at info level . [CODESPLIT] def pout ( msg , log = None ) : _print ( msg , sys . stdout , log_func = log . info if log else None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "print_tree : prints out structure of tree Args : indent ( int ) : What level of indentation at which to start printing Returns : None [CODESPLIT] def print_tree ( self , indent = 2 ) : config . LOGGER . info ( \"{indent}{data}\" . format ( indent = \"   \" * indent , data = str ( self ) ) ) for child in self . children : child . print_tree ( indent + 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "mono - exponential curve . [CODESPLIT] def algo_exp ( x , m , t , b ) : return m * np . exp ( - t * x ) + b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterative flatten . [CODESPLIT] def iflatten ( L ) : for sublist in L : if hasattr ( sublist , '__iter__' ) : for item in iflatten ( sublist ) : yield item else : yield sublist", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flip an image horizontally or vertically . [CODESPLIT] def imflip ( img , direction = 'horizontal' ) : assert direction in [ 'horizontal' , 'vertical' ] if direction == 'horizontal' : return np . flip ( img , axis = 1 ) else : return np . flip ( img , axis = 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Builds sphinx docs from a given directory . [CODESPLIT] def build_docs ( directory ) : os . chdir ( directory ) process = subprocess . Popen ( [ \"make\" , \"html\" ] , cwd = directory ) process . communicate ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write a chunk to file and update the progress bar [CODESPLIT] def _chunk_write ( chunk , local_file , progress ) : local_file . write ( chunk ) progress . update_with_increment_value ( len ( chunk ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "* Get the root path for this python package - used in unit testing code * [CODESPLIT] def getpackagepath ( ) : moduleDirectory = os . path . dirname ( __file__ ) packagePath = os . path . dirname ( __file__ ) + \"/../\" return packagePath", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flushes the prompt before requesting the input [CODESPLIT] def _normal_prompt ( self ) : sys . stdout . write ( self . __get_ps1 ( ) ) sys . stdout . flush ( ) return safe_input ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shortcut to create md5 hash : param s : : return : [CODESPLIT] def md5_string ( s ) : m = hashlib . md5 ( ) m . update ( s ) return str ( m . hexdigest ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def write_only_property ( f ) : docstring = f . __doc__ return property ( fset = f , doc = docstring )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse a string into a Message object model . [CODESPLIT] def message_from_string ( s , * args , * * kws ) : from future . backports . email . parser import Parser return Parser ( * args , * * kws ) . parsestr ( s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a random ( i . e . unique ) string identifier [CODESPLIT] def _get_random_id ( ) : symbols = string . ascii_uppercase + string . ascii_lowercase + string . digits return '' . join ( random . choice ( symbols ) for _ in range ( 15 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "add arrow to plot [CODESPLIT] def add_arrow ( self , x1 , y1 , x2 , y2 , * * kws ) : self . panel . add_arrow ( x1 , y1 , x2 , y2 , * * kws )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a percentile range from an array of values . [CODESPLIT] def ci ( a , which = 95 , axis = None ) : p = 50 - which / 2 , 50 + which / 2 return percentiles ( a , p , axis )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a string with the callable signature and its docstring . [CODESPLIT] def get_callable_documentation ( the_callable ) : return wrap_text_in_a_box ( title = get_callable_signature_as_string ( the_callable ) , body = ( getattr ( the_callable , '__doc__' ) or 'No documentation' ) . replace ( '\\n' , '\\n\\n' ) , style = 'ascii_double' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse string into Identity dictionary . [CODESPLIT] def string_to_identity ( identity_str ) : m = _identity_regexp . match ( identity_str ) result = m . groupdict ( ) log . debug ( 'parsed identity: %s' , result ) return { k : v for k , v in result . items ( ) if v }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The main ( cli ) interface for the pylint runner . [CODESPLIT] def main ( output = None , error = None , verbose = False ) : runner = Runner ( args = [ \"--verbose\" ] if verbose is not False else None ) runner . run ( output , error )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates one element of the collection [CODESPLIT] def update_one ( self , query , doc ) : if self . table is None : self . build_table ( ) if u\"$set\" in doc : doc = doc [ u\"$set\" ] allcond = self . parse_query ( query ) try : result = self . table . update ( doc , allcond ) except : # TODO: check table.update result # check what pymongo does in that case result = None return UpdateResult ( raw_result = result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Composes multiple modification functions in order . [CODESPLIT] def compose ( * parameter_functions ) : def composed_fn ( var_name , variable , phase ) : for fn in parameter_functions : variable = fn ( var_name , variable , phase ) return variable return composed_fn", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns all files in a given directory [CODESPLIT] def list_files ( directory ) : return [ f for f in pathlib . Path ( directory ) . iterdir ( ) if f . is_file ( ) and not f . name . startswith ( '.' ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the final coverage report . This outputs the coverage report aggregating coverage from the unit test runs ( not system test runs ) and then erases coverage data . [CODESPLIT] def cover ( session ) : session . interpreter = 'python3.6' session . install ( 'coverage' , 'pytest-cov' ) session . run ( 'coverage' , 'report' , '--show-missing' , '--fail-under=100' ) session . run ( 'coverage' , 'erase' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Invoke pytest replacing argv . Return result code . [CODESPLIT] def run_tests ( self ) : with _save_argv ( _sys . argv [ : 1 ] + self . addopts ) : result_code = __import__ ( 'pytest' ) . main ( ) if result_code : raise SystemExit ( result_code )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pure - Python implementation of itertools . combinations ( l 2 ) . [CODESPLIT] def combinations ( l ) : result = [ ] for x in xrange ( len ( l ) - 1 ) : ls = l [ x + 1 : ] for y in ls : result . append ( ( l [ x ] , y ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "BBox [CODESPLIT] def bbox ( self ) : return self . left , self . top , self . right , self . bottom", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieves and removes the first task from the heap . [CODESPLIT] def PopTask ( self ) : try : _ , task = heapq . heappop ( self . _heap ) except IndexError : return None self . _task_identifiers . remove ( task . identifier ) return task", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns an ExpMatrix containing all pairwise sample correlations . [CODESPLIT] def sample_correlations ( self ) : C = np . corrcoef ( self . X . T ) corr_matrix = ExpMatrix ( genes = self . samples , samples = self . samples , X = C ) return corr_matrix", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a temporary filename based on filename . [CODESPLIT] def get_incomplete_path ( filename ) : random_suffix = \"\" . join ( random . choice ( string . ascii_uppercase + string . digits ) for _ in range ( 6 ) ) return filename + \".incomplete\" + random_suffix", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the shape of the dataset as ( rows cols ) . [CODESPLIT] def shape ( self ) : if not self . data : return ( 0 , 0 ) return ( len ( self . data ) , len ( self . dimensions ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns file name of file at given url . [CODESPLIT] def get_file_name ( url ) : return os . path . basename ( urllib . parse . urlparse ( url ) . path ) or 'unknown_name'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return random lognormal variates . [CODESPLIT] def rlognormal ( mu , tau , size = None ) : return np . random . lognormal ( mu , np . sqrt ( 1. / tau ) , size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a kafka cluster configuration return the number of partitions in the offset topic . It will raise an UnknownTopic exception if the topic cannot be found . [CODESPLIT] def get_offset_topic_partition_count ( kafka_config ) : metadata = get_topic_partition_metadata ( kafka_config . broker_list ) if CONSUMER_OFFSET_TOPIC not in metadata : raise UnknownTopic ( \"Consumer offset topic is missing.\" ) return len ( metadata [ CONSUMER_OFFSET_TOPIC ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to get the location of a Python file . [CODESPLIT] def getScriptLocation ( ) : location = os . path . abspath ( \"./\" ) if __file__ . rfind ( \"/\" ) != - 1 : location = __file__ [ : __file__ . rfind ( \"/\" ) ] return location", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return possible range for max function . [CODESPLIT] def max_values ( args ) : return Interval ( max ( x . low for x in args ) , max ( x . high for x in args ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a camelCased string and converts to snake_case . [CODESPLIT] def camel_to_snake_case ( name ) : pattern = r'[A-Z][a-z]+|[A-Z]+(?![a-z])' return '_' . join ( map ( str . lower , re . findall ( pattern , name ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the given code line by line with printing as list of lines and return variable ans . [CODESPLIT] def runcode ( code ) : for line in code : print ( '# ' + line ) exec ( line , globals ( ) ) print ( '# return ans' ) return ans", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read tag data from file and return as unicode string . [CODESPLIT] def read_utf8 ( fh , byteorder , dtype , count , offsetsize ) : return fh . read ( count ) . decode ( 'utf-8' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "internal helper function to run shell commands and get output [CODESPLIT] def run_cmd ( command , verbose = True , shell = '/bin/bash' ) : process = Popen ( command , shell = True , stdout = PIPE , stderr = STDOUT , executable = shell ) output = process . stdout . read ( ) . decode ( ) . strip ( ) . split ( '\\n' ) if verbose : # return full output including empty lines return output return [ line for line in output if line . strip ( ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace all the ocurrences ( in a file ) of a string with another value . [CODESPLIT] def replace_all ( filepath , searchExp , replaceExp ) : for line in fileinput . input ( filepath , inplace = 1 ) : if searchExp in line : line = line . replace ( searchExp , replaceExp ) sys . stdout . write ( line )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Imports from javascript source file . globals is your globals () [CODESPLIT] def import_js ( path , lib_name , globals ) : with codecs . open ( path_as_local ( path ) , \"r\" , \"utf-8\" ) as f : js = f . read ( ) e = EvalJs ( ) e . execute ( js ) var = e . context [ 'var' ] globals [ lib_name ] = var . to_python ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a file into a string PRE : fname is a small file ( to avoid hogging memory and its discontents ) [CODESPLIT] def file_to_str ( fname ) : data = None # rU = read with Universal line terminator with open ( fname , 'rU' ) as fd : data = fd . read ( ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deserializes Java objects and primitive data serialized by ObjectOutputStream from a string . [CODESPLIT] def loads ( string ) : f = StringIO . StringIO ( string ) marshaller = JavaObjectUnmarshaller ( f ) marshaller . add_transformer ( DefaultObjectTransformer ( ) ) return marshaller . readObject ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs a shell command returns console output . [CODESPLIT] def _run_cmd_get_output ( cmd ) : process = subprocess . Popen ( cmd . split ( ) , stdout = subprocess . PIPE ) out , err = process . communicate ( ) return out or err", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate size of all files in path . [CODESPLIT] def _calc_dir_size ( path ) : dir_size = 0 for ( root , dirs , files ) in os . walk ( path ) : for fn in files : full_fn = os . path . join ( root , fn ) dir_size += os . path . getsize ( full_fn ) return dir_size", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generator that yields lines from standard input . [CODESPLIT] def standard_input ( ) : with click . get_text_stream ( \"stdin\" ) as stdin : while stdin . readable ( ) : line = stdin . readline ( ) if line : yield line . strip ( ) . encode ( \"utf-8\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get string from file . [CODESPLIT] def get_file_string ( filepath ) : with open ( os . path . abspath ( filepath ) ) as f : return f . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert camelcase to lowercase and underscore . [CODESPLIT] def camel_to_underscore ( string ) : string = FIRST_CAP_RE . sub ( r'\\1_\\2' , string ) return ALL_CAP_RE . sub ( r'\\1_\\2' , string ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the eigvals of mat and then find the center eigval difference . [CODESPLIT] def center_eigenvalue_diff ( mat ) : N = len ( mat ) evals = np . sort ( la . eigvals ( mat ) ) diff = np . abs ( evals [ N / 2 ] - evals [ N / 2 - 1 ] ) return diff", "target": 1, "target_options": ["no_match", "match"]}
{"input": "dict . update but which merges child dicts ( dict2 takes precedence where there s conflict ) . [CODESPLIT] def recursively_update ( d , d2 ) : for k , v in d2 . items ( ) : if k in d : if isinstance ( v , dict ) : recursively_update ( d [ k ] , v ) continue d [ k ] = v", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute entropy on the string [CODESPLIT] def entropy ( string ) : p , lns = Counter ( string ) , float ( len ( string ) ) return - sum ( count / lns * math . log ( count / lns , 2 ) for count in p . values ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Connect to a redis instance . [CODESPLIT] def __connect ( ) : global redis_instance if use_tcp_socket : redis_instance = redis . StrictRedis ( host = hostname , port = port ) else : redis_instance = redis . StrictRedis ( unix_socket_path = unix_socket )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all matches in an input string . : rtype : regex . match . span : param _regex : A regular expression pattern . : param _str : Text on which to run the pattern . [CODESPLIT] def _regex_span ( _regex , _str , case_insensitive = True ) : if case_insensitive : flags = regex . IGNORECASE | regex . FULLCASE | regex . VERSION1 else : flags = regex . VERSION1 comp = regex . compile ( _regex , flags = flags ) matches = comp . finditer ( _str ) for match in matches : yield match", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if * key * is present else False . [CODESPLIT] def __contains__ ( self , key ) : pickled_key = self . _pickle_key ( key ) return bool ( self . redis . hexists ( self . key , pickled_key ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Gets the string representation of the given type . [CODESPLIT] def getTypeStr ( _type ) : if isinstance ( _type , CustomType ) : return str ( _type ) if hasattr ( _type , '__name__' ) : return _type . __name__ return ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": see :: meth : RedisMap . keys [CODESPLIT] def values ( self ) : for val in self . _client . hvals ( self . key_prefix ) : yield self . _loads ( val )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an instance of RedisSet . [CODESPLIT] def get_instance ( key , expire = None ) : global _instances try : instance = _instances [ key ] except KeyError : instance = RedisSet ( key , _redis , expire = expire ) _instances [ key ] = instance return instance", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": see :: meth : RedisMap . __setitem__ [CODESPLIT] def __setitem__ ( self , field , value ) : return self . _client . hset ( self . key_prefix , field , self . _dumps ( value ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the week start date and end date [CODESPLIT] def get_week_start_end_day ( ) : t = date . today ( ) wd = t . weekday ( ) return ( t - timedelta ( wd ) , t + timedelta ( 6 - wd ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a stringified representation of this object . [CODESPLIT] def __repr__ ( self ) : return str ( { 'name' : self . _name , 'watts' : self . _watts , 'type' : self . _output_type , 'id' : self . _integration_id } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wraps the given dictionary such that the given fallback function will be called when a nonexistent key is accessed . [CODESPLIT] def _defaultdict ( dct , fallback = _illegal_character ) : out = defaultdict ( lambda : fallback ) for k , v in six . iteritems ( dct ) : out [ k ] = v return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip apostrophe and s from the end of a string . [CODESPLIT] def unapostrophe ( text ) : text = re . sub ( r'[%s]s?$' % '' . join ( APOSTROPHES ) , '' , text ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validate input data . [CODESPLIT] def _validate_input_data ( self , data , request ) : validator = self . _get_input_validator ( request ) if isinstance ( data , ( list , tuple ) ) : return map ( validator . validate , data ) else : return validator . validate ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test whether text contains string or matches regex . [CODESPLIT] def ismatch ( text , pattern ) : if hasattr ( pattern , 'search' ) : return pattern . search ( text ) is not None else : return pattern in text if Config . options . case_sensitive else pattern . lower ( ) in text . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extracts all integers from a string an return them in a list [CODESPLIT] def get_numbers ( s ) : result = map ( int , re . findall ( r'[0-9]+' , unicode ( s ) ) ) return result + [ 1 ] * ( 2 - len ( result ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a camelCased string and converts to snake_case . [CODESPLIT] def camel_to_snake_case ( name ) : pattern = r'[A-Z][a-z]+|[A-Z]+(?![a-z])' return '_' . join ( map ( str . lower , re . findall ( pattern , name ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a leading hash # at the beginning of every line in the source . [CODESPLIT] def _add_hash ( source ) : source = '\\n' . join ( '# ' + line . rstrip ( ) for line in source . splitlines ( ) ) return source", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find a number using a given regular expression . If the string cannot be found returns None . The regex should contain one matching group as only the result of the first group is returned . The group should only contain numeric characters ( [ 0 - 9 ] + ) . s - The string to search . regex - A string containing the regular expression . Returns an integer or None . [CODESPLIT] def find_number ( regex , s ) : result = find_string ( regex , s ) if result is None : return None return int ( result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Close the db and release memory [CODESPLIT] def close ( self ) : if self . db is not None : self . db . commit ( ) self . db . close ( ) self . db = None return", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip # markers at the front of a block of comment text . [CODESPLIT] def strip_comment_marker ( text ) : lines = [ ] for line in text . splitlines ( ) : lines . append ( line . lstrip ( '#' ) ) text = textwrap . dedent ( '\\n' . join ( lines ) ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Filter the dict * d * to remove keys not in * keys * . [CODESPLIT] def filter_dict_by_key ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip generated files that are only present in source distributions . [CODESPLIT] def strip_sdist_extras ( filelist ) : return [ name for name in filelist if not file_matches ( name , IGNORE ) and not file_matches_regexps ( name , IGNORE_REGEXPS ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute all tests ( normal and slow ) with coverage enabled . [CODESPLIT] def coverage ( ctx , opts = \"\" ) : return test ( ctx , coverage = True , include_slow = True , opts = opts )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes trailing zeros in the list of integers and returns a new list of integers [CODESPLIT] def _remove_blank ( l ) : ret = [ ] for i , _ in enumerate ( l ) : if l [ i ] == 0 : break ret . append ( l [ i ] ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove punctuation from string s . [CODESPLIT] def unpunctuate ( s , * , char_blacklist = string . punctuation ) : # remove punctuation s = \"\" . join ( c for c in s if c not in char_blacklist ) # remove consecutive spaces return \" \" . join ( filter ( None , s . split ( \" \" ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cosine interpolation [CODESPLIT] def interpolate_logscale_single ( start , end , coefficient ) : return np . exp ( np . log ( start ) + ( np . log ( end ) - np . log ( start ) ) * coefficient )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flushes the prompt before requesting the input [CODESPLIT] def _normal_prompt ( self ) : sys . stdout . write ( self . __get_ps1 ( ) ) sys . stdout . flush ( ) return safe_input ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a comma separated string to a list [CODESPLIT] def _str_to_list ( s ) : _list = s . split ( \",\" ) return list ( map ( lambda i : i . lstrip ( ) , _list ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Constrain numbers to ( 0 1 ) interval [CODESPLIT] def open01 ( x , limit = 1.e-6 ) : try : return np . array ( [ min ( max ( y , limit ) , 1. - limit ) for y in x ] ) except TypeError : return min ( max ( x , limit ) , 1. - limit )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove key from dict and return value . [CODESPLIT] def pop ( self , key ) : if key in self . _keys : self . _keys . remove ( key ) super ( ListDict , self ) . pop ( key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes dict keys which have have self as value . [CODESPLIT] def _remove_dict_keys_with_value ( dict_ , val ) : return { k : v for k , v in dict_ . items ( ) if v is not val }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply the coefficients from a linear fit to an array of x y positions . [CODESPLIT] def apply_fit ( xy , coeffs ) : x_new = coeffs [ 0 ] [ 2 ] + coeffs [ 0 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 0 ] [ 1 ] * xy [ : , 1 ] y_new = coeffs [ 1 ] [ 2 ] + coeffs [ 1 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 1 ] [ 1 ] * xy [ : , 1 ] return x_new , y_new", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes all . py files . [CODESPLIT] def clean_py_files ( path ) : for dirname , subdirlist , filelist in os . walk ( path ) : for f in filelist : if f . endswith ( 'py' ) : os . remove ( os . path . join ( dirname , f ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list of plottable CBC parameter variables [CODESPLIT] def get_param_names ( cls ) : return [ m [ 0 ] for m in inspect . getmembers ( cls ) if type ( m [ 1 ] ) == property ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load graph as defined by a DOT file . The file is assumed to be in DOT format . It will be loaded parsed and a Dot class will be returned representing the graph . [CODESPLIT] def graph_from_dot_file ( path ) : fd = file ( path , 'rb' ) data = fd . read ( ) fd . close ( ) return graph_from_dot_data ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pop the heap value from the heap . [CODESPLIT] def pop ( h ) : n = h . size ( ) - 1 h . swap ( 0 , n ) down ( h , 0 , n ) return h . pop ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove legend for axes or gca . [CODESPLIT] def remove_legend ( ax = None ) : from pylab import gca , draw if ax is None : ax = gca ( ) ax . legend_ = None draw ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "There s probably a way to do this with string functions but I was lazy . Replace all instances of \\ r or \\ n in a string with something else . [CODESPLIT] def replaceNewlines ( string , newlineChar ) : if newlineChar in string : segments = string . split ( newlineChar ) string = \"\" for segment in segments : string += segment return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Provides hook for Python2 iterator functionality . [CODESPLIT] def next ( self ) : _LOGGER . debug ( \"reading next\" ) if self . closed : _LOGGER . debug ( \"stream is closed\" ) raise StopIteration ( ) line = self . readline ( ) if not line : _LOGGER . debug ( \"nothing more to read\" ) raise StopIteration ( ) return line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add dots . [CODESPLIT] def _dotify ( cls , data ) : return '' . join ( char if char in cls . PRINTABLE_DATA else '.' for char in data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove all unwanted characters from text . [CODESPLIT] def clean ( self , text ) : return '' . join ( [ c for c in text if c in self . alphabet ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "============================================================= Demo of the histogram ( hist ) function with multiple data sets ============================================================= [CODESPLIT] def PyplotHistogram ( ) : import numpy as np import matplotlib . pyplot as plt np . random . seed ( 0 ) n_bins = 10 x = np . random . randn ( 1000 , 3 ) fig , axes = plt . subplots ( nrows = 2 , ncols = 2 ) ax0 , ax1 , ax2 , ax3 = axes . flatten ( ) colors = [ 'red' , 'tan' , 'lime' ] ax0 . hist ( x , n_bins , normed = 1 , histtype = 'bar' , color = colors , label = colors ) ax0 . legend ( prop = { 'size' : 10 } ) ax0 . set_title ( 'bars with legend' ) ax1 . hist ( x , n_bins , normed = 1 , histtype = 'bar' , stacked = True ) ax1 . set_title ( 'stacked bar' ) ax2 . hist ( x , n_bins , histtype = 'step' , stacked = True , fill = False ) ax2 . set_title ( 'stack step (unfilled)' ) # Make a multiple-histogram of data-sets with different length. x_multi = [ np . random . randn ( n ) for n in [ 10000 , 5000 , 2000 ] ] ax3 . hist ( x_multi , n_bins , histtype = 'bar' ) ax3 . set_title ( 'different sample sizes' ) fig . tight_layout ( ) return fig", "target": 1, "target_options": ["no_match", "match"]}
{"input": "why is this not in heapq [CODESPLIT] def _heappush_max ( heap , item ) : heap . append ( item ) heapq . _siftdown_max ( heap , 0 , len ( heap ) - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "copy the dict filter_keywords [CODESPLIT] def _remove_keywords ( d ) : return { k : v for k , v in iteritems ( d ) if k not in RESERVED }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Places all the child widgets in the appropriate positions . [CODESPLIT] def __grid_widgets ( self ) : scrollbar_column = 0 if self . __compound is tk . LEFT else 2 self . _canvas . grid ( row = 0 , column = 1 , sticky = \"nswe\" ) self . _scrollbar . grid ( row = 0 , column = scrollbar_column , sticky = \"ns\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Undoes the effects of the escape () function . [CODESPLIT] def unescape ( str ) : out = '' prev_backslash = False for char in str : if not prev_backslash and char == '\\\\' : prev_backslash = True continue out += char prev_backslash = False return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "replace nan in a by val and returns the replaced array and the nan position [CODESPLIT] def _replace_nan ( a , val ) : mask = isnull ( a ) return where_method ( val , mask , a ) , mask", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap vertical table in a function for TabularOutputFormatter . [CODESPLIT] def adapter ( data , headers , * * kwargs ) : keys = ( 'sep_title' , 'sep_character' , 'sep_length' ) return vertical_table ( data , headers , * * filter_dict_by_key ( kwargs , keys ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generates and returns a numpy array from raw data bytes . [CODESPLIT] def _arrayFromBytes ( dataBytes , metadata ) : array = numpy . fromstring ( dataBytes , dtype = numpy . typeDict [ metadata [ 'dtype' ] ] ) if 'shape' in metadata : array = array . reshape ( metadata [ 'shape' ] ) return array", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return matrix as csv data . [CODESPLIT] def csv_matrix_print ( classes , table ) : result = \"\" classes . sort ( ) for i in classes : for j in classes : result += str ( table [ i ] [ j ] ) + \",\" result = result [ : - 1 ] + \"\\n\" return result [ : - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Suppress warning about untrusted SSL certificate . [CODESPLIT] def disable_insecure_request_warning ( ) : import requests from requests . packages . urllib3 . exceptions import InsecureRequestWarning requests . packages . urllib3 . disable_warnings ( InsecureRequestWarning )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Called by remote workers . Useful to populate main module globals () for interactive shells . Retrieves the serialized function . [CODESPLIT] def getFunction ( self ) : return functionFactory ( self . code , self . name , self . defaults , self . globals , self . imports , )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Login user for protected API calls . [CODESPLIT] def login ( self , username , password = None , token = None ) : self . session . basic_auth ( username , password )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param string s : under_scored string to be CamelCased : return : CamelCase version of input : rtype : str [CODESPLIT] def to_camel ( s ) : # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups return re . sub ( r'_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , '_' + s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reset all parameters to their default values . [CODESPLIT] def reset_params ( self ) : self . __params = dict ( [ p , None ] for p in self . param_names ) self . set_params ( self . param_defaults )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function executes the request with the provided json payload and return the json response [CODESPLIT] def make_post_request ( self , url , auth , json_payload ) : response = requests . post ( url , auth = auth , json = json_payload ) return response . json ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reshape a multidimensional array to a vector . [CODESPLIT] def arr_to_vector ( arr ) : dim = array_dim ( arr ) tmp_arr = [ ] for n in range ( len ( dim ) - 1 ) : for inner in arr : for i in inner : tmp_arr . append ( i ) arr = tmp_arr tmp_arr = [ ] return arr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "swap and then flatten axes 0 and 1 [CODESPLIT] def sf01 ( arr ) : s = arr . shape return arr . swapaxes ( 0 , 1 ) . reshape ( s [ 0 ] * s [ 1 ] , * s [ 2 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list where the duplicates have been removed . [CODESPLIT] def distinct ( l ) : seen = set ( ) seen_add = seen . add return ( _ for _ in l if not ( _ in seen or seen_add ( _ ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clean function to know how much time took the execution of one statement [CODESPLIT] def print_result_from_timeit ( stmt = 'pass' , setup = 'pass' , number = 1000000 ) : units = [ \"s\" , \"ms\" , \"us\" , \"ns\" ] duration = timeit ( stmt , setup , number = int ( number ) ) avg_duration = duration / float ( number ) thousands = int ( math . floor ( math . log ( avg_duration , 1000 ) ) ) print ( \"Total time: %fs. Average run: %.3f%s.\" % ( duration , avg_duration * ( 1000 ** - thousands ) , units [ - thousands ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function for running binary search on a sorted list . [CODESPLIT] def binSearch ( arr , val ) : i = bisect_left ( arr , val ) if i != len ( arr ) and arr [ i ] == val : return i return - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "if the value is in the list move it to the front and return it . [CODESPLIT] def list_move_to_front ( l , value = 'other' ) : l = list ( l ) if value in l : l . remove ( value ) l . insert ( 0 , value ) return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "For a given value the function finds the nearest value in the array and returns its index . [CODESPLIT] def find_nearest_index ( arr , value ) : arr = np . array ( arr ) index = ( abs ( arr - value ) ) . argmin ( ) return index", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the index of the closest in xarr to value val [CODESPLIT] def closest ( xarr , val ) : idx_closest = np . argmin ( np . abs ( np . array ( xarr ) - val ) ) return idx_closest", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalizes the given vector . The vector given may have any number of dimensions . [CODESPLIT] def v_normalize ( v ) : vmag = v_magnitude ( v ) return [ v [ i ] / vmag for i in range ( len ( v ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load the state from the given file moving to the file s directory during load ( temporarily moving back after loaded ) [CODESPLIT] def load ( filename ) : path , name = os . path . split ( filename ) path = path or '.' with util . indir ( path ) : return pickle . load ( open ( name , 'rb' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def rotation_matrix ( sigma ) : radians = sigma * np . pi / 180.0 r11 = np . cos ( radians ) r12 = - np . sin ( radians ) r21 = np . sin ( radians ) r22 = np . cos ( radians ) R = np . array ( [ [ r11 , r12 ] , [ r21 , r22 ] ] ) return R", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read the contents of a file [CODESPLIT] def readme ( filename , encoding = 'utf8' ) : with io . open ( filename , encoding = encoding ) as source : return source . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a file descriptor for a plain text or gzipped file binary read mode for subprocess interaction . [CODESPLIT] def bin_open ( fname : str ) : if fname . endswith ( \".gz\" ) : return gzip . open ( fname , \"rb\" ) return open ( fname , \"rb\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns json format for symbol [CODESPLIT] def jsonify ( symbol ) : try : # all symbols have a toJson method, try it return json . dumps ( symbol . toJson ( ) , indent = '  ' ) except AttributeError : pass return json . dumps ( symbol , indent = '  ' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a new image by copying the image on a * color * background . [CODESPLIT] def copy_image_on_background ( image , color = WHITE ) : background = Image . new ( \"RGB\" , image . size , color ) background . paste ( image , mask = image . split ( ) [ 3 ] ) return background", "target": 1, "target_options": ["no_match", "match"]}
{"input": "swap and then flatten axes 0 and 1 [CODESPLIT] def sf01 ( arr ) : s = arr . shape return arr . swapaxes ( 0 , 1 ) . reshape ( s [ 0 ] * s [ 1 ] , * s [ 2 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Console to STDOUT [CODESPLIT] def pstd ( self , * args , * * kwargs ) : kwargs [ 'file' ] = self . out self . print ( * args , * * kwargs ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove a file from an AWS S3 bucket . [CODESPLIT] def remove_file_from_s3 ( awsclient , bucket , key ) : client_s3 = awsclient . get_client ( 's3' ) response = client_s3 . delete_object ( Bucket = bucket , Key = key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Args : img ( PIL Image ) : Image to be padded . [CODESPLIT] def __call__ ( self , img ) : return F . pad ( img , self . padding , self . fill , self . padding_mode )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "converts a base64 string to a file [CODESPLIT] def base64ToImage ( imgData , out_path , out_file ) : fh = open ( os . path . join ( out_path , out_file ) , \"wb\" ) fh . write ( imgData . decode ( 'base64' ) ) fh . close ( ) del fh return os . path . join ( out_path , out_file )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strips a figure into multiple figures with a trace on each of them [CODESPLIT] def strip_figures ( figure ) : fig = [ ] for trace in figure [ 'data' ] : fig . append ( dict ( data = [ trace ] , layout = figure [ 'layout' ] ) ) return fig", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Draw a graph and save it into a file [CODESPLIT] def draw ( graph , fname ) : ag = networkx . nx_agraph . to_agraph ( graph ) ag . draw ( fname , prog = 'dot' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "prints the top n lines of a file [CODESPLIT] def head ( filename , n = 10 ) : with freader ( filename ) as fr : for _ in range ( n ) : print ( fr . readline ( ) . strip ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the underlying PySLLSocket object with which the C extension functions interface . [CODESPLIT] def _sslobj ( sock ) : pass if isinstance ( sock . _sslobj , _ssl . _SSLSocket ) : return sock . _sslobj else : return sock . _sslobj . _sslobj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Copy docstring from existing object to the decorated callable . [CODESPLIT] def see_doc ( obj_with_doc ) : def decorator ( fn ) : fn . __doc__ = obj_with_doc . __doc__ return fn return decorator", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a scatter plot . [CODESPLIT] def scatter ( self , * args , * * kwargs ) : cls = _make_class ( ScatterVisual , _default_marker = kwargs . pop ( 'marker' , None ) , ) return self . _add_item ( cls , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return matrix as csv data . [CODESPLIT] def csv_matrix_print ( classes , table ) : result = \"\" classes . sort ( ) for i in classes : for j in classes : result += str ( table [ i ] [ j ] ) + \",\" result = result [ : - 1 ] + \"\\n\" return result [ : - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute a normal python statement in user namespace . [CODESPLIT] def ex ( self , cmd ) : with self . builtin_trap : exec cmd in self . user_global_ns , self . user_ns", "target": 1, "target_options": ["no_match", "match"]}
{"input": "printdict [CODESPLIT] def printdict ( adict ) : dlist = list ( adict . keys ( ) ) dlist . sort ( ) for i in range ( 0 , len ( dlist ) ) : print ( dlist [ i ] , adict [ dlist [ i ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "To allow devs to log as early as possible logging will already be handled here [CODESPLIT] def handle_logging ( self ) : configure_logging ( self . get_scrapy_options ( ) ) # Disable duplicates self . __scrapy_options [ \"LOG_ENABLED\" ] = False # Now, after log-level is correctly set, lets log them. for msg in self . log_output : if msg [ \"level\" ] is \"error\" : self . log . error ( msg [ \"msg\" ] ) elif msg [ \"level\" ] is \"info\" : self . log . info ( msg [ \"msg\" ] ) elif msg [ \"level\" ] is \"debug\" : self . log . debug ( msg [ \"msg\" ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given an index for the text return the corresponding ( row col ) tuple . ( 0 - based . Returns ( 0 0 ) for index = 0 . ) [CODESPLIT] def translate_index_to_position ( self , index ) : # Find start of this line. row , row_index = self . _find_line_start_index ( index ) col = index - row_index return row , col", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print in color . [CODESPLIT] def printc ( cls , txt , color = colors . red ) : print ( cls . color_txt ( txt , color ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns seconds since 0h00 . [CODESPLIT] def time2seconds ( t ) : return t . hour * 3600 + t . minute * 60 + t . second + float ( t . microsecond ) / 1e6", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a string containing the type and text of the exception . [CODESPLIT] def format_exception ( e ) : from . utils . printing import fill return '\\n' . join ( fill ( line ) for line in traceback . format_exception_only ( type ( e ) , e ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes JSON formatted data converting it into native Python objects [CODESPLIT] def json ( body , charset = 'utf-8' , * * kwargs ) : return json_converter . loads ( text ( body , charset = charset ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fetch a subset of randomzied GUIDs from the whitelist [CODESPLIT] def get_randomized_guid_sample ( self , item_count ) : dataset = self . get_whitelist ( ) random . shuffle ( dataset ) return dataset [ : item_count ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Select rows where the given field evaluates True . [CODESPLIT] def selecttrue ( table , field , complement = False ) : return select ( table , field , lambda v : bool ( v ) , complement = complement )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads a tif file to a 2D NumPy array [CODESPLIT] def ReadTif ( tifFile ) : img = Image . open ( tifFile ) img = np . array ( img ) return img", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute summary statistics of a unique ( S_TYPE_UNIQUE ) variable ( a Series ) . [CODESPLIT] def describe_unique_1d ( series ) : return pd . Series ( [ base . S_TYPE_UNIQUE ] , index = [ 'type' ] , name = series . name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read tag data from file and return as numpy array . [CODESPLIT] def read_numpy ( fd , byte_order , dtype , count ) : return numpy . fromfile ( fd , byte_order + dtype [ - 1 ] , count )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "read the lines from a file into a list [CODESPLIT] def get_list_from_file ( file_name ) : with open ( file_name , mode = 'r' , encoding = 'utf-8' ) as f1 : lst = f1 . readlines ( ) return lst", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert to snake case . [CODESPLIT] def to_snake_case ( text ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "read the lines from a file into a list [CODESPLIT] def get_list_from_file ( file_name ) : with open ( file_name , mode = 'r' , encoding = 'utf-8' ) as f1 : lst = f1 . readlines ( ) return lst", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find rightmost value less than or equal to x . [CODESPLIT] def find_le ( a , x ) : i = bs . bisect_right ( a , x ) if i : return i - 1 raise ValueError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the pixel at ( x y ) to the integers in sequence color . [CODESPLIT] def setPixel ( self , x , y , color ) : return _fitz . Pixmap_setPixel ( self , x , y , color )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adjust image balance and contrast [CODESPLIT] def lighting ( im , b , c ) : if b == 0 and c == 1 : return im mu = np . average ( im ) return np . clip ( ( im - mu ) * c + mu + b , 0. , 1. ) . astype ( np . float32 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Round the number to the specified number of significant figures [CODESPLIT] def round_sig ( x , sig ) : return round ( x , sig - int ( floor ( log10 ( abs ( x ) ) ) ) - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the shape of the region as ( x y w h ) [CODESPLIT] def getTuple ( self ) : return ( self . x , self . y , self . w , self . h )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip all the accents from the string [CODESPLIT] def strip_accents ( string ) : return u'' . join ( ( character for character in unicodedata . normalize ( 'NFD' , string ) if unicodedata . category ( character ) != 'Mn' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip all the accents from the string [CODESPLIT] def strip_accents ( string ) : return u'' . join ( ( character for character in unicodedata . normalize ( 'NFD' , string ) if unicodedata . category ( character ) != 'Mn' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Assumes myList is sorted . Returns closest value to myNumber . If two numbers are equally close return the smallest number . [CODESPLIT] def get_closest_index ( myList , myNumber ) : closest_values_index = _np . where ( self . time == take_closest ( myList , myNumber ) ) [ 0 ] [ 0 ] return closest_values_index", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip agents from a string . [CODESPLIT] def strip_accents ( text ) : normalized_str = unicodedata . normalize ( 'NFD' , text ) return '' . join ( [ c for c in normalized_str if unicodedata . category ( c ) != 'Mn' ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "if the value is in the list move it to the front and return it . [CODESPLIT] def list_move_to_front ( l , value = 'other' ) : l = list ( l ) if value in l : l . remove ( value ) l . insert ( 0 , value ) return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param source : some iterable source ( list file etc ) : param lineSep : string of separators ( chars ) that must be removed : return : list of non empty lines with removed separators [CODESPLIT] def cleanLines ( source , lineSep = os . linesep ) : stripped = ( line . strip ( lineSep ) for line in source ) return ( line for line in stripped if len ( line ) != 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fit the module . [CODESPLIT] def partial_fit ( self , X , y = None , classes = None , * * fit_params ) : if not self . initialized_ : self . initialize ( ) self . notify ( 'on_train_begin' , X = X , y = y ) try : self . fit_loop ( X , y , * * fit_params ) except KeyboardInterrupt : pass self . notify ( 'on_train_end' , X = X , y = y ) return self", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Direct access to byte data . [CODESPLIT] def getbyteslice ( self , start , end ) : c = self . _rawarray [ start : end ] return c", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a new dict with any empty items removed . [CODESPLIT] def _remove_empty_items ( d , required ) : new_dict = { } for k , v in d . items ( ) : if k in required : new_dict [ k ] = v elif isinstance ( v , int ) or v : # \"if v\" would suppress emitting int(0) new_dict [ k ] = v return new_dict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Direct access to byte data . [CODESPLIT] def getbyteslice ( self , start , end ) : c = self . _rawarray [ start : end ] return c", "target": 1, "target_options": ["no_match", "match"]}
{"input": "splits iterables a in equal parts of size sz [CODESPLIT] def partition ( a , sz ) : return [ a [ i : i + sz ] for i in range ( 0 , len ( a ) , sz ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses dynamic programming to infer the location of spaces in a string without spaces . [CODESPLIT] def split ( s ) : l = [ _split ( x ) for x in _SPLIT_RE . split ( s ) ] return [ item for sublist in l for item in sublist ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield successive n - sized chunks from an iterable . [CODESPLIT] def chunks ( iterable , chunk ) : for i in range ( 0 , len ( iterable ) , chunk ) : yield iterable [ i : i + chunk ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a unique ID that is somewhat guaranteed to be unique among all instances running at the same time . [CODESPLIT] def generate_unique_host_id ( ) : host = \".\" . join ( reversed ( socket . gethostname ( ) . split ( \".\" ) ) ) pid = os . getpid ( ) return \"%s.%d\" % ( host , pid )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace any non - word characters with a dash . [CODESPLIT] def dashrepl ( value ) : patt = re . compile ( r'\\W' , re . UNICODE ) return re . sub ( patt , '-' , value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def smooth_array ( array , amount = 1 ) : if amount == 0 : return array # we have to store the old values in a temp array to keep the # smoothing from affecting the smoothing new_array = _n . array ( array ) for n in range ( len ( array ) ) : new_array [ n ] = smooth ( array , n , amount ) return new_array", "target": 1, "target_options": ["no_match", "match"]}
{"input": "mono - exponential curve . [CODESPLIT] def algo_exp ( x , m , t , b ) : return m * np . exp ( - t * x ) + b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an appropriate positive infinity for this dtype . [CODESPLIT] def get_neg_infinity ( dtype ) : if issubclass ( dtype . type , ( np . floating , np . integer ) ) : return - np . inf if issubclass ( dtype . type , np . complexfloating ) : return - np . inf - 1j * np . inf return NINF", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return sanitized Eidos text field for human readability . [CODESPLIT] def _sanitize ( text ) : d = { '-LRB-' : '(' , '-RRB-' : ')' } return re . sub ( '|' . join ( d . keys ( ) ) , lambda m : d [ m . group ( 0 ) ] , text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of dictionaries which are sorted for only unique entries . [CODESPLIT] def unique_list_dicts ( dlist , key ) : return list ( dict ( ( val [ key ] , val ) for val in dlist ) . values ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "if we have a compatible fill_value and arr dtype then fill [CODESPLIT] def _maybe_fill ( arr , fill_value = np . nan ) : if _isna_compat ( arr , fill_value ) : arr . fill ( fill_value ) return arr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Round a number to a precision [CODESPLIT] def round_to_int ( number , precision ) : precision = int ( precision ) rounded = ( int ( number ) + precision / 2 ) // precision * precision return rounded", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts and image to matrix ( one pixel per line ) [CODESPLIT] def im2mat ( I ) : return I . reshape ( ( I . shape [ 0 ] * I . shape [ 1 ] , I . shape [ 2 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Scattering form - factor amplitude of a sphere normalized to F ( q = 0 ) = V [CODESPLIT] def Fsphere ( q , R ) : return 4 * np . pi / q ** 3 * ( np . sin ( q * R ) - q * R * np . cos ( q * R ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts and image to matrix ( one pixel per line ) [CODESPLIT] def im2mat ( I ) : return I . reshape ( ( I . shape [ 0 ] * I . shape [ 1 ] , I . shape [ 2 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Process the docstring for a given python object . [CODESPLIT] def process_docstring ( app , what , name , obj , options , lines ) : result_lines = lines if app . config . napoleon_numpy_docstring : docstring = ExtendedNumpyDocstring ( result_lines , app . config , app , what , name , obj , options ) result_lines = docstring . lines ( ) if app . config . napoleon_google_docstring : docstring = ExtendedGoogleDocstring ( result_lines , app . config , app , what , name , obj , options ) result_lines = docstring . lines ( ) lines [ : ] = result_lines [ : ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "splits iterables a in equal parts of size sz [CODESPLIT] def partition ( a , sz ) : return [ a [ i : i + sz ] for i in range ( 0 , len ( a ) , sz ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a JsonResponse . Make sure you have django installed first . [CODESPLIT] def json_response ( data , status = 200 ) : from django . http import JsonResponse return JsonResponse ( data = data , status = status , safe = isinstance ( data , dict ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Chunk one big list into few small lists . [CODESPLIT] def chunked ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "prompt_yes_or_no : Prompt user to reply with a y / n response Args : None Returns : None [CODESPLIT] def prompt_yes_or_no ( message ) : user_input = input ( \"{} [y/n]:\" . format ( message ) ) . lower ( ) if user_input . startswith ( \"y\" ) : return True elif user_input . startswith ( \"n\" ) : return False else : return prompt_yes_or_no ( message )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like a bulk : meth : forceput . [CODESPLIT] def forceupdate ( self , * args , * * kw ) : self . _update ( False , self . _ON_DUP_OVERWRITE , * args , * * kw )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Unwrap a Python 2 . 6 SSL socket so we can call shutdown () [CODESPLIT] def _shutdown_transport ( self ) : if self . sock is not None : try : unwrap = self . sock . unwrap except AttributeError : return try : self . sock = unwrap ( ) except ValueError : # Failure within SSL might mean unwrap exists but socket is not # deemed wrapped pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform column - stacking on a list of 2d data blocks . [CODESPLIT] def column_stack_2d ( data ) : return list ( list ( itt . chain . from_iterable ( _ ) ) for _ in zip ( * data ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns x rounded to n significant figures . [CODESPLIT] def round_figures ( x , n ) : return round ( x , int ( n - math . ceil ( math . log10 ( abs ( x ) ) ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Starts the web server . [CODESPLIT] def start ( ) : global app bottle . run ( app , host = conf . WebHost , port = conf . WebPort , debug = conf . WebAutoReload , reloader = conf . WebAutoReload , quiet = conf . WebQuiet )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a function that is only callable once ; any other call will do nothing [CODESPLIT] def _callable_once ( func ) : def once ( * args , * * kwargs ) : if not once . called : once . called = True return func ( * args , * * kwargs ) once . called = False return once", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Called by remote workers . Useful to populate main module globals () for interactive shells . Retrieves the serialized function . [CODESPLIT] def getFunction ( self ) : return functionFactory ( self . code , self . name , self . defaults , self . globals , self . imports , )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compile and return a Module s code object . [CODESPLIT] def get_code ( module ) : fp = open ( module . path ) try : return compile ( fp . read ( ) , str ( module . name ) , 'exec' ) finally : fp . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Executes self . function to convert LazyString instance to a real str . [CODESPLIT] def __str__ ( self ) : if not hasattr ( self , '_str' ) : self . _str = self . function ( * self . args , * * self . kwargs ) return self . _str", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a shell - escaped version of the string s . [CODESPLIT] def quote ( self , s ) : if six . PY2 : from pipes import quote else : from shlex import quote return quote ( s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Save a Keras model definition to JSON with given path [CODESPLIT] def save_keras_definition ( keras_model , path ) : model_json = keras_model . to_json ( ) with open ( path , \"w\" ) as json_file : json_file . write ( model_json )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip agents from a string . [CODESPLIT] def strip_accents ( text ) : normalized_str = unicodedata . normalize ( 'NFD' , text ) return '' . join ( [ c for c in normalized_str if unicodedata . category ( c ) != 'Mn' ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert dict of ascii str / unicode to dict of str if necessary [CODESPLIT] def str_dict ( some_dict ) : return { str ( k ) : str ( v ) for k , v in some_dict . items ( ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a given file is available in the cache or not [CODESPLIT] def is_cached ( file_name ) : gml_file_path = join ( join ( expanduser ( '~' ) , OCTOGRID_DIRECTORY ) , file_name ) return isfile ( gml_file_path )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove commas from a float [CODESPLIT] def clean_float ( v ) : if v is None or not str ( v ) . strip ( ) : return None return float ( str ( v ) . replace ( ',' , '' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Local test . [CODESPLIT] def test ( ) : from spyder . utils . qthelpers import qapplication app = qapplication ( ) dlg = ProjectDialog ( None ) dlg . show ( ) sys . exit ( app . exec_ ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return index of last character in string for which func ( char ) evaluates to True . [CODESPLIT] def findLastCharIndexMatching ( text , func ) : for i in range ( len ( text ) - 1 , - 1 , - 1 ) : if func ( text [ i ] ) : return i", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shortcut to create md5 hash : param s : : return : [CODESPLIT] def md5_string ( s ) : m = hashlib . md5 ( ) m . update ( s ) return str ( m . hexdigest ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns unique elements from a list preserving the original order [CODESPLIT] def unique_element ( ll ) : seen = { } result = [ ] for item in ll : if item in seen : continue seen [ item ] = 1 result . append ( item ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A small helper function to convert a string to a numeric value if appropriate [CODESPLIT] def _convert_to_float_if_possible ( s ) : try : ret = float ( s ) except ( ValueError , TypeError ) : ret = s return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add an object to Javascript . [CODESPLIT] def add_to_js ( self , name , var ) : frame = self . page ( ) . mainFrame ( ) frame . addToJavaScriptWindowObject ( name , var )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Interpolate linearly variable x in rangeX onto rangeY . [CODESPLIT] def lin_interp ( x , rangeX , rangeY ) : s = ( x - rangeX [ 0 ] ) / mag ( rangeX [ 1 ] - rangeX [ 0 ] ) y = rangeY [ 0 ] * ( 1 - s ) + rangeY [ 1 ] * s return y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Send signal to process . [CODESPLIT] def process_kill ( pid , sig = None ) : sig = sig or signal . SIGTERM os . kill ( pid , sig )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string from snake_case to CamelCase . [CODESPLIT] def parse_case_snake_to_camel ( snake , upper_first = True ) : snake = snake . split ( '_' ) first_part = snake [ 0 ] if upper_first : first_part = first_part . title ( ) return first_part + '' . join ( word . title ( ) for word in snake [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Finish up a session . [CODESPLIT] def destroy ( self ) : if self . session_type == 'bash' : # TODO: does this work/handle already being logged out/logged in deep OK? self . logout ( ) elif self . session_type == 'vagrant' : # TODO: does this work/handle already being logged out/logged in deep OK? self . logout ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set yaxis limits . [CODESPLIT] def ylim ( self , low , high , index = 1 ) : self . layout [ 'yaxis' + str ( index ) ] [ 'range' ] = [ low , high ] return self", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the string without any initial or final quotes . [CODESPLIT] def _repr_strip ( mystring ) : r = repr ( mystring ) if r . startswith ( \"'\" ) and r . endswith ( \"'\" ) : return r [ 1 : - 1 ] else : return r", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Array of bytes [CODESPLIT] def barray ( iterlines ) : lst = [ line . encode ( 'utf-8' ) for line in iterlines ] arr = numpy . array ( lst ) return arr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Configure constant clipping settings . [CODESPLIT] def set_gradclip_const ( self , min_value , max_value ) : callBigDlFunc ( self . bigdl_type , \"setConstantClip\" , self . value , min_value , max_value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show the x - axis tick labels for a subplot . [CODESPLIT] def show_xticklabels ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . show_xticklabels ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Connects to the given host [CODESPLIT] def connect ( self ) : self . socket = socket . create_connection ( self . address , self . timeout )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Kill all running processes . [CODESPLIT] def kill_all ( self , kill_signal , kill_shell = False ) : for key in self . processes . keys ( ) : self . kill_process ( key , kill_signal , kill_shell )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set cursor position [CODESPLIT] def set_cursor_position ( self , position ) : position = self . get_position ( position ) cursor = self . textCursor ( ) cursor . setPosition ( position ) self . setTextCursor ( cursor ) self . ensureCursorVisible ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Closes and waits for subprocess to exit . [CODESPLIT] def _finish ( self ) : if self . _process . returncode is None : self . _process . stdin . flush ( ) self . _process . stdin . close ( ) self . _process . wait ( ) self . closed = True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Downsample x by factor using striding . [CODESPLIT] def downsample_with_striding ( array , factor ) : return array [ tuple ( np . s_ [ : : f ] for f in factor ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove missing values according to Baloo s convention . [CODESPLIT] def dropna ( self , subset = None ) : subset = check_and_obtain_subset_columns ( subset , self ) not_nas = [ v . notna ( ) for v in self [ subset ] . _iter ( ) ] and_filter = reduce ( lambda x , y : x & y , not_nas ) return self [ and_filter ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Dump the parent of a PID . [CODESPLIT] def dump_parent ( self , obj ) : if not self . _is_parent ( obj ) : return self . _dump_relative ( obj . pid ) return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets the title of the console window . [CODESPLIT] def title ( msg ) : if sys . platform . startswith ( \"win\" ) : ctypes . windll . kernel32 . SetConsoleTitleW ( tounicode ( msg ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Call a system command in the background disown it and hide it s output . [CODESPLIT] def disown ( cmd ) : subprocess . Popen ( cmd , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sort input filename list by datetime [CODESPLIT] def sort_fn_list ( fn_list ) : dt_list = get_dt_list ( fn_list ) fn_list_sort = [ fn for ( dt , fn ) in sorted ( zip ( dt_list , fn_list ) ) ] return fn_list_sort", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function to test the validity of singular value decomposition by reconstructing original data . [CODESPLIT] def test_SVD ( pca ) : _ = pca rec = N . dot ( _ . U , N . dot ( _ . sigma , _ . V ) ) assert N . allclose ( _ . arr , rec )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of symbols . [CODESPLIT] def symbols ( ) : symbols = [ ] for line in symbols_stream ( ) : symbols . append ( line . decode ( 'utf-8' ) . strip ( ) ) return symbols", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a text into separate words . [CODESPLIT] def tokenize_list ( self , text ) : return [ self . get_record_token ( record ) for record in self . analyze ( text ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run a Tensorflow model on the Iris dataset . [CODESPLIT] def main ( argv = None ) : args = parse_arguments ( sys . argv if argv is None else argv ) tf . logging . set_verbosity ( tf . logging . INFO ) learn_runner . run ( experiment_fn = get_experiment_fn ( args ) , output_dir = args . job_dir )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is this an integer . [CODESPLIT] def is_integer ( obj ) : if PYTHON3 : return isinstance ( obj , int ) return isinstance ( obj , ( int , long ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Start the Django dev server . [CODESPLIT] def server ( port ) : args = [ 'python' , 'manage.py' , 'runserver' ] if port : args . append ( port ) run . main ( args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove the stopped threads from the internal thread list . [CODESPLIT] def remove_stopped_threads ( self ) : self . threads = [ t for t in self . threads if t . is_alive ( ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn CDMRemote variable into something like a numpy . ndarray . [CODESPLIT] def open_store_variable ( self , name , var ) : data = indexing . LazilyOuterIndexedArray ( CDMArrayWrapper ( name , self ) ) return Variable ( var . dimensions , data , { a : getattr ( var , a ) for a in var . ncattrs ( ) } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize time in arbitrary timezone to UTC naive object . [CODESPLIT] def normalize_time ( timestamp ) : offset = timestamp . utcoffset ( ) if offset is None : return timestamp return timestamp . replace ( tzinfo = None ) - offset", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Error handler [CODESPLIT] def on_error ( e ) : # pragma: no cover exname = { 'RuntimeError' : 'Runtime error' , 'Value Error' : 'Value error' } sys . stderr . write ( '{}: {}\\n' . format ( exname [ e . __class__ . __name__ ] , str ( e ) ) ) sys . stderr . write ( 'See file slam_error.log for additional details.\\n' ) sys . exit ( 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return unix SECOND timestamp of num mondays ago [CODESPLIT] def prevmonday ( num ) : today = get_today ( ) lastmonday = today - timedelta ( days = today . weekday ( ) , weeks = num ) return lastmonday", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is a workaround where Collections are no longer iterable when using JPype . [CODESPLIT] def _listify ( collection ) : new_list = [ ] for index in range ( len ( collection ) ) : new_list . append ( collection [ index ] ) return new_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip all the accents from the string [CODESPLIT] def strip_accents ( string ) : return u'' . join ( ( character for character in unicodedata . normalize ( 'NFD' , string ) if unicodedata . category ( character ) != 'Mn' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the string without any initial or final quotes . [CODESPLIT] def _repr_strip ( mystring ) : r = repr ( mystring ) if r . startswith ( \"'\" ) and r . endswith ( \"'\" ) : return r [ 1 : - 1 ] else : return r", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses dynamic programming to infer the location of spaces in a string without spaces . [CODESPLIT] def split ( s ) : l = [ _split ( x ) for x in _SPLIT_RE . split ( s ) ] return [ item for sublist in l for item in sublist ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts camel - case identifiers to snake - case . [CODESPLIT] def to_snake_case ( s ) : return re . sub ( '([^_A-Z])([A-Z])' , lambda m : m . group ( 1 ) + '_' + m . group ( 2 ) . lower ( ) , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Swap i and j rows [CODESPLIT] def _swap_rows ( self , i , j ) : L = np . eye ( 3 , dtype = 'intc' ) L [ i , i ] = 0 L [ j , j ] = 0 L [ i , j ] = 1 L [ j , i ] = 1 self . _L . append ( L . copy ( ) ) self . _A = np . dot ( L , self . _A )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Provide a command prompt . [CODESPLIT] def input ( self , prompt , default = None , show_default = True ) : return click . prompt ( prompt , default = default , show_default = show_default )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return file name ( s ) from Tkinter s file open dialog . [CODESPLIT] def askopenfilename ( * * kwargs ) : try : from Tkinter import Tk import tkFileDialog as filedialog except ImportError : from tkinter import Tk , filedialog root = Tk ( ) root . withdraw ( ) root . update ( ) filenames = filedialog . askopenfilename ( * * kwargs ) root . destroy ( ) return filenames", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get list of datetime objects extracted from a filename [CODESPLIT] def get_dt_list ( fn_list ) : dt_list = np . array ( [ fn_getdatetime ( fn ) for fn in fn_list ] ) return dt_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Toggles document word wrap . [CODESPLIT] def toggle_word_wrap ( self ) : self . setWordWrapMode ( not self . wordWrapMode ( ) and QTextOption . WordWrap or QTextOption . NoWrap ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like np . unique ( item_list return_inverse = True ) [CODESPLIT] def unique_inverse ( item_list ) : import utool as ut unique_items = ut . unique ( item_list ) inverse = list_alignment ( unique_items , item_list ) return unique_items , inverse", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Hide the window . [CODESPLIT] def hide ( self ) : self . tk . withdraw ( ) self . _visible = False if self . _modal : self . tk . grab_release ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Move the turtle forward . [CODESPLIT] def forward ( self , step ) : x = self . pos_x + math . cos ( math . radians ( self . rotation ) ) * step y = self . pos_y + math . sin ( math . radians ( self . rotation ) ) * step prev_brush_state = self . brush_on self . brush_on = True self . move ( x , y ) self . brush_on = prev_brush_state", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove all children from the widget [CODESPLIT] def empty ( self ) : for k in list ( self . children . keys ( ) ) : self . remove_child ( self . children [ k ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initializes functions that are invoked when the user or OS wants to kill this process . : return : [CODESPLIT] def set_stop_handler ( self ) : signal . signal ( signal . SIGTERM , self . graceful_stop ) signal . signal ( signal . SIGABRT , self . graceful_stop ) signal . signal ( signal . SIGINT , self . graceful_stop )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a Listbox with a vertical scrollbar . [CODESPLIT] def __init__ ( self , master = None , compound = tk . RIGHT , autohidescrollbar = True , * * kwargs ) : ttk . Frame . __init__ ( self , master ) self . columnconfigure ( 1 , weight = 1 ) self . rowconfigure ( 0 , weight = 1 ) self . listbox = tk . Listbox ( self , * * kwargs ) if autohidescrollbar : self . scrollbar = AutoHideScrollbar ( self , orient = tk . VERTICAL , command = self . listbox . yview ) else : self . scrollbar = ttk . Scrollbar ( self , orient = tk . VERTICAL , command = self . listbox . yview ) self . config_listbox ( yscrollcommand = self . scrollbar . set ) if compound is not tk . LEFT and compound is not tk . RIGHT : raise ValueError ( \"Invalid compound value passed: {0}\" . format ( compound ) ) self . __compound = compound self . _grid_widgets ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if the image is a sequenced image . [CODESPLIT] def _is_image_sequenced ( image ) : try : image . seek ( 1 ) image . seek ( 0 ) result = True except EOFError : result = False return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "extract features in a sentence [CODESPLIT] def sent2features ( sentence , template ) : return [ word2features ( sentence , i , template ) for i in range ( len ( sentence ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialize EGL and return EGL version tuple . [CODESPLIT] def eglInitialize ( display ) : majorVersion = ( _c_int * 1 ) ( ) minorVersion = ( _c_int * 1 ) ( ) res = _lib . eglInitialize ( display , majorVersion , minorVersion ) if res == EGL_FALSE : raise RuntimeError ( 'Could not initialize' ) return majorVersion [ 0 ] , minorVersion [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Forward mouse cursor position events to the example [CODESPLIT] def mouse_move_event ( self , event ) : self . example . mouse_position_event ( event . x ( ) , event . y ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a list of ( key value ) pairs and turns it into a dict . [CODESPLIT] def list2dict ( lst ) : dic = { } for k , v in lst : dic [ k ] = v return dic", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return enum constant s converted to a canonical snake - case . [CODESPLIT] def normalize_enum_constant ( s ) : if s . islower ( ) : return s if s . isupper ( ) : return s . lower ( ) return \"\" . join ( ch if ch . islower ( ) else \"_\" + ch . lower ( ) for ch in s ) . strip ( \"_\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pull comma separated string values out of a text file and converts them to float list [CODESPLIT] def string_to_float_list ( string_var ) : try : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ', ' ) ] except : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ',' ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "swap and then flatten axes 0 and 1 [CODESPLIT] def sf01 ( arr ) : s = arr . shape return arr . swapaxes ( 0 , 1 ) . reshape ( s [ 0 ] * s [ 1 ] , * s [ 2 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Recursively find size of a tree . Slow . [CODESPLIT] def size ( self ) : if self is NULL : return 0 return 1 + self . left . size ( ) + self . right . size ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Should we skip logging for this handler? [CODESPLIT] def should_skip_logging ( func ) : disabled = strtobool ( request . headers . get ( \"x-request-nolog\" , \"false\" ) ) return disabled or getattr ( func , SKIP_LOGGING , False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turns the multi - line output of a benchmark process into a sequence of BenchmarkResult instances . [CODESPLIT] def stdout_to_results ( s ) : results = s . strip ( ) . split ( '\\n' ) return [ BenchmarkResult ( * r . split ( ) ) for r in results ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an appropriate positive infinity for this dtype . [CODESPLIT] def get_neg_infinity ( dtype ) : if issubclass ( dtype . type , ( np . floating , np . integer ) ) : return - np . inf if issubclass ( dtype . type , np . complexfloating ) : return - np . inf - 1j * np . inf return NINF", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a new set which is the union of I { self } and I { other } . [CODESPLIT] def union ( self , other ) : obj = self . _clone ( ) obj . union_update ( other ) return obj", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This callback is invoked when the user checks the Use Scrollbars box in the preferences pane . [CODESPLIT] def set_scrollbars_cb ( self , w , tf ) : scrollbars = 'on' if tf else 'off' self . t_ . set ( scrollbars = scrollbars )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if arguments are tuple type . [CODESPLIT] def tuple_check ( * args , func = None ) : func = func or inspect . stack ( ) [ 2 ] [ 3 ] for var in args : if not isinstance ( var , ( tuple , collections . abc . Sequence ) ) : name = type ( var ) . __name__ raise TupleError ( f'Function {func} expected tuple, {name} got instead.' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return possible range for min function . [CODESPLIT] def min_values ( args ) : return Interval ( min ( x . low for x in args ) , min ( x . high for x in args ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts markdown content to text [CODESPLIT] def md_to_text ( content ) : text = None html = markdown . markdown ( content ) if html : text = html_to_text ( content ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This will convert the data from a list of list to a list of dictionary : return : list of dict [CODESPLIT] def list_of_dict ( self ) : ret = [ ] for row in self : ret . append ( dict ( [ ( self . _col_names [ i ] , row [ i ] ) for i in range ( len ( self . _col_names ) ) ] ) ) return ReprListDict ( ret , col_names = self . _col_names , col_types = self . _col_types , width_limit = self . _width_limit , digits = self . _digits , convert_unicode = self . _convert_unicode )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns an updated copy of the dictionary without modifying the original [CODESPLIT] def copy_and_update ( dictionary , update ) : newdict = dictionary . copy ( ) newdict . update ( update ) return newdict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Display both SQLAlchemy and Python help statements [CODESPLIT] def _help ( ) : statement = '%s%s' % ( shelp , phelp % ', ' . join ( cntx_ . keys ( ) ) ) print statement . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get input from the user given an input function and an input string [CODESPLIT] def get_input ( input_func , input_str ) : val = input_func ( \"Please enter your {0}: \" . format ( input_str ) ) while not val or not len ( val . strip ( ) ) : val = input_func ( \"You didn't enter a valid {0}, please try again: \" . format ( input_str ) ) return val", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a string for various input types [CODESPLIT] def check_str ( obj ) : if isinstance ( obj , str ) : return obj if isinstance ( obj , float ) : return str ( int ( obj ) ) else : return str ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Collect digits from a string [CODESPLIT] def str2int ( string_with_int ) : return int ( \"\" . join ( [ char for char in string_with_int if char in string . digits ] ) or 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def parse_parameter ( value ) : if any ( ( isinstance ( value , float ) , isinstance ( value , int ) , isinstance ( value , bool ) ) ) : return value try : return int ( value ) except ValueError : try : return float ( value ) except ValueError : if value in string_aliases . true_boolean_aliases : return True elif value in string_aliases . false_boolean_aliases : return False else : return str ( value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like isin but checks whether this expression s value ( s ) are not contained in the passed values . See isin docs for full usage . [CODESPLIT] def notin ( arg , values ) : op = ops . NotContains ( arg , values ) return op . to_expr ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates data is a timestamp [CODESPLIT] def is_timestamp ( instance ) : if not isinstance ( instance , ( int , str ) ) : return True return datetime . fromtimestamp ( int ( instance ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds a new event handler . [CODESPLIT] def subscribe ( self , handler ) : assert callable ( handler ) , \"Invalid handler %s\" % handler self . handlers . append ( handler )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Downloads and returns the full text of a particular page in the document . [CODESPLIT] def get_page_text ( self , page ) : url = self . get_page_text_url ( page ) return self . _get_url ( url )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Intends to get the bound field from the form regarding the field name [CODESPLIT] def get_form_bound_field ( form , field_name ) : field = form . fields [ field_name ] field = field . get_bound_field ( form , field_name ) return field", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the scroll region on the canvas [CODESPLIT] def set_scrollregion ( self , event = None ) : self . canvas . configure ( scrollregion = self . canvas . bbox ( 'all' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A function to generate the latex representation of sympy expressions . [CODESPLIT] def print_latex ( o ) : if can_print_latex ( o ) : s = latex ( o , mode = 'plain' ) s = s . replace ( '\\\\dag' , '\\\\dagger' ) s = s . strip ( '$' ) return '$$%s$$' % s # Fallback to the string printer return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check that the page title matches the given one . [CODESPLIT] def page_title ( step , title ) : with AssertContextManager ( step ) : assert_equals ( world . browser . title , title )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set an object s field to default if it doesn t have a value [CODESPLIT] def setdefault ( obj , field , default ) : setattr ( obj , field , getattr ( obj , field , default ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "assertRedirects from Django TestCase follows the redirects chains this assertion does not - which is more like real unit testing [CODESPLIT] def assert_redirect ( self , response , expected_url = None ) : self . assertIn ( response . status_code , self . redirect_codes , self . _get_redirect_assertion_message ( response ) , ) if expected_url : location_header = response . _headers . get ( 'location' , None ) self . assertEqual ( location_header , ( 'Location' , str ( expected_url ) ) , 'Response should redirect to {0}, but it redirects to {1} instead' . format ( expected_url , location_header [ 1 ] , ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Inserts a horizontal ( commented ) line tot the generated code . [CODESPLIT] def _write_separator ( self ) : tmp = self . _page_width - ( ( 4 * self . __indent_level ) + 2 ) self . _write_line ( '# ' + ( '-' * tmp ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "stupid windows . converts the backslash to forwardslash for consistency [CODESPLIT] def __unixify ( self , s ) : return os . path . normpath ( s ) . replace ( os . sep , \"/\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts an ARRAY string stored in the database back into a Numpy array . [CODESPLIT] def convert_array ( array ) : out = io . BytesIO ( array ) out . seek ( 0 ) return np . load ( out )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Saves the case as an Excel spreadsheet . [CODESPLIT] def save_excel ( self , fd ) : from pylon . io . excel import ExcelWriter ExcelWriter ( self ) . write ( fd )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a copy of a dictionary with all keys converted to camel case . This is just calls to_camel_case on each of the keys in the dictionary and returns a new dictionary . [CODESPLIT] def _keys_to_camel_case ( self , obj ) : return dict ( ( to_camel_case ( key ) , value ) for ( key , value ) in obj . items ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prints the top row of a table [CODESPLIT] def top ( n , width = WIDTH , style = STYLE ) : return hrule ( n , width , linestyle = STYLES [ style ] . top )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the encoding type . [CODESPLIT] def get_encoding ( binary ) : try : from chardet import detect except ImportError : LOGGER . error ( \"Please install the 'chardet' module\" ) sys . exit ( 1 ) encoding = detect ( binary ) . get ( 'encoding' ) return 'iso-8859-1' if encoding == 'CP949' else encoding", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clean the argument value to eliminate None or Falsy values if needed . [CODESPLIT] def clear_list_value ( self , value ) : # Don't go any further: this value is empty. if not value : return self . empty_value # Clean empty items if wanted if self . clean_empty : value = [ v for v in value if v ] return value or self . empty_value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the file name from an url Parameters ---------- url : str [CODESPLIT] def get_url_file_name ( url ) : assert isinstance ( url , ( str , _oldstr ) ) return urlparse . urlparse ( url ) . path . split ( '/' ) [ - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The minimal ~photutils . aperture . BoundingBox for the cutout region with respect to the original ( large ) image . [CODESPLIT] def bbox ( self ) : return BoundingBox ( self . slices [ 1 ] . start , self . slices [ 1 ] . stop , self . slices [ 0 ] . start , self . slices [ 0 ] . stop )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prompt the user for input and handle any abort exceptions . [CODESPLIT] def prompt ( * args , * * kwargs ) : try : return click . prompt ( * args , * * kwargs ) except click . Abort : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a single document from the collection this class is bound to . Additional arguments are processed according to _prepare_find prior to passing to PyMongo where positional parameters are interpreted as query fragments parametric keyword arguments combined and other keyword arguments passed along with minor transformation . Automatically calls to_mongo with the retrieved data . https : // api . mongodb . com / python / current / api / pymongo / collection . html#pymongo . collection . Collection . find_one [CODESPLIT] def find_one ( cls , * args , * * kw ) : if len ( args ) == 1 and not isinstance ( args [ 0 ] , Filter ) : args = ( getattr ( cls , cls . __pk__ ) == args [ 0 ] , ) Doc , collection , query , options = cls . _prepare_find ( * args , * * kw ) result = Doc . from_mongo ( collection . find_one ( query , * * options ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generates a unique token associated to the user [CODESPLIT] def generate_user_token ( self , user , salt = None ) : return self . token_serializer . dumps ( str ( user . id ) , salt = salt )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the 1 - based index of the last object on this page relative to total objects found ( hits ) . [CODESPLIT] def end_index ( self ) : return ( ( self . number - 1 ) * self . paginator . per_page + len ( self . object_list ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a shell - escaped version of the string s . [CODESPLIT] def quote ( self , s ) : if six . PY2 : from pipes import quote else : from shlex import quote return quote ( s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the number of ticks . [CODESPLIT] def ynticks ( self , nticks , index = 1 ) : self . layout [ 'yaxis' + str ( index ) ] [ 'nticks' ] = nticks return self", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate value of class attribute last_page . [CODESPLIT] def _set_lastpage ( self ) : self . last_page = ( len ( self . _page_data ) - 1 ) // self . screen . page_size", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Install venv + deps . [CODESPLIT] def venv ( ) : try : import virtualenv # NOQA except ImportError : sh ( \"%s -m pip install virtualenv\" % PYTHON ) if not os . path . isdir ( \"venv\" ) : sh ( \"%s -m virtualenv venv\" % PYTHON ) sh ( \"venv\\\\Scripts\\\\pip install -r %s\" % ( REQUIREMENTS_TXT ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialize the server logging configuration . [CODESPLIT] def ServerLoggingStartupInit ( ) : global LOGGER if local_log : logging . debug ( \"Using local LogInit from %s\" , local_log ) local_log . LogInit ( ) logging . debug ( \"Using local AppLogInit from %s\" , local_log ) LOGGER = local_log . AppLogInit ( ) else : LogInit ( ) LOGGER = AppLogInit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute init tasks for all components ( virtualenv pip ) . [CODESPLIT] def init ( ) : print ( yellow ( \"# Setting up environment...\\n\" , True ) ) virtualenv . init ( ) virtualenv . update_requirements ( ) print ( green ( \"\\n# DONE.\" , True ) ) print ( green ( \"Type \" ) + green ( \"activate\" , True ) + green ( \" to enable your virtual environment.\" ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Allow \\ n . join ( ... ) statements to work in Py2 and Py3 . : param sep : : param joinable : : return : [CODESPLIT] def _py2_and_3_joiner ( sep , joinable ) : if ISPY3 : sep = bytes ( sep , DEFAULT_ENCODING ) joined = sep . join ( joinable ) return joined . decode ( DEFAULT_ENCODING ) if ISPY3 else joined", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Order - preserving sorting function . [CODESPLIT] def csort ( objs , key ) : idxs = dict ( ( obj , i ) for ( i , obj ) in enumerate ( objs ) ) return sorted ( objs , key = lambda obj : ( key ( obj ) , idxs [ obj ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Put the text into the storage associated with the key . [CODESPLIT] def put_text ( self , key , text ) : with open ( key , \"w\" ) as fh : fh . write ( text )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Destroy a driver [CODESPLIT] def destroy_webdriver ( driver ) : # This is some very flaky code in selenium. Hence the retries # and catch-all exceptions try : retry_call ( driver . close , tries = 2 ) except Exception : pass try : driver . quit ( ) except Exception : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rewrite a file adding a line to its beginning . [CODESPLIT] def prepend_line ( filepath , line ) : with open ( filepath ) as f : lines = f . readlines ( ) lines . insert ( 0 , line ) with open ( filepath , 'w' ) as f : f . writelines ( lines )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap text with markdown specific flavour . [CODESPLIT] def build_code ( self , lang , body ) : self . out . append ( \"```\" + lang ) self . build_markdown ( lang , body ) self . out . append ( \"```\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check the checkbox matching the CSS selector . [CODESPLIT] def check_by_selector ( self , selector ) : elem = find_element_by_jquery ( world . browser , selector ) if not elem . is_selected ( ) : elem . click ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decide if the Ipython command line is running code . [CODESPLIT] def IPYTHON_MAIN ( ) : import pkg_resources runner_frame = inspect . getouterframes ( inspect . currentframe ( ) ) [ - 2 ] return ( getattr ( runner_frame , \"function\" , None ) == pkg_resources . load_entry_point ( \"ipython\" , \"console_scripts\" , \"ipython\" ) . __name__ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Because standard distinct used on the all fields are very slow and works only with PostgreSQL database this method provides alternative to the standard distinct method . : return : qs with unique objects [CODESPLIT] def fast_distinct ( self ) : return self . model . objects . filter ( pk__in = self . values_list ( 'pk' , flat = True ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Places all the child widgets in the appropriate positions . [CODESPLIT] def __grid_widgets ( self ) : scrollbar_column = 0 if self . __compound is tk . LEFT else 2 self . _canvas . grid ( row = 0 , column = 1 , sticky = \"nswe\" ) self . _scrollbar . grid ( row = 0 , column = scrollbar_column , sticky = \"ns\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retries function until it doesn t raise an EINTR error [CODESPLIT] def retry_on_signal ( function ) : while True : try : return function ( ) except EnvironmentError , e : if e . errno != errno . EINTR : raise", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initializes an stdin input reader . [CODESPLIT] def __init__ ( self , encoding = 'utf-8' ) : super ( StdinInputReader , self ) . __init__ ( sys . stdin , encoding = encoding )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Assert an alert is showing with the given text . [CODESPLIT] def check_alert ( self , text ) : try : alert = Alert ( world . browser ) if alert . text != text : raise AssertionError ( \"Alert text expected to be {!r}, got {!r}.\" . format ( text , alert . text ) ) except WebDriverException : # PhantomJS is kinda poor pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write the ROI model to a FITS file . [CODESPLIT] def write_fits ( self , fitsfile ) : tab = self . create_table ( ) hdu_data = fits . table_to_hdu ( tab ) hdus = [ fits . PrimaryHDU ( ) , hdu_data ] fits_utils . write_hdus ( hdus , fitsfile )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of rows preceding the data table for * series * in the Excel worksheet . [CODESPLIT] def series_table_row_offset ( self , series ) : title_and_spacer_rows = series . index * 2 data_point_rows = series . data_point_offset return title_and_spacer_rows + data_point_rows", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract from the given iterable of lines the list of words . [CODESPLIT] def extract_words ( lines ) : for line in lines : for word in re . findall ( r\"\\w+\" , line ) : yield word", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all child objects in nested lists of strings . [CODESPLIT] def as_list ( self ) : return [ self . name , self . value , [ x . as_list for x in self . children ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrap itertools . groupby to make life easier . [CODESPLIT] def group_by ( iterable , key_func ) : groups = ( list ( sub ) for key , sub in groupby ( iterable , key_func ) ) return zip ( groups , groups )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check element for required attributes . Raise NotValidXmlException on error . [CODESPLIT] def required_attributes ( element , * attributes ) : if not reduce ( lambda still_valid , param : still_valid and param in element . attrib , attributes , True ) : raise NotValidXmlException ( msg_err_missing_attributes ( element . tag , * attributes ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transforms an XML string it to python - zimbra dict format [CODESPLIT] def xml_str_to_dict ( s ) : xml = minidom . parseString ( s ) return pythonzimbra . tools . xmlserializer . dom_to_dict ( xml . firstChild )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Appends the prefix to the topic before sendingf [CODESPLIT] def send ( self , topic , * args , * * kwargs ) : prefix_topic = self . heroku_kafka . prefix_topic ( topic ) return super ( HerokuKafkaProducer , self ) . send ( prefix_topic , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the element with the highest probability . [CODESPLIT] def best ( self ) : b = ( - 1e999999 , None ) for k , c in iteritems ( self . counts ) : b = max ( b , ( c , k ) ) return b [ 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Opens the RPC communication channel for clients . [CODESPLIT] def _Open ( self , hostname , port ) : try : self . _xmlrpc_server = SimpleXMLRPCServer . SimpleXMLRPCServer ( ( hostname , port ) , logRequests = False , allow_none = True ) except SocketServer . socket . error as exception : logger . warning ( ( 'Unable to bind a RPC server on {0:s}:{1:d} with error: ' '{2!s}' ) . format ( hostname , port , exception ) ) return False self . _xmlrpc_server . register_function ( self . _callback , self . _RPC_FUNCTION_NAME ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Predict the class for X . [CODESPLIT] def predict ( self , X ) : return [ self . classes [ prediction . argmax ( ) ] for prediction in self . predict_proba ( X ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the top - level element of a document sub - tree containing the YAML serialization of a Python object . [CODESPLIT] def yaml_to_param ( obj , name ) : return from_pyvalue ( u\"yaml:%s\" % name , unicode ( yaml . dump ( obj ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A background thread to kill the process if it takes too long . [CODESPLIT] def timeout_thread_handler ( timeout , stop_event ) : stop_happened = stop_event . wait ( timeout ) if stop_happened is False : print ( \"Killing program due to %f second timeout\" % timeout ) os . _exit ( 2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "implementation of safe dumper using Ordered Dict Yaml Dumper [CODESPLIT] def safe_dump ( data , stream = None , * * kwds ) : return yaml . dump ( data , stream = stream , Dumper = ODYD , * * kwds )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "\\ kills the child and exits [CODESPLIT] def cli_command_quit ( self , msg ) : if self . state == State . RUNNING and self . sprocess and self . sprocess . proc : self . sprocess . proc . kill ( ) else : sys . exit ( 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the top - level element of a document sub - tree containing the YAML serialization of a Python object . [CODESPLIT] def yaml_to_param ( obj , name ) : return from_pyvalue ( u\"yaml:%s\" % name , unicode ( yaml . dump ( obj ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the most common element in iterable . [CODESPLIT] def _most_common ( iterable ) : data = Counter ( iterable ) return max ( data , key = data . __getitem__ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "yields a connected socket [CODESPLIT] def connected_socket ( address , timeout = 3 ) : sock = socket . create_connection ( address , timeout ) yield sock sock . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Called set the returned future s state that of the future we yielded and set the current future for the iterator . [CODESPLIT] def _return_result ( self , done ) : chain_future ( done , self . _running_future ) self . current_future = done self . current_index = self . _unfinished . pop ( done )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Like pretty but print to stdout . [CODESPLIT] def pprint ( obj , verbose = False , max_width = 79 , newline = '\\n' ) : printer = RepresentationPrinter ( sys . stdout , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) sys . stdout . write ( newline ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract a ZIP archive to a directory [CODESPLIT] def unzip_file_to_dir ( path_to_zip , output_directory ) : z = ZipFile ( path_to_zip , 'r' ) z . extractall ( output_directory ) z . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the X / Y coordinate limits for the full resulting image [CODESPLIT] def _get_xy_scaling_parameters ( self ) : return self . mx , self . bx , self . my , self . by", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Constrain numbers to ( 0 1 ) interval [CODESPLIT] def open01 ( x , limit = 1.e-6 ) : try : return np . array ( [ min ( max ( y , limit ) , 1. - limit ) for y in x ] ) except TypeError : return min ( max ( x , limit ) , 1. - limit )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Init connection and consumer with openstack mq . [CODESPLIT] def init_mq ( self ) : mq = self . init_connection ( ) self . init_consumer ( mq ) return mq . connection", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adjust dirty flag depending on editor s content [CODESPLIT] def _on_text_changed ( self ) : if not self . _cleaning : ln = TextHelper ( self ) . cursor_position ( ) [ 0 ] self . _modified_lines . add ( ln )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the approximate size of the queue ( not reliable! ) . [CODESPLIT] def qsize ( self ) : self . mutex . acquire ( ) n = self . _qsize ( ) self . mutex . release ( ) return n", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Linear oldstyle interpolation of the transform matrix . [CODESPLIT] def _linearInterpolationTransformMatrix ( matrix1 , matrix2 , value ) : return tuple ( _interpolateValue ( matrix1 [ i ] , matrix2 [ i ] , value ) for i in range ( len ( matrix1 ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "helper to clean up an input string [CODESPLIT] def clean ( some_string , uppercase = False ) : if uppercase : return some_string . strip ( ) . upper ( ) else : return some_string . strip ( ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "stack_as_string [CODESPLIT] def stack_as_string ( ) : if sys . version_info . major == 3 : stack = io . StringIO ( ) else : stack = io . BytesIO ( ) traceback . print_stack ( file = stack ) stack . seek ( 0 ) stack = stack . read ( ) return stack", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns date range for the previous full month . [CODESPLIT] def get_previous_month ( self ) : end = utils . get_month_start ( ) - relativedelta ( days = 1 ) end = utils . to_datetime ( end ) start = utils . get_month_start ( end ) return start , end", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a millisecond accuracy timestamp to a datetime [CODESPLIT] def ms_to_datetime ( ms ) : dt = datetime . datetime . utcfromtimestamp ( ms / 1000 ) return dt . replace ( microsecond = ( ms % 1000 ) * 1000 ) . replace ( tzinfo = pytz . utc )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a ctypes int pointer array to a numpy array . [CODESPLIT] def cint32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int32 ) ) : return np . fromiter ( cptr , dtype = np . int32 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a multi - dimensional array and returns a 1 dimensional array with the same contents . [CODESPLIT] def flatten_array ( grid ) : grid = [ grid [ i ] [ j ] for i in range ( len ( grid ) ) for j in range ( len ( grid [ i ] ) ) ] while type ( grid [ 0 ] ) is list : grid = flatten_array ( grid ) return grid", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the md5 hash for a file . [CODESPLIT] def get_md5_for_file ( file ) : md5 = hashlib . md5 ( ) while True : data = file . read ( md5 . block_size ) if not data : break md5 . update ( data ) return md5 . hexdigest ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get list of all uppercase non - private globals ( doesn t start with _ ) . [CODESPLIT] def _get_all_constants ( ) : return [ key for key in globals ( ) . keys ( ) if all ( [ not key . startswith ( \"_\" ) , # publicly accesible key . upper ( ) == key , # uppercase type ( globals ( ) [ key ] ) in _ALLOWED # and with type from _ALLOWED ] ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns data as : class : numpy . recarray . [CODESPLIT] def recarray ( self ) : return numpy . rec . fromrecords ( self . records , names = self . names )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "IP address range validation and expansion . [CODESPLIT] def ip_address_list ( ips ) : # first, try it as a single IP address try : return ip_address ( ips ) except ValueError : pass # then, consider it as an ipaddress.IPv[4|6]Network instance and expand it return list ( ipaddress . ip_network ( u ( ips ) ) . hosts ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads an array from bytestring with big - endian data . [CODESPLIT] def be_array_from_bytes ( fmt , data ) : arr = array . array ( str ( fmt ) , data ) return fix_byteorder ( arr )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a proper string that should work in both Py3 / Py2 [CODESPLIT] def polite_string ( a_string ) : if is_py3 ( ) and hasattr ( a_string , 'decode' ) : try : return a_string . decode ( 'utf-8' ) except UnicodeDecodeError : return a_string return a_string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Imports from javascript source file . globals is your globals () [CODESPLIT] def import_js ( path , lib_name , globals ) : with codecs . open ( path_as_local ( path ) , \"r\" , \"utf-8\" ) as f : js = f . read ( ) e = EvalJs ( ) e . execute ( js ) var = e . context [ 'var' ] globals [ lib_name ] = var . to_python ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Unified rounding in all python versions . [CODESPLIT] def py3round ( number ) : if abs ( round ( number ) - number ) == 0.5 : return int ( 2.0 * round ( number / 2.0 ) ) return int ( round ( number ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deletes the document lines under cursor . [CODESPLIT] def delete_lines ( self ) : cursor = self . textCursor ( ) self . __select_text_under_cursor_blocks ( cursor ) cursor . removeSelectedText ( ) cursor . deleteChar ( ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Acquire a lock on the output file prevents collisions between multiple runs . [CODESPLIT] def __enter__ ( self ) : self . fd = open ( self . filename , 'a' ) fcntl . lockf ( self . fd , fcntl . LOCK_EX ) return self . fd", "target": 1, "target_options": ["no_match", "match"]}
{"input": "str to bytes ( py3k ) [CODESPLIT] def to_bytes ( value ) : vtype = type ( value ) if vtype == bytes or vtype == type ( None ) : return value try : return vtype . encode ( value ) except UnicodeEncodeError : pass return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Natural log of scipy norm function truncated at zero [CODESPLIT] def ln_norm ( x , mu , sigma = 1.0 ) : return np . log ( stats . norm ( loc = mu , scale = sigma ) . pdf ( x ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs a shell command returns console output . [CODESPLIT] def _run_cmd_get_output ( cmd ) : process = subprocess . Popen ( cmd . split ( ) , stdout = subprocess . PIPE ) out , err = process . communicate ( ) return out or err", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Lasso Regression [CODESPLIT] def cric__lasso ( ) : model = sklearn . linear_model . LogisticRegression ( penalty = \"l1\" , C = 0.002 ) # we want to explain the raw probability outputs of the trees model . predict = lambda X : model . predict_proba ( X ) [ : , 1 ] return model", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove any duplicate entries . [CODESPLIT] def unique ( transactions ) : seen = set ( ) # TODO: Handle comments return [ x for x in transactions if not ( x in seen or seen . add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exponential survival likelihood accounting for censoring [CODESPLIT] def survival ( value = t , lam = lam , f = failure ) : return sum ( f * log ( lam ) - lam * value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert snake_case to camel_case . [CODESPLIT] def to_identifier ( s ) : if s . startswith ( 'GPS' ) : s = 'Gps' + s [ 3 : ] return '' . join ( [ i . capitalize ( ) for i in s . split ( '_' ) ] ) if '_' in s else s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find longest ORF from the given list of ORFs . [CODESPLIT] def get_longest_orf ( orfs ) : sorted_orf = sorted ( orfs , key = lambda x : len ( x [ 'sequence' ] ) , reverse = True ) [ 0 ] return sorted_orf", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip excess spaces from a string [CODESPLIT] def strip_spaces ( s ) : return u\" \" . join ( [ c for c in s . split ( u' ' ) if c ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the value of each QuerySet but also add the # property to each return item . [CODESPLIT] def _unordered_iterator ( self ) : for i , qs in zip ( self . _queryset_idxs , self . _querysets ) : for item in qs : setattr ( item , '#' , i ) yield item", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Qt / Python2 / 3 compatibility helper . [CODESPLIT] def handle_qbytearray ( obj , encoding ) : if isinstance ( obj , QByteArray ) : obj = obj . data ( ) return to_text_string ( obj , encoding = encoding )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the last n results ( or possibly less if not found ) . Note that the last results are not necessarily the best ones! Depending on the search type . [CODESPLIT] def searchlast ( self , n = 10 ) : solutions = deque ( [ ] , n ) for solution in self : solutions . append ( solution ) return solutions", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the clipboard s text on OS X . [CODESPLIT] def osx_clipboard_get ( ) : p = subprocess . Popen ( [ 'pbpaste' , '-Prefer' , 'ascii' ] , stdout = subprocess . PIPE ) text , stderr = p . communicate ( ) # Text comes in with old Mac \\r line endings. Change them to \\n. text = text . replace ( '\\r' , '\\n' ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Magnitude of a complex matrix . [CODESPLIT] def magnitude ( X ) : r = np . real ( X ) i = np . imag ( X ) return np . sqrt ( r * r + i * i )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Packs a list of triple indexes into a 2D numpy array . [CODESPLIT] def pack_triples_numpy ( triples ) : if len ( triples ) == 0 : return np . array ( [ ] , dtype = np . int64 ) return np . stack ( list ( map ( _transform_triple_numpy , triples ) ) , axis = 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "sets the aspect ratio of the current zoom level of the imshow image [CODESPLIT] def image_set_aspect ( aspect = 1.0 , axes = \"gca\" ) : if axes is \"gca\" : axes = _pylab . gca ( ) e = axes . get_images ( ) [ 0 ] . get_extent ( ) axes . set_aspect ( abs ( ( e [ 1 ] - e [ 0 ] ) / ( e [ 3 ] - e [ 2 ] ) ) / aspect )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert dict of ascii str / unicode to dict of str if necessary [CODESPLIT] def str_dict ( some_dict ) : return { str ( k ) : str ( v ) for k , v in some_dict . items ( ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Random uniform variates . [CODESPLIT] def runiform ( lower , upper , size = None ) : return np . random . uniform ( lower , upper , size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn dict keys and values into native strings . [CODESPLIT] def stringify_dict_contents ( dct ) : return { str_if_nested_or_str ( k ) : str_if_nested_or_str ( v ) for k , v in dct . items ( ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shortcut to do range filters on genomic datasets . [CODESPLIT] def range ( self , chromosome , start , stop , exact = False ) : return self . _clone ( filters = [ GenomicFilter ( chromosome , start , stop , exact ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an appropriate positive infinity for this dtype . [CODESPLIT] def get_neg_infinity ( dtype ) : if issubclass ( dtype . type , ( np . floating , np . integer ) ) : return - np . inf if issubclass ( dtype . type , np . complexfloating ) : return - np . inf - 1j * np . inf return NINF", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns json contents as string [CODESPLIT] def open_json ( file_name ) : with open ( file_name , \"r\" ) as json_data : data = json . load ( json_data ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fast %Y - %m - %d parsing . [CODESPLIT] def parse_date ( s ) : try : return datetime . date ( int ( s [ : 4 ] ) , int ( s [ 5 : 7 ] ) , int ( s [ 8 : 10 ] ) ) except ValueError : # other accepted format used in one-day data set return datetime . datetime . strptime ( s , '%d %B %Y' ) . date ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper that clears the composition . [CODESPLIT] def _clear ( self ) : draw = ImageDraw . Draw ( self . _background_image ) draw . rectangle ( self . _device . bounding_box , fill = \"black\" ) del draw", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a public RSA key from a PEM file . [CODESPLIT] def import_public_rsa_key_from_file ( filename ) : with open ( filename , \"rb\" ) as key_file : public_key = serialization . load_pem_public_key ( key_file . read ( ) , backend = default_backend ( ) ) return public_key", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the contents of an object stored in S3 as bytes [CODESPLIT] def get_as_bytes ( self , s3_path ) : ( bucket , key ) = self . _path_to_bucket_and_key ( s3_path ) obj = self . s3 . Object ( bucket , key ) contents = obj . get ( ) [ 'Body' ] . read ( ) return contents", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": rtype : numpy matrix [CODESPLIT] def load_data ( filename ) : data = pandas . read_csv ( filename , header = None , delimiter = '\\t' , skiprows = 9 ) return data . as_matrix ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a random hash for a confirmation secret . [CODESPLIT] def hash_producer ( * args , * * kwargs ) : return hashlib . md5 ( six . text_type ( uuid . uuid4 ( ) ) . encode ( 'utf-8' ) ) . hexdigest ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param string s : under_scored string to be CamelCased : return : CamelCase version of input : rtype : str [CODESPLIT] def to_camel ( s ) : # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups return re . sub ( r'_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , '_' + s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def get_translucent_cmap ( r , g , b ) : class TranslucentCmap ( BaseColormap ) : glsl_map = \"\"\"\n        vec4 translucent_fire(float t) {{\n            return vec4({0}, {1}, {2}, t);\n        }}\n        \"\"\" . format ( r , g , b ) return TranslucentCmap ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Receive the content of url parse it as JSON and return the object . [CODESPLIT] def get_jsonparsed_data ( url ) : response = urlopen ( url ) data = response . read ( ) . decode ( 'utf-8' ) return json . loads ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add up a list of freq counts to get the total counts . [CODESPLIT] def reduce_freqs ( freqlist ) : allfreqs = np . zeros_like ( freqlist [ 0 ] ) for f in freqlist : allfreqs += f return allfreqs", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": see :: meth : RedisMap . __setitem__ [CODESPLIT] def __setitem__ ( self , field , value ) : return self . _client . hset ( self . key_prefix , field , self . _dumps ( value ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the user s registration date as a UNIX timestamp . [CODESPLIT] def get_unixtime_registered ( self ) : doc = self . _request ( self . ws_prefix + \".getInfo\" , True ) return int ( doc . getElementsByTagName ( \"registered\" ) [ 0 ] . getAttribute ( \"unixtime\" ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Push item onto heap maintaining the heap invariant . [CODESPLIT] def heappush_max ( heap , item ) : heap . append ( item ) _siftdown_max ( heap , 0 , len ( heap ) - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Visible width of a potentially multiline content . [CODESPLIT] def _multiline_width ( multiline_s , line_width_fn = len ) : return max ( map ( line_width_fn , re . split ( \"[\\r\\n]\" , multiline_s ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": returns : absolute path to where the job . ini is [CODESPLIT] def input_dir ( self ) : return os . path . abspath ( os . path . dirname ( self . inputs [ 'job_ini' ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A handy wrapper to get a remote file content [CODESPLIT] def get_remote_content ( filepath ) : with hide ( 'running' ) : temp = BytesIO ( ) get ( filepath , temp ) content = temp . getvalue ( ) . decode ( 'utf-8' ) return content . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This will equal 124 for the V1 database . [CODESPLIT] def __len__ ( self ) : length = 0 for typ , siz , _ in self . format : length += siz return length", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove problem characters from string [CODESPLIT] def remove_bad ( string ) : remove = [ ':' , ',' , '(' , ')' , ' ' , '|' , ';' , '\\'' ] for c in remove : string = string . replace ( c , '_' ) return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the unique elements of a collection even if those elements are unhashable and unsortable like dicts and sets [CODESPLIT] def unique ( seq ) : cleaned = [ ] for each in seq : if each not in cleaned : cleaned . append ( each ) return cleaned", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dataframe that is a cross between dataframes df1 and df2 [CODESPLIT] def cross_join ( df1 , df2 ) : if len ( df1 ) == 0 : return df2 if len ( df2 ) == 0 : return df1 # Add as lists so that the new index keeps the items in # the order that they are added together all_columns = pd . Index ( list ( df1 . columns ) + list ( df2 . columns ) ) df1 [ 'key' ] = 1 df2 [ 'key' ] = 1 return pd . merge ( df1 , df2 , on = 'key' ) . loc [ : , all_columns ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip all the accents from the string [CODESPLIT] def strip_accents ( string ) : return u'' . join ( ( character for character in unicodedata . normalize ( 'NFD' , string ) if unicodedata . category ( character ) != 'Mn' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Segmented min op . [CODESPLIT] def SegmentMin ( a , ids ) : func = lambda idxs : np . amin ( a [ idxs ] , axis = 0 ) return seg_map ( func , a , ids ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "remove problem characters from string [CODESPLIT] def remove_bad ( string ) : remove = [ ':' , ',' , '(' , ')' , ' ' , '|' , ';' , '\\'' ] for c in remove : string = string . replace ( c , '_' ) return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns an updated copy of the dictionary without modifying the original [CODESPLIT] def copy_and_update ( dictionary , update ) : newdict = dictionary . copy ( ) newdict . update ( update ) return newdict", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes non - alpha characters and converts spaces to hyphens . Useful for making file names . Source : http : // stackoverflow . com / questions / 5574042 / string - slugification - in - python [CODESPLIT] def slugify ( string ) : string = re . sub ( '[^\\w .-]' , '' , string ) string = string . replace ( \" \" , \"-\" ) return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cleans trailing whitespaces and replaces also multiple whitespaces with a single space . [CODESPLIT] def strip_spaces ( value , sep = None , join = True ) : value = value . strip ( ) value = [ v . strip ( ) for v in value . split ( sep ) ] join_sep = sep or ' ' return join_sep . join ( value ) if join else value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Choose the most common item from the list or the first item if all items are unique . [CODESPLIT] def mostCommonItem ( lst ) : # This elegant solution from: http://stackoverflow.com/a/1518632/1760218 lst = [ l for l in lst if l ] if lst : return max ( set ( lst ) , key = lst . count ) else : return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split message to list by commas and trim whitespace . [CODESPLIT] def __normalize_list ( self , msg ) : if isinstance ( msg , list ) : msg = \"\" . join ( msg ) return list ( map ( lambda x : x . strip ( ) , msg . split ( \",\" ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Choose the most common item from the list or the first item if all items are unique . [CODESPLIT] def mostCommonItem ( lst ) : # This elegant solution from: http://stackoverflow.com/a/1518632/1760218 lst = [ l for l in lst if l ] if lst : return max ( set ( lst ) , key = lst . count ) else : return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "reduces a multiline string to a single line of text . [CODESPLIT] def reduce_multiline ( string ) : string = str ( string ) return \" \" . join ( [ item . strip ( ) for item in string . split ( \"\\n\" ) if item . strip ( ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the element with the specified ID . [CODESPLIT] def get_element_with_id ( self , id ) : # Should we maintain a hashmap of ids to make this more efficient? Probably overkill. # TODO: Elements can contain nested elements (captions, footnotes, table cells, etc.) return next ( ( el for el in self . elements if el . id == id ) , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes a : py : class : . Series from the chart . [CODESPLIT] def remove_series ( self , series ) : if len ( self . all_series ( ) ) == 1 : raise ValueError ( \"Cannot remove last series from %s\" % str ( self ) ) self . _all_series . remove ( series ) series . _chart = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def matrixTimesVector ( MM , aa ) : bb = np . zeros ( 3 , np . float ) for ii in range ( 3 ) : bb [ ii ] = np . sum ( MM [ ii , : ] * aa ) return bb", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a Vector as the product of the vector and a real number . [CODESPLIT] def multiply ( self , number ) : return self . from_list ( [ x * number for x in self . to_list ( ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validate that the input is a list of strings . [CODESPLIT] def validate_string_list ( lst ) : if not isinstance ( lst , list ) : raise ValueError ( 'input %r must be a list' % lst ) for x in lst : if not isinstance ( x , basestring ) : raise ValueError ( 'element %r in list must be a string' % x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip agents from a string . [CODESPLIT] def strip_accents ( text ) : normalized_str = unicodedata . normalize ( 'NFD' , text ) return '' . join ( [ c for c in normalized_str if unicodedata . category ( c ) != 'Mn' ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the file name from an url Parameters ---------- url : str [CODESPLIT] def get_url_file_name ( url ) : assert isinstance ( url , ( str , _oldstr ) ) return urlparse . urlparse ( url ) . path . split ( '/' ) [ - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip accents to prepare for slugification . [CODESPLIT] def strip_accents ( s ) : nfkd = unicodedata . normalize ( 'NFKD' , unicode ( s ) ) return u'' . join ( ch for ch in nfkd if not unicodedata . combining ( ch ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "numpy . ndarray dumper . [CODESPLIT] def dump_nparray ( self , obj , class_name = numpy_ndarray_class_name ) : return { \"$\" + class_name : self . _json_convert ( obj . tolist ( ) ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transpose the columns into rows remove all of the rows that are empty after the first cell then transpose back . The result is that columns that have a header but no data in the body are removed assuming the header is the first row . [CODESPLIT] def drop_empty ( rows ) : return zip ( * [ col for col in zip ( * rows ) if bool ( filter ( bool , col [ 1 : ] ) ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "For a given value the function finds the nearest value in the array and returns its index . [CODESPLIT] def find_nearest_index ( arr , value ) : arr = np . array ( arr ) index = ( abs ( arr - value ) ) . argmin ( ) return index", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a dictionary and a key list remove any data in the dictionary with the given keys . [CODESPLIT] def rm_keys_from_dict ( d , keys ) : # Loop for each key given for key in keys : # Is the key in the dictionary? if key in d : try : d . pop ( key , None ) except KeyError : # Not concerned with an error. Keep going. pass return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "expects a _n . array returns the global minimum of ( value - array ) ^2 [CODESPLIT] def index_nearest ( value , array ) : a = ( array - value ) ** 2 return index ( a . min ( ) , a )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "non - recursively break spaces and remove newlines in the tag [CODESPLIT] def _breakRemNewlines ( tag ) : for i , c in enumerate ( tag . contents ) : if type ( c ) != bs4 . element . NavigableString : continue c . replace_with ( re . sub ( r' {2,}' , ' ' , c ) . replace ( '\\n' , '' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ignore sizes of dimensions ( 1 2 ) of a 4d tensor in shape inference . [CODESPLIT] def forget_xy ( t ) : shape = ( t . shape [ 0 ] , None , None , t . shape [ 3 ] ) return tf . placeholder_with_default ( t , shape )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get dimension of an array getting the number of rows and the max num of columns . [CODESPLIT] def get_dimension_array ( array ) : if all ( isinstance ( el , list ) for el in array ) : result = [ len ( array ) , len ( max ( [ x for x in array ] , key = len , ) ) ] # elif array and isinstance(array, list): else : result = [ len ( array ) , 1 ] return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Python s input () is blocking which means the event loop we set above can t be running while we re blocking there . This method will let the loop run while we wait for input . [CODESPLIT] async def async_input ( prompt ) : print ( prompt , end = '' , flush = True ) return ( await loop . run_in_executor ( None , sys . stdin . readline ) ) . rstrip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a list of words given text removing punctuation . [CODESPLIT] def wordify ( text ) : stopset = set ( nltk . corpus . stopwords . words ( 'english' ) ) tokens = nltk . WordPunctTokenizer ( ) . tokenize ( text ) return [ w for w in tokens if w not in stopset ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of rows preceding the data table for * series * in the Excel worksheet . [CODESPLIT] def series_table_row_offset ( self , series ) : title_and_spacer_rows = series . index * 2 data_point_rows = series . data_point_offset return title_and_spacer_rows + data_point_rows", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of rows preceding the data table for * series * in the Excel worksheet . [CODESPLIT] def series_table_row_offset ( self , series ) : title_and_spacer_rows = series . index * 2 data_point_rows = series . data_point_offset return title_and_spacer_rows + data_point_rows", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A non - optimal implementation of a regex filter [CODESPLIT] def subn_filter ( s , find , replace , count = 0 ) : return re . gsub ( find , replace , count , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "set nan and inf rows from x to zero [CODESPLIT] def clean_with_zeros ( self , x ) : x [ ~ np . any ( np . isnan ( x ) | np . isinf ( x ) , axis = 1 ) ] = 0 return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a . npy array . [CODESPLIT] def read_array ( path , mmap_mode = None ) : file_ext = op . splitext ( path ) [ 1 ] if file_ext == '.npy' : return np . load ( path , mmap_mode = mmap_mode ) raise NotImplementedError ( \"The file extension `{}` \" . format ( file_ext ) + \"is not currently supported.\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply re . sub to bunch of ( pattern repl ) [CODESPLIT] def _sub_patterns ( patterns , text ) : for pattern , repl in patterns : text = re . sub ( pattern , repl , text ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all child objects in nested lists of strings . [CODESPLIT] def as_list ( self ) : return [ self . name , self . value , [ x . as_list for x in self . children ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip apostrophe and s from the end of a string . [CODESPLIT] def unapostrophe ( text ) : text = re . sub ( r'[%s]s?$' % '' . join ( APOSTROPHES ) , '' , text ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pull a querystring value from the request . [CODESPLIT] def parse_querystring ( self , req , name , field ) : return core . get_value ( req . args , name , field )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resample spectrum onto desired grid [CODESPLIT] def resample ( grid , wl , flux ) : flux_rs = ( interpolate . interp1d ( wl , flux ) ) ( grid ) return flux_rs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Represent string / bytes s as base64 omitting newlines [CODESPLIT] def toBase64 ( s ) : if isinstance ( s , str ) : s = s . encode ( \"utf-8\" ) return binascii . b2a_base64 ( s ) [ : - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Downsample x by factor using striding . [CODESPLIT] def downsample_with_striding ( array , factor ) : return array [ tuple ( np . s_ [ : : f ] for f in factor ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the access and modified times of the file specified by path . [CODESPLIT] def utime ( self , * args , * * kwargs ) : os . utime ( self . extended_path , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to unpickle data from picklefile . [CODESPLIT] def unpickle_file ( picklefile , * * kwargs ) : with open ( picklefile , 'rb' ) as f : return pickle . load ( f , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reshape data into ( num_example batch_size ) [CODESPLIT] def batchify ( data , batch_size ) : nbatch = data . shape [ 0 ] // batch_size data = data [ : nbatch * batch_size ] data = data . reshape ( ( batch_size , nbatch ) ) . T return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Attempt to restart the bot . [CODESPLIT] def do_restart ( self , line ) : self . bot . _frame = 0 self . bot . _namespace . clear ( ) self . bot . _namespace . update ( self . bot . _initial_namespace )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns ( module locals ) of the funciton depth frames away from the caller [CODESPLIT] def extract_module_locals ( depth = 0 ) : f = sys . _getframe ( depth + 1 ) global_ns = f . f_globals module = sys . modules [ global_ns [ '__name__' ] ] return ( module , f . f_locals )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return BGR image read by opencv [CODESPLIT] def imdecode ( image_path ) : import os assert os . path . exists ( image_path ) , image_path + ' not found' im = cv2 . imread ( image_path ) return im", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a generator of tuples k c such that k is the name of the python attribute for the column and c is the name of the column in the sql table . [CODESPLIT] def get_column_keys_and_names ( table ) : ins = inspect ( table ) return ( ( k , c . name ) for k , c in ins . mapper . c . items ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Natural sort order [CODESPLIT] def naturalsortkey ( s ) : return [ int ( part ) if part . isdigit ( ) else part for part in re . split ( '([0-9]+)' , s ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return zero - th element of a one - element data container . [CODESPLIT] def get_X0 ( X ) : if pandas_available and isinstance ( X , pd . DataFrame ) : assert len ( X ) == 1 x = np . array ( X . iloc [ 0 ] ) else : x , = X return x", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return one vector projected on the vector other [CODESPLIT] def project ( self , other ) : n = other . normalized ( ) return self . dot ( n ) * n", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Preprocess string to transform all diacritics and remove other special characters than appropriate : param string : : return : [CODESPLIT] def preprocess ( string ) : string = unicode ( string , encoding = \"utf-8\" ) # convert diacritics to simpler forms string = regex1 . sub ( lambda x : accents [ x . group ( ) ] , string ) # remove all rest of the unwanted characters return regex2 . sub ( '' , string ) . encode ( 'utf-8' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return current datetime with timezone applied [ all timezones ] print sorted ( pytz . all_timezones ) [CODESPLIT] def timestamp ( format = DATEFMT , timezone = 'Africa/Johannesburg' ) : return formatdate ( datetime . now ( tz = pytz . timezone ( timezone ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "try to get a string from the lookup table return instead of key error [CODESPLIT] def _try_lookup ( table , value , default = \"\" ) : try : string = table [ value ] except KeyError : string = default return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write a file with the PID of this server instance . [CODESPLIT] def write_pid_file ( ) : pidfile = os . path . basename ( sys . argv [ 0 ] ) [ : - 3 ] + '.pid' # strip .py, add .pid with open ( pidfile , 'w' ) as fh : fh . write ( \"%d\\n\" % os . getpid ( ) ) fh . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "reverse the k : v pairs [CODESPLIT] def inverse ( d ) : output = { } for k , v in unwrap ( d ) . items ( ) : output [ v ] = output . get ( v , [ ] ) output [ v ] . append ( k ) return output", "target": 1, "target_options": ["no_match", "match"]}
{"input": "given a segment ( rectangle ) and an image returns it s corresponding subimage [CODESPLIT] def region_from_segment ( image , segment ) : x , y , w , h = segment return image [ y : y + h , x : x + w ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Round a time DOWN to half nearest half - hour . [CODESPLIT] def _round_half_hour ( record ) : k = record . datetime + timedelta ( minutes = - ( record . datetime . minute % 30 ) ) return datetime ( k . year , k . month , k . day , k . hour , k . minute , 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function for splitting 2D data into x and y component to make equations simpler [CODESPLIT] def unpack2D ( _x ) : _x = np . atleast_2d ( _x ) x = _x [ : , 0 ] y = _x [ : , 1 ] return x , y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Round a datetime object to a multiple of a timedelta dt : datetime . datetime object default now . [CODESPLIT] def __round_time ( self , dt ) : round_to = self . _resolution . total_seconds ( ) seconds = ( dt - dt . min ) . seconds rounding = ( seconds + round_to / 2 ) // round_to * round_to return dt + timedelta ( 0 , rounding - seconds , - dt . microsecond )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Crops and / or pads an image to a target width and height . [CODESPLIT] def resize_image_with_crop_or_pad ( img , target_height , target_width ) : h , w = target_height , target_width max_h , max_w , c = img . shape # crop img = crop_center ( img , min ( max_h , h ) , min ( max_w , w ) ) # pad padded_img = np . zeros ( shape = ( h , w , c ) , dtype = img . dtype ) padded_img [ : img . shape [ 0 ] , : img . shape [ 1 ] , : img . shape [ 2 ] ] = img return padded_img", "target": 1, "target_options": ["no_match", "match"]}
{"input": "helper function for parsing FRED date string into datetime [CODESPLIT] def _parse ( self , date_str , format = '%Y-%m-%d' ) : rv = pd . to_datetime ( date_str , format = format ) if hasattr ( rv , 'to_pydatetime' ) : rv = rv . to_pydatetime ( ) return rv", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Temporary helper function to link to the API routes [CODESPLIT] def home ( ) : return dict ( links = dict ( api = '{}{}' . format ( request . url , PREFIX [ 1 : ] ) ) ) , HTTPStatus . OK", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of all parsed comments in a file . Mostly for testing & interactive use . [CODESPLIT] def parse_comments_for_file ( filename ) : return [ parse_comment ( strip_stars ( comment ) , next_line ) for comment , next_line in get_doc_comments ( read_file ( filename ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Start web application [CODESPLIT] def web ( host , port ) : from . webserver . web import get_app get_app ( ) . run ( host = host , port = port )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "View the quaternion array as an array of floats [CODESPLIT] def as_float_array ( a ) : return np . asarray ( a , dtype = np . quaternion ) . view ( ( np . double , 4 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run the event loop . [CODESPLIT] def run ( self ) : self . signal_init ( ) self . listen_init ( ) self . logger . info ( 'starting' ) self . loop . start ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert the parameter into a dictionary before calling jsonp if it s not already one [CODESPLIT] def dict_jsonp ( param ) : if not isinstance ( param , dict ) : param = dict ( param ) return jsonp ( param )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a file and close it . Returns the file source . [CODESPLIT] def file_read ( filename ) : fobj = open ( filename , 'r' ) source = fobj . read ( ) fobj . close ( ) return source", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calls the specified Trigger of another Area with the optionally given parameters . [CODESPLIT] def trigger ( self , target : str , trigger : str , parameters : Dict [ str , Any ] = { } ) : pass", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Categorical accuracy [CODESPLIT] def cat_acc ( y_true , y_pred ) : return np . mean ( y_true . argmax ( axis = 1 ) == y_pred . argmax ( axis = 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Measured similarity between two points in a multi - dimensional space . [CODESPLIT] def tanimoto_coefficient ( a , b ) : return sum ( map ( lambda ( x , y ) : float ( x ) * float ( y ) , zip ( a , b ) ) ) / sum ( [ - sum ( map ( lambda ( x , y ) : float ( x ) * float ( y ) , zip ( a , b ) ) ) , sum ( map ( lambda x : float ( x ) ** 2 , a ) ) , sum ( map ( lambda x : float ( x ) ** 2 , b ) ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flat nested list of lists into a single list . [CODESPLIT] def flatten ( l , types = ( list , float ) ) : l = [ item if isinstance ( item , types ) else [ item ] for item in l ] return [ item for sublist in l for item in sublist ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Complex non - optimized Discrete Fourier Transform [CODESPLIT] def dft ( blk , freqs , normalize = True ) : dft_data = ( sum ( xn * cexp ( - 1j * n * f ) for n , xn in enumerate ( blk ) ) for f in freqs ) if normalize : lblk = len ( blk ) return [ v / lblk for v in dft_data ] return list ( dft_data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "save something to a pickle file [CODESPLIT] def pickle_save ( thing , fname ) : pickle . dump ( thing , open ( fname , \"wb\" ) , pickle . HIGHEST_PROTOCOL ) return thing", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replaces occurrences of a match string in a given list of strings and returns a list of new strings . The match string can be a regex expression . [CODESPLIT] def replace_list ( items , match , replacement ) : return [ replace ( item , match , replacement ) for item in items ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Saves the dictionary in json format : param fname : file to save to [CODESPLIT] def save ( self , fname ) : with open ( fname , 'wb' ) as f : json . dump ( self , f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Plots the classification decision boundary of model on X with labels y . Using numpy and matplotlib . [CODESPLIT] def plot_decision_boundary ( model , X , y , step = 0.1 , figsize = ( 10 , 8 ) , alpha = 0.4 , size = 20 ) : x_min , x_max = X [ : , 0 ] . min ( ) - 1 , X [ : , 0 ] . max ( ) + 1 y_min , y_max = X [ : , 1 ] . min ( ) - 1 , X [ : , 1 ] . max ( ) + 1 xx , yy = np . meshgrid ( np . arange ( x_min , x_max , step ) , np . arange ( y_min , y_max , step ) ) f , ax = plt . subplots ( figsize = figsize ) Z = model . predict ( np . c_ [ xx . ravel ( ) , yy . ravel ( ) ] ) Z = Z . reshape ( xx . shape ) ax . contourf ( xx , yy , Z , alpha = alpha ) ax . scatter ( X [ : , 0 ] , X [ : , 1 ] , c = y , s = size , edgecolor = 'k' ) plt . show ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "stupid windows . converts the backslash to forwardslash for consistency [CODESPLIT] def __unixify ( self , s ) : return os . path . normpath ( s ) . replace ( os . sep , \"/\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Output a networkx graph to a DOT file . [CODESPLIT] def to_dotfile ( G : nx . DiGraph , filename : str ) : A = to_agraph ( G ) A . write ( filename )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Marshal incoming data into Python objects . [CODESPLIT] def _deserialize ( cls , key , value , fields ) : converter = cls . _get_converter_for_field ( key , None , fields ) return converter . deserialize ( value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "print a binary tree [CODESPLIT] def print_bintree ( tree , indent = '  ' ) : for n in sorted ( tree . keys ( ) ) : print \"%s%s\" % ( indent * depth ( n , tree ) , n )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Zoom into axis . [CODESPLIT] def zoom ( ax , xy = 'x' , factor = 1 ) : limits = ax . get_xlim ( ) if xy == 'x' else ax . get_ylim ( ) new_limits = ( 0.5 * ( limits [ 0 ] + limits [ 1 ] ) + 1. / factor * np . array ( ( - 0.5 , 0.5 ) ) * ( limits [ 1 ] - limits [ 0 ] ) ) if xy == 'x' : ax . set_xlim ( new_limits ) else : ax . set_ylim ( new_limits )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raw print to sys . __stdout__ otherwise identical interface to print () . [CODESPLIT] def raw_print ( * args , * * kw ) : print ( * args , sep = kw . get ( 'sep' , ' ' ) , end = kw . get ( 'end' , '\\n' ) , file = sys . __stdout__ ) sys . __stdout__ . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show a basic reference about the GUI Console . [CODESPLIT] def page_guiref ( arg_s = None ) : from IPython . core import page page . page ( gui_reference , auto_html = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute a normal python statement in user namespace . [CODESPLIT] def ex ( self , cmd ) : with self . builtin_trap : exec cmd in self . user_global_ns , self . user_ns", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the URL that was the source of this response . If the request that generated this response redirected this method will return the final redirect location . [CODESPLIT] def geturl ( self ) : if self . retries is not None and len ( self . retries . history ) : return self . retries . history [ - 1 ] . redirect_location else : return self . _request_url", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns elapsed time at update . [CODESPLIT] def _elapsed ( self ) : self . last_time = time . time ( ) return self . last_time - self . start", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Use Python % format strings as template format specifiers . [CODESPLIT] def PythonPercentFormat ( format_str ) : if format_str . startswith ( 'printf ' ) : fmt = format_str [ len ( 'printf ' ) : ] return lambda value : fmt % value else : return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return attrs with keys in keys list [CODESPLIT] def _pick_attrs ( attrs , keys ) : return dict ( ( k , v ) for k , v in attrs . items ( ) if k in keys )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print something on screen when self . verbose == True [CODESPLIT] def _screen ( self , s , newline = False ) : if self . verbose : if newline : print ( s ) else : print ( s , end = ' ' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create output from Jinja template . [CODESPLIT] def gen_text ( env : TextIOBase , package : str , tmpl : str ) : if env : env_args = json_datetime . load ( env ) else : env_args = { } jinja_env = template . setup ( package ) echo ( jinja_env . get_template ( tmpl ) . render ( * * env_args ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the dotproduct of two vectors . [CODESPLIT] def dot_v3 ( v , w ) : return sum ( [ x * y for x , y in zip ( v , w ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve requested URL [CODESPLIT] def _get_url ( url ) : try : data = HTTP_SESSION . get ( url , stream = True ) data . raise_for_status ( ) except requests . exceptions . RequestException as exc : raise FetcherException ( exc ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "sets the aspect ratio of the current zoom level of the imshow image [CODESPLIT] def image_set_aspect ( aspect = 1.0 , axes = \"gca\" ) : if axes is \"gca\" : axes = _pylab . gca ( ) e = axes . get_images ( ) [ 0 ] . get_extent ( ) axes . set_aspect ( abs ( ( e [ 1 ] - e [ 0 ] ) / ( e [ 3 ] - e [ 2 ] ) ) / aspect )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Encodes Unicode strings to byte strings if necessary . [CODESPLIT] def b ( s ) : return s if isinstance ( s , bytes ) else s . encode ( locale . getpreferredencoding ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the pixel at ( x y ) to the integers in sequence color . [CODESPLIT] def setPixel ( self , x , y , color ) : return _fitz . Pixmap_setPixel ( self , x , y , color )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Establish tunnel connection early because otherwise httplib would improperly set Host : header to proxy s IP : port . [CODESPLIT] def _prepare_proxy ( self , conn ) : conn . set_tunnel ( self . _proxy_host , self . port , self . proxy_headers ) conn . connect ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Serialises a protobuf object as json [CODESPLIT] def toJson ( protoObject , indent = None ) : # Using the internal method because this way we can reformat the JSON js = json_format . MessageToDict ( protoObject , False ) return json . dumps ( js , indent = indent )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clears the default matplotlib ticks . [CODESPLIT] def clear_matplotlib_ticks ( self , axis = \"both\" ) : ax = self . get_axes ( ) plotting . clear_matplotlib_ticks ( ax = ax , axis = axis )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the name of the newest file given an iterable of file names . [CODESPLIT] def newest_file ( file_iterable ) : return max ( file_iterable , key = lambda fname : os . path . getmtime ( fname ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates or updates a property for the instance for each parameter . [CODESPLIT] def update ( self , * * kwargs ) : for key , value in kwargs . items ( ) : setattr ( self , key , value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a leading hash # at the beginning of every line in the source . [CODESPLIT] def _add_hash ( source ) : source = '\\n' . join ( '# ' + line . rstrip ( ) for line in source . splitlines ( ) ) return source", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Draw a horizontal line up to a given length . [CODESPLIT] def hline ( self , x , y , width , color ) : self . rect ( x , y , width , 1 , color , fill = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Obtain a real address as an integer from an objectproxy . [CODESPLIT] def objectproxy_realaddress ( obj ) : voidp = QROOT . TPython . ObjectProxy_AsVoidPtr ( obj ) return C . addressof ( C . c_char . from_buffer ( voidp ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for plotting . [CODESPLIT] def finish_plot ( ) : plt . legend ( ) plt . grid ( color = '0.7' ) plt . xlabel ( 'x' ) plt . ylabel ( 'y' ) plt . show ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve contents of each page of PDF [CODESPLIT] def resources ( self ) : return [ self . pdf . getPage ( i ) for i in range ( self . pdf . getNumPages ( ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the smallest angle going from angle source to angle target . [CODESPLIT] def smallest_signed_angle ( source , target ) : dth = target - source dth = ( dth + np . pi ) % ( 2.0 * np . pi ) - np . pi return dth", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Closest distance between a line segment and a point [CODESPLIT] def distance_to_line ( a , b , p ) : return distance ( closest_point ( a , b , p ) , p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Dump Python object as JSON string . [CODESPLIT] def dump_json ( obj ) : return simplejson . dumps ( obj , ignore_nan = True , default = json_util . default )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Emit a sine wave at the given frequency . [CODESPLIT] def sine_wave ( frequency ) : xs = tf . reshape ( tf . range ( _samples ( ) , dtype = tf . float32 ) , [ 1 , _samples ( ) , 1 ] ) ts = xs / FLAGS . sample_rate return tf . sin ( 2 * math . pi * frequency * ts )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set of bound SymPy symbols contained within the equation . [CODESPLIT] def bound_symbols ( self ) : try : lhs_syms = self . lhs . bound_symbols except AttributeError : lhs_syms = set ( ) try : rhs_syms = self . rhs . bound_symbols except AttributeError : rhs_syms = set ( ) return lhs_syms | rhs_syms", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get dimension of an array getting the number of rows and the max num of columns . [CODESPLIT] def get_dimension_array ( array ) : if all ( isinstance ( el , list ) for el in array ) : result = [ len ( array ) , len ( max ( [ x for x in array ] , key = len , ) ) ] # elif array and isinstance(array, list): else : result = [ len ( array ) , 1 ] return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if the given value is a scalar . [CODESPLIT] def is_scalar ( value ) : return np . isscalar ( value ) or ( isinstance ( value , np . ndarray ) and ( len ( np . squeeze ( value ) . shape ) == 0 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "iterator version of get_list_column [CODESPLIT] def iget_list_column_slice ( list_ , start = None , stop = None , stride = None ) : if isinstance ( start , slice ) : slice_ = start else : slice_ = slice ( start , stop , stride ) return ( row [ slice_ ] for row in list_ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Unified rounding in all python versions . [CODESPLIT] def py3round ( number ) : if abs ( round ( number ) - number ) == 0.5 : return int ( 2.0 * round ( number / 2.0 ) ) return int ( round ( number ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Unified rounding in all python versions . [CODESPLIT] def py3round ( number ) : if abs ( round ( number ) - number ) == 0.5 : return int ( 2.0 * round ( number / 2.0 ) ) return int ( round ( number ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Natural sort order [CODESPLIT] def naturalsortkey ( s ) : return [ int ( part ) if part . isdigit ( ) else part for part in re . split ( '([0-9]+)' , s ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a list unique retaining order of initial appearance . [CODESPLIT] def unique_list ( lst ) : uniq = [ ] for item in lst : if item not in uniq : uniq . append ( item ) return uniq", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Natural sort order [CODESPLIT] def naturalsortkey ( s ) : return [ int ( part ) if part . isdigit ( ) else part for part in re . split ( '([0-9]+)' , s ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Natural sort order [CODESPLIT] def naturalsortkey ( s ) : return [ int ( part ) if part . isdigit ( ) else part for part in re . split ( '([0-9]+)' , s ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "converts py2 unicode / py3 bytestring into str Args : string ( unicode byte_string ) : string to be converted Returns : ( str ) [CODESPLIT] def ub_to_str ( string ) : if not isinstance ( string , str ) : if six . PY2 : return str ( string ) else : return string . decode ( ) return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sort list elements by name . [CODESPLIT] def sort_by_name ( self ) : super ( JSSObjectList , self ) . sort ( key = lambda k : k . name )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Splits string into n sized chunks . [CODESPLIT] def schunk ( string , size ) : return [ string [ i : i + size ] for i in range ( 0 , len ( string ) , size ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all rows from a cursor as a dict . [CODESPLIT] def _dictfetchall ( self , cursor ) : columns = [ col [ 0 ] for col in cursor . description ] return [ dict ( zip ( columns , row ) ) for row in cursor . fetchall ( ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the media - type of the file at the given filepath [CODESPLIT] def guess_media_type ( filepath ) : o = subprocess . check_output ( [ 'file' , '--mime-type' , '-Lb' , filepath ] ) o = o . strip ( ) return o", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Splits a string into parts at multiple characters [CODESPLIT] def _split ( string , splitters ) : part = '' for character in string : if character in splitters : yield part part = '' else : part += character yield part", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def mouse_get_pos ( ) : p = POINT ( ) AUTO_IT . AU3_MouseGetPos ( ctypes . byref ( p ) ) return p . x , p . y", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param source : some iterable source ( list file etc ) : param lineSep : string of separators ( chars ) that must be removed : return : list of non empty lines with removed separators [CODESPLIT] def cleanLines ( source , lineSep = os . linesep ) : stripped = ( line . strip ( lineSep ) for line in source ) return ( line for line in stripped if len ( line ) != 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "read a simple text file from a private location to get username and password [CODESPLIT] def read_credentials ( fname ) : with open ( fname , 'r' ) as f : username = f . readline ( ) . strip ( '\\n' ) password = f . readline ( ) . strip ( '\\n' ) return username , password", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Splits a list into chunks [CODESPLIT] def chunks ( arr , size ) : for i in _range ( 0 , len ( arr ) , size ) : yield arr [ i : i + size ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Obtain a logger for the calling module . [CODESPLIT] def calling_logger ( height = 1 ) : stack = inspect . stack ( ) height = min ( len ( stack ) - 1 , height ) caller = stack [ height ] scope = caller [ 0 ] . f_globals path = scope [ '__name__' ] if path == '__main__' : path = scope [ '__package__' ] or os . path . basename ( sys . argv [ 0 ] ) return logging . getLogger ( path )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wipe the store [CODESPLIT] def wipe ( self ) : query = \"DELETE FROM {}\" . format ( self . __tablename__ ) connection = sqlite3 . connect ( self . sqlite_file ) cursor = connection . cursor ( ) cursor . execute ( query ) connection . commit ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Python s input () is blocking which means the event loop we set above can t be running while we re blocking there . This method will let the loop run while we wait for input . [CODESPLIT] async def async_input ( prompt ) : print ( prompt , end = '' , flush = True ) return ( await loop . run_in_executor ( None , sys . stdin . readline ) ) . rstrip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deserialize b ( instance of bytes ) to a Python object . [CODESPLIT] def loadb ( b ) : assert isinstance ( b , ( bytes , bytearray ) ) return std_json . loads ( b . decode ( 'utf-8' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform list into a maxheap in - place in O ( len ( x )) time . [CODESPLIT] def _heapify_max ( x ) : n = len ( x ) for i in reversed ( range ( n // 2 ) ) : _siftup_max ( x , i )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Outputs json with formatting edits + object handling . [CODESPLIT] def dumps ( obj ) : return json . dumps ( obj , indent = 4 , sort_keys = True , cls = CustomEncoder )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the string without any initial or final quotes . [CODESPLIT] def _repr_strip ( mystring ) : r = repr ( mystring ) if r . startswith ( \"'\" ) and r . endswith ( \"'\" ) : return r [ 1 : - 1 ] else : return r", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform list into a maxheap in - place in O ( len ( x )) time . [CODESPLIT] def _heapify_max ( x ) : n = len ( x ) for i in reversed ( range ( n // 2 ) ) : _siftup_max ( x , i )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Softsign op . [CODESPLIT] def Softsign ( a ) : return np . divide ( a , np . add ( np . abs ( a ) , 1 ) ) ,", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieve a simple OAuth Token for use with the local http client . [CODESPLIT] def get_oauth_token ( ) : url = \"{0}/token\" . format ( DEFAULT_ORIGIN [ \"Origin\" ] ) r = s . get ( url = url ) return r . json ( ) [ \"t\" ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update conda packages in a conda env [CODESPLIT] def update ( packages , env = None , user = None ) : packages = ' ' . join ( packages . split ( ',' ) ) cmd = _create_conda_cmd ( 'update' , args = [ packages , '--yes' , '-q' ] , env = env , user = user ) return _execcmd ( cmd , user = user )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn list of keywords into dictionary . [CODESPLIT] def _kw ( keywords ) : r = { } for k , v in keywords : r [ k ] = v return r", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print out a log message only if verbose mode . [CODESPLIT] def logv ( msg , * args , * * kwargs ) : if settings . VERBOSE : log ( msg , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ajout d un message de log de type DEBUG [CODESPLIT] def debug ( self , text ) : self . logger . debug ( \"{}{}\" . format ( self . message_prefix , text ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Encode a python boolean ( True / False ) . [CODESPLIT] def _encode_bool ( name , value , dummy0 , dummy1 ) : return b\"\\x08\" + name + ( value and b\"\\x01\" or b\"\\x00\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets a new value to map element [CODESPLIT] def set_as_object ( self , value ) : self . clear ( ) map = MapConverter . to_map ( value ) self . append ( map )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine with width in pixels of string . [CODESPLIT] def text_width ( string , font_name , font_size ) : return stringWidth ( string , fontName = font_name , fontSize = font_size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Store ipython references in the __builtin__ namespace . [CODESPLIT] def activate ( self ) : add_builtin = self . add_builtin for name , func in self . auto_builtins . iteritems ( ) : add_builtin ( name , func )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return list - lookalike of representation string of objects [CODESPLIT] def __repr__ ( self ) : strings = [ ] for currItem in self : strings . append ( \"%s\" % currItem ) return \"(%s)\" % ( \", \" . join ( strings ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compile XML mappings in addition to base add behavior . [CODESPLIT] def add_to_enum ( self , clsdict ) : super ( XmlMappedEnumMember , self ) . add_to_enum ( clsdict ) self . register_xml_mapping ( clsdict )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns all rows from a cursor as a dict ( rather than a headerless table ) [CODESPLIT] def dictfetchall ( cursor ) : desc = cursor . description return [ dict ( zip ( [ col [ 0 ] for col in desc ] , row ) ) for row in cursor . fetchall ( ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "I strip extra whitespace off multi - line strings if they are ready to be stripped! [CODESPLIT] def text_cleanup ( data , key , last_type ) : if key in data and last_type == STRING_TYPE : data [ key ] = data [ key ] . strip ( ) return data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if value can be part of binary / bitwise operations . [CODESPLIT] def isbinary ( * args ) : return all ( map ( lambda c : isnumber ( c ) or isbool ( c ) , args ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the angle between vectors a and b in degrees . [CODESPLIT] def angle ( x , y ) : return arccos ( dot ( x , y ) / ( norm ( x ) * norm ( y ) ) ) * 180. / pi", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets the title on the underlying matplotlib AxesSubplot . [CODESPLIT] def set_title ( self , title , * * kwargs ) : ax = self . get_axes ( ) ax . set_title ( title , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Communicate with the child process without closing stdin . [CODESPLIT] def correspond ( text ) : subproc . stdin . write ( text ) subproc . stdin . flush ( ) return drain ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "apply a function to all non - dict values in a dictionary [CODESPLIT] def dictapply ( d , fn ) : for k , v in d . items ( ) : if isinstance ( v , dict ) : v = dictapply ( v , fn ) else : d [ k ] = fn ( v ) return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "decorator to convert a * args method to one taking a iterable [CODESPLIT] def _varargs_to_iterable_method ( func ) : def wrapped ( self , iterable , * * kwargs ) : return func ( self , * iterable , * * kwargs ) return wrapped", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Redirect to the canonical URI for this resource . [CODESPLIT] def redirect ( cls , request , response ) : if cls . meta . legacy_redirect : if request . method in ( 'GET' , 'HEAD' , ) : # A SAFE request is allowed to redirect using a 301 response . status = http . client . MOVED_PERMANENTLY else : # All other requests must use a 307 response . status = http . client . TEMPORARY_REDIRECT else : # Modern redirects are allowed. Let's have some fun. # Hopefully you're client supports this. # The RFC explicitly discourages UserAgent sniffing. response . status = http . client . PERMANENT_REDIRECT # Terminate the connection. response . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace the format variables in all items of data . [CODESPLIT] def _replace_variables ( data , variables ) : formatter = string . Formatter ( ) return [ formatter . vformat ( item , [ ] , variables ) for item in data ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Show exception with traceback . [CODESPLIT] def format_exc ( * exc_info ) : typ , exc , tb = exc_info or sys . exc_info ( ) error = traceback . format_exception ( typ , exc , tb ) return \"\" . join ( error )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert this confusion matrix into a 2x2 plain list of values . [CODESPLIT] def to_list ( self ) : return [ [ int ( self . table . cell_values [ 0 ] [ 1 ] ) , int ( self . table . cell_values [ 0 ] [ 2 ] ) ] , [ int ( self . table . cell_values [ 1 ] [ 1 ] ) , int ( self . table . cell_values [ 1 ] [ 2 ] ) ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a list of coords for 3 points Compute the area of this triangle . [CODESPLIT] def get_tri_area ( pts ) : a , b , c = pts [ 0 ] , pts [ 1 ] , pts [ 2 ] v1 = np . array ( b ) - np . array ( a ) v2 = np . array ( c ) - np . array ( a ) area_tri = abs ( sp . linalg . norm ( sp . cross ( v1 , v2 ) ) / 2 ) return area_tri", "target": 1, "target_options": ["no_match", "match"]}
{"input": "matching of datetimes in time columns for data filtering [CODESPLIT] def datetime_match ( data , dts ) : dts = dts if islistable ( dts ) else [ dts ] if any ( [ not isinstance ( i , datetime . datetime ) for i in dts ] ) : error_msg = ( \"`time` can only be filtered by datetimes\" ) raise TypeError ( error_msg ) return data . isin ( dts )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove duplicates in a list . [CODESPLIT] def _uniquify ( _list ) : seen = set ( ) result = [ ] for x in _list : if x not in seen : result . append ( x ) seen . add ( x ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Command line parser . [CODESPLIT] def parse_command_args ( ) : parser = argparse . ArgumentParser ( description = 'Register PB devices.' ) parser . add_argument ( 'num_pb' , type = int , help = 'Number of PBs devices to register.' ) return parser . parse_args ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pauses script execution until a given process exists . : param process : : param timeout : : return : [CODESPLIT] def process_wait ( process , timeout = 0 ) : ret = AUTO_IT . AU3_ProcessWait ( LPCWSTR ( process ) , INT ( timeout ) ) return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A tensorflow variable tranfomed to be constrained in a L2 unit ball . [CODESPLIT] def unit_ball_L2 ( shape ) : x = tf . Variable ( tf . zeros ( shape ) ) return constrain_L2 ( x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "\\ Asserts that two iterables contain the same values . [CODESPLIT] def expect_all ( a , b ) : assert all ( _a == _b for _a , _b in zip_longest ( a , b ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Hparams for transformer on LM pretraining ( with 64k vocab ) on TPU . [CODESPLIT] def transformer_tall_pretrain_lm_tpu_adafactor ( ) : hparams = transformer_tall_pretrain_lm ( ) update_hparams_for_tpu ( hparams ) hparams . max_length = 1024 # For multi-problem on TPU we need it in absolute examples. hparams . batch_size = 8 hparams . multiproblem_vocab_size = 2 ** 16 return hparams", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Assert that a value must be a given type . [CODESPLIT] def _assert_is_type ( name , value , value_type ) : if not isinstance ( value , value_type ) : if type ( value_type ) is tuple : types = ', ' . join ( t . __name__ for t in value_type ) raise ValueError ( '{0} must be one of ({1})' . format ( name , types ) ) else : raise ValueError ( '{0} must be {1}' . format ( name , value_type . __name__ ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates data is a timestamp [CODESPLIT] def is_timestamp ( instance ) : if not isinstance ( instance , ( int , str ) ) : return True return datetime . fromtimestamp ( int ( instance ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a structured NumPy array into a Table . [CODESPLIT] def from_array ( cls , arr ) : return cls ( ) . with_columns ( [ ( f , arr [ f ] ) for f in arr . dtype . names ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns whether * obj * is iterable lazily such as generators range objects etc . [CODESPLIT] def is_lazy_iterable ( obj ) : return isinstance ( obj , ( types . GeneratorType , collections . MappingView , six . moves . range , enumerate ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Called when asyncio . Protocol loses the network connection . [CODESPLIT] def connection_lost ( self , exc ) : if exc is None : self . log . warning ( 'eof from receiver?' ) else : self . log . warning ( 'Lost connection to receiver: %s' , exc ) self . transport = None if self . _connection_lost_callback : self . _loop . call_soon ( self . _connection_lost_callback )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Center all lines of the text . It is assumed that all lines width is smaller then B { width } because the line width will not be checked . Args : text ( str ) : Text to wrap . width ( int ) : Maximum number of characters per line . Returns : str : Centered text . [CODESPLIT] def center_text ( text , width = 80 ) : centered = [ ] for line in text . splitlines ( ) : centered . append ( line . center ( width ) ) return \"\\n\" . join ( centered )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "StringIO constructor shim for the async wrapper . [CODESPLIT] def StringIO ( * args , * * kwargs ) : raw = sync_io . StringIO ( * args , * * kwargs ) return AsyncStringIOWrapper ( raw )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert obj to the timezone timezone . [CODESPLIT] def convert_timezone ( obj , timezone ) : if timezone is None : return obj . replace ( tzinfo = None ) return pytz . timezone ( timezone ) . localize ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": py : func : asyncio . coroutine [CODESPLIT] async def write ( self , data ) : await self . wait ( \"write\" ) start = _now ( ) await super ( ) . write ( data ) self . append ( \"write\" , data , start )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update inplace widgets position when doing vertical scroll [CODESPLIT] def yview ( self , * args ) : self . after_idle ( self . __updateWnds ) ttk . Treeview . yview ( self , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Debug a single doctest docstring in argument src [CODESPLIT] def debug_src ( src , pm = False , globs = None ) : testsrc = script_from_examples ( src ) debug_script ( testsrc , pm , globs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Scroll both categories Canvas and scrolling container [CODESPLIT] def _set_scroll_v ( self , * args ) : self . _canvas_categories . yview ( * args ) self . _canvas_scroll . yview ( * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get distance between pairs of lat - lon points [CODESPLIT] def Distance ( lat1 , lon1 , lat2 , lon2 ) : az12 , az21 , dist = wgs84_geod . inv ( lon1 , lat1 , lon2 , lat2 ) return az21 , dist", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Display some text in a monospaced font with no line wrapping . This function is suitable for displaying code and text that is formatted using spaces . [CODESPLIT] def codebox ( msg = \"\" , title = \" \" , text = \"\" ) : return tb . textbox ( msg , title , text , codebox = 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "move to util_iter [CODESPLIT] def isetdiff_flags ( list1 , list2 ) : set2 = set ( list2 ) return ( item not in set2 for item in list1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "print ( out the results of the comparison using a nice table ) [CODESPLIT] def printComparison ( results , class_or_prop ) : data = [ ] Row = namedtuple ( 'Row' , [ class_or_prop , 'VALIDATED' ] ) for k , v in sorted ( results . items ( ) , key = lambda x : x [ 1 ] ) : data += [ Row ( k , str ( v ) ) ] pprinttable ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert axis coordinate to bin index . [CODESPLIT] def val_to_bin ( edges , x ) : ibin = np . digitize ( np . array ( x , ndmin = 1 ) , edges ) - 1 return ibin", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a sentence and adds a newline every words_per_line words . [CODESPLIT] def split_long_sentence ( sentence , words_per_line ) : words = sentence . split ( ' ' ) split_sentence = '' for i in range ( len ( words ) ) : split_sentence = split_sentence + words [ i ] if ( i + 1 ) % words_per_line == 0 : split_sentence = split_sentence + '\\n' elif i != len ( words ) - 1 : split_sentence = split_sentence + \" \" return split_sentence", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Install the hooks for focus events . [CODESPLIT] def hook_focus_events ( self ) : widget = self . widget widget . focusInEvent = self . focusInEvent widget . focusOutEvent = self . focusOutEvent", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the given cached item is invalid . [CODESPLIT] def needs_update ( self , cache_key ) : if not self . cacheable ( cache_key ) : # An uncacheable CacheKey is always out of date. return True return self . _read_sha ( cache_key ) != cache_key . hash", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove a file from an AWS S3 bucket . [CODESPLIT] def remove_file_from_s3 ( awsclient , bucket , key ) : client_s3 = awsclient . get_client ( 's3' ) response = client_s3 . delete_object ( Bucket = bucket , Key = key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update the dev_info data from a dictionary . [CODESPLIT] def update ( self , params ) : dev_info = self . json_state . get ( 'deviceInfo' ) dev_info . update ( { k : params [ k ] for k in params if dev_info . get ( k ) } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads an array from bytestring with big - endian data . [CODESPLIT] def be_array_from_bytes ( fmt , data ) : arr = array . array ( str ( fmt ) , data ) return fix_byteorder ( arr )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A coroutine which creates a tshark process runs the given callback on each packet that is received from it and closes the process when it is done . [CODESPLIT] async def packets_from_tshark ( self , packet_callback , packet_count = None , close_tshark = True ) : tshark_process = await self . _get_tshark_process ( packet_count = packet_count ) try : await self . _go_through_packets_from_fd ( tshark_process . stdout , packet_callback , packet_count = packet_count ) except StopCapture : pass finally : if close_tshark : await self . _close_async ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is the same functionality as int . from_bytes in python 3 [CODESPLIT] def _from_bytes ( bytes , byteorder = \"big\" , signed = False ) : return int . from_bytes ( bytes , byteorder = byteorder , signed = signed )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "As a convenience turn Python lists and tuples into NumPy arrays . [CODESPLIT] def _to_array ( value ) : if isinstance ( value , ( tuple , list ) ) : return array ( value ) elif isinstance ( value , ( float , int ) ) : return np . float64 ( value ) else : return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Source : https : // github . com / ipython / ipython_genutils [CODESPLIT] def cast_bytes ( s , encoding = None ) : if not isinstance ( s , bytes ) : return encode ( s , encoding ) return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "String to binary . [CODESPLIT] def s2b ( s ) : ret = [ ] for c in s : ret . append ( bin ( ord ( c ) ) [ 2 : ] . zfill ( 8 ) ) return \"\" . join ( ret )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coerce value to an JSON - compatible representation . [CODESPLIT] def _bytes_to_json ( value ) : if isinstance ( value , bytes ) : value = base64 . standard_b64encode ( value ) . decode ( \"ascii\" ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Random uniform variates . [CODESPLIT] def runiform ( lower , upper , size = None ) : return np . random . uniform ( lower , upper , size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieves the cached data value for the specified engine version hash and dictionary key [CODESPLIT] def getCachedDataKey ( engineVersionHash , key ) : cacheFile = CachedDataManager . _cacheFileForHash ( engineVersionHash ) return JsonDataManager ( cacheFile ) . getKey ( key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create unique labels . [CODESPLIT] def get_labels ( labels ) : label_u = unique_labels ( labels ) label_u_line = [ i + \"_line\" for i in label_u ] return label_u , label_u_line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a list of coords for 3 points Compute the area of this triangle . [CODESPLIT] def get_tri_area ( pts ) : a , b , c = pts [ 0 ] , pts [ 1 ] , pts [ 2 ] v1 = np . array ( b ) - np . array ( a ) v2 = np . array ( c ) - np . array ( a ) area_tri = abs ( sp . linalg . norm ( sp . cross ( v1 , v2 ) ) / 2 ) return area_tri", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return unique elements from list while preserving order . From https : // stackoverflow . com / a / 480227 / 2589328 [CODESPLIT] def remove_duplicates ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the variance of values in a series . [CODESPLIT] def var ( series ) : if np . issubdtype ( series . dtype , np . number ) : return series . var ( ) else : return np . nan", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raises an AssertionError if expected is actual . [CODESPLIT] def assert_is_not ( expected , actual , message = None , extra = None ) : assert expected is not actual , _assert_fail_message ( message , expected , actual , \"is\" , extra )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set a restore point ( copy the object ) then call the method . : return : obj . do_method ( * args ) [CODESPLIT] def do ( self ) : self . restore_point = self . obj . copy ( ) return self . do_method ( self . obj , * self . args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "stupid windows . converts the backslash to forwardslash for consistency [CODESPLIT] def __unixify ( self , s ) : return os . path . normpath ( s ) . replace ( os . sep , \"/\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "read a simple text file from a private location to get username and password [CODESPLIT] def read_credentials ( fname ) : with open ( fname , 'r' ) as f : username = f . readline ( ) . strip ( '\\n' ) password = f . readline ( ) . strip ( '\\n' ) return username , password", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Internal function to overcome pickling problem in python2 . [CODESPLIT] def _parallel_compare_helper ( class_obj , pairs , x , x_link = None ) : return class_obj . _compute ( pairs , x , x_link )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Hparams for transformer on LM pretraining ( with 64k vocab ) on TPU . [CODESPLIT] def transformer_tall_pretrain_lm_tpu_adafactor ( ) : hparams = transformer_tall_pretrain_lm ( ) update_hparams_for_tpu ( hparams ) hparams . max_length = 1024 # For multi-problem on TPU we need it in absolute examples. hparams . batch_size = 8 hparams . multiproblem_vocab_size = 2 ** 16 return hparams", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the output shape from an array . [CODESPLIT] def out_shape_from_array ( arr ) : arr = np . asarray ( arr ) if arr . ndim == 1 : return arr . shape else : return ( arr . shape [ 1 ] , )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Send data to specified socket . [CODESPLIT] def send ( socket , data , num_bytes = 20 ) : pickled_data = pickle . dumps ( data , - 1 ) length = str ( len ( pickled_data ) ) . zfill ( num_bytes ) socket . sendall ( length . encode ( ) ) socket . sendall ( pickled_data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert CamelCase to lower_and_underscore . [CODESPLIT] def decamelise ( text ) : s = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sorts the rows of a matrix by hierarchical clustering . [CODESPLIT] def hclust_linearize ( U ) : from scipy . cluster import hierarchy Z = hierarchy . ward ( U ) return hierarchy . leaves_list ( hierarchy . optimal_leaf_ordering ( Z , U ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts an ARRAY string stored in the database back into a Numpy array . [CODESPLIT] def convert_array ( array ) : out = io . BytesIO ( array ) out . seek ( 0 ) return np . load ( out )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Changes a column name in a DataFrame Parameters : df - DataFrame DataFrame to operate on col_name - string Name of column to change new_col_name - string New name of column [CODESPLIT] def col_rename ( df , col_name , new_col_name ) : col_list = list ( df . columns ) for index , value in enumerate ( col_list ) : if value == col_name : col_list [ index ] = new_col_name break df . columns = col_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function for conversion of various data types into numeric representation . [CODESPLIT] def _to_numeric ( val ) : if isinstance ( val , ( int , float , datetime . datetime , datetime . timedelta ) ) : return val return float ( val )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit the shell session . [CODESPLIT] def do_exit ( self , arg ) : if self . current : self . current . close ( ) self . resource_manager . close ( ) del self . resource_manager return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pretty printing for numpy matrix X [CODESPLIT] def print_matrix ( X , decimals = 1 ) : for row in np . round ( X , decimals = decimals ) : print ( row )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes // - comments and single - line C - style / * * / comments . [CODESPLIT] def CleanseComments ( line ) : commentpos = line . find ( '//' ) if commentpos != - 1 and not IsCppString ( line [ : commentpos ] ) : line = line [ : commentpos ] . rstrip ( ) # get rid of /* ... */ return _RE_PATTERN_CLEANSE_LINE_C_COMMENTS . sub ( '' , line )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets the cursor to the desired position . [CODESPLIT] def set_cursor ( self , x , y ) : curses . curs_set ( 1 ) self . screen . move ( y , x )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove files specified multiple times in a list . [CODESPLIT] def _remove_duplicate_files ( xs ) : seen = set ( [ ] ) out = [ ] for x in xs : if x [ \"path\" ] not in seen : out . append ( x ) seen . add ( x [ \"path\" ] ) return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert value from json to a python object [CODESPLIT] def process_result_value ( self , value , dialect ) : if value is not None : value = simplejson . loads ( value ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Toggle linear / log scale for Y - axis . [CODESPLIT] def log_y_cb ( self , w , val ) : self . tab_plot . logy = val self . plot_two_columns ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "For a given command line supplied argument negotiate the content parse the schema and then return any issues to stdout or if no schema issues return success exit code . [CODESPLIT] def main ( source ) : if source is None : click . echo ( \"You need to supply a file or url to a schema to a swagger schema, for\" \"the validator to work.\" ) return 1 try : load ( source ) click . echo ( \"Validation passed\" ) return 0 except ValidationError as e : raise click . ClickException ( str ( e ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yaml either have automatically converted it to a datetime object or it is a string that will be validated later . [CODESPLIT] def is_timestamp ( obj ) : return isinstance ( obj , datetime . datetime ) or is_string ( obj ) or is_int ( obj ) or is_float ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def check_for_positional_argument ( kwargs , name , default = False ) : if name in kwargs : if str ( kwargs [ name ] ) == \"True\" : return True elif str ( kwargs [ name ] ) == \"False\" : return False else : return kwargs [ name ] return default", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check lowercase key item . [CODESPLIT] def __contains__ ( self , key ) : assert isinstance ( key , basestring ) return dict . __contains__ ( self , key . lower ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the last item of a sequence . [CODESPLIT] def do_last ( environment , seq ) : try : return next ( iter ( reversed ( seq ) ) ) except StopIteration : return environment . undefined ( 'No last item, sequence was empty.' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print results straight to stdout [CODESPLIT] def stdout_display ( ) : if sys . version_info [ 0 ] == 2 : yield SmartBuffer ( sys . stdout ) else : yield SmartBuffer ( sys . stdout . buffer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a WAV file and returns the data and sample rate [CODESPLIT] def readwav ( filename ) : from scipy . io . wavfile import read as readwav samplerate , signal = readwav ( filename ) return signal , samplerate", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a boolean indicating if the code is executed inside softimage . [CODESPLIT] def inside_softimage ( ) : try : import maya return False except ImportError : pass try : from win32com . client import Dispatch as disp disp ( 'XSI.Application' ) return True except : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the value of the input matched by given selector . [CODESPLIT] def set_input_value ( self , selector , value ) : script = 'document.querySelector(\"%s\").setAttribute(\"value\", \"%s\")' script = script % ( selector , value ) self . evaluate ( script )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return whether or not user can access a project . [CODESPLIT] def can_access ( self , user ) : return self . class_ . is_admin ( user ) or self . is_ready and self . class_ in user . classes", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return internal state useful for testing . [CODESPLIT] def state ( self ) : return { 'c' : self . c , 's0' : self . s0 , 's1' : self . s1 , 's2' : self . s2 }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get an item from a dict which contains just one item . [CODESPLIT] def get_single_item ( d ) : assert len ( d ) == 1 , 'Single-item dict must have just one item, not %d.' % len ( d ) return next ( six . iteritems ( d ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Places a legend box outside a matplotlib Axes instance . [CODESPLIT] def mpl_outside_legend ( ax , * * kwargs ) : box = ax . get_position ( ) ax . set_position ( [ box . x0 , box . y0 , box . width * 0.75 , box . height ] ) # Put a legend to the right of the current axis ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1 , 1 ) , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "\\ kills the child and exits [CODESPLIT] def cli_command_quit ( self , msg ) : if self . state == State . RUNNING and self . sprocess and self . sprocess . proc : self . sprocess . proc . kill ( ) else : sys . exit ( 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Dictionary of noun phrase frequencies in this text . [CODESPLIT] def np_counts ( self ) : counts = defaultdict ( int ) for phrase in self . noun_phrases : counts [ phrase ] += 1 return counts", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True when the graph has the given edge . [CODESPLIT] def has_edge ( self , p_from , p_to ) : return p_from in self . _edges and p_to in self . _edges [ p_from ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return frequencies for DFT [CODESPLIT] def fft_freqs ( n_fft , fs ) : return np . arange ( 0 , ( n_fft // 2 + 1 ) ) / float ( n_fft ) * float ( fs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "determines whether the card number is valid . [CODESPLIT] def is_valid ( number ) : n = str ( number ) if not n . isdigit ( ) : return False return int ( n [ - 1 ] ) == get_check_digit ( n [ : - 1 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if a file is located within the given directory . [CODESPLIT] def contained_in ( filename , directory ) : filename = os . path . normcase ( os . path . abspath ( filename ) ) directory = os . path . normcase ( os . path . abspath ( directory ) ) return os . path . commonprefix ( [ filename , directory ] ) == directory", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Flatten a nested list . [CODESPLIT] def flatten ( l ) : return sum ( map ( flatten , l ) , [ ] ) if isinstance ( l , list ) or isinstance ( l , tuple ) else [ l ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if a line consists only of a single punctuation character . [CODESPLIT] def is_delimiter ( line ) : return bool ( line ) and line [ 0 ] in punctuation and line [ 0 ] * len ( line ) == line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return matrix as csv data . [CODESPLIT] def csv_matrix_print ( classes , table ) : result = \"\" classes . sort ( ) for i in classes : for j in classes : result += str ( table [ i ] [ j ] ) + \",\" result = result [ : - 1 ] + \"\\n\" return result [ : - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Install RPM Python binding . [CODESPLIT] def install_rpm_py ( ) : python_path = sys . executable cmd = '{0} install.py' . format ( python_path ) exit_status = os . system ( cmd ) if exit_status != 0 : raise Exception ( 'Command failed: {0}' . format ( cmd ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if we are on a Lyon machine [CODESPLIT] def we_are_in_lyon ( ) : import socket try : hostname = socket . gethostname ( ) ip = socket . gethostbyname ( hostname ) except socket . gaierror : return False return ip . startswith ( \"134.158.\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write a dict to a JSON file . [CODESPLIT] def _write_json ( file , contents ) : with open ( file , 'w' ) as f : return json . dump ( contents , f , indent = 2 , sort_keys = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Serialize obj as a JSON formatted stream to fp [CODESPLIT] def _serialize_json ( obj , fp ) : json . dump ( obj , fp , indent = 4 , default = serialize )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a password is valid [CODESPLIT] def is_password_valid ( password ) : pattern = re . compile ( r\"^.{4,75}$\" ) return bool ( pattern . match ( password ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks whether all number in the sequence s lie inside the interval formed by l and r . [CODESPLIT] def are_in_interval ( s , l , r , border = 'included' ) : return numpy . all ( [ IntensityRangeStandardization . is_in_interval ( x , l , r , border ) for x in s ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pop - up menu and wx . EVT_CLOSE closing event [CODESPLIT] def on_close ( self , evt ) : self . stop ( ) # DoseWatcher if evt . EventObject is not self : # Avoid deadlocks self . Close ( ) # wx.Frame evt . Skip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Function shows last rows . [CODESPLIT] def list_view_changed ( self , widget , event , data = None ) : adj = self . scrolled_window . get_vadjustment ( ) adj . set_value ( adj . get_upper ( ) - adj . get_page_size ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform check_array ( X ) after removing infinite values ( numpy . inf ) from the given distance matrix . [CODESPLIT] def check_precomputed_distance_matrix ( X ) : tmp = X . copy ( ) tmp [ np . isinf ( tmp ) ] = 1 check_array ( tmp )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Indicates whether or not the given row contains valid data . [CODESPLIT] def is_valid_row ( cls , row ) : for k in row . keys ( ) : if row [ k ] is None : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if the given user is in all given groups [CODESPLIT] def user_in_all_groups ( user , groups ) : return user_is_superuser ( user ) or all ( user_in_group ( user , group ) for group in groups )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last week as a period string [CODESPLIT] def get_period_last_3_months ( ) -> str : today = Datum ( ) today . today ( ) # start_date = today - timedelta(weeks=13) start_date = today . clone ( ) start_date . subtract_months ( 3 ) period = get_period ( start_date . date , today . date ) return period", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Process an iterable of dictionaries . For each dictionary d convert ( in place ) d [ key ] to a float . If that fails convert it to None . [CODESPLIT] def dictlist_convert_to_float ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : try : d [ key ] = float ( d [ key ] ) except ValueError : d [ key ] = None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns previous weekday used for observances [CODESPLIT] def previous_workday ( dt ) : dt -= timedelta ( days = 1 ) while dt . weekday ( ) > 4 : # Mon-Fri are 0-4 dt -= timedelta ( days = 1 ) return dt", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This method lets you take advantage of spacy s batch processing . Default implementation is to just iterate over the texts and call split_sentences . [CODESPLIT] def batch_split_sentences ( self , texts : List [ str ] ) -> List [ List [ str ] ] : return [ self . split_sentences ( text ) for text in texts ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a scalar a to a list and all iterables to list as well . [CODESPLIT] def listify ( a ) : if a is None : return [ ] elif not isinstance ( a , ( tuple , list , np . ndarray ) ) : return [ a ] return list ( a )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get all the database column names for the specified table . [CODESPLIT] def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Discover the current time zone and it s standard string representation ( for source { d } ) . [CODESPLIT] def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( \"%z\" ) tzstr = tzstr [ : - 2 ] + \":\" + tzstr [ - 2 : ] return dt . tzinfo , tzstr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dict with swapped keys and values [CODESPLIT] def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing [CODESPLIT] def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A non - negative integer . [CODESPLIT] def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add enough tabs to align in two columns [CODESPLIT] def get_margin ( length ) : if length > 23 : margin_left = \"\\t\" chars = 1 elif length > 15 : margin_left = \"\\t\\t\" chars = 2 elif length > 7 : margin_left = \"\\t\\t\\t\" chars = 3 else : margin_left = \"\\t\\t\\t\\t\" chars = 4 return margin_left", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load JSON file [CODESPLIT] def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute the given multiquery . [CODESPLIT] async def executemany ( self , sql : str , parameters : Iterable [ Iterable [ Any ] ] ) -> None : await self . _execute ( self . _cursor . executemany , sql , parameters )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Index of the last occurrence of x in the sequence . [CODESPLIT] def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements . [CODESPLIT] def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a text into a list of tokens . [CODESPLIT] def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes all non - printable characters from a text string [CODESPLIT] def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a sequence of indices into their corresponding labels . [CODESPLIT] def indices_to_labels ( self , indices : Sequence [ int ] ) -> List [ str ] : return [ ( self . INDEX_TO_LABEL [ index ] ) for index in indices ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether flyweight object with specified key has already been created . [CODESPLIT] def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x . [CODESPLIT] def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a list of the top topn features in this : class : . Feature \\ . [CODESPLIT] def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper to make map () behave the same on Py2 and Py3 . [CODESPLIT] def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for iterating only nonempty lines without line breaks [CODESPLIT] def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a str and transform it into a byte array . [CODESPLIT] def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements . [CODESPLIT] def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Args : x : iterable of strings [CODESPLIT] def gen_lower ( x : Iterable [ str ] ) -> Generator [ str , None , None ] : for string in x : yield string . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . ) [CODESPLIT] def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "generate a lower - cased camelCase string from an underscore_string . For example : my_variable_name - > myVariableName [CODESPLIT] def lower_camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = components [ 0 ] for component in components [ 1 : ] : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is the SQLAlchemy column type a string type? [CODESPLIT] def is_sqlatype_string ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . String )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn a list into a comma - and / or and - separated string . [CODESPLIT] def list_to_str ( lst ) : if len ( lst ) == 1 : str_ = lst [ 0 ] elif len ( lst ) == 2 : str_ = ' and ' . join ( lst ) elif len ( lst ) > 2 : str_ = ', ' . join ( lst [ : - 1 ] ) str_ += ', and {0}' . format ( lst [ - 1 ] ) else : raise ValueError ( 'List of length 0 provided.' ) return str_", "target": 1, "target_options": ["no_match", "match"]}
{"input": "docstring for argparse [CODESPLIT] def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all ( and only ) the chars in the given string . [CODESPLIT] def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "SetCursorPos from Win32 . Set mouse cursor to point x y . x : int . y : int . Return bool True if succeed otherwise False . [CODESPLIT] def SetCursorPos ( x : int , y : int ) -> bool : return bool ( ctypes . windll . user32 . SetCursorPos ( x , y ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dict with swapped keys and values [CODESPLIT] def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right . [CODESPLIT] def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of dimensions of a tensor [CODESPLIT] def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert human readable string to datetime . datetime . [CODESPLIT] def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove nans in a set of 1D arrays . [CODESPLIT] def remove_nans_1D ( * args ) -> tuple : vals = np . isnan ( args [ 0 ] ) for a in args : vals |= np . isnan ( a ) return tuple ( np . array ( a ) [ ~ vals ] for a in args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether flyweight object with specified key has already been created . [CODESPLIT] def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format an object as a latex string . [CODESPLIT] def _latex_format ( obj : Any ) -> str : if isinstance ( obj , float ) : try : return sympy . latex ( symbolize ( obj ) ) except ValueError : return \"{0:.4g}\" . format ( obj ) return str ( obj )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine whether sh has any value [CODESPLIT] def is_empty_shape ( sh : ShExJ . Shape ) -> bool : return sh . closed is None and sh . expression is None and sh . extra is None and sh . semActs is None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line . [CODESPLIT] def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . ) [CODESPLIT] def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "P the month [CODESPLIT] def pmon ( month ) : year , month = month . split ( '-' ) return '{month_name}, {year}' . format ( month_name = calendar . month_name [ int ( month ) ] , year = year , )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements . [CODESPLIT] def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Custom lower string function . Examples : FooBar - > foo_bar [CODESPLIT] def _lower ( string ) : if not string : return \"\" new_string = [ string [ 0 ] . lower ( ) ] for char in string [ 1 : ] : if char . isupper ( ) : new_string . append ( \"_\" ) new_string . append ( char . lower ( ) ) return \"\" . join ( new_string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a consistent ( key value ) iterable on dict - like objects including lists of tuple pairs . [CODESPLIT] def iterate_items ( dictish ) : if hasattr ( dictish , 'iteritems' ) : return dictish . iteritems ( ) if hasattr ( dictish , 'items' ) : return dictish . items ( ) return dictish", "target": 1, "target_options": ["no_match", "match"]}
{"input": "area () - > number [CODESPLIT] def area ( self ) : area = 0.0 for segment in self . segments ( ) : area += ( ( segment . p . x * segment . q . y ) - ( segment . q . x * segment . p . y ) ) / 2 return area", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return dict mapping item - > indices . [CODESPLIT] def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the recall . [CODESPLIT] def recall_score ( y_true , y_pred , average = 'micro' , suffix = False ) : true_entities = set ( get_entities ( y_true , suffix ) ) pred_entities = set ( get_entities ( y_pred , suffix ) ) nb_correct = len ( true_entities & pred_entities ) nb_true = len ( true_entities ) score = nb_correct / nb_true if nb_true > 0 else 0 return score", "target": 1, "target_options": ["no_match", "match"]}
{"input": "zoom out full data range [CODESPLIT] def unzoom_all ( self , event = None ) : if len ( self . conf . zoom_lims ) > 0 : self . conf . zoom_lims = [ self . conf . zoom_lims [ 0 ] ] self . unzoom ( event )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Writes text to a file . [CODESPLIT] def write_text ( filename : str , text : str ) -> None : with open ( filename , 'w' ) as f : # type: TextIO print ( text , file = f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Right replaces count occurrences of old with new in string . For example :: [CODESPLIT] def right_replace ( string , old , new , count = 1 ) : if not string : return string return new . join ( string . rsplit ( old , count ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Purely a debugging aid : Ascii - art picture of a tree descended from node [CODESPLIT] def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Same as . filter () but with appends all args with NOT [CODESPLIT] def exclude ( self , * args , * * kwargs ) -> \"QuerySet\" : return self . _filter_or_exclude ( negate = True , * args , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert string from camel case to snake case . [CODESPLIT] def camel_to_snake ( s : str ) -> str : return CAMEL_CASE_RE . sub ( r'_\\1' , s ) . strip ( ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Discover the current time zone and it s standard string representation ( for source { d } ) . [CODESPLIT] def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( \"%z\" ) tzstr = tzstr [ : - 2 ] + \":\" + tzstr [ - 2 : ] return dt . tzinfo , tzstr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "zfill ( x width ) - > string [CODESPLIT] def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run parallel execution of futures and return mapping of their results to the provided keys . Just a neat shortcut around asyncio . gather () [CODESPLIT] async def parallel_results ( future_map : Sequence [ Tuple ] ) -> Dict : ctx_methods = OrderedDict ( future_map ) fs = list ( ctx_methods . values ( ) ) results = await asyncio . gather ( * fs ) results = { key : results [ idx ] for idx , key in enumerate ( ctx_methods . keys ( ) ) } return results", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** . [CODESPLIT] def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Try to infer an object s dtype for use in arithmetic ops [CODESPLIT] def maybe_infer_dtype_type ( element ) : tipo = None if hasattr ( element , 'dtype' ) : tipo = element . dtype elif is_list_like ( element ) : element = np . asarray ( element ) tipo = element . dtype return tipo", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Hacky workaround for old installs of the library on systems without python - future that were keeping the 2to3 update from working after auto - update . [CODESPLIT] def bytes_hack ( buf ) : ub = None if sys . version_info > ( 3 , ) : ub = buf else : ub = bytes ( buf ) return ub", "target": 1, "target_options": ["no_match", "match"]}
{"input": "filter for dict note f should have signature : f :: key - > value - > bool [CODESPLIT] def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if two pathes represent the same file . [CODESPLIT] def samefile ( a : str , b : str ) -> bool : try : return os . path . samefile ( a , b ) except OSError : return os . path . normpath ( a ) == os . path . normpath ( b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load JSON file [CODESPLIT] def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit this application [CODESPLIT] def do_quit ( self , _ : argparse . Namespace ) -> bool : self . _should_quit = True return self . _STOP_AND_EXIT", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Covert numpy array to tensorflow tensor [CODESPLIT] def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate the first value in each row . [CODESPLIT] def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format numpy array as a string . [CODESPLIT] def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( \",\" ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + \"%s[%s]\" % ( arr . dtype , shape )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "mouse_event from Win32 . [CODESPLIT] def mouse_event ( dwFlags : int , dx : int , dy : int , dwData : int , dwExtraInfo : int ) -> None : ctypes . windll . user32 . mouse_event ( dwFlags , dx , dy , dwData , dwExtraInfo )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format numpy array as a string . [CODESPLIT] def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( \",\" ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + \"%s[%s]\" % ( arr . dtype , shape )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Iterate through multiple lists or arrays of equal size [CODESPLIT] def _izip ( * iterables ) : # This izip routine is from itertools # izip('ABCD', 'xy') --> Ax By iterators = map ( iter , iterables ) while iterators : yield tuple ( map ( next , iterators ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Merge two dicts and return a new dict . Much like subclassing works . [CODESPLIT] def extend ( a : dict , b : dict ) -> dict : res = a . copy ( ) res . update ( b ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pull a file directly from S3 . [CODESPLIT] def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a list of lists into a flat list . Args : x : list of lists [CODESPLIT] def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise . [CODESPLIT] def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right . [CODESPLIT] def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add value to the output row width based on index [CODESPLIT] def append_num_column ( self , text : str , index : int ) : width = self . columns [ index ] [ \"width\" ] return f\"{text:>{width}}\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Under UNIX : is a keystroke available? [CODESPLIT] def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "i th Regression Model Gaussian [CODESPLIT] def _gaussian_function ( self , datalength : int , values : np . ndarray , height : int , index : int ) -> np . ndarray : return height * np . exp ( - ( 1 / ( self . spread_number * datalength ) ) * ( values - ( ( datalength / self . function_number ) * index ) ) ** 2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a tuple from parsing a b c d - > ( a b c d ) [CODESPLIT] def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a list of strings to a list of integers . [CODESPLIT] def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if cnr or cns files are empty ( only have a header ) [CODESPLIT] def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Very simple grep that returns the first matching line in a file . String matching only does not do REs as currently implemented . [CODESPLIT] def grep ( pattern , filename ) : try : # for line in file # if line matches pattern: #    return line return next ( ( L for L in open ( filename ) if L . find ( pattern ) >= 0 ) ) except StopIteration : return ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Inquire whether file a was written since file b . [CODESPLIT] def _newer ( a , b ) : if not os . path . exists ( a ) : return False if not os . path . exists ( b ) : return True return os . path . getmtime ( a ) >= os . path . getmtime ( b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Under UNIX : is a keystroke available? [CODESPLIT] def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Truncate string values . [CODESPLIT] def truncate_string ( value , max_width = None ) : if isinstance ( value , text_type ) and max_width is not None and len ( value ) > max_width : return value [ : max_width ] return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialize attributes for informative output . [CODESPLIT] def __init__ ( self , enum_obj : Any ) -> None : if enum_obj : self . name = enum_obj self . items = ', ' . join ( [ str ( i ) for i in enum_obj ] ) else : self . items = ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of elements equal to elem present in the queue [CODESPLIT] def count ( self , elem ) : return self . _left_list . count ( elem ) + self . _right_list . count ( elem )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility method to run commands synchronously for testing . [CODESPLIT] def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( \"Event loop is already running.\" ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last week as a period string [CODESPLIT] def get_period_last_3_months ( ) -> str : today = Datum ( ) today . today ( ) # start_date = today - timedelta(weeks=13) start_date = today . clone ( ) start_date . subtract_months ( 3 ) period = get_period ( start_date . date , today . date ) return period", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the item that appears most frequently in the given list . [CODESPLIT] def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . ) [CODESPLIT] def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Very simple grep that returns the first matching line in a file . String matching only does not do REs as currently implemented . [CODESPLIT] def grep ( pattern , filename ) : try : # for line in file # if line matches pattern: #    return line return next ( ( L for L in open ( filename ) if L . find ( pattern ) >= 0 ) ) except StopIteration : return ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the memory is too full for further caching . [CODESPLIT] def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the last weekday in a given month . e . g : [CODESPLIT] def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A basis that orders qubits ascending based on a key function . [CODESPLIT] def sorted_by ( key : Callable [ [ raw_types . Qid ] , Any ] ) -> 'QubitOrder' : return QubitOrder ( lambda qubits : tuple ( sorted ( qubits , key = key ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if a value is a finite number . [CODESPLIT] def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rate limit a function . [CODESPLIT] def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if a value is a finite number . [CODESPLIT] def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts an dict to a Enum . [CODESPLIT] def dict_to_enum_fn ( d : Dict [ str , Any ] , enum_class : Type [ Enum ] ) -> Enum : return enum_class [ d [ 'name' ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Smooth an image [CODESPLIT] def smooth_image ( image , sigma , sigma_in_physical_coordinates = True , FWHM = False , max_kernel_width = 32 ) : if image . components == 1 : return _smooth_image_helper ( image , sigma , sigma_in_physical_coordinates , FWHM , max_kernel_width ) else : imagelist = utils . split_channels ( image ) newimages = [ ] for image in imagelist : newimage = _smooth_image_helper ( image , sigma , sigma_in_physical_coordinates , FWHM , max_kernel_width ) newimages . append ( newimage ) return utils . merge_channels ( newimages )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cast to float tensor [CODESPLIT] def fcast ( value : float ) -> TensorLike : newvalue = tf . cast ( value , FTYPE ) if DEVICE == 'gpu' : newvalue = newvalue . gpu ( ) # Why is this needed?  # pragma: no cover return newvalue", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right . [CODESPLIT] def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Accepts a binary string and returns the detected filetype . Return value is the mimetype if mime = True otherwise a human readable name . [CODESPLIT] def from_buffer ( buffer , mime = False ) : m = _get_magic_type ( mime ) return m . from_buffer ( buffer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "zfill ( x width ) - > string [CODESPLIT] def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the longest common substring in a list of strings . Credit : http : // stackoverflow . com / questions / 2892931 / longest - common - substring - from - more - than - two - strings - python [CODESPLIT] def long_substr ( data ) : substr = '' if len ( data ) > 1 and len ( data [ 0 ] ) > 0 : for i in range ( len ( data [ 0 ] ) ) : for j in range ( len ( data [ 0 ] ) - i + 1 ) : if j > len ( substr ) and all ( data [ 0 ] [ i : i + j ] in x for x in data ) : substr = data [ 0 ] [ i : i + j ] elif len ( data ) == 1 : substr = data [ 0 ] return substr", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": return : int [CODESPLIT] def __next__ ( self ) : self . current += 1 if self . current > self . total : raise StopIteration else : return self . iterable [ self . current - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the last weekday in a given month . e . g : [CODESPLIT] def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A non - negative integer . [CODESPLIT] def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Context manager that suppresses stdout . [CODESPLIT] def suppress_stdout ( ) : save_stdout = sys . stdout sys . stdout = DevNull ( ) yield sys . stdout = save_stdout", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for iterating only nonempty lines without line breaks [CODESPLIT] def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a function that will call a named method on the target object with optional positional and keyword arguments . [CODESPLIT] def method_caller ( method_name , * args , * * kwargs ) : def call_method ( target ) : func = getattr ( target , method_name ) return func ( * args , * * kwargs ) return call_method", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This will erase all but say 30 of the legend entries and remake the legend . You ll probably have to move it back into your favorite position at this point . [CODESPLIT] def impose_legend_limit ( limit = 30 , axes = \"gca\" , * * kwargs ) : if axes == \"gca\" : axes = _pylab . gca ( ) # make these axes current _pylab . axes ( axes ) # loop over all the lines_pylab. for n in range ( 0 , len ( axes . lines ) ) : if n > limit - 1 and not n == len ( axes . lines ) - 1 : axes . lines [ n ] . set_label ( \"_nolegend_\" ) if n == limit - 1 and not n == len ( axes . lines ) - 1 : axes . lines [ n ] . set_label ( \"...\" ) _pylab . legend ( * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Hacky workaround for old installs of the library on systems without python - future that were keeping the 2to3 update from working after auto - update . [CODESPLIT] def bytes_hack ( buf ) : ub = None if sys . version_info > ( 3 , ) : ub = buf else : ub = bytes ( buf ) return ub", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Splits on multiple given separators . [CODESPLIT] def multi_split ( s , split ) : # type: (S, Iterable[S]) -> List[S] for r in split : s = s . replace ( r , \"|\" ) return [ i for i in s . split ( \"|\" ) if len ( i ) > 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if a value is an integer number . [CODESPLIT] def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate the first value in each row . [CODESPLIT] def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "filter for dict note f should have signature : f :: key - > value - > bool [CODESPLIT] def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list produced by applying : func : multiple_replace to every string in stringlist . [CODESPLIT] def replace_in_list ( stringlist : Iterable [ str ] , replacedict : Dict [ str , str ] ) -> List [ str ] : newlist = [ ] for fromstring in stringlist : newlist . append ( multiple_replace ( fromstring , replacedict ) ) return newlist", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a byte array into an integer array . The number of bytes forming an integer is defined by num [CODESPLIT] def convert_bytes_to_ints ( in_bytes , num ) : dt = numpy . dtype ( '>i' + str ( num ) ) return numpy . frombuffer ( in_bytes , dt )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Executes SQL ; returns list of first values of each row . [CODESPLIT] def fetchallfirstvalues ( self , sql : str , * args ) -> List [ Any ] : rows = self . fetchall ( sql , * args ) return [ row [ 0 ] for row in rows ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Entry point for reading las data in pylas [CODESPLIT] def read_las ( source , closefd = True ) : with open_las ( source , closefd = closefd ) as reader : return reader . read ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Hacky workaround for old installs of the library on systems without python - future that were keeping the 2to3 update from working after auto - update . [CODESPLIT] def bytes_hack ( buf ) : ub = None if sys . version_info > ( 3 , ) : ub = buf else : ub = bytes ( buf ) return ub", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Truncates a value to a number of decimals places [CODESPLIT] def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Detects whether a line is present within a file . [CODESPLIT] def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a tuple from parsing a b c d - > ( a b c d ) [CODESPLIT] def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove any duplicate item preserving order [CODESPLIT] def de_duplicate ( items ) : result = [ ] for item in items : if item not in result : result . append ( item ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield booleans unpacking integers of dtype bit - length . [CODESPLIT] def unpackbools ( integers , dtype = 'L' ) : atoms = ATOMS [ dtype ] for chunk in integers : for a in atoms : yield not not chunk & a", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses a file or directory of files into a set of Document objects . [CODESPLIT] def _generate ( self ) : doc_count = 0 for fp in self . all_files : for doc in self . _get_docs_for_path ( fp ) : yield doc doc_count += 1 if doc_count >= self . max_docs : return", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Constructs a trainable tfd . MultivariateNormalTriL distribution . [CODESPLIT] def multivariate_normal_tril ( x , dims , layer_fn = tf . compat . v1 . layers . dense , loc_fn = lambda x : x , scale_fn = tril_with_diag_softplus_and_shift , name = None ) : with tf . compat . v1 . name_scope ( name , 'multivariate_normal_tril' , [ x , dims ] ) : x = tf . convert_to_tensor ( value = x , name = 'x' ) x = layer_fn ( x , dims + dims * ( dims + 1 ) // 2 ) return tfd . MultivariateNormalTriL ( loc = loc_fn ( x [ ... , : dims ] ) , scale_tril = scale_fn ( x [ ... , dims : ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a list of arrays of the same shape and take the element wise average . [CODESPLIT] def average_arrays ( arrays : List [ mx . nd . NDArray ] ) -> mx . nd . NDArray : if not arrays : raise ValueError ( \"arrays is empty.\" ) if len ( arrays ) == 1 : return arrays [ 0 ] check_condition ( all ( arrays [ 0 ] . shape == a . shape for a in arrays ) , \"nd array shapes do not match\" ) return mx . nd . add_n ( * arrays ) / len ( arrays )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield all items from iterable except the last one . [CODESPLIT] def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "target": 1, "target_options": ["no_match", "match"]}
{"input": "string dict / object / value to JSON [CODESPLIT] def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Report whether another set contains this set . [CODESPLIT] def issubset ( self , other ) : if len ( self ) > len ( other ) : # Fast check for obvious cases return False return all ( item in other for item in self )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a str and transform it into a byte array . [CODESPLIT] def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string to a list with sanitization . [CODESPLIT] def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Truncates a value to a number of decimals places [CODESPLIT] def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if cnr or cns files are empty ( only have a header ) [CODESPLIT] def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if the dataset name is valid . [CODESPLIT] def name_is_valid ( name ) : # The name can only be 80 characters long. if len ( name ) > MAX_NAME_LENGTH : return False return bool ( NAME_VALID_CHARS_REGEX . match ( name ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "takes a list of lists l and returns a flat list [CODESPLIT] def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a file exists is non - empty and is more recent than cmp_fname . [CODESPLIT] def file_uptodate ( fname , cmp_fname ) : try : return ( file_exists ( fname ) and file_exists ( cmp_fname ) and getmtime ( fname ) >= getmtime ( cmp_fname ) ) except OSError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for iterating only nonempty lines without line breaks [CODESPLIT] def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a str and transform it into a byte array . [CODESPLIT] def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list of synsets of a word after lemmatization . [CODESPLIT] def has_synset ( word : str ) -> list : return wn . synsets ( lemmatize ( word , neverstem = True ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line . [CODESPLIT] def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Under UNIX : is a keystroke available? [CODESPLIT] def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing [CODESPLIT] def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the available drive names on the system . Always returns a list . [CODESPLIT] def get_system_drives ( ) : drives = [ ] if os . name == 'nt' : import ctypes bitmask = ctypes . windll . kernel32 . GetLogicalDrives ( ) letter = ord ( 'A' ) while bitmask > 0 : if bitmask & 1 : name = chr ( letter ) + ':' + os . sep if os . path . isdir ( name ) : drives . append ( name ) bitmask >>= 1 letter += 1 else : current_drive = get_drive ( os . getcwd ( ) ) if current_drive : drive = current_drive else : drive = os . sep drives . append ( drive ) return drives", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a byte array into an integer array . The number of bytes forming an integer is defined by num [CODESPLIT] def convert_bytes_to_ints ( in_bytes , num ) : dt = numpy . dtype ( '>i' + str ( num ) ) return numpy . frombuffer ( in_bytes , dt )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Like rotate but modifies l in - place . [CODESPLIT] def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Hacky workaround for old installs of the library on systems without python - future that were keeping the 2to3 update from working after auto - update . [CODESPLIT] def bytes_hack ( buf ) : ub = None if sys . version_info > ( 3 , ) : ub = buf else : ub = bytes ( buf ) return ub", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a text into a list of tokens . [CODESPLIT] def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing [CODESPLIT] def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility method to run commands synchronously for testing . [CODESPLIT] def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( \"Event loop is already running.\" ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return dict mapping item - > indices . [CODESPLIT] def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrun True if x is a valid YYYYMMDD date ; otherwise return False . [CODESPLIT] def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read 4 bytes from bytestream as an unsigned 32 - bit integer . [CODESPLIT] def read32 ( bytestream ) : dt = np . dtype ( np . uint32 ) . newbyteorder ( '>' ) return np . frombuffer ( bytestream . read ( 4 ) , dtype = dt ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "generate a lower - cased camelCase string from an underscore_string . For example : my_variable_name - > myVariableName [CODESPLIT] def lower_camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = components [ 0 ] for component in components [ 1 : ] : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return physical memory usage ( float ) Requires the cross - platform psutil ( > = v0 . 3 ) library ( https : // github . com / giampaolo / psutil ) [CODESPLIT] def psutil_phymem_usage ( ) : import psutil # This is needed to avoid a deprecation warning error with\n # newer psutil versions\n try : percent = psutil . virtual_memory ( ) . percent except : percent = psutil . phymem_usage ( ) . percent return percent", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A non - negative integer . [CODESPLIT] def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the settings file exists or not [CODESPLIT] def file_exists ( self ) -> bool : cfg_path = self . file_path assert cfg_path return path . isfile ( cfg_path )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function returns a truncated repr () of an object . [CODESPLIT] def _short_repr ( obj ) : stringified = pprint . saferepr ( obj ) if len ( stringified ) > 200 : return '%s... (%d bytes)' % ( stringified [ : 200 ] , len ( stringified ) ) return stringified", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Release lock on compilation directory . [CODESPLIT] def release_lock ( ) : get_lock . n_lock -= 1 assert get_lock . n_lock >= 0 # Only really release lock once all lock requests have ended. if get_lock . lock_is_enabled and get_lock . n_lock == 0 : get_lock . start_time = None get_lock . unlocker . unlock ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the duplicates in a list . [CODESPLIT] def find_duplicates ( l : list ) -> set : return set ( [ x for x in l if l . count ( x ) > 1 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is implementet so column min / max is only active when bgcolor is [CODESPLIT] def change_bgcolor_enable ( self , state ) : self . dataModel . bgcolor ( state ) self . bgcolor_global . setEnabled ( not self . is_series and state > 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right . [CODESPLIT] def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Skip a section [CODESPLIT] def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if a value is an integer number . [CODESPLIT] def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected [CODESPLIT] def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove nans in a set of 1D arrays . [CODESPLIT] def remove_nans_1D ( * args ) -> tuple : vals = np . isnan ( args [ 0 ] ) for a in args : vals |= np . isnan ( a ) return tuple ( np . array ( a ) [ ~ vals ] for a in args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rate limit a function . [CODESPLIT] def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a new copied dictionary without the keys with None values from the given Mapping object . [CODESPLIT] def clean_map ( obj : Mapping [ Any , Any ] ) -> Mapping [ Any , Any ] : return { k : v for k , v in obj . items ( ) if v is not None }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for iterating only nonempty lines without line breaks [CODESPLIT] def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses hostname from URL . : param url : URL : return : hostname [CODESPLIT] def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Verify Django 1 . 11 is present if Python 2 . 7 is active [CODESPLIT] def validate_django_compatible_with_python ( ) : python_version = sys . version [ : 5 ] django_version = django . get_version ( ) if sys . version_info == ( 2 , 7 ) and django_version >= \"2\" : click . BadArgumentUsage ( \"Please install Django v1.11 for Python {}, or switch to Python >= v3.4\" . format ( python_version ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return memory usage of python process in MB [CODESPLIT] def memory_usage ( ) : try : import psutil import os except ImportError : return _memory_usage_ps ( ) process = psutil . Process ( os . getpid ( ) ) mem = process . memory_info ( ) [ 0 ] / float ( 2 ** 20 ) return mem", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected [CODESPLIT] def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements . [CODESPLIT] def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The current position of the cursor . [CODESPLIT] def position ( self ) -> Position : return Position ( self . _index , self . _lineno , self . _col_offset )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Very simple grep that returns the first matching line in a file . String matching only does not do REs as currently implemented . [CODESPLIT] def grep ( pattern , filename ) : try : # for line in file # if line matches pattern: #    return line return next ( ( L for L in open ( filename ) if L . find ( pattern ) >= 0 ) ) except StopIteration : return ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute column : input is the input text string token is a token instance [CODESPLIT] def find_column ( token ) : i = token . lexpos input = token . lexer . lexdata while i > 0 : if input [ i - 1 ] == '\\n' : break i -= 1 column = token . lexpos - i + 1 return column", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a file exists is non - empty and is more recent than cmp_fname . [CODESPLIT] def file_uptodate ( fname , cmp_fname ) : try : return ( file_exists ( fname ) and file_exists ( cmp_fname ) and getmtime ( fname ) >= getmtime ( cmp_fname ) ) except OSError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the leading numeric part of a string . [CODESPLIT] def numeric_part ( s ) : m = re_numeric_part . match ( s ) if m : return int ( m . group ( 1 ) ) return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return the number of channels present in samples [CODESPLIT] def numchannels ( samples : np . ndarray ) -> int : if len ( samples . shape ) == 1 : return 1 else : return samples . shape [ 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a str and transform it into a byte array . [CODESPLIT] def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run parallel execution of futures and return mapping of their results to the provided keys . Just a neat shortcut around asyncio . gather () [CODESPLIT] async def parallel_results ( future_map : Sequence [ Tuple ] ) -> Dict : ctx_methods = OrderedDict ( future_map ) fs = list ( ctx_methods . values ( ) ) results = await asyncio . gather ( * fs ) results = { key : results [ idx ] for idx , key in enumerate ( ctx_methods . keys ( ) ) } return results", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all ( and only ) the chars in the given string . [CODESPLIT] def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check that all arrays have consistent first dimensions . [CODESPLIT] def check_consistent_length ( * arrays ) : uniques = np . unique ( [ _num_samples ( X ) for X in arrays if X is not None ] ) if len ( uniques ) > 1 : raise ValueError ( \"Found arrays with inconsistent numbers of samples: %s\" % str ( uniques ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if a value is an integer number . [CODESPLIT] def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "! [CODESPLIT] def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb", "target": 1, "target_options": ["no_match", "match"]}
{"input": "zfill ( x width ) - > string [CODESPLIT] def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Try to infer an object s dtype for use in arithmetic ops [CODESPLIT] def maybe_infer_dtype_type ( element ) : tipo = None if hasattr ( element , 'dtype' ) : tipo = element . dtype elif is_list_like ( element ) : element = np . asarray ( element ) tipo = element . dtype return tipo", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected [CODESPLIT] def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes as input a string in Kunwinjku and segments it into phoneme - like units based on the standard orthographic rules specified at http : // bininjgunwok . org . au / [CODESPLIT] def segment_str ( text : str , phoneme_inventory : Set [ str ] = PHONEMES ) -> str : text = text . lower ( ) text = segment_into_tokens ( text , phoneme_inventory ) return text", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print at most limit elements of list . [CODESPLIT] def _brief_print_list ( lst , limit = 7 ) : lst = list ( lst ) if len ( lst ) > limit : return _brief_print_list ( lst [ : limit // 2 ] , limit ) + ', ..., ' + _brief_print_list ( lst [ - limit // 2 : ] , limit ) return ', ' . join ( [ \"'%s'\" % str ( i ) for i in lst ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Concatenate a sequence of arrays . [CODESPLIT] def uconcatenate ( arrs , axis = 0 ) : v = np . concatenate ( arrs , axis = axis ) v = _validate_numpy_wrapper_units ( v , arrs ) return v", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a tuple from parsing a b c d - > ( a b c d ) [CODESPLIT] def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a datetime from GnuCash 2 . 6 date string [CODESPLIT] def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts string presented in camel case to snake case . [CODESPLIT] def camel_to_snake_case ( string ) : s = _1 . sub ( r'\\1_\\2' , string ) return _2 . sub ( r'\\1_\\2' , s ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } ) [CODESPLIT] def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x . [CODESPLIT] def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list of synsets of a word after lemmatization . [CODESPLIT] def has_synset ( word : str ) -> list : return wn . synsets ( lemmatize ( word , neverstem = True ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if all sequences in the list have the same length . [CODESPLIT] def are_token_parallel ( sequences : Sequence [ Sized ] ) -> bool : if not sequences or len ( sequences ) == 1 : return True return all ( len ( s ) == len ( sequences [ 0 ] ) for s in sequences )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "filter for dict note f should have signature : f :: key - > value - > bool [CODESPLIT] def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Add a margin to both ends of each line in the string . [CODESPLIT] def margin ( text ) : lines = str ( text ) . split ( '\\n' ) return '\\n' . join ( '  {}  ' . format ( l ) for l in lines )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a consistent ( key value ) iterable on dict - like objects including lists of tuple pairs . [CODESPLIT] def iterate_items ( dictish ) : if hasattr ( dictish , 'iteritems' ) : return dictish . iteritems ( ) if hasattr ( dictish , 'items' ) : return dictish . items ( ) return dictish", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns an array ( any sequence of floats really ) as a string . [CODESPLIT] def toStringArray ( name , a , width = 0 ) : string = name + \": \" cnt = 0 for i in a : string += \"%4.2f  \" % i if width > 0 and ( cnt + 1 ) % width == 0 : string += '\\n' cnt += 1 return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return the higher parent which is not an AssignName Tuple or List node [CODESPLIT] def assign_parent ( node : astroid . node_classes . NodeNG ) -> astroid . node_classes . NodeNG : while node and isinstance ( node , ( astroid . AssignName , astroid . Tuple , astroid . List ) ) : node = node . parent return node", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Repeat each item in iterable n times . [CODESPLIT] def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return datetime object from timestamp in Excel serial format . [CODESPLIT] def excel_datetime ( timestamp , epoch = None ) : if epoch is None : epoch = datetime . datetime . fromordinal ( 693594 ) return epoch + datetime . timedelta ( timestamp )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform a simple check if the value is callable . [CODESPLIT] def callable_validator ( v : Any ) -> AnyCallable : if callable ( v ) : return v raise errors . CallableError ( value = v )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield . [CODESPLIT] def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a generator over iterable that tells whether the current item is the last one . Usage : >>> iterable = range ( 10 ) >>> for index is_last item in enum_mark_last ( iterable ) : >>> print ( index item end = \\ n if is_last else ) [CODESPLIT] def enum_mark_last ( iterable , start = 0 ) : it = iter ( iterable ) count = start try : last = next ( it ) except StopIteration : return for val in it : yield count , False , last last = val count += 1 yield count , True , last", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print at most limit elements of list . [CODESPLIT] def _brief_print_list ( lst , limit = 7 ) : lst = list ( lst ) if len ( lst ) > limit : return _brief_print_list ( lst [ : limit // 2 ] , limit ) + ', ..., ' + _brief_print_list ( lst [ - limit // 2 : ] , limit ) return ', ' . join ( [ \"'%s'\" % str ( i ) for i in lst ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last week as a period string [CODESPLIT] def get_period_last_3_months ( ) -> str : today = Datum ( ) today . today ( ) # start_date = today - timedelta(weeks=13) start_date = today . clone ( ) start_date . subtract_months ( 3 ) period = get_period ( start_date . date , today . date ) return period", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Truncates a value to a number of decimals places [CODESPLIT] def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Time execution of function . Returns ( res seconds ) . [CODESPLIT] def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is the SQLAlchemy column type a string type? [CODESPLIT] def is_sqlatype_string ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . String )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert string from snake case to camel case . [CODESPLIT] def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a str and transform it into a byte array . [CODESPLIT] def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return if the token is in the list or not . [CODESPLIT] def contains ( self , token : str ) -> bool : self . _validate_token ( token ) return token in self", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a string related to a model name and extract its model number . [CODESPLIT] def detect_model_num ( string ) : match = re . match ( MODEL_NUM_REGEX , string ) if match : return int ( match . group ( ) ) return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get all the database column names for the specified table . [CODESPLIT] def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Detects whether a line is present within a file . [CODESPLIT] def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shape of histogram s data . [CODESPLIT] def shape ( self ) -> Tuple [ int , ... ] : return tuple ( bins . bin_count for bins in self . _binnings )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "filter for dict note f should have signature : f :: key - > value - > bool [CODESPLIT] def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the item that appears most frequently in the given list . [CODESPLIT] def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a text into a list of tokens . [CODESPLIT] def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": ">>> imt2tup ( PGA ) ( PGA ) >>> imt2tup ( SA ( 1 . 0 ) ) ( SA 1 . 0 ) >>> imt2tup ( SA ( 1 ) ) ( SA 1 . 0 ) [CODESPLIT] def imt2tup ( string ) : s = string . strip ( ) if not s . endswith ( ')' ) : # no parenthesis, PGA is considered the same as PGA() return ( s , ) name , rest = s . split ( '(' , 1 ) return ( name , ) + tuple ( float ( x ) for x in ast . literal_eval ( rest [ : - 1 ] + ',' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Help store an action . [CODESPLIT] def _store_helper ( model : Action , session : Optional [ Session ] = None ) -> None : if session is None : session = _make_session ( ) session . add ( model ) session . commit ( ) session . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handles cursor left events [CODESPLIT] def _cursorLeft ( self ) : if self . cursorPos > 0 : self . cursorPos -= 1 sys . stdout . write ( console . CURSOR_LEFT ) sys . stdout . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a str and transform it into a byte array . [CODESPLIT] def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts string presented in camel case to snake case . [CODESPLIT] def camel_to_snake_case ( string ) : s = _1 . sub ( r'\\1_\\2' , string ) return _2 . sub ( r'\\1_\\2' , s ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get domain part of an url . [CODESPLIT] def get_domain ( url ) : parse_result = urlparse ( url ) domain = \"{schema}://{netloc}\" . format ( schema = parse_result . scheme , netloc = parse_result . netloc ) return domain", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows . [CODESPLIT] def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate a delay to retry using an exponential backoff algorithm . [CODESPLIT] def exponential_backoff ( attempt : int , cap : int = 1200 ) -> timedelta : base = 3 temp = min ( base * 2 ** attempt , cap ) return timedelta ( seconds = temp / 2 + random . randint ( 0 , temp / 2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a new copied dictionary without the keys with None values from the given Mapping object . [CODESPLIT] def clean_map ( obj : Mapping [ Any , Any ] ) -> Mapping [ Any , Any ] : return { k : v for k , v in obj . items ( ) if v is not None }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns all column names and their data types as a list . [CODESPLIT] def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if a value is an integer number . [CODESPLIT] def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return flattened dictionary from MultiDict . [CODESPLIT] def flatten_multidict ( multidict ) : return dict ( [ ( key , value if len ( value ) > 1 else value [ 0 ] ) for ( key , value ) in multidict . iterlists ( ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts an dict to a Enum . [CODESPLIT] def dict_to_enum_fn ( d : Dict [ str , Any ] , enum_class : Type [ Enum ] ) -> Enum : return enum_class [ d [ 'name' ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if gate tensor is ( almost ) Hermitian [CODESPLIT] def almost_hermitian ( gate : Gate ) -> bool : return np . allclose ( asarray ( gate . asoperator ( ) ) , asarray ( gate . H . asoperator ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements . [CODESPLIT] def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line . [CODESPLIT] def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return view of the recarray with all int32 cast to int64 . [CODESPLIT] def to_int64 ( a ) : # build new dtype and replace i4 --> i8 def promote_i4 ( typestr ) : if typestr [ 1 : ] == 'i4' : typestr = typestr [ 0 ] + 'i8' return typestr dtype = [ ( name , promote_i4 ( typestr ) ) for name , typestr in a . dtype . descr ] return a . astype ( dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Insert None as value for missing fields . [CODESPLIT] def inject_nulls ( data : Mapping , field_names ) -> dict : record = dict ( ) for field in field_names : record [ field ] = data . get ( field , None ) return record", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip the whitespace from all column names in the given DataFrame and return the result . [CODESPLIT] def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Hacky workaround for old installs of the library on systems without python - future that were keeping the 2to3 update from working after auto - update . [CODESPLIT] def bytes_hack ( buf ) : ub = None if sys . version_info > ( 3 , ) : ub = buf else : ub = bytes ( buf ) return ub", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for iterating only nonempty lines without line breaks [CODESPLIT] def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Verifies that a string path actually exists and is a file [CODESPLIT] def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "docstring for argparse [CODESPLIT] def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Very simple grep that returns the first matching line in a file . String matching only does not do REs as currently implemented . [CODESPLIT] def grep ( pattern , filename ) : try : # for line in file # if line matches pattern: #    return line return next ( ( L for L in open ( filename ) if L . find ( pattern ) >= 0 ) ) except StopIteration : return ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "takes a list of lists l and returns a flat list [CODESPLIT] def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the longest string size for a string entry across data . [CODESPLIT] def _prm_get_longest_stringsize ( string_list ) : maxlength = 1 for stringar in string_list : if isinstance ( stringar , np . ndarray ) : if stringar . ndim > 0 : for string in stringar . ravel ( ) : maxlength = max ( len ( string ) , maxlength ) else : maxlength = max ( len ( stringar . tolist ( ) ) , maxlength ) else : maxlength = max ( len ( stringar ) , maxlength ) # Make the string Col longer than needed in order to allow later on slightly larger strings return int ( maxlength * 1.5 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if specified value exists in int enum ; otherwise False . [CODESPLIT] def has_value ( cls , value : int ) -> bool : return any ( value == item . value for item in cls )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Skip a section [CODESPLIT] def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If we re not on the first line ( of a multiline input ) go a line up otherwise go back in history . ( If nothing is selected . ) [CODESPLIT] def auto_up ( self , count = 1 , go_to_start_of_line_if_history_changes = False ) : if self . complete_state : self . complete_previous ( count = count ) elif self . document . cursor_position_row > 0 : self . cursor_up ( count = count ) elif not self . selection_state : self . history_backward ( count = count ) # Go to the start of the line? if go_to_start_of_line_if_history_changes : self . cursor_position += self . document . get_start_of_line_position ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a value wrap it in a 0 - D numpy . ndarray . [CODESPLIT] def to_0d_array ( value : Any ) -> np . ndarray : if np . isscalar ( value ) or ( isinstance ( value , np . ndarray ) and value . ndim == 0 ) : return np . array ( value ) else : return to_0d_object_array ( value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple helper hash function [CODESPLIT] def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Covert numpy array to tensorflow tensor [CODESPLIT] def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "target": 1, "target_options": ["no_match", "match"]}
{"input": "docstring for argparse [CODESPLIT] def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a tuple from parsing a b c d - > ( a b c d ) [CODESPLIT] def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Accepts a filename and returns the detected filetype . Return value is the mimetype if mime = True otherwise a human readable name . [CODESPLIT] def from_file ( filename , mime = False ) : m = _get_magic_type ( mime ) return m . from_file ( filename )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ">>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7 [CODESPLIT] def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip the whitespace from all column names in the given DataFrame and return the result . [CODESPLIT] def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn a list into a comma - and / or and - separated string . [CODESPLIT] def list_to_str ( lst ) : if len ( lst ) == 1 : str_ = lst [ 0 ] elif len ( lst ) == 2 : str_ = ' and ' . join ( lst ) elif len ( lst ) > 2 : str_ = ', ' . join ( lst [ : - 1 ] ) str_ += ', and {0}' . format ( lst [ - 1 ] ) else : raise ValueError ( 'List of length 0 provided.' ) return str_", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Finds the index of an item in list which satisfies predicate : param predicateFn : predicate function to run on items of list : param items : list of tuples : return : first index for which predicate function returns True [CODESPLIT] def getIndex ( predicateFn : Callable [ [ T ] , bool ] , items : List [ T ] ) -> int : try : return next ( i for i , v in enumerate ( items ) if predicateFn ( v ) ) except StopIteration : return - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all ( and only ) the chars in the given string . [CODESPLIT] def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return extension identifying format of given filename [CODESPLIT] def infer_format ( filename : str ) -> str : _ , ext = os . path . splitext ( filename ) return ext", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Concatenate url and argument dictionary regardless of whether url has existing query parameters . [CODESPLIT] def url_concat ( url , args ) : if not args : return url if url [ - 1 ] not in ( '?' , '&' ) : url += '&' if ( '?' in url ) else '?' return url + urllib . urlencode ( args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get version information for components used by Spyder [CODESPLIT] def get_versions ( reporev = True ) : import sys import platform import qtpy import qtpy . QtCore revision = None if reporev : from spyder . utils import vcs revision , branch = vcs . get_git_revision ( os . path . dirname ( __dir__ ) ) if not sys . platform == 'darwin' : # To avoid a crash with our Mac app system = platform . system ( ) else : system = 'Darwin' return { 'spyder' : __version__ , 'python' : platform . python_version ( ) , # \"2.7.3\" 'bitness' : 64 if sys . maxsize > 2 ** 32 else 32 , 'qt' : qtpy . QtCore . __version__ , 'qt_api' : qtpy . API_NAME , # PyQt5 'qt_api_ver' : qtpy . PYQT_VERSION , 'system' : system , # Linux, Windows, ... 'release' : platform . release ( ) , # XP, 10.6, 2.2.0, etc. 'revision' : revision , # '9fdf926eccce' }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . ) [CODESPLIT] def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the index of the earliest occurence of an item from a list in a string [CODESPLIT] def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a CSV object to a numpy array . [CODESPLIT] def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } ) [CODESPLIT] def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shape of histogram s data . [CODESPLIT] def shape ( self ) -> Tuple [ int , ... ] : return tuple ( bins . bin_count for bins in self . _binnings )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the keys that maps to the top n max values in the given dict . [CODESPLIT] def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a persistent set from iterable . Optionally takes a sizing parameter equivalent to that used for : py : func : pmap . [CODESPLIT] def pset ( iterable = ( ) , pre_size = 8 ) : if not iterable : return _EMPTY_PSET return PSet . _from_iterable ( iterable , pre_size = pre_size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generates RGB values from HSV values in line with a typical light spectrum . [CODESPLIT] def hsv2rgb_spectrum ( hsv ) : h , s , v = hsv return hsv2rgb_raw ( ( ( h * 192 ) >> 8 , s , v ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "HTTP POST operation to API endpoint . [CODESPLIT] def post ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'POST' , endpoint , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the input filename with path is a file and is not empty . [CODESPLIT] def isfile_notempty ( inputfile : str ) -> bool : try : return isfile ( inputfile ) and getsize ( inputfile ) > 0 except TypeError : raise TypeError ( 'inputfile is not a valid type' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Define a generator function and return it [CODESPLIT] def __iter__ ( self ) : def generator ( ) : for i , obj in enumerate ( self . _sequence ) : if i >= self . _limit : break yield obj raise StopIteration return generator", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns its parameter as an integer or raises django . forms . ValidationError . [CODESPLIT] def clean_int ( x ) -> int : try : return int ( x ) except ValueError : raise forms . ValidationError ( \"Cannot convert to integer: {}\" . format ( repr ( x ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for iterating only nonempty lines without line breaks [CODESPLIT] def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "checks if you are on a 64 bit platform [CODESPLIT] def check64bit ( current_system = \"python\" ) : if current_system == \"python\" : return sys . maxsize > 2147483647 elif current_system == \"os\" : import platform pm = platform . machine ( ) if pm != \"..\" and pm . endswith ( '64' ) : # recent Python (not Iron) return True else : if 'PROCESSOR_ARCHITEW6432' in os . environ : return True # 32 bit program running on 64 bit Windows try : # 64 bit Windows 64 bit program return os . environ [ 'PROCESSOR_ARCHITECTURE' ] . endswith ( '64' ) except IndexError : pass # not Windows try : # this often works in Linux return '64' in platform . architecture ( ) [ 0 ] except Exception : # is an older version of Python, assume also an older os@ # (best we can guess) return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a str and transform it into a byte array . [CODESPLIT] def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Skip a section [CODESPLIT] def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format an object s repr method with specific attributes . [CODESPLIT] def format_repr ( obj , attributes ) -> str : attribute_repr = ', ' . join ( ( '{}={}' . format ( attr , repr ( getattr ( obj , attr ) ) ) for attr in attributes ) ) return \"{0}({1})\" . format ( obj . __class__ . __qualname__ , attribute_repr )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads words from a file . [CODESPLIT] def _read_words ( filename ) : with tf . gfile . GFile ( filename , \"r\" ) as f : if sys . version_info [ 0 ] >= 3 : return f . read ( ) . replace ( \"\\n\" , \" %s \" % EOS ) . split ( ) else : return f . read ( ) . decode ( \"utf-8\" ) . replace ( \"\\n\" , \" %s \" % EOS ) . split ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "! [CODESPLIT] def u16le_list_to_byte_list ( data ) : byteData = [ ] for h in data : byteData . extend ( [ h & 0xff , ( h >> 8 ) & 0xff ] ) return byteData", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Under UNIX : is a keystroke available? [CODESPLIT] def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a scalar a to a list and all iterables to list as well . [CODESPLIT] def listify ( a ) : if a is None : return [ ] elif not isinstance ( a , ( tuple , list , np . ndarray ) ) : return [ a ] return list ( a )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sort files or folders by modified time [CODESPLIT] def sort_by_modified ( files_or_folders : list ) -> list : return sorted ( files_or_folders , key = os . path . getmtime , reverse = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The current position of the cursor . [CODESPLIT] def position ( self ) -> Position : return Position ( self . _index , self . _lineno , self . _col_offset )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run verbose PyLint on source . Optionally specify fmt = html for HTML output . [CODESPLIT] def lint ( fmt = 'colorized' ) : if fmt == 'html' : outfile = 'pylint_report.html' local ( 'pylint -f %s davies > %s || true' % ( fmt , outfile ) ) local ( 'open %s' % outfile ) else : local ( 'pylint -f %s davies || true' % fmt )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip the whitespace from all column names in the given DataFrame and return the result . [CODESPLIT] def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the item that appears most frequently in the given list . [CODESPLIT] def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deletes all files whose filename matches the glob pattern ( via : func : glob . glob ) . [CODESPLIT] def rmglob ( pattern : str ) -> None : for f in glob . glob ( pattern ) : os . remove ( f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a tuple from parsing a b c d - > ( a b c d ) [CODESPLIT] def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the last weekday in a given month . e . g : [CODESPLIT] def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cast to float tensor [CODESPLIT] def fcast ( value : float ) -> TensorLike : newvalue = tf . cast ( value , FTYPE ) if DEVICE == 'gpu' : newvalue = newvalue . gpu ( ) # Why is this needed?  # pragma: no cover return newvalue", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes an array add indentation to each entry and prints it . [CODESPLIT] def PrintIndented ( self , file , ident , code ) : for entry in code : print >> file , '%s%s' % ( ident , entry )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sort files or folders by modified time [CODESPLIT] def sort_by_modified ( files_or_folders : list ) -> list : return sorted ( files_or_folders , key = os . path . getmtime , reverse = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Purely a debugging aid : Ascii - art picture of a tree descended from node [CODESPLIT] def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows . [CODESPLIT] def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "generate a lower - cased camelCase string from an underscore_string . For example : my_variable_name - > myVariableName [CODESPLIT] def lower_camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = components [ 0 ] for component in components [ 1 : ] : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "skip performing substitutions that are outside the bounds of the string [CODESPLIT] def valid_substitution ( strlen , index ) : values = index [ 0 ] return all ( [ strlen > i for i in values ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return flattened dictionary from MultiDict . [CODESPLIT] def flatten_multidict ( multidict ) : return dict ( [ ( key , value if len ( value ) > 1 else value [ 0 ] ) for ( key , value ) in multidict . iterlists ( ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all ( and only ) the chars in the given string . [CODESPLIT] def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a variation from a base value [CODESPLIT] def _gauss ( mean : int , sigma : int ) -> int : return int ( random . gauss ( mean , sigma ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility method to run commands synchronously for testing . [CODESPLIT] def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( \"Event loop is already running.\" ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "string dict / object / value to JSON [CODESPLIT] def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if the response has been rate limited by CARTO APIs [CODESPLIT] def is_rate_limited ( response ) : if ( response . status_code == codes . too_many_requests and 'Retry-After' in response . headers and int ( response . headers [ 'Retry-After' ] ) >= 0 ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create an empty array with appropriate shape . [CODESPLIT] def _create_empty_array ( self , frames , always_2d , dtype ) : import numpy as np if always_2d or self . channels > 1 : shape = frames , self . channels else : shape = frames , return np . empty ( shape , dtype , order = 'C' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if a value is an integer number . [CODESPLIT] def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Time execution of function . Returns ( res seconds ) . [CODESPLIT] def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fail unless first equals second as determined by the == operator . [CODESPLIT] def assert_equal ( first , second , msg_fmt = \"{msg}\" ) : if isinstance ( first , dict ) and isinstance ( second , dict ) : assert_dict_equal ( first , second , msg_fmt ) elif not first == second : msg = \"{!r} != {!r}\" . format ( first , second ) fail ( msg_fmt . format ( msg = msg , first = first , second = second ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230 [CODESPLIT] def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows . [CODESPLIT] def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Try to infer an object s dtype for use in arithmetic ops [CODESPLIT] def maybe_infer_dtype_type ( element ) : tipo = None if hasattr ( element , 'dtype' ) : tipo = element . dtype elif is_list_like ( element ) : element = np . asarray ( element ) tipo = element . dtype return tipo", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format numpy array as a string . [CODESPLIT] def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( \",\" ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + \"%s[%s]\" % ( arr . dtype , shape )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing [CODESPLIT] def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Setup the flask - cache on a flask app [CODESPLIT] def setup_cache ( app : Flask , cache_config ) -> Optional [ Cache ] : if cache_config and cache_config . get ( 'CACHE_TYPE' ) != 'null' : return Cache ( app , config = cache_config ) return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read 4 bytes from bytestream as an unsigned 32 - bit integer . [CODESPLIT] def read32 ( bytestream ) : dt = np . dtype ( np . uint32 ) . newbyteorder ( '>' ) return np . frombuffer ( bytestream . read ( 4 ) , dtype = dt ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a list of lists into a flat list . Args : x : list of lists [CODESPLIT] def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert string from camel case to snake case . [CODESPLIT] def camel_to_snake ( s : str ) -> str : return CAMEL_CASE_RE . sub ( r'_\\1' , s ) . strip ( ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper to make map () behave the same on Py2 and Py3 . [CODESPLIT] def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the index of the earliest occurence of an item from a list in a string [CODESPLIT] def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Repeat each item in iterable n times . [CODESPLIT] def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield all items from iterable except the last one . [CODESPLIT] def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Small straight scoring according to yatzy rules [CODESPLIT] def score_small_straight_yatzy ( dice : List [ int ] ) -> int : dice_set = set ( dice ) if _are_two_sets_equal ( { 1 , 2 , 3 , 4 , 5 } , dice_set ) : return sum ( dice ) return 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read 4 bytes from bytestream as an unsigned 32 - bit integer . [CODESPLIT] def read32 ( bytestream ) : dt = np . dtype ( np . uint32 ) . newbyteorder ( '>' ) return np . frombuffer ( bytestream . read ( 4 ) , dtype = dt ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert things on the way from Python to the database . [CODESPLIT] def process_literal_param ( self , value : Optional [ List [ int ] ] , dialect : Dialect ) -> str : retval = self . _intlist_to_dbstr ( value ) return retval", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes trailing zeroes from indexable collection of numbers [CODESPLIT] def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a list of the top topn features in this : class : . Feature \\ . [CODESPLIT] def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert string from camel case to snake case . [CODESPLIT] def camel_to_snake ( s : str ) -> str : return CAMEL_CASE_RE . sub ( r'_\\1' , s ) . strip ( ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether flyweight object with specified key has already been created . [CODESPLIT] def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add value to a set in a dictionary by key [CODESPLIT] def dict_of_sets_add ( dictionary , key , value ) : # type: (DictUpperBound, Any, Any) -> None set_objs = dictionary . get ( key , set ( ) ) set_objs . add ( value ) dictionary [ key ] = set_objs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pull a file directly from S3 . [CODESPLIT] def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected [CODESPLIT] def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Discover the current time zone and it s standard string representation ( for source { d } ) . [CODESPLIT] def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( \"%z\" ) tzstr = tzstr [ : - 2 ] + \":\" + tzstr [ - 2 : ] return dt . tzinfo , tzstr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rate limit a function . [CODESPLIT] def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the last weekday in a given month . e . g : [CODESPLIT] def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A helper function that checks if a matrix is unitary . [CODESPLIT] def is_unitary ( matrix : np . ndarray ) -> bool : rows , cols = matrix . shape if rows != cols : return False return np . allclose ( np . eye ( rows ) , matrix . dot ( matrix . T . conj ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Signed greater - than comparison [CODESPLIT] def SGT ( self , a , b ) : # http://gavwood.com/paper.pdf s0 , s1 = to_signed ( a ) , to_signed ( b ) return Operators . ITEBV ( 256 , s0 > s1 , 1 , 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the index of the earliest occurence of an item from a list in a string [CODESPLIT] def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Replace all ( frm to ) tuples in args in string s . [CODESPLIT] def replaceStrs ( s , * args ) : if args == ( ) : return s mapping = dict ( ( frm , to ) for frm , to in args ) return re . sub ( \"|\" . join ( map ( re . escape , mapping . keys ( ) ) ) , lambda match : mapping [ match . group ( 0 ) ] , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a file exists and is non - empty . [CODESPLIT] def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield . [CODESPLIT] def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compress things in a py2 / 3 safe fashion >>> json_str = { test : 1 } >>> blob = zlib_compress ( json_str ) [CODESPLIT] def zlib_compress ( data ) : if PY3K : if isinstance ( data , str ) : return zlib . compress ( bytes ( data , 'utf-8' ) ) return zlib . compress ( data ) return zlib . compress ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility method to run commands synchronously for testing . [CODESPLIT] def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( \"Event loop is already running.\" ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the virtual cursor position . [CODESPLIT] def get_cursor ( self ) : x , y = self . _cursor width , height = self . parent . get_size ( ) while x >= width : x -= width y += 1 if y >= height and self . scrollMode == 'scroll' : y = height - 1 return x , y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield lines found in given file [CODESPLIT] def file_lines ( bblfile : str ) -> iter : with open ( bblfile ) as fd : yield from ( line . rstrip ( ) for line in fd if line . rstrip ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Report whether another set contains this set . [CODESPLIT] def issubset ( self , other ) : if len ( self ) > len ( other ) : # Fast check for obvious cases return False return all ( item in other for item in self )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A non - negative integer . [CODESPLIT] def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "rounds float to closest int : rtype : int : param n : float [CODESPLIT] def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a variation from a base value [CODESPLIT] def _gauss ( mean : int , sigma : int ) -> int : return int ( random . gauss ( mean , sigma ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the keys that maps to the top n max values in the given dict . [CODESPLIT] def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return flattened dictionary from MultiDict . [CODESPLIT] def flatten_multidict ( multidict ) : return dict ( [ ( key , value if len ( value ) > 1 else value [ 0 ] ) for ( key , value ) in multidict . iterlists ( ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the conda executable robustly across conda versions . [CODESPLIT] def _find_conda ( ) : if 'CONDA_EXE' in os . environ : conda = os . environ [ 'CONDA_EXE' ] else : conda = util . which ( 'conda' ) return conda", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Truncate string values . [CODESPLIT] def truncate_string ( value , max_width = None ) : if isinstance ( value , text_type ) and max_width is not None and len ( value ) > max_width : return value [ : max_width ] return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get version information for components used by Spyder [CODESPLIT] def get_versions ( reporev = True ) : import sys import platform import qtpy import qtpy . QtCore revision = None if reporev : from spyder . utils import vcs revision , branch = vcs . get_git_revision ( os . path . dirname ( __dir__ ) ) if not sys . platform == 'darwin' : # To avoid a crash with our Mac app system = platform . system ( ) else : system = 'Darwin' return { 'spyder' : __version__ , 'python' : platform . python_version ( ) , # \"2.7.3\" 'bitness' : 64 if sys . maxsize > 2 ** 32 else 32 , 'qt' : qtpy . QtCore . __version__ , 'qt_api' : qtpy . API_NAME , # PyQt5 'qt_api_ver' : qtpy . PYQT_VERSION , 'system' : system , # Linux, Windows, ... 'release' : platform . release ( ) , # XP, 10.6, 2.2.0, etc. 'revision' : revision , # '9fdf926eccce' }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This is a dirty little template function generator that turns single - brace Mustache - style template strings into functions that interpolate dict keys : [CODESPLIT] def templategetter ( tmpl ) : tmpl = tmpl . replace ( '{' , '%(' ) tmpl = tmpl . replace ( '}' , ')s' ) return lambda data : tmpl % data", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield . [CODESPLIT] def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the memory is too full for further caching . [CODESPLIT] def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if specified value exists in int enum ; otherwise False . [CODESPLIT] def has_value ( cls , value : int ) -> bool : return any ( value == item . value for item in cls )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns database SQL datatype for a column : e . g . VARCHAR . [CODESPLIT] def get_datatype ( self , table : str , column : str ) -> str : return self . flavour . get_datatype ( self , table , column ) . upper ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert human readable string to datetime . datetime . [CODESPLIT] def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "SwitchToThisWindow from Win32 . handle : int the handle of a native window . [CODESPLIT] def SwitchToThisWindow ( handle : int ) -> None : ctypes . windll . user32 . SwitchToThisWindow ( ctypes . c_void_p ( handle ) , 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cast to float tensor [CODESPLIT] def fcast ( value : float ) -> TensorLike : newvalue = tf . cast ( value , FTYPE ) if DEVICE == 'gpu' : newvalue = newvalue . gpu ( ) # Why is this needed?  # pragma: no cover return newvalue", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get version information for components used by Spyder [CODESPLIT] def get_versions ( reporev = True ) : import sys import platform import qtpy import qtpy . QtCore revision = None if reporev : from spyder . utils import vcs revision , branch = vcs . get_git_revision ( os . path . dirname ( __dir__ ) ) if not sys . platform == 'darwin' : # To avoid a crash with our Mac app system = platform . system ( ) else : system = 'Darwin' return { 'spyder' : __version__ , 'python' : platform . python_version ( ) , # \"2.7.3\" 'bitness' : 64 if sys . maxsize > 2 ** 32 else 32 , 'qt' : qtpy . QtCore . __version__ , 'qt_api' : qtpy . API_NAME , # PyQt5 'qt_api_ver' : qtpy . PYQT_VERSION , 'system' : system , # Linux, Windows, ... 'release' : platform . release ( ) , # XP, 10.6, 2.2.0, etc. 'revision' : revision , # '9fdf926eccce' }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Covert numpy array to tensorflow tensor [CODESPLIT] def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert an array like object to the NPY format . [CODESPLIT] def array_to_npy ( array_like ) : # type: (np.array or Iterable or int or float) -> object buffer = BytesIO ( ) np . save ( buffer , array_like ) return buffer . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all ( and only ) the uppercase chars in the given string . [CODESPLIT] def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns day number of the last day of the month : param t : datetime : return : int [CODESPLIT] def get_last_day_of_month ( t : datetime ) -> int : tn = t + timedelta ( days = 32 ) tn = datetime ( year = tn . year , month = tn . month , day = 1 ) tt = tn - timedelta ( hours = 1 ) return tt . day", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrun True if x is a valid YYYYMMDD date ; otherwise return False . [CODESPLIT] def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses a property node [CODESPLIT] def _parse_property ( self , node ) : # type: (ElementTree.Element) -> Tuple[str, Any] # Get information name = node . attrib [ ATTR_NAME ] vtype = node . attrib . get ( ATTR_VALUE_TYPE , TYPE_STRING ) # Look for a value as a single child node try : value_node = next ( iter ( node ) ) value = self . _parse_value_node ( vtype , value_node ) except StopIteration : # Value is an attribute value = self . _convert_value ( vtype , node . attrib [ ATTR_VALUE ] ) return name , value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Verify Django 1 . 11 is present if Python 2 . 7 is active [CODESPLIT] def validate_django_compatible_with_python ( ) : python_version = sys . version [ : 5 ] django_version = django . get_version ( ) if sys . version_info == ( 2 , 7 ) and django_version >= \"2\" : click . BadArgumentUsage ( \"Please install Django v1.11 for Python {}, or switch to Python >= v3.4\" . format ( python_version ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if a node is an intersection [CODESPLIT] def is_intersection ( g , n ) : return len ( set ( g . predecessors ( n ) + g . successors ( n ) ) ) > 2", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Linearly interpolate between two float values . [CODESPLIT] def interpolate ( f1 : float , f2 : float , factor : float ) -> float : return f1 + ( f2 - f1 ) * factor", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes all non - printable characters from a text string [CODESPLIT] def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Curried version of the built - in reduce . >>> reduce ( lambda x y : x + y ) ( [ 1 2 3 4 5 ] ) 15 [CODESPLIT] def reduce ( function , initval = None ) : if initval is None : return lambda s : __builtin__ . reduce ( function , s ) else : return lambda s : __builtin__ . reduce ( function , s , initval )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get domain part of an url . [CODESPLIT] def get_domain ( url ) : parse_result = urlparse ( url ) domain = \"{schema}://{netloc}\" . format ( schema = parse_result . scheme , netloc = parse_result . netloc ) return domain", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Escape data for tab - separated value ( TSV ) format . [CODESPLIT] def tsv_escape ( x : Any ) -> str : if x is None : return \"\" x = str ( x ) return x . replace ( \"\\t\" , \"\\\\t\" ) . replace ( \"\\n\" , \"\\\\n\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the memory is too full for further caching . [CODESPLIT] def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rate limit a function . [CODESPLIT] def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pull a file directly from S3 . [CODESPLIT] def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements . [CODESPLIT] def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string to a list with sanitization . [CODESPLIT] def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "( str ) - > int All the digits in a given string are concatenated and converted into a single number . [CODESPLIT] def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Implementation of AnyParser API [CODESPLIT] def _get_parsing_plan_for_multifile_children ( self , obj_on_fs : PersistedObject , desired_type : Type [ Any ] , logger : Logger ) -> Dict [ str , Any ] : raise Exception ( 'This should never happen, since this parser relies on underlying parsers' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Verifies that a string path actually exists and is a file [CODESPLIT] def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230 [CODESPLIT] def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list of synsets of a word after lemmatization . [CODESPLIT] def has_synset ( word : str ) -> list : return wn . synsets ( lemmatize ( word , neverstem = True ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert hex string like \\ x0A \\ xE3 to 2787 . [CODESPLIT] def hex_to_int ( value ) : if version_info . major >= 3 : return int . from_bytes ( value , \"big\" ) return int ( value . encode ( \"hex\" ) , 16 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a datetime from GnuCash 2 . 6 date string [CODESPLIT] def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given the total number of items determine the number of items that can be added to each bin with a limit on the bin size . [CODESPLIT] def partition_items ( count , bin_size ) : num_bins = int ( math . ceil ( count / float ( bin_size ) ) ) bins = [ 0 ] * num_bins for i in range ( count ) : bins [ i % num_bins ] += 1 return bins", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows . [CODESPLIT] def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right . [CODESPLIT] def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrun True if x is a valid YYYYMMDD date ; otherwise return False . [CODESPLIT] def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a list into a space - separated string and puts it in a dictionary [CODESPLIT] def encode_list ( key , list_ ) : # type: (str, Iterable) -> Dict[str, str] if not list_ : return { } return { key : \" \" . join ( str ( i ) for i in list_ ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrun True if x is a valid YYYYMMDD date ; otherwise return False . [CODESPLIT] def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check that the namespace is defined by an enumeration and that the name is a member . [CODESPLIT] def has_enumerated_namespace_name ( self , namespace : str , name : str ) -> bool : return self . has_enumerated_namespace ( namespace ) and name in self . namespace_to_terms [ namespace ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cast to float tensor [CODESPLIT] def fcast ( value : float ) -> TensorLike : newvalue = tf . cast ( value , FTYPE ) if DEVICE == 'gpu' : newvalue = newvalue . gpu ( ) # Why is this needed?  # pragma: no cover return newvalue", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns all column names and their data types as a list . [CODESPLIT] def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Index of the last occurrence of x in the sequence . [CODESPLIT] def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deletes all files whose filename matches the glob pattern ( via : func : glob . glob ) . [CODESPLIT] def rmglob ( pattern : str ) -> None : for f in glob . glob ( pattern ) : os . remove ( f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Time execution of function . Returns ( res seconds ) . [CODESPLIT] def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if all sequences in the list have the same length . [CODESPLIT] def are_token_parallel ( sequences : Sequence [ Sized ] ) -> bool : if not sequences or len ( sequences ) == 1 : return True return all ( len ( s ) == len ( sequences [ 0 ] ) for s in sequences )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if the queue is full False otherwise ( not reliable! ) . [CODESPLIT] def full ( self ) : return self . maxsize and len ( self . list ) >= self . maxsize or False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine whether etype is a List or other iterable [CODESPLIT] def is_iterable ( etype ) -> bool : return type ( etype ) is GenericMeta and issubclass ( etype . __extra__ , Iterable )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Skip a section [CODESPLIT] def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Time execution of function . Returns ( res seconds ) . [CODESPLIT] def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A non - negative integer . [CODESPLIT] def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements . [CODESPLIT] def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates that the object itself is some kinda string [CODESPLIT] def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Time execution of function . Returns ( res seconds ) . [CODESPLIT] def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find a line number given a line map and a character offset . [CODESPLIT] def get_line_number ( line_map , offset ) : for lineno , line_offset in enumerate ( line_map , start = 1 ) : if line_offset > offset : return lineno return - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "( Point Point ) - > Point Return the point that lies in between the two input points . [CODESPLIT] def _mid ( pt1 , pt2 ) : ( x0 , y0 ) , ( x1 , y1 ) = pt1 , pt2 return 0.5 * ( x0 + x1 ) , 0.5 * ( y0 + y1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a snake_case_string to a camelCaseString . [CODESPLIT] def snake_to_camel ( value ) : camel = \"\" . join ( word . title ( ) for word in value . split ( \"_\" ) ) return value [ : 1 ] . lower ( ) + camel [ 1 : ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reset to the default text color on console window . Return bool True if succeed otherwise False . [CODESPLIT] def ResetConsoleColor ( ) -> bool : if sys . stdout : sys . stdout . flush ( ) bool ( ctypes . windll . kernel32 . SetConsoleTextAttribute ( _ConsoleOutputHandle , _DefaultConsoleColor ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right . [CODESPLIT] def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit execution with return code and message : param msg : Message displayed prior to exit : param code : code returned upon exiting [CODESPLIT] def Exit ( msg , code = 1 ) : print >> sys . stderr , msg sys . exit ( code )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list of synsets of a word after lemmatization . [CODESPLIT] def has_synset ( word : str ) -> list : return wn . synsets ( lemmatize ( word , neverstem = True ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a variation from a base value [CODESPLIT] def _gauss ( mean : int , sigma : int ) -> int : return int ( random . gauss ( mean , sigma ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x . [CODESPLIT] def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether flyweight object with specified key has already been created . [CODESPLIT] def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a value in bytes ( in string format ) to megabytes . [CODESPLIT] def val_mb ( valstr : Union [ int , str ] ) -> str : try : return \"{:.3f}\" . format ( int ( valstr ) / ( 1024 * 1024 ) ) except ( TypeError , ValueError ) : return '?'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "From Python collections module documentation [CODESPLIT] def moving_average ( iterable , n ) : it = iter ( iterable ) d = collections . deque ( itertools . islice ( it , n - 1 ) ) d . appendleft ( 0 ) s = sum ( d ) for elem in it : s += elem - d . popleft ( ) d . append ( elem ) yield s / float ( n )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Release the USB interface again . [CODESPLIT] def _close ( self ) : self . _usb_handle . releaseInterface ( ) try : # If we're using PyUSB >= 1.0 we can re-attach the kernel driver here. self . _usb_handle . dev . attach_kernel_driver ( 0 ) except : pass self . _usb_int = None self . _usb_handle = None return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Finds the longest path in a dag between two nodes [CODESPLIT] def dag_longest_path ( graph , source , target ) : if source == target : return [ source ] allpaths = nx . all_simple_paths ( graph , source , target ) longest_path = [ ] for l in allpaths : if len ( l ) > len ( longest_path ) : longest_path = l return longest_path", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the item that appears most frequently in the given list . [CODESPLIT] def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ] [CODESPLIT] def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Truncates a value to a number of decimals places [CODESPLIT] def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Purely a debugging aid : Ascii - art picture of a tree descended from node [CODESPLIT] def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add value to a set in a dictionary by key [CODESPLIT] def dict_of_sets_add ( dictionary , key , value ) : # type: (DictUpperBound, Any, Any) -> None set_objs = dictionary . get ( key , set ( ) ) set_objs . add ( value ) dictionary [ key ] = set_objs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a list of strings to a list of integers . [CODESPLIT] def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple helper hash function [CODESPLIT] def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts name to lower camel case . Words are identified by capitalization dashes and underscores . [CODESPLIT] def fmt_camel ( name ) : words = split_words ( name ) assert len ( words ) > 0 first = words . pop ( 0 ) . lower ( ) return first + '' . join ( [ word . capitalize ( ) for word in words ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if a value is an integer number . [CODESPLIT] def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a variation from a base value [CODESPLIT] def _gauss ( mean : int , sigma : int ) -> int : return int ( random . gauss ( mean , sigma ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "zfill ( x width ) - > string [CODESPLIT] def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a function that will call a named method on the target object with optional positional and keyword arguments . [CODESPLIT] def method_caller ( method_name , * args , * * kwargs ) : def call_method ( target ) : func = getattr ( target , method_name ) return func ( * args , * * kwargs ) return call_method", "target": 1, "target_options": ["no_match", "match"]}
{"input": ">>> l = [ 1 1 1 ] >>> obj_in_list_always ( l 1 ) True >>> l . append ( 2 ) >>> obj_in_list_always ( l 1 ) False [CODESPLIT] def obj_in_list_always ( target_list , obj ) : for item in set ( target_list ) : if item is not obj : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } ) [CODESPLIT] def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read 4 bytes from bytestream as an unsigned 32 - bit integer . [CODESPLIT] def read32 ( bytestream ) : dt = np . dtype ( np . uint32 ) . newbyteorder ( '>' ) return np . frombuffer ( bytestream . read ( 4 ) , dtype = dt ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "filter for dict note f should have signature : f :: key - > value - > bool [CODESPLIT] def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of dimensions of a tensor [CODESPLIT] def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print out a neat targets dependency tree based on requested targets . [CODESPLIT] def cmd_dot ( conf : Config ) : build_context = BuildContext ( conf ) populate_targets_graph ( build_context , conf ) if conf . output_dot_file is None : write_dot ( build_context , conf , sys . stdout ) else : with open ( conf . output_dot_file , 'w' ) as out_file : write_dot ( build_context , conf , out_file )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Swap the methods atom to remove method with key . [CODESPLIT] def __remove_method ( m : lmap . Map , key : T ) -> lmap . Map : return m . dissoc ( key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simplified check to see if the text appears to be a URL . [CODESPLIT] def looks_like_url ( url ) : if not isinstance ( url , basestring ) : return False if not isinstance ( url , basestring ) or len ( url ) >= 1024 or not cre_url . match ( url ) : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get domain part of an url . [CODESPLIT] def get_domain ( url ) : parse_result = urlparse ( url ) domain = \"{schema}://{netloc}\" . format ( schema = parse_result . scheme , netloc = parse_result . netloc ) return domain", "target": 1, "target_options": ["no_match", "match"]}
{"input": "( pre ) Connects some or all redis clients inside the pool . [CODESPLIT] def preconnect ( self , size = - 1 ) : if size == - 1 and self . max_size == - 1 : raise ClientError ( \"size=-1 not allowed with pool max_size=-1\" ) limit = min ( size , self . max_size ) if size != - 1 else self . max_size clients = yield [ self . get_connected_client ( ) for _ in range ( 0 , limit ) ] for client in clients : self . release_client ( client )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": returns the minimum of the column [CODESPLIT] def min ( self ) : res = self . _qexec ( \"min(%s)\" % self . _name ) if len ( res ) > 0 : self . _min = res [ 0 ] [ 0 ] return self . _min", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230 [CODESPLIT] def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the year . [CODESPLIT] def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of dimensions of a tensor [CODESPLIT] def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate random UUID . [CODESPLIT] def uuid ( self , version : int = None ) -> str : bits = self . random . getrandbits ( 128 ) return str ( uuid . UUID ( int = bits , version = version ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Setup the flask - cache on a flask app [CODESPLIT] def setup_cache ( app : Flask , cache_config ) -> Optional [ Cache ] : if cache_config and cache_config . get ( 'CACHE_TYPE' ) != 'null' : return Cache ( app , config = cache_config ) return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute the given multiquery . [CODESPLIT] async def executemany ( self , sql : str , parameters : Iterable [ Iterable [ Any ] ] ) -> None : await self . _execute ( self . _cursor . executemany , sql , parameters )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "rounds float to closest int : rtype : int : param n : float [CODESPLIT] def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rate limit a function . [CODESPLIT] def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a string is equivalent to None . [CODESPLIT] def is_none ( string_ , default = 'raise' ) : none = [ 'none' , 'undefined' , 'unknown' , 'null' , '' ] if string_ . lower ( ) in none : return True elif not default : return False else : raise ValueError ( 'The value \\'{}\\' cannot be mapped to none.' . format ( string_ ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if two pathes represent the same file . [CODESPLIT] def samefile ( a : str , b : str ) -> bool : try : return os . path . samefile ( a , b ) except OSError : return os . path . normpath ( a ) == os . path . normpath ( b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit this application [CODESPLIT] def do_quit ( self , _ : argparse . Namespace ) -> bool : self . _should_quit = True return self . _STOP_AND_EXIT", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a list of strings to a list of integers . [CODESPLIT] def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "HTTP request method of interface implementation . [CODESPLIT] def _request ( self , method : str , endpoint : str , params : dict = None , data : dict = None , headers : dict = None ) -> dict :", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Last time step available . [CODESPLIT] def last ( self ) : if self . _last is UNDETERMINED : # not necessarily the last one... self . _last = self . sdat . tseries . index [ - 1 ] return self [ self . _last ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Moves the displayed plot to the previous one [CODESPLIT] def prevPlot ( self ) : if self . stacker . currentIndex ( ) > 0 : self . stacker . setCurrentIndex ( self . stacker . currentIndex ( ) - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decode base64 string to byte array . [CODESPLIT] def decodebytes ( input ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _decodebytes_py3 ( input ) return _decodebytes_py2 ( input )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a list of the top topn features in this : class : . Feature \\ . [CODESPLIT] def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return unique list of iterable items preserving order . [CODESPLIT] def uniqued ( iterable ) : seen = set ( ) return [ item for item in iterable if item not in seen and not seen . add ( item ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ensure a set of input VCFs do not have duplicate samples . [CODESPLIT] def _check_samples_nodups ( fnames ) : counts = defaultdict ( int ) for f in fnames : for s in get_samples ( f ) : counts [ s ] += 1 duplicates = [ s for s , c in counts . items ( ) if c > 1 ] if duplicates : raise ValueError ( \"Duplicate samples found in inputs %s: %s\" % ( duplicates , fnames ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes trailing zeroes from indexable collection of numbers [CODESPLIT] def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decode base64 padding being optional . [CODESPLIT] def decode_base64 ( data : str ) -> bytes : missing_padding = len ( data ) % 4 if missing_padding != 0 : data += \"=\" * ( 4 - missing_padding ) return base64 . decodebytes ( data . encode ( \"utf-8\" ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Warn if nans exist in a numpy array . [CODESPLIT] def warn_if_nans_exist ( X ) : null_count = count_rows_with_nans ( X ) total = len ( X ) percent = 100 * null_count / total if null_count > 0 : warning_message = 'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' 'complete rows will be plotted.' . format ( null_count , total , percent ) warnings . warn ( warning_message , DataWarning )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x . [CODESPLIT] def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Repeat each item in iterable n times . [CODESPLIT] def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item", "target": 1, "target_options": ["no_match", "match"]}
{"input": "takes a list of lists l and returns a flat list [CODESPLIT] def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Performs an element - wise check to determine if the NDArray contains an infinite element or not . TODO : remove this funciton after upgrade to MXNet 1 . 4 . * in favor of mx . ndarray . contrib . isfinite () [CODESPLIT] def isfinite ( data : mx . nd . NDArray ) -> mx . nd . NDArray : is_data_not_nan = data == data is_data_not_infinite = data . abs ( ) != np . inf return mx . nd . logical_and ( is_data_not_infinite , is_data_not_nan )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Executes a given query string on an open postgres database . [CODESPLIT] def execute_sql ( self , query ) : c = self . con . cursor ( ) c . execute ( query ) result = [ ] if c . rowcount > 0 : try : result = c . fetchall ( ) except psycopg2 . ProgrammingError : pass return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a list of lists into a flat list . Args : x : list of lists [CODESPLIT] def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected [CODESPLIT] def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts all strings in a column to uppercase . [CODESPLIT] def str_upper ( x ) : sl = _to_string_sequence ( x ) . upper ( ) return column . ColumnStringArrow ( sl . bytes , sl . indices , sl . length , sl . offset , string_sequence = sl )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if values are not increasing . [CODESPLIT] def non_increasing ( values ) : return all ( x >= y for x , y in zip ( values , values [ 1 : ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x . [CODESPLIT] def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the longest string size for a string entry across data . [CODESPLIT] def _prm_get_longest_stringsize ( string_list ) : maxlength = 1 for stringar in string_list : if isinstance ( stringar , np . ndarray ) : if stringar . ndim > 0 : for string in stringar . ravel ( ) : maxlength = max ( len ( string ) , maxlength ) else : maxlength = max ( len ( stringar . tolist ( ) ) , maxlength ) else : maxlength = max ( len ( stringar ) , maxlength ) # Make the string Col longer than needed in order to allow later on slightly larger strings return int ( maxlength * 1.5 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Asynchronous generator for lines from subprocess stdout . [CODESPLIT] async def stdout ( self ) -> AsyncGenerator [ str , None ] : await self . wait_running ( ) async for line in self . _subprocess . stdout : # type: ignore yield line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if given trees share the same structure of powernodes independently of ( power ) node names and same edge topology between ( power ) nodes . [CODESPLIT] def same_network ( atree , btree ) -> bool : return same_hierarchy ( atree , btree ) and same_topology ( atree , btree )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns all column names and their data types as a list . [CODESPLIT] def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert string from camel case to snake case . [CODESPLIT] def camel_to_snake ( s : str ) -> str : return CAMEL_CASE_RE . sub ( r'_\\1' , s ) . strip ( ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper around Django s get_language utility . For Django > = 1 . 8 get_language returns None in case no translation is activate . Here we patch this behavior e . g . for back - end functionality requiring access to translated fields [CODESPLIT] def get_language ( ) : from parler import appsettings language = dj_get_language ( ) if language is None and appsettings . PARLER_DEFAULT_ACTIVATE : return appsettings . PARLER_DEFAULT_LANGUAGE_CODE else : return language", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return flattened dictionary from MultiDict . [CODESPLIT] def flatten_multidict ( multidict ) : return dict ( [ ( key , value if len ( value ) > 1 else value [ 0 ] ) for ( key , value ) in multidict . iterlists ( ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes all non - printable characters from a text string [CODESPLIT] def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the item that appears most frequently in the given list . [CODESPLIT] def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": param data : Base 64 encoded data to decode . : type data : bytes : return : Base 64 decoded data . : rtype : bytes [CODESPLIT] def b64_decode ( data : bytes ) -> bytes : missing_padding = len ( data ) % 4 if missing_padding != 0 : data += b'=' * ( 4 - missing_padding ) return urlsafe_b64decode ( data )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert human readable string to datetime . datetime . [CODESPLIT] def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Covert numpy array to tensorflow tensor [CODESPLIT] def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** . [CODESPLIT] def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Hacky workaround for old installs of the library on systems without python - future that were keeping the 2to3 update from working after auto - update . [CODESPLIT] def bytes_hack ( buf ) : ub = None if sys . version_info > ( 3 , ) : ub = buf else : ub = bytes ( buf ) return ub", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove the element from a set lists or dict . >>> L = [ Lucy ] ; S = set ( [ Sky ] ) ; D = { Diamonds : True } ; >>> remove_once ( L Lucy ) ; remove_once ( S Sky ) ; remove_once ( D Diamonds ) ; >>> print L S D [] set ( [] ) {} [CODESPLIT] def remove_once ( gset , elem ) : remove = getattr ( gset , 'remove' , None ) if remove is not None : remove ( elem ) else : del gset [ elem ] return elem", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if n is a prime number [CODESPLIT] def is_prime ( n ) : if n % 2 == 0 and n > 2 : return False return all ( n % i for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "* A datetime stamp in MySQL format : YYYY - MM - DDTHH : MM : SS * [CODESPLIT] def get_now_sql_datetime ( ) : ## > IMPORTS ## from datetime import datetime , date , time now = datetime . now ( ) now = now . strftime ( \"%Y-%m-%dT%H:%M:%S\" ) return now", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all ( and only ) the chars in the given string . [CODESPLIT] def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run verbose PyLint on source . Optionally specify fmt = html for HTML output . [CODESPLIT] def lint ( fmt = 'colorized' ) : if fmt == 'html' : outfile = 'pylint_report.html' local ( 'pylint -f %s davies > %s || true' % ( fmt , outfile ) ) local ( 'open %s' % outfile ) else : local ( 'pylint -f %s davies || true' % fmt )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } ) [CODESPLIT] def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get all the database column names for the specified table . [CODESPLIT] def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sample from independent normal distributions [CODESPLIT] def sample_normal ( mean , var , rng ) : ret = numpy . sqrt ( var ) * rng . randn ( * mean . shape ) + mean return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper to make map () behave the same on Py2 and Py3 . [CODESPLIT] def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of elements equal to elem present in the queue [CODESPLIT] def count ( self , elem ) : return self . _left_list . count ( elem ) + self . _right_list . count ( elem )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists . [CODESPLIT] def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the index of the earliest occurence of an item from a list in a string [CODESPLIT] def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists . [CODESPLIT] def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Purely a debugging aid : Ascii - art picture of a tree descended from node [CODESPLIT] def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a datetime from GnuCash 2 . 6 date string [CODESPLIT] def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x . [CODESPLIT] def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the item that appears most frequently in the given list . [CODESPLIT] def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1 [CODESPLIT] def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pull a file directly from S3 . [CODESPLIT] def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Try to initialize the given module instance . [CODESPLIT] def try_instance_init ( self , instance , late_start = False ) : try : instance . init_try += 1 # Maybe it's a retry if not late_start and instance . init_try > 1 : # Do not try until too frequently, or it's too loopy if instance . last_init_try > time . time ( ) - MODULE_INIT_PERIOD : logger . info ( \"Too early to retry initialization, retry period is %d seconds\" , MODULE_INIT_PERIOD ) # logger.info(\"%s / %s\", instance.last_init_try, time.time()) return False instance . last_init_try = time . time ( ) logger . info ( \"Trying to initialize module: %s\" , instance . name ) # If it's an external module, create/update Queues() if instance . is_external : instance . create_queues ( self . daemon . sync_manager ) # The module instance init function says if initialization is ok if not instance . init ( ) : logger . warning ( \"Module %s initialisation failed.\" , instance . name ) return False logger . info ( \"Module %s is initialized.\" , instance . name ) except Exception as exp : # pylint: disable=broad-except # pragma: no cover, simple protection msg = \"The module instance %s raised an exception \" \"on initialization: %s, I remove it!\" % ( instance . name , str ( exp ) ) self . configuration_errors . append ( msg ) logger . error ( msg ) logger . exception ( exp ) return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add colons after every second digit . [CODESPLIT] def add_colons ( s ) : return ':' . join ( [ s [ i : i + 2 ] for i in range ( 0 , len ( s ) , 2 ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the memory is too full for further caching . [CODESPLIT] def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all ( and only ) the uppercase chars in the given string . [CODESPLIT] def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "zfill ( x width ) - > string [CODESPLIT] def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Skip a section [CODESPLIT] def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes an ISO - 8601 string and returns a datetime . [CODESPLIT] def iso_string_to_python_datetime ( isostring : str ) -> Optional [ datetime . datetime ] : if not isostring : return None # if you parse() an empty string, you get today's date return dateutil . parser . parse ( isostring )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Within the dictionary d find a key that matches ( in case - insensitive fashion ) the key k and return it ( or None if there isn t one ) . [CODESPLIT] def get_case_insensitive_dict_key ( d : Dict , k : str ) -> Optional [ str ] : for key in d . keys ( ) : if k . lower ( ) == key . lower ( ) : return key return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load JSON file [CODESPLIT] def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dict with swapped keys and values [CODESPLIT] def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield . [CODESPLIT] def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Raise ValueError if more than one keyword argument is not none . [CODESPLIT] def check_oneof ( * * kwargs ) : # Sanity check: If no keyword arguments were sent, this is fine. if not kwargs : return None not_nones = [ val for val in kwargs . values ( ) if val is not None ] if len ( not_nones ) > 1 : raise ValueError ( 'Only one of {fields} should be set.' . format ( fields = ', ' . join ( sorted ( kwargs . keys ( ) ) ) , ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility function to print sqlite queries before executing . [CODESPLIT] def execute ( cur , * args ) : stmt = args [ 0 ] if len ( args ) > 1 : stmt = stmt . replace ( '%' , '%%' ) . replace ( '?' , '%r' ) print ( stmt % ( args [ 1 ] ) ) return cur . execute ( * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield all items from iterable except the last one . [CODESPLIT] def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a python_style_variable_name to lowerCamelCase . [CODESPLIT] def camelize ( key ) : return '' . join ( x . capitalize ( ) if i > 0 else x for i , x in enumerate ( key . split ( '_' ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper to make map () behave the same on Py2 and Py3 . [CODESPLIT] def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialize attributes for informative output . [CODESPLIT] def __init__ ( self , enum_obj : Any ) -> None : if enum_obj : self . name = enum_obj self . items = ', ' . join ( [ str ( i ) for i in enum_obj ] ) else : self . items = ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fast median operation for masked array using 50th - percentile [CODESPLIT] def fast_median ( a ) : a = checkma ( a ) #return scoreatpercentile(a.compressed(), 50) if a . count ( ) > 0 : out = np . percentile ( a . compressed ( ) , 50 ) else : out = np . ma . masked return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Collect data into fixed - length chunks or blocks . [CODESPLIT] def _groups_of_size ( iterable , n , fillvalue = None ) : # _groups_of_size('ABCDEFG', 3, 'x') --> ABC DEF Gxx args = [ iter ( iterable ) ] * n return zip_longest ( fillvalue = fillvalue , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get version information for components used by Spyder [CODESPLIT] def get_versions ( reporev = True ) : import sys import platform import qtpy import qtpy . QtCore revision = None if reporev : from spyder . utils import vcs revision , branch = vcs . get_git_revision ( os . path . dirname ( __dir__ ) ) if not sys . platform == 'darwin' : # To avoid a crash with our Mac app system = platform . system ( ) else : system = 'Darwin' return { 'spyder' : __version__ , 'python' : platform . python_version ( ) , # \"2.7.3\" 'bitness' : 64 if sys . maxsize > 2 ** 32 else 32 , 'qt' : qtpy . QtCore . __version__ , 'qt_api' : qtpy . API_NAME , # PyQt5 'qt_api_ver' : qtpy . PYQT_VERSION , 'system' : system , # Linux, Windows, ... 'release' : platform . release ( ) , # XP, 10.6, 2.2.0, etc. 'revision' : revision , # '9fdf926eccce' }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Looks for a longest common string between any two given strings passed : param str_a : str : param str_b : str [CODESPLIT] def long_substring ( str_a , str_b ) : data = [ str_a , str_b ] substr = '' if len ( data ) > 1 and len ( data [ 0 ] ) > 0 : for i in range ( len ( data [ 0 ] ) ) : for j in range ( len ( data [ 0 ] ) - i + 1 ) : if j > len ( substr ) and all ( data [ 0 ] [ i : i + j ] in x for x in data ) : substr = data [ 0 ] [ i : i + j ] return substr . strip ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if a value is a finite number . [CODESPLIT] def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a generator that squashes two iterables into one . [CODESPLIT] def squash ( self , a , b ) : return ( ( '' . join ( x ) if isinstance ( x , tuple ) else x ) for x in itertools . product ( a , b ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a new copied dictionary without the keys with None values from the given Mapping object . [CODESPLIT] def clean_map ( obj : Mapping [ Any , Any ] ) -> Mapping [ Any , Any ] : return { k : v for k , v in obj . items ( ) if v is not None }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the year . [CODESPLIT] def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Time execution of function . Returns ( res seconds ) . [CODESPLIT] def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Like rotate but modifies l in - place . [CODESPLIT] def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "HTTP POST operation to API endpoint . [CODESPLIT] def post ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'POST' , endpoint , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "gets the dimensions depending on python version and os [CODESPLIT] def get_window_dim ( ) : version = sys . version_info if version >= ( 3 , 3 ) : return _size_36 ( ) if platform . system ( ) == 'Windows' : return _size_windows ( ) return _size_27 ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Args : x : iterable of strings [CODESPLIT] def gen_lower ( x : Iterable [ str ] ) -> Generator [ str , None , None ] : for string in x : yield string . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the keys that maps to the top n max values in the given dict . [CODESPLIT] def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a filepath returns all the commits that modified this file ( following renames ) . [CODESPLIT] def get_commits_modified_file ( self , filepath : str ) -> List [ str ] : path = str ( Path ( filepath ) ) commits = [ ] try : commits = self . git . log ( \"--follow\" , \"--format=%H\" , path ) . split ( '\\n' ) except GitCommandError : logger . debug ( \"Could not find information of file %s\" , path ) return commits", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute the given multiquery . [CODESPLIT] async def executemany ( self , sql : str , parameters : Iterable [ Iterable [ Any ] ] ) -> None : await self . _execute ( self . _cursor . executemany , sql , parameters )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper around Django s get_language utility . For Django > = 1 . 8 get_language returns None in case no translation is activate . Here we patch this behavior e . g . for back - end functionality requiring access to translated fields [CODESPLIT] def get_language ( ) : from parler import appsettings language = dj_get_language ( ) if language is None and appsettings . PARLER_DEFAULT_ACTIVATE : return appsettings . PARLER_DEFAULT_LANGUAGE_CODE else : return language", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Under UNIX : is a keystroke available? [CODESPLIT] def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test for greater than . [CODESPLIT] def __gt__ ( self , other ) : if isinstance ( other , Address ) : return str ( self ) > str ( other ) raise TypeError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get cosine similarity between two words . If a word is not in the vocabulary KeyError will be raised . [CODESPLIT] def similarity ( word1 : str , word2 : str ) -> float : return _MODEL . similarity ( word1 , word2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a snake cased version of a string . [CODESPLIT] def snake_case ( a_string ) : partial = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , a_string ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , partial ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the default bucket from a list of buckets i . e . the largest bucket . [CODESPLIT] def get_default_bucket_key ( buckets : List [ Tuple [ int , int ] ] ) -> Tuple [ int , int ] : return max ( buckets )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Swap the methods atom to remove method with key . [CODESPLIT] def __remove_method ( m : lmap . Map , key : T ) -> lmap . Map : return m . dissoc ( key )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rate limit a function . [CODESPLIT] def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dict with swapped keys and values [CODESPLIT] def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return dict mapping item - > indices . [CODESPLIT] def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get all the database column names for the specified table . [CODESPLIT] def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right . [CODESPLIT] def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Index of the last occurrence of x in the sequence . [CODESPLIT] def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "! [CODESPLIT] def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a json array as a list [CODESPLIT] def __as_list ( value : List [ JsonObjTypes ] ) -> List [ JsonTypes ] : return [ e . _as_dict if isinstance ( e , JsonObj ) else e for e in value ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove any duplicate item preserving order [CODESPLIT] def de_duplicate ( items ) : result = [ ] for item in items : if item not in result : result . append ( item ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the keys that maps to the top n max values in the given dict . [CODESPLIT] def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform dictionary of environment variables into Docker - e parameters . [CODESPLIT] def docker_environment ( env ) : return ' ' . join ( [ \"-e \\\"%s=%s\\\"\" % ( key , value . replace ( \"$\" , \"\\\\$\" ) . replace ( \"\\\"\" , \"\\\\\\\"\" ) . replace ( \"`\" , \"\\\\`\" ) ) for key , value in env . items ( ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Makes the HTTP request ( synchronous ) and return the deserialized data . To make an async request set the asynchronous parameter . [CODESPLIT] def call_api ( self , resource_path , method , path_params = None , query_params = None , header_params = None , body = None , post_params = None , files = None , response_type = None , auth_settings = None , asynchronous = None , _return_http_data_only = None , collection_formats = None , _preload_content = True , _request_timeout = None ) : if not asynchronous : return self . __call_api ( resource_path , method , path_params , query_params , header_params , body , post_params , files , response_type , auth_settings , _return_http_data_only , collection_formats , _preload_content , _request_timeout ) else : thread = self . pool . apply_async ( self . __call_api , ( resource_path , method , path_params , query_params , header_params , body , post_params , files , response_type , auth_settings , _return_http_data_only , collection_formats , _preload_content , _request_timeout ) ) return thread", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a snake_case_string to a camelCaseString . [CODESPLIT] def snake_to_camel ( value ) : camel = \"\" . join ( word . title ( ) for word in value . split ( \"_\" ) ) return value [ : 1 ] . lower ( ) + camel [ 1 : ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A non - negative integer . [CODESPLIT] def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of elements equal to elem present in the queue [CODESPLIT] def count ( self , elem ) : return self . _left_list . count ( elem ) + self . _right_list . count ( elem )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise . [CODESPLIT] def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Under UNIX : is a keystroke available? [CODESPLIT] def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line . [CODESPLIT] def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the year . [CODESPLIT] def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple helper hash function [CODESPLIT] def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return an ISO - 8601 representation of a datetime object . [CODESPLIT] def datetime_iso_format ( date ) : return \"{0:0>4}-{1:0>2}-{2:0>2}T{3:0>2}:{4:0>2}:{5:0>2}Z\" . format ( date . year , date . month , date . day , date . hour , date . minute , date . second )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Very simple grep that returns the first matching line in a file . String matching only does not do REs as currently implemented . [CODESPLIT] def grep ( pattern , filename ) : try : # for line in file # if line matches pattern: #    return line return next ( ( L for L in open ( filename ) if L . find ( pattern ) >= 0 ) ) except StopIteration : return ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn a list into a comma - and / or and - separated string . [CODESPLIT] def list_to_str ( lst ) : if len ( lst ) == 1 : str_ = lst [ 0 ] elif len ( lst ) == 2 : str_ = ' and ' . join ( lst ) elif len ( lst ) > 2 : str_ = ', ' . join ( lst [ : - 1 ] ) str_ += ', and {0}' . format ( lst [ - 1 ] ) else : raise ValueError ( 'List of length 0 provided.' ) return str_", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tries to work out the highlight . js language of a given file name or shebang . Returns an empty string if none match . [CODESPLIT] def get_language ( query : str ) -> str : query = query . lower ( ) for language in LANGUAGES : if query . endswith ( language ) : return language return ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run verbose PyLint on source . Optionally specify fmt = html for HTML output . [CODESPLIT] def lint ( fmt = 'colorized' ) : if fmt == 'html' : outfile = 'pylint_report.html' local ( 'pylint -f %s davies > %s || true' % ( fmt , outfile ) ) local ( 'open %s' % outfile ) else : local ( 'pylint -f %s davies || true' % fmt )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if a value is a finite number . [CODESPLIT] def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strips # comments that exist at the top of the given lines [CODESPLIT] def _strip_top_comments ( lines : Sequence [ str ] , line_separator : str ) -> str : lines = copy . copy ( lines ) while lines and lines [ 0 ] . startswith ( \"#\" ) : lines = lines [ 1 : ] return line_separator . join ( lines )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Class decorator for adding a class local logger [CODESPLIT] def scope_logger ( cls ) : cls . log = logging . getLogger ( '{0}.{1}' . format ( cls . __module__ , cls . __name__ ) ) return cls", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230 [CODESPLIT] def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a PNG file and decode it into flat row flat pixel format . [CODESPLIT] def read_flat ( self ) : x , y , pixel , meta = self . read ( ) arraycode = 'BH' [ meta [ 'bitdepth' ] > 8 ] pixel = array ( arraycode , itertools . chain ( * pixel ) ) return x , y , pixel , meta", "target": 1, "target_options": ["no_match", "match"]}
{"input": "SwitchToThisWindow from Win32 . handle : int the handle of a native window . [CODESPLIT] def SwitchToThisWindow ( handle : int ) -> None : ctypes . windll . user32 . SwitchToThisWindow ( ctypes . c_void_p ( handle ) , 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convent hex color to tuple #ffffff - > ( 255 255 255 ) #ffff00ff - > ( 255 255 0 255 ) [CODESPLIT] def hex_color_to_tuple ( hex ) : hex = hex [ 1 : ] length = len ( hex ) // 2 return tuple ( int ( hex [ i * 2 : i * 2 + 2 ] , 16 ) for i in range ( length ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper to make map () behave the same on Py2 and Py3 . [CODESPLIT] def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if specified value exists in int enum ; otherwise False . [CODESPLIT] def has_value ( cls , value : int ) -> bool : return any ( value == item . value for item in cls )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes trailing zeroes from indexable collection of numbers [CODESPLIT] def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit execution with return code and message : param msg : Message displayed prior to exit : param code : code returned upon exiting [CODESPLIT] def Exit ( msg , code = 1 ) : print >> sys . stderr , msg sys . exit ( code )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "checks if you are on a 64 bit platform [CODESPLIT] def check64bit ( current_system = \"python\" ) : if current_system == \"python\" : return sys . maxsize > 2147483647 elif current_system == \"os\" : import platform pm = platform . machine ( ) if pm != \"..\" and pm . endswith ( '64' ) : # recent Python (not Iron) return True else : if 'PROCESSOR_ARCHITEW6432' in os . environ : return True # 32 bit program running on 64 bit Windows try : # 64 bit Windows 64 bit program return os . environ [ 'PROCESSOR_ARCHITECTURE' ] . endswith ( '64' ) except IndexError : pass # not Windows try : # this often works in Linux return '64' in platform . architecture ( ) [ 0 ] except Exception : # is an older version of Python, assume also an older os@ # (best we can guess) return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip the whitespace from all column names in the given DataFrame and return the result . [CODESPLIT] def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "string dict / object / value to JSON [CODESPLIT] def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert reading value to float ( if possible ) [CODESPLIT] def parse_reading ( val : str ) -> Optional [ float ] : try : return float ( val ) except ValueError : logging . warning ( 'Reading of \"%s\" is not a number' , val ) return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Accepts a binary string and returns the detected filetype . Return value is the mimetype if mime = True otherwise a human readable name . [CODESPLIT] def from_buffer ( buffer , mime = False ) : m = _get_magic_type ( mime ) return m . from_buffer ( buffer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if key exists in datastore . True if yes False if no . [CODESPLIT] def check_key ( self , key : str ) -> bool : keys = self . get_keys ( ) return key in keys", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Capitalize a sentence . [CODESPLIT] def capitalize ( string ) : if not string : return string if len ( string ) == 1 : return string . upper ( ) return string [ 0 ] . upper ( ) + string [ 1 : ] . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Try to infer an object s dtype for use in arithmetic ops [CODESPLIT] def maybe_infer_dtype_type ( element ) : tipo = None if hasattr ( element , 'dtype' ) : tipo = element . dtype elif is_list_like ( element ) : element = np . asarray ( element ) tipo = element . dtype return tipo", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the keys that maps to the top n max values in the given dict . [CODESPLIT] def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Export the graph to the dot file filename . dot . [CODESPLIT] def export_to_dot ( self , filename : str = 'output' ) -> None : with open ( filename + '.dot' , 'w' ) as output : output . write ( self . as_dot ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns full ISO string for the given date [CODESPLIT] def to_iso_string ( self ) -> str : assert isinstance ( self . value , datetime ) return datetime . isoformat ( self . value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decode base64 string to byte array . [CODESPLIT] def decodebytes ( input ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _decodebytes_py3 ( input ) return _decodebytes_py2 ( input )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Try to capitalize properly a title string . [CODESPLIT] def fix_title_capitalization ( title ) : if re . search ( \"[A-Z]\" , title ) and re . search ( \"[a-z]\" , title ) : return title word_list = re . split ( ' +' , title ) final = [ word_list [ 0 ] . capitalize ( ) ] for word in word_list [ 1 : ] : if word . upper ( ) in COMMON_ACRONYMS : final . append ( word . upper ( ) ) elif len ( word ) > 3 : final . append ( word . capitalize ( ) ) else : final . append ( word . lower ( ) ) return \" \" . join ( final )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes an array add indentation to each entry and prints it . [CODESPLIT] def PrintIndented ( self , file , ident , code ) : for entry in code : print >> file , '%s%s' % ( ident , entry )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Purely a debugging aid : Ascii - art picture of a tree descended from node [CODESPLIT] def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes all blank lines in @string [CODESPLIT] def remove_blank_lines ( string ) : return \"\\n\" . join ( line for line in string . split ( \"\\n\" ) if len ( line . strip ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a UUID object to a 22 - char BUID string [CODESPLIT] def uuid2buid ( value ) : if six . PY3 : # pragma: no cover return urlsafe_b64encode ( value . bytes ) . decode ( 'utf-8' ) . rstrip ( '=' ) else : return six . text_type ( urlsafe_b64encode ( value . bytes ) . rstrip ( '=' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for iterating only nonempty lines without line breaks [CODESPLIT] def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is the SQLAlchemy column type a string type? [CODESPLIT] def is_sqlatype_string ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . String )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "replace ( str old new [ maxreplace ] ) - > string [CODESPLIT] def replace ( s , old , new , maxreplace = - 1 ) : return s . replace ( old , new , maxreplace )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the item that appears most frequently in the given list . [CODESPLIT] def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the longest string size for a string entry across data . [CODESPLIT] def _prm_get_longest_stringsize ( string_list ) : maxlength = 1 for stringar in string_list : if isinstance ( stringar , np . ndarray ) : if stringar . ndim > 0 : for string in stringar . ravel ( ) : maxlength = max ( len ( string ) , maxlength ) else : maxlength = max ( len ( stringar . tolist ( ) ) , maxlength ) else : maxlength = max ( len ( stringar ) , maxlength ) # Make the string Col longer than needed in order to allow later on slightly larger strings return int ( maxlength * 1.5 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deletes all files whose filename matches the glob pattern ( via : func : glob . glob ) . [CODESPLIT] def rmglob ( pattern : str ) -> None : for f in glob . glob ( pattern ) : os . remove ( f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of dimensions of a tensor [CODESPLIT] def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Index of the last occurrence of x in the sequence . [CODESPLIT] def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if a value is a finite number . [CODESPLIT] def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "HTTP POST operation to API endpoint . [CODESPLIT] def post ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'POST' , endpoint , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "docstring for argparse [CODESPLIT] def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a list of lists into a flat list . Args : x : list of lists [CODESPLIT] def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a sequence of indices into their corresponding labels . [CODESPLIT] def indices_to_labels ( self , indices : Sequence [ int ] ) -> List [ str ] : return [ ( self . INDEX_TO_LABEL [ index ] ) for index in indices ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip all color codes from a string . Returns empty string for falsey inputs . [CODESPLIT] def strip_codes ( s : Any ) -> str : return codepat . sub ( '' , str ( s ) if ( s or ( s == 0 ) ) else '' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "filter for dict note f should have signature : f :: key - > value - > bool [CODESPLIT] def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ] [CODESPLIT] def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility method to run commands synchronously for testing . [CODESPLIT] def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( \"Event loop is already running.\" ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return local machine unique identifier . [CODESPLIT] def local_machine_uuid ( ) : result = subprocess . check_output ( 'hal-get-property --udi ' '/org/freedesktop/Hal/devices/computer ' '--key system.hardware.uuid' . split ( ) ) . strip ( ) return uuid . UUID ( hex = result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last week as a period string [CODESPLIT] def get_period_last_3_months ( ) -> str : today = Datum ( ) today . today ( ) # start_date = today - timedelta(weeks=13) start_date = today . clone ( ) start_date . subtract_months ( 3 ) period = get_period ( start_date . date , today . date ) return period", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing [CODESPLIT] def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a list of the top topn features in this : class : . Feature \\ . [CODESPLIT] def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Discover the current time zone and it s standard string representation ( for source { d } ) . [CODESPLIT] def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( \"%z\" ) tzstr = tzstr [ : - 2 ] + \":\" + tzstr [ - 2 : ] return dt . tzinfo , tzstr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility function to print sqlite queries before executing . [CODESPLIT] def execute ( cur , * args ) : stmt = args [ 0 ] if len ( args ) > 1 : stmt = stmt . replace ( '%' , '%%' ) . replace ( '?' , '%r' ) print ( stmt % ( args [ 1 ] ) ) return cur . execute ( * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Detects whether a line is present within a file . [CODESPLIT] def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x . [CODESPLIT] def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper to make map () behave the same on Py2 and Py3 . [CODESPLIT] def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield all items from iterable except the last one . [CODESPLIT] def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the year . [CODESPLIT] def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all ( and only ) the chars in the given string . [CODESPLIT] def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the current value of stocks [CODESPLIT] def get_value ( self ) -> Decimal : quantity = self . get_quantity ( ) price = self . get_last_available_price ( ) if not price : # raise ValueError(\"no price found for\", self.full_symbol) return Decimal ( 0 ) value = quantity * price . value return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the index of the earliest occurence of an item from a list in a string [CODESPLIT] def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the keys that maps to the top n max values in the given dict . [CODESPLIT] def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads text file contents [CODESPLIT] def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get domain part of an url . [CODESPLIT] def get_domain ( url ) : parse_result = urlparse ( url ) domain = \"{schema}://{netloc}\" . format ( schema = parse_result . scheme , netloc = parse_result . netloc ) return domain", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing [CODESPLIT] def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if a value is a finite number . [CODESPLIT] def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the tanimoto set similarity . [CODESPLIT] def tanimoto_set_similarity ( x : Iterable [ X ] , y : Iterable [ X ] ) -> float : a , b = set ( x ) , set ( y ) union = a | b if not union : return 0.0 return len ( a & b ) / len ( union )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert human readable string to datetime . datetime . [CODESPLIT] def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Purely a debugging aid : Ascii - art picture of a tree descended from node [CODESPLIT] def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the string representation of self . [CODESPLIT] def __repr__ ( self ) -> str : return '{0}({1})' . format ( type ( self ) . __name__ , repr ( self . string ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reshuffle the indicies of a bipartite matrix A [ ij kl ] - > A [ lj ki ] . [CODESPLIT] def _reshuffle ( mat , shape ) : return np . reshape ( np . transpose ( np . reshape ( mat , shape ) , ( 3 , 1 , 2 , 0 ) ) , ( shape [ 3 ] * shape [ 1 ] , shape [ 0 ] * shape [ 2 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if a string is quoted : param arg : the string being checked for quotes : return : True if a string is quoted [CODESPLIT] def is_quoted ( arg : str ) -> bool : return len ( arg ) > 1 and arg [ 0 ] == arg [ - 1 ] and arg [ 0 ] in constants . QUOTES", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given [ A B C ] return A B or C . [CODESPLIT] def quoted_or_list ( items : List [ str ] ) -> Optional [ str ] : return or_list ( [ f\"'{item}'\" for item in items ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple helper hash function [CODESPLIT] def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the fist ( left - hand ) digits in a string as a single integer ignoring sign ( + / - ) . >>> first_digits ( + 123 . 456 ) 123 [CODESPLIT] def first_digits ( s , default = 0 ) : s = re . split ( r'[^0-9]+' , str ( s ) . strip ( ) . lstrip ( '+-' + charlist . whitespace ) ) if len ( s ) and len ( s [ 0 ] ) : return int ( s [ 0 ] ) return default", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if test is True for all array elements . Otherwise returns False . [CODESPLIT] def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def run_time ( ) -> timedelta : delta = start_time if start_time else datetime . utcnow ( ) return datetime . utcnow ( ) - delta", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all ( and only ) the uppercase chars in the given string . [CODESPLIT] def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a random walk and return True if the walker has returned to the origin after taking n steps . [CODESPLIT] def returned ( n ) : ## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk for pos in randwalk ( ) >> drop ( 1 ) >> takei ( xrange ( n - 1 ) ) : if pos == Origin : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert GPU arras to numpy and return them [CODESPLIT] def to_np ( * args ) : if len ( args ) > 1 : return ( cp . asnumpy ( x ) for x in args ) else : return cp . asnumpy ( args [ 0 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of elements equal to elem present in the queue [CODESPLIT] def count ( self , elem ) : return self . _left_list . count ( elem ) + self . _right_list . count ( elem )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a generator over iterable that tells whether the current item is the last one . Usage : >>> iterable = range ( 10 ) >>> for index is_last item in enum_mark_last ( iterable ) : >>> print ( index item end = \\ n if is_last else ) [CODESPLIT] def enum_mark_last ( iterable , start = 0 ) : it = iter ( iterable ) count = start try : last = next ( it ) except StopIteration : return for val in it : yield count , False , last last = val count += 1 yield count , True , last", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rate limit a function . [CODESPLIT] def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230 [CODESPLIT] def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if duration_seconds have expired since start_time [CODESPLIT] def duration_expired ( start_time , duration_seconds ) : if duration_seconds is not None : delta_seconds = datetime_delta_to_seconds ( dt . datetime . now ( ) - start_time ) if delta_seconds >= duration_seconds : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper to make map () behave the same on Py2 and Py3 . [CODESPLIT] def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shamelessly taken from Django . https : // github . com / django / django / blob / master / django / utils / text . py [CODESPLIT] def get_valid_filename ( s ) : s = str ( s ) . strip ( ) . replace ( ' ' , '_' ) return re . sub ( r'(?u)[^-\\w.]' , '' , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Override this method for processing captcha . [CODESPLIT] async def enter_captcha ( self , url : str , sid : str ) -> str : raise VkCaptchaNeeded ( url , sid )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate the first value in each row . [CODESPLIT] def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn a list into a comma - and / or and - separated string . [CODESPLIT] def list_to_str ( lst ) : if len ( lst ) == 1 : str_ = lst [ 0 ] elif len ( lst ) == 2 : str_ = ' and ' . join ( lst ) elif len ( lst ) > 2 : str_ = ', ' . join ( lst [ : - 1 ] ) str_ += ', and {0}' . format ( lst [ - 1 ] ) else : raise ValueError ( 'List of length 0 provided.' ) return str_", "target": 1, "target_options": ["no_match", "match"]}
{"input": "decode ( bytearray raw = False ) - > value [CODESPLIT] def decode ( self , bytes , raw = False ) : return struct . unpack ( self . format , buffer ( bytes ) ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Index of the last occurrence of x in the sequence . [CODESPLIT] def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if values are not increasing . [CODESPLIT] def non_increasing ( values ) : return all ( x >= y for x , y in zip ( values , values [ 1 : ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get all the database column names for the specified table . [CODESPLIT] def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Detects whether a line is present within a file . [CODESPLIT] def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the index of the earliest occurence of an item from a list in a string [CODESPLIT] def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if given trees share the same structure of powernodes independently of ( power ) node names and same edge topology between ( power ) nodes . [CODESPLIT] def same_network ( atree , btree ) -> bool : return same_hierarchy ( atree , btree ) and same_topology ( atree , btree )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a consistent ( key value ) iterable on dict - like objects including lists of tuple pairs . [CODESPLIT] def iterate_items ( dictish ) : if hasattr ( dictish , 'iteritems' ) : return dictish . iteritems ( ) if hasattr ( dictish , 'items' ) : return dictish . items ( ) return dictish", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a Python datetime to a string literal compatible with SQLite including the millisecond field . [CODESPLIT] def python_utc_datetime_to_sqlite_strftime_string ( value : datetime . datetime ) -> str : millisec_str = str ( round ( value . microsecond / 1000 ) ) . zfill ( 3 ) return value . strftime ( \"%Y-%m-%d %H:%M:%S\" ) + \".\" + millisec_str", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Purely a debugging aid : Ascii - art picture of a tree descended from node [CODESPLIT] def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "safe version of pow [CODESPLIT] def safe_pow ( base , exp ) : if exp > MAX_EXPONENT : raise RuntimeError ( \"Invalid exponent, max exponent is {}\" . format ( MAX_EXPONENT ) ) return base ** exp", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes trailing zeroes from indexable collection of numbers [CODESPLIT] def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Covert numpy array to tensorflow tensor [CODESPLIT] def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230 [CODESPLIT] def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a folder on S3 . [CODESPLIT] def mkdir ( self , target_folder ) : self . printv ( \"Making directory: %s\" % target_folder ) self . k . key = re . sub ( r\"^/|/$\" , \"\" , target_folder ) + \"/\" self . k . set_contents_from_string ( '' ) self . k . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fast median operation for masked array using 50th - percentile [CODESPLIT] def fast_median ( a ) : a = checkma ( a ) #return scoreatpercentile(a.compressed(), 50) if a . count ( ) > 0 : out = np . percentile ( a . compressed ( ) , 50 ) else : out = np . ma . masked return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove the prefix from the text if it exists . [CODESPLIT] def remove_prefix ( text , prefix ) : null , prefix , rest = text . rpartition ( prefix ) return rest", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return local machine unique identifier . [CODESPLIT] def local_machine_uuid ( ) : result = subprocess . check_output ( 'hal-get-property --udi ' '/org/freedesktop/Hal/devices/computer ' '--key system.hardware.uuid' . split ( ) ) . strip ( ) return uuid . UUID ( hex = result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert things on the way from Python to the database . [CODESPLIT] def process_literal_param ( self , value : Optional [ List [ int ] ] , dialect : Dialect ) -> str : retval = self . _intlist_to_dbstr ( value ) return retval", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Finds first file in path whose filename matches pattern ( via : func : fnmatch . fnmatch ) or raises : exc : IndexError . [CODESPLIT] def find_first ( pattern : str , path : str ) -> str : try : return find ( pattern , path ) [ 0 ] except IndexError : log . critical ( '''Couldn't find \"{}\" in \"{}\"''' , pattern , path ) raise", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper method to check if a set of types is the { AnyObject } singleton [CODESPLIT] def is_any_type_set ( sett : Set [ Type ] ) -> bool : return len ( sett ) == 1 and is_any_type ( min ( sett ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a byte array into an integer array . The number of bytes forming an integer is defined by num [CODESPLIT] def convert_bytes_to_ints ( in_bytes , num ) : dt = numpy . dtype ( '>i' + str ( num ) ) return numpy . frombuffer ( in_bytes , dt )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ">>> from utool . util_set import * # NOQA [CODESPLIT] def union ( cls , * sets ) : import utool as ut lists_ = ut . flatten ( [ list ( s ) for s in sets ] ) return cls ( lists_ )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cleanup temporary directory . [CODESPLIT] def _cleanup ( path : str ) -> None : if os . path . isdir ( path ) : shutil . rmtree ( path )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise . [CODESPLIT] def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": raises docker . exceptions . APIError [CODESPLIT] def running_containers ( name_filter : str ) -> List [ str ] : return [ container . short_id for container in docker_client . containers . list ( filters = { \"name\" : name_filter } ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield lines found in given file [CODESPLIT] def file_lines ( bblfile : str ) -> iter : with open ( bblfile ) as fd : yield from ( line . rstrip ( ) for line in fd if line . rstrip ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all ( and only ) the uppercase chars in the given string . [CODESPLIT] def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "skip performing substitutions that are outside the bounds of the string [CODESPLIT] def valid_substitution ( strlen , index ) : values = index [ 0 ] return all ( [ strlen > i for i in values ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compute the recall . [CODESPLIT] def recall_score ( y_true , y_pred , average = 'micro' , suffix = False ) : true_entities = set ( get_entities ( y_true , suffix ) ) pred_entities = set ( get_entities ( y_pred , suffix ) ) nb_correct = len ( true_entities & pred_entities ) nb_true = len ( true_entities ) score = nb_correct / nb_true if nb_true > 0 else 0 return score", "target": 1, "target_options": ["no_match", "match"]}
{"input": "( str ) - > int All the digits in a given string are concatenated and converted into a single number . [CODESPLIT] def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "! [CODESPLIT] def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is the SQLAlchemy column type an integer type? [CODESPLIT] def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "takes a list of lists l and returns a flat list [CODESPLIT] def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Truncates a value to a number of decimals places [CODESPLIT] def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a list of lists into a flat list . Args : x : list of lists [CODESPLIT] def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a variation from a base value [CODESPLIT] def _gauss ( mean : int , sigma : int ) -> int : return int ( random . gauss ( mean , sigma ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add mark to the index - th character of the given string . Return the new string after applying change . Notice : index > 0 [CODESPLIT] def add_mark_at ( string , index , mark ) : if index == - 1 : return string # Python can handle the case which index is out of range of given string return string [ : index ] + add_mark_char ( string [ index ] , mark ) + string [ index + 1 : ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected [CODESPLIT] def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the first location of the maximum value of x . The position is calculated relatively to the length of x . [CODESPLIT] def first_location_of_maximum ( x ) : if not isinstance ( x , ( np . ndarray , pd . Series ) ) : x = np . asarray ( x ) return np . argmax ( x ) / len ( x ) if len ( x ) > 0 else np . NaN", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Bulk load docs [CODESPLIT] def bulk_load_docs ( es , docs ) : chunk_size = 200 try : results = elasticsearch . helpers . bulk ( es , docs , chunk_size = chunk_size ) log . debug ( f\"Elasticsearch documents loaded: {results[0]}\" ) # elasticsearch.helpers.parallel_bulk(es, terms, chunk_size=chunk_size, thread_count=4) if len ( results [ 1 ] ) > 0 : log . error ( \"Bulk load errors {}\" . format ( results ) ) except elasticsearch . ElasticsearchException as e : log . error ( \"Indexing error: {}\\n\" . format ( e ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "string dict / object / value to JSON [CODESPLIT] def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit this application [CODESPLIT] def do_quit ( self , _ : argparse . Namespace ) -> bool : self . _should_quit = True return self . _STOP_AND_EXIT", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Signed greater - than comparison [CODESPLIT] def SGT ( self , a , b ) : # http://gavwood.com/paper.pdf s0 , s1 = to_signed ( a ) , to_signed ( b ) return Operators . ITEBV ( 256 , s0 > s1 , 1 , 0 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether flyweight object with specified key has already been created . [CODESPLIT] def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Report whether another set contains this set . [CODESPLIT] def issubset ( self , other ) : if len ( self ) > len ( other ) : # Fast check for obvious cases return False return all ( item in other for item in self )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "HTTP request method of interface implementation . [CODESPLIT] def _request ( self , method : str , endpoint : str , params : dict = None , data : dict = None , headers : dict = None ) -> dict :", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Writes a serializeable object as a JSON file [CODESPLIT] def _write_json ( obj , path ) : # type: (object, str) -> None with open ( path , 'w' ) as f : json . dump ( obj , f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a list of lists into a flat list . Args : x : list of lists [CODESPLIT] def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the last weekday in a given month . e . g : [CODESPLIT] def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the set of implemented system flags . [CODESPLIT] def get_system_flags ( ) -> FrozenSet [ Flag ] : return frozenset ( { Seen , Recent , Deleted , Flagged , Answered , Draft } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper to make map () behave the same on Py2 and Py3 . [CODESPLIT] def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit execution with return code and message : param msg : Message displayed prior to exit : param code : code returned upon exiting [CODESPLIT] def Exit ( msg , code = 1 ) : print >> sys . stderr , msg sys . exit ( code )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates that the object itself is some kinda string [CODESPLIT] def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fetch all remaining rows . [CODESPLIT] async def fetchall ( self ) -> Iterable [ sqlite3 . Row ] : return await self . _execute ( self . _cursor . fetchall )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replace {{ variable - name }} with stored value . [CODESPLIT] def replace_variables ( self , source : str , variables : dict ) -> str : try : replaced = re . sub ( \"{{(.*?)}}\" , lambda m : variables . get ( m . group ( 1 ) , \"\" ) , source ) except TypeError : replaced = source return replaced", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine whether sh has any value [CODESPLIT] def is_empty_shape ( sh : ShExJ . Shape ) -> bool : return sh . closed is None and sh . expression is None and sh . extra is None and sh . semActs is None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the duplicated items in the given collection [CODESPLIT] def duplicates ( coll ) : return list ( set ( x for x in coll if coll . count ( x ) > 1 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line . [CODESPLIT] def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** . [CODESPLIT] def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line . [CODESPLIT] def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a file exists and is non - empty . [CODESPLIT] def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit this application [CODESPLIT] def do_quit ( self , _ : argparse . Namespace ) -> bool : self . _should_quit = True return self . _STOP_AND_EXIT", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Runs Django collectstatic command in silent mode . [CODESPLIT] def collect_static ( ) -> bool : from django . core . management import execute_from_command_line # from django.conf import settings # if not os.listdir(settings.STATIC_ROOT): wf ( 'Collecting static files... ' , False ) execute_from_command_line ( [ './manage.py' , 'collectstatic' , '-c' , '--noinput' , '-v0' ] ) wf ( '[+]\\n' ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if key exists in datastore . True if yes False if no . [CODESPLIT] def check_key ( self , key : str ) -> bool : keys = self . get_keys ( ) return key in keys", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yields all permutations with replacement : list ( product ( cat repeat = 2 )) = > [ ( c c ) ( c a ) ( c t ) ( a c ) ( a a ) ( a t ) ( t c ) ( t a ) ( t t ) ] [CODESPLIT] def product ( * args , * * kwargs ) : p = [ [ ] ] for iterable in map ( tuple , args ) * kwargs . get ( \"repeat\" , 1 ) : p = [ x + [ y ] for x in p for y in iterable ] for p in p : yield tuple ( p )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read a PNG file and decode it into flat row flat pixel format . [CODESPLIT] def read_flat ( self ) : x , y , pixel , meta = self . read ( ) arraycode = 'BH' [ meta [ 'bitdepth' ] > 8 ] pixel = array ( arraycode , itertools . chain ( * pixel ) ) return x , y , pixel , meta", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for iterating only nonempty lines without line breaks [CODESPLIT] def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is the SQLAlchemy column type a string type? [CODESPLIT] def is_sqlatype_string ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . String )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the index of the earliest occurence of an item from a list in a string [CODESPLIT] def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip the whitespace from all column names in the given DataFrame and return the result . [CODESPLIT] def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sample from independent normal distributions [CODESPLIT] def sample_normal ( mean , var , rng ) : ret = numpy . sqrt ( var ) * rng . randn ( * mean . shape ) + mean return ret", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decode base64 string to byte array . [CODESPLIT] def decodebytes ( input ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _decodebytes_py3 ( input ) return _decodebytes_py2 ( input )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right . [CODESPLIT] def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "An Iterable may be a list or a generator . This ensures we get a list without making an unnecessary copy . [CODESPLIT] def ensure_list ( iterable : Iterable [ A ] ) -> List [ A ] : if isinstance ( iterable , list ) : return iterable else : return list ( iterable )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a CSV object to a numpy array . [CODESPLIT] def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run verbose PyLint on source . Optionally specify fmt = html for HTML output . [CODESPLIT] def lint ( fmt = 'colorized' ) : if fmt == 'html' : outfile = 'pylint_report.html' local ( 'pylint -f %s davies > %s || true' % ( fmt , outfile ) ) local ( 'open %s' % outfile ) else : local ( 'pylint -f %s davies || true' % fmt )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Closure of log for zero arguments . [CODESPLIT] def _protected_log ( x1 ) : with np . errstate ( divide = 'ignore' , invalid = 'ignore' ) : return np . where ( np . abs ( x1 ) > 0.001 , np . log ( np . abs ( x1 ) ) , 0. )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper to make map () behave the same on Py2 and Py3 . [CODESPLIT] def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Verifies that a string path actually exists and is a file [CODESPLIT] def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Index of the last occurrence of x in the sequence . [CODESPLIT] def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Index of the last occurrence of x in the sequence . [CODESPLIT] def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if all sequences in the list have the same length . [CODESPLIT] def are_token_parallel ( sequences : Sequence [ Sized ] ) -> bool : if not sequences or len ( sequences ) == 1 : return True return all ( len ( s ) == len ( sequences [ 0 ] ) for s in sequences )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return local machine unique identifier . [CODESPLIT] def local_machine_uuid ( ) : result = subprocess . check_output ( 'hal-get-property --udi ' '/org/freedesktop/Hal/devices/computer ' '--key system.hardware.uuid' . split ( ) ) . strip ( ) return uuid . UUID ( hex = result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the current version of the library is outdated . [CODESPLIT] def _check_update_ ( self ) : try : data = requests . get ( \"https://pypi.python.org/pypi/jira/json\" , timeout = 2.001 ) . json ( ) released_version = data [ 'info' ] [ 'version' ] if parse_version ( released_version ) > parse_version ( __version__ ) : warnings . warn ( \"You are running an outdated version of JIRA Python %s. Current version is %s. Do not file any bugs against older versions.\" % ( __version__ , released_version ) ) except requests . RequestException : pass except Exception as e : logging . warning ( e )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x . [CODESPLIT] def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test for greater than . [CODESPLIT] def __gt__ ( self , other ) : if isinstance ( other , Address ) : return str ( self ) > str ( other ) raise TypeError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "docstring for argparse [CODESPLIT] def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return list item number or default if don t exist [CODESPLIT] def _get_or_default ( mylist , i , default = None ) : if i >= len ( mylist ) : return default else : return mylist [ i ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "docstring for argparse [CODESPLIT] def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Right replaces count occurrences of old with new in string . For example :: [CODESPLIT] def right_replace ( string , old , new , count = 1 ) : if not string : return string return new . join ( string . rsplit ( old , count ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove any duplicate item preserving order [CODESPLIT] def de_duplicate ( items ) : result = [ ] for item in items : if item not in result : result . append ( item ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** . [CODESPLIT] def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper for opj_version library routine . [CODESPLIT] def version ( ) : OPENJPEG . opj_version . restype = ctypes . c_char_p library_version = OPENJPEG . opj_version ( ) if sys . hexversion >= 0x03000000 : return library_version . decode ( 'utf-8' ) else : return library_version", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fail unless first equals second as determined by the == operator . [CODESPLIT] def assert_equal ( first , second , msg_fmt = \"{msg}\" ) : if isinstance ( first , dict ) and isinstance ( second , dict ) : assert_dict_equal ( first , second , msg_fmt ) elif not first == second : msg = \"{!r} != {!r}\" . format ( first , second ) fail ( msg_fmt . format ( msg = msg , first = first , second = second ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Right replaces count occurrences of old with new in string . For example :: [CODESPLIT] def right_replace ( string , old , new , count = 1 ) : if not string : return string return new . join ( string . rsplit ( old , count ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if the given node is an object from the __builtin__ module . [CODESPLIT] def is_builtin_object ( node : astroid . node_classes . NodeNG ) -> bool : return node and node . root ( ) . name == BUILTINS_NAME", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Capitalize a sentence . [CODESPLIT] def capitalize ( string ) : if not string : return string if len ( string ) == 1 : return string . upper ( ) return string [ 0 ] . upper ( ) + string [ 1 : ] . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the last weekday in a given month . e . g : [CODESPLIT] def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fibonacci example function [CODESPLIT] def fib ( n ) : assert n > 0 a , b = 1 , 1 for i in range ( n - 1 ) : a , b = b , a + b return a", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether flyweight object with specified key has already been created . [CODESPLIT] def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "target": 1, "target_options": ["no_match", "match"]}
{"input": "string dict / object / value to JSON [CODESPLIT] def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "From itertools cookbook . [ a b c ... ] - > ( a b ) ( b c ) ... [CODESPLIT] def pairwise ( iterable ) : first , second = tee ( iterable ) next ( second , None ) return zip ( first , second )", "target": 1, "target_options": ["no_match", "match"]}
{"input": " [CODESPLIT] def to_graphviz ( graph ) : ret = [ 'digraph g {' ] vertices = [ ] node_ids = dict ( [ ( name , 'node' + idx ) for ( idx , name ) in enumerate ( list ( graph ) ) ] ) for node in list ( graph ) : ret . append ( '  \"%s\" [label=\"%s\"];' % ( node_ids [ node ] , node ) ) for target in graph [ node ] : vertices . append ( '  \"%s\" -> \"%s\";' % ( node_ids [ node ] , node_ids [ target ] ) ) ret += vertices ret . append ( '}' ) return '\\n' . join ( ret )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Truncates a value to a number of decimals places [CODESPLIT] def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check that the image width is superior to width [CODESPLIT] def _width_is_big_enough ( image , width ) : if width > image . size [ 0 ] : raise ImageSizeError ( image . size [ 0 ] , width )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Bulk load docs [CODESPLIT] def bulk_load_docs ( es , docs ) : chunk_size = 200 try : results = elasticsearch . helpers . bulk ( es , docs , chunk_size = chunk_size ) log . debug ( f\"Elasticsearch documents loaded: {results[0]}\" ) # elasticsearch.helpers.parallel_bulk(es, terms, chunk_size=chunk_size, thread_count=4) if len ( results [ 1 ] ) > 0 : log . error ( \"Bulk load errors {}\" . format ( results ) ) except elasticsearch . ElasticsearchException as e : log . error ( \"Indexing error: {}\\n\" . format ( e ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads text file contents [CODESPLIT] def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a string related to a model name and extract its model number . [CODESPLIT] def detect_model_num ( string ) : match = re . match ( MODEL_NUM_REGEX , string ) if match : return int ( match . group ( ) ) return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "( Point Point ) - > Point Return the point that lies in between the two input points . [CODESPLIT] def _mid ( pt1 , pt2 ) : ( x0 , y0 ) , ( x1 , y1 ) = pt1 , pt2 return 0.5 * ( x0 + x1 ) , 0.5 * ( y0 + y1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert human readable string to datetime . datetime . [CODESPLIT] def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove any duplicate item preserving order [CODESPLIT] def de_duplicate ( items ) : result = [ ] for item in items : if item not in result : result . append ( item ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": return : int [CODESPLIT] def __next__ ( self ) : self . current += 1 if self . current > self . total : raise StopIteration else : return self . iterable [ self . current - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements . [CODESPLIT] def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is the SQLAlchemy column type an integer type? [CODESPLIT] def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts an dict to a Enum . [CODESPLIT] def dict_to_enum_fn ( d : Dict [ str , Any ] , enum_class : Type [ Enum ] ) -> Enum : return enum_class [ d [ 'name' ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is the SQLAlchemy column type an integer type? [CODESPLIT] def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrun True if x is a valid YYYYMMDD date ; otherwise return False . [CODESPLIT] def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield all items from iterable except the last one . [CODESPLIT] def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Log out information about a Request object . [CODESPLIT] def _log_response ( response ) : message = u'Received HTTP {0} response: {1}' . format ( response . status_code , response . text ) if response . status_code >= 400 : # pragma: no cover logger . warning ( message ) else : logger . debug ( message )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A small utility function which determines if we re running in QTConsole s context . [CODESPLIT] def _in_qtconsole ( ) -> bool : try : from IPython import get_ipython try : from ipykernel . zmqshell import ZMQInteractiveShell shell_object = ZMQInteractiveShell except ImportError : from IPython . kernel . zmq import zmqshell shell_object = zmqshell . ZMQInteractiveShell return isinstance ( get_ipython ( ) , shell_object ) except Exception : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the last weekday in a given month . e . g : [CODESPLIT] def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a view into the memory [CODESPLIT] def read ( self , start_position : int , size : int ) -> memoryview : return memoryview ( self . _bytes ) [ start_position : start_position + size ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If we re not on the first line ( of a multiline input ) go a line up otherwise go back in history . ( If nothing is selected . ) [CODESPLIT] def auto_up ( self , count = 1 , go_to_start_of_line_if_history_changes = False ) : if self . complete_state : self . complete_previous ( count = count ) elif self . document . cursor_position_row > 0 : self . cursor_up ( count = count ) elif not self . selection_state : self . history_backward ( count = count ) # Go to the start of the line? if go_to_start_of_line_if_history_changes : self . cursor_position += self . document . get_start_of_line_position ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convenience method for setting the value of an openpyxl cell [CODESPLIT] def set_cell_value ( cell , value ) : if OPENPYXL_MAJOR_VERSION > 1 : cell . value = value else : cell . internal_value = value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test whether a stream can be written to . [CODESPLIT] def writable_stream ( handle ) : if isinstance ( handle , io . IOBase ) and sys . version_info >= ( 3 , 5 ) : return handle . writable ( ) try : handle . write ( b'' ) except ( io . UnsupportedOperation , IOError ) : return False else : return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Asks a question yes no style [CODESPLIT] def ask_bool ( question : str , default : bool = True ) -> bool : default_q = \"Y/n\" if default else \"y/N\" answer = input ( \"{0} [{1}]: \" . format ( question , default_q ) ) lower = answer . lower ( ) if not lower : return default return lower == \"y\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "An Iterable may be a list or a generator . This ensures we get a list without making an unnecessary copy . [CODESPLIT] def ensure_list ( iterable : Iterable [ A ] ) -> List [ A ] : if isinstance ( iterable , list ) : return iterable else : return list ( iterable )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a variation from a base value [CODESPLIT] def _gauss ( mean : int , sigma : int ) -> int : return int ( random . gauss ( mean , sigma ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Repeat each item in iterable n times . [CODESPLIT] def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if specified value exists in int enum ; otherwise False . [CODESPLIT] def has_value ( cls , value : int ) -> bool : return any ( value == item . value for item in cls )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Under UNIX : is a keystroke available? [CODESPLIT] def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts string presented in camel case to snake case . [CODESPLIT] def camel_to_snake_case ( string ) : s = _1 . sub ( r'\\1_\\2' , string ) return _2 . sub ( r'\\1_\\2' , s ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts name to lower camel case . Words are identified by capitalization dashes and underscores . [CODESPLIT] def fmt_camel ( name ) : words = split_words ( name ) assert len ( words ) > 0 first = words . pop ( 0 ) . lower ( ) return first + '' . join ( [ word . capitalize ( ) for word in words ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The current position of the cursor . [CODESPLIT] def position ( self ) -> Position : return Position ( self . _index , self . _lineno , self . _col_offset )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Build a dictionary of { node pair : set of edge types } . [CODESPLIT] def get_edge_relations ( graph : BELGraph ) -> Mapping [ Tuple [ BaseEntity , BaseEntity ] , Set [ str ] ] : return group_dict_set ( ( ( u , v ) , d [ RELATION ] ) for u , v , d in graph . edges ( data = True ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a list of lists into a flat list . Args : x : list of lists [CODESPLIT] def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the settings file exists or not [CODESPLIT] def file_exists ( self ) -> bool : cfg_path = self . file_path assert cfg_path return path . isfile ( cfg_path )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return local machine unique identifier . [CODESPLIT] def local_machine_uuid ( ) : result = subprocess . check_output ( 'hal-get-property --udi ' '/org/freedesktop/Hal/devices/computer ' '--key system.hardware.uuid' . split ( ) ) . strip ( ) return uuid . UUID ( hex = result )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if n is a prime number [CODESPLIT] def is_prime ( n ) : if n % 2 == 0 and n > 2 : return False return all ( n % i for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cut if needed . [CODESPLIT] def __setitem__ ( self , * args , * * kwargs ) : super ( History , self ) . __setitem__ ( * args , * * kwargs ) if len ( self ) > self . size : self . popitem ( False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a text into a list of tokens . [CODESPLIT] def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Purely a debugging aid : Ascii - art picture of a tree descended from node [CODESPLIT] def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "List the usb id of all android devices connected to the computer that are detected by adb . [CODESPLIT] def list_adb_devices_by_usb_id ( ) : out = adb . AdbProxy ( ) . devices ( [ '-l' ] ) clean_lines = new_str ( out , 'utf-8' ) . strip ( ) . split ( '\\n' ) results = [ ] for line in clean_lines : tokens = line . strip ( ) . split ( ) if len ( tokens ) > 2 and tokens [ 1 ] == 'device' : results . append ( tokens [ 2 ] ) return results", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if a value is a finite number . [CODESPLIT] def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normal cumulative density function . [CODESPLIT] def normcdf ( x , log = False ) : y = np . atleast_1d ( x ) . copy ( ) flib . normcdf ( y ) if log : if ( y > 0 ) . all ( ) : return np . log ( y ) return - np . inf return y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "! [CODESPLIT] def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Closure of log for zero arguments . [CODESPLIT] def _protected_log ( x1 ) : with np . errstate ( divide = 'ignore' , invalid = 'ignore' ) : return np . where ( np . abs ( x1 ) > 0.001 , np . log ( np . abs ( x1 ) ) , 0. )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a file exists and is non - empty . [CODESPLIT] def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks file sizes for host [CODESPLIT] def check_max_filesize ( chosen_file , max_size ) : if os . path . getsize ( chosen_file ) > max_size : return False else : return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Maintain dict ordering - but make string version prettier [CODESPLIT] def pretty_describe ( object , nestedness = 0 , indent = 2 ) : if not isinstance ( object , dict ) : return str ( object ) sep = f'\\n{\" \" * nestedness * indent}' out = sep . join ( ( f'{k}: {pretty_describe(v, nestedness + 1)}' for k , v in object . items ( ) ) ) if nestedness > 0 and out : return f'{sep}{out}' return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Merge two dicts and return a new dict . Much like subclassing works . [CODESPLIT] def extend ( a : dict , b : dict ) -> dict : res = a . copy ( ) res . update ( b ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert human readable string to datetime . datetime . [CODESPLIT] def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read and return an entire section [CODESPLIT] def _read_section ( self ) : lines = [ self . _last [ self . _last . find ( \":\" ) + 1 : ] ] self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : lines . append ( self . _last ) self . _last = self . _f . readline ( ) return lines", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Time execution of function . Returns ( res seconds ) . [CODESPLIT] def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if test is True for all array elements . Otherwise returns False . [CODESPLIT] def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts an dict to a Enum . [CODESPLIT] def dict_to_enum_fn ( d : Dict [ str , Any ] , enum_class : Type [ Enum ] ) -> Enum : return enum_class [ d [ 'name' ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decode base64 padding being optional . [CODESPLIT] def decode_base64 ( data : str ) -> bytes : missing_padding = len ( data ) % 4 if missing_padding != 0 : data += \"=\" * ( 4 - missing_padding ) return base64 . decodebytes ( data . encode ( \"utf-8\" ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all ( and only ) the lowercase chars in the given string . [CODESPLIT] def lowercase_chars ( string : any ) -> str : return '' . join ( [ c if c . islower ( ) else '' for c in str ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Covert numpy array to tensorflow tensor [CODESPLIT] def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "target": 1, "target_options": ["no_match", "match"]}
{"input": "string dict / object / value to JSON [CODESPLIT] def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Intenal method : check if current cache size exceeds maximum cache size and pop the oldest item in this case [CODESPLIT] def _check_limit ( self ) : # First compress self . _compress ( ) # Then check the max size if len ( self . _store ) >= self . _max_size : self . _store . popitem ( last = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "( str ) - > int All the digits in a given string are concatenated and converted into a single number . [CODESPLIT] def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes all blank lines in @string [CODESPLIT] def remove_blank_lines ( string ) : return \"\\n\" . join ( line for line in string . split ( \"\\n\" ) if len ( line . strip ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print at most limit elements of list . [CODESPLIT] def _brief_print_list ( lst , limit = 7 ) : lst = list ( lst ) if len ( lst ) > limit : return _brief_print_list ( lst [ : limit // 2 ] , limit ) + ', ..., ' + _brief_print_list ( lst [ - limit // 2 : ] , limit ) return ', ' . join ( [ \"'%s'\" % str ( i ) for i in lst ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Detects whether a line is present within a file . [CODESPLIT] def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "zfill ( x width ) - > string [CODESPLIT] def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn a list into a comma - and / or and - separated string . [CODESPLIT] def list_to_str ( lst ) : if len ( lst ) == 1 : str_ = lst [ 0 ] elif len ( lst ) == 2 : str_ = ' and ' . join ( lst ) elif len ( lst ) > 2 : str_ = ', ' . join ( lst [ : - 1 ] ) str_ += ', and {0}' . format ( lst [ - 1 ] ) else : raise ValueError ( 'List of length 0 provided.' ) return str_", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all ( and only ) the uppercase chars in the given string . [CODESPLIT] def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Properly kill Python process including zombie threads . [CODESPLIT] def _exit ( self , status_code ) : # If there are active threads still running infinite loops, sys.exit # won't kill them but os._exit will. os._exit skips calling cleanup # handlers, flushing stdio buffers, etc. exit_func = os . _exit if threading . active_count ( ) > 1 else sys . exit exit_func ( status_code )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates that the object itself is some kinda string [CODESPLIT] def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts an dict to a Enum . [CODESPLIT] def dict_to_enum_fn ( d : Dict [ str , Any ] , enum_class : Type [ Enum ] ) -> Enum : return enum_class [ d [ 'name' ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return dict mapping item - > indices . [CODESPLIT] def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Update dict with keys and values if keys do not already exist . [CODESPLIT] def update_kwargs ( kwargs , * * keyvalues ) : for key , value in keyvalues . items ( ) : if key not in kwargs : kwargs [ key ] = value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute the given multiquery . [CODESPLIT] async def executemany ( self , sql : str , parameters : Iterable [ Iterable [ Any ] ] ) -> None : await self . _execute ( self . _cursor . executemany , sql , parameters )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Skip a section [CODESPLIT] def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if two pathes represent the same file . [CODESPLIT] def samefile ( a : str , b : str ) -> bool : try : return os . path . samefile ( a , b ) except OSError : return os . path . normpath ( a ) == os . path . normpath ( b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a file exists and is non - empty . [CODESPLIT] def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run parallel execution of futures and return mapping of their results to the provided keys . Just a neat shortcut around asyncio . gather () [CODESPLIT] async def parallel_results ( future_map : Sequence [ Tuple ] ) -> Dict : ctx_methods = OrderedDict ( future_map ) fs = list ( ctx_methods . values ( ) ) results = await asyncio . gather ( * fs ) results = { key : results [ idx ] for idx , key in enumerate ( ctx_methods . keys ( ) ) } return results", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a str and transform it into a byte array . [CODESPLIT] def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Time execution of function . Returns ( res seconds ) . [CODESPLIT] def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrive first element in List . [CODESPLIT] def head ( self ) -> Any : lambda_list = self . _get_value ( ) return lambda_list ( lambda head , _ : head )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a datetime from GnuCash 2 . 6 date string [CODESPLIT] def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if specified value exists in int enum ; otherwise False . [CODESPLIT] def has_value ( cls , value : int ) -> bool : return any ( value == item . value for item in cls )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reshuffle the indicies of a bipartite matrix A [ ij kl ] - > A [ lj ki ] . [CODESPLIT] def _reshuffle ( mat , shape ) : return np . reshape ( np . transpose ( np . reshape ( mat , shape ) , ( 3 , 1 , 2 , 0 ) ) , ( shape [ 3 ] * shape [ 1 ] , shape [ 0 ] * shape [ 2 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Partition a list of integers into a list of partitions [CODESPLIT] def integer_partition ( size : int , nparts : int ) -> Iterator [ List [ List [ int ] ] ] : for part in algorithm_u ( range ( size ) , nparts ) : yield part", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit execution with return code and message : param msg : Message displayed prior to exit : param code : code returned upon exiting [CODESPLIT] def Exit ( msg , code = 1 ) : print >> sys . stderr , msg sys . exit ( code )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Filter and ensure that the returned value is of type int . [CODESPLIT] def filter_float ( n : Node , query : str ) -> float : return _scalariter2item ( n , query , float )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the negated mask . If elements of input mask have 0 and non - zero values then the returned matrix will have all elements 0 ( 1 ) where the original one has non - zero ( 0 ) . : param mask : Input mask : type mask : np . array : return : array of same shape and dtype = int8 as input array : rtype : np . array [CODESPLIT] def negate_mask ( mask ) : res = np . ones ( mask . shape , dtype = np . int8 ) res [ mask > 0 ] = 0 return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "filter for dict note f should have signature : f :: key - > value - > bool [CODESPLIT] def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return memory usage of python process in MB [CODESPLIT] def memory_usage ( ) : try : import psutil import os except ImportError : return _memory_usage_ps ( ) process = psutil . Process ( os . getpid ( ) ) mem = process . memory_info ( ) [ 0 ] / float ( 2 ** 20 ) return mem", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert string from snake case to camel case . [CODESPLIT] def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses hostname from URL . : param url : URL : return : hostname [CODESPLIT] def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "simple method to determine if a url is relative or absolute [CODESPLIT] def is_relative_url ( url ) : if url . startswith ( \"#\" ) : return None if url . find ( \"://\" ) > 0 or url . startswith ( \"//\" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A non - negative integer . [CODESPLIT] def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find a forced assignment if possible from a clause with only 1 variable not bound in the model . >>> find_unit_clause ( [ A|B|C B|~C ~A|~B ] { A : True } ) ( B False ) [CODESPLIT] def find_unit_clause ( clauses , model ) : for clause in clauses : P , value = unit_clause_assign ( clause , model ) if P : return P , value return None , None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrun True if x is a valid YYYYMMDD date ; otherwise return False . [CODESPLIT] def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates that the object itself is some kinda string [CODESPLIT] def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a scalar a to a list and all iterables to list as well . [CODESPLIT] def listify ( a ) : if a is None : return [ ] elif not isinstance ( a , ( tuple , list , np . ndarray ) ) : return [ a ] return list ( a )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the year . [CODESPLIT] def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip the whitespace from all column names in the given DataFrame and return the result . [CODESPLIT] def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the index of the earliest occurence of an item from a list in a string [CODESPLIT] def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the UTC time now but with no timezone information in : class : datetime . datetime format . [CODESPLIT] def get_now_utc_notz_datetime ( ) -> datetime . datetime : now = datetime . datetime . utcnow ( ) return now . replace ( tzinfo = None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** . [CODESPLIT] def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a digraph string fragment based on the passed - in module [CODESPLIT] def make_dep_graph ( depender ) : shutit_global . shutit_global_object . yield_to_draw ( ) digraph = '' for dependee_id in depender . depends_on : digraph = ( digraph + '\"' + depender . module_id + '\"->\"' + dependee_id + '\";\\n' ) return digraph", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a datetime from GnuCash 2 . 6 date string [CODESPLIT] def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the conda executable robustly across conda versions . [CODESPLIT] def _find_conda ( ) : if 'CONDA_EXE' in os . environ : conda = os . environ [ 'CONDA_EXE' ] else : conda = util . which ( 'conda' ) return conda", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Connects to an Access database via ODBC with the DSN prespecified . [CODESPLIT] def connect_to_database_odbc_access ( self , dsn : str , autocommit : bool = True ) -> None : self . connect ( engine = ENGINE_ACCESS , interface = INTERFACE_ODBC , dsn = dsn , autocommit = autocommit )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a tuple from parsing a b c d - > ( a b c d ) [CODESPLIT] def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a random walk and return True if the walker has returned to the origin after taking n steps . [CODESPLIT] def returned ( n ) : ## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk for pos in randwalk ( ) >> drop ( 1 ) >> takei ( xrange ( n - 1 ) ) : if pos == Origin : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the UTC time now but with no timezone information in : class : datetime . datetime format . [CODESPLIT] def get_now_utc_notz_datetime ( ) -> datetime . datetime : now = datetime . datetime . utcnow ( ) return now . replace ( tzinfo = None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the range of the colormap to [ * min_val * * max_val * ] [CODESPLIT] def set_range ( self , min_val , max_val ) : if min_val > max_val : max_val , min_val = min_val , max_val self . values = ( ( ( self . values * 1.0 - self . values . min ( ) ) / ( self . values . max ( ) - self . values . min ( ) ) ) * ( max_val - min_val ) + min_val )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit execution with return code and message : param msg : Message displayed prior to exit : param code : code returned upon exiting [CODESPLIT] def Exit ( msg , code = 1 ) : print >> sys . stderr , msg sys . exit ( code )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if test is True for all array elements . Otherwise returns False . [CODESPLIT] def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate the first value in each row . [CODESPLIT] def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a tuple from parsing a b c d - > ( a b c d ) [CODESPLIT] def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Purely a debugging aid : Ascii - art picture of a tree descended from node [CODESPLIT] def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add value to a set in a dictionary by key [CODESPLIT] def dict_of_sets_add ( dictionary , key , value ) : # type: (DictUpperBound, Any, Any) -> None set_objs = dictionary . get ( key , set ( ) ) set_objs . add ( value ) dictionary [ key ] = set_objs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads text file contents [CODESPLIT] def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1 [CODESPLIT] def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "simple method to determine if a url is relative or absolute [CODESPLIT] def is_relative_url ( url ) : if url . startswith ( \"#\" ) : return None if url . find ( \"://\" ) > 0 or url . startswith ( \"//\" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a random walk and return True if the walker has returned to the origin after taking n steps . [CODESPLIT] def returned ( n ) : ## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk for pos in randwalk ( ) >> drop ( 1 ) >> takei ( xrange ( n - 1 ) ) : if pos == Origin : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists . [CODESPLIT] def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a mapping from indices to labels . [CODESPLIT] def make_indices_to_labels ( labels : Set [ str ] ) -> Dict [ int , str ] : return { index : label for index , label in enumerate ( [ \"pad\" ] + sorted ( list ( labels ) ) ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "- > #int width of the terminal window [CODESPLIT] def get_terminal_width ( ) : # http://www.brandonrubin.me/2014/03/18/python-snippet-get-terminal-width/ command = [ 'tput' , 'cols' ] try : width = int ( subprocess . check_output ( command ) ) except OSError as e : print ( \"Invalid Command '{0}': exit status ({1})\" . format ( command [ 0 ] , e . errno ) ) except subprocess . CalledProcessError as e : print ( \"'{0}' returned non-zero exit status: ({1})\" . format ( command , e . returncode ) ) else : return width", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print at most limit elements of list . [CODESPLIT] def _brief_print_list ( lst , limit = 7 ) : lst = list ( lst ) if len ( lst ) > limit : return _brief_print_list ( lst [ : limit // 2 ] , limit ) + ', ..., ' + _brief_print_list ( lst [ - limit // 2 : ] , limit ) return ', ' . join ( [ \"'%s'\" % str ( i ) for i in lst ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If the statement is false raise the given exception . [CODESPLIT] def assert_or_raise ( stmt : bool , exception : Exception , * exception_args , * * exception_kwargs ) -> None : if not stmt : raise exception ( * exception_args , * * exception_kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Detects whether a line is present within a file . [CODESPLIT] def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return the higher parent which is not an AssignName Tuple or List node [CODESPLIT] def assign_parent ( node : astroid . node_classes . NodeNG ) -> astroid . node_classes . NodeNG : while node and isinstance ( node , ( astroid . AssignName , astroid . Tuple , astroid . List ) ) : node = node . parent return node", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows . [CODESPLIT] def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if a string is quoted : param arg : the string being checked for quotes : return : True if a string is quoted [CODESPLIT] def is_quoted ( arg : str ) -> bool : return len ( arg ) > 1 and arg [ 0 ] == arg [ - 1 ] and arg [ 0 ] in constants . QUOTES", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the set of implemented system flags . [CODESPLIT] def get_system_flags ( ) -> FrozenSet [ Flag ] : return frozenset ( { Seen , Recent , Deleted , Flagged , Answered , Draft } )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Finds the longest path in a dag between two nodes [CODESPLIT] def dag_longest_path ( graph , source , target ) : if source == target : return [ source ] allpaths = nx . all_simple_paths ( graph , source , target ) longest_path = [ ] for l in allpaths : if len ( l ) > len ( longest_path ) : longest_path = l return longest_path", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Apply a function fn over a rolling window of size window . [CODESPLIT] def rollapply ( data , window , fn ) : res = data . copy ( ) res [ : ] = np . nan n = len ( data ) if window > n : return res for i in range ( window - 1 , n ) : res . iloc [ i ] = fn ( data . iloc [ i - window + 1 : i + 1 ] ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A helper function that checks if a matrix is unitary . [CODESPLIT] def is_unitary ( matrix : np . ndarray ) -> bool : rows , cols = matrix . shape if rows != cols : return False return np . allclose ( np . eye ( rows ) , matrix . dot ( matrix . T . conj ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a list of lists into a flat list . Args : x : list of lists [CODESPLIT] def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "( Point Point ) - > Point Return the point that lies in between the two input points . [CODESPLIT] def _mid ( pt1 , pt2 ) : ( x0 , y0 ) , ( x1 , y1 ) = pt1 , pt2 return 0.5 * ( x0 + x1 ) , 0.5 * ( y0 + y1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . ) [CODESPLIT] def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the longest common substring in a list of strings . Credit : http : // stackoverflow . com / questions / 2892931 / longest - common - substring - from - more - than - two - strings - python [CODESPLIT] def long_substr ( data ) : substr = '' if len ( data ) > 1 and len ( data [ 0 ] ) > 0 : for i in range ( len ( data [ 0 ] ) ) : for j in range ( len ( data [ 0 ] ) - i + 1 ) : if j > len ( substr ) and all ( data [ 0 ] [ i : i + j ] in x for x in data ) : substr = data [ 0 ] [ i : i + j ] elif len ( data ) == 1 : substr = data [ 0 ] return substr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Truncates a value to a number of decimals places [CODESPLIT] def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns a a random string that represent a binary representation [CODESPLIT] def binary ( length ) : num = randint ( 1 , 999999 ) mask = '0' * length return ( mask + '' . join ( [ str ( num >> i & 1 ) for i in range ( 7 , - 1 , - 1 ) ] ) ) [ - length : ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resets all headers and content for this response . [CODESPLIT] def clear ( self ) -> None : self . _headers = httputil . HTTPHeaders ( { \"Server\" : \"TornadoServer/%s\" % tornado . version , \"Content-Type\" : \"text/html; charset=UTF-8\" , \"Date\" : httputil . format_timestamp ( time . time ( ) ) , } ) self . set_default_headers ( ) self . _write_buffer = [ ] # type: List[bytes] self . _status_code = 200 self . _reason = httputil . responses [ 200 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if this connection is closing . [CODESPLIT] def is_closing ( self ) -> bool : return self . stream . closed ( ) or self . client_terminated or self . server_terminated", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Duplicates a requests . Session . [CODESPLIT] def copy_session ( session : requests . Session ) -> requests . Session : new = requests . Session ( ) new . cookies = requests . utils . cookiejar_from_dict ( requests . utils . dict_from_cookiejar ( session . cookies ) ) new . headers = session . headers . copy ( ) return new", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a scalar a to a list and all iterables to list as well . [CODESPLIT] def listify ( a ) : if a is None : return [ ] elif not isinstance ( a , ( tuple , list , np . ndarray ) ) : return [ a ] return list ( a )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes trailing zeroes from indexable collection of numbers [CODESPLIT] def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the memory is too full for further caching . [CODESPLIT] def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a str and transform it into a byte array . [CODESPLIT] def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a list of the top topn features in this : class : . Feature \\ . [CODESPLIT] def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Within the dictionary d find a key that matches ( in case - insensitive fashion ) the key k and return it ( or None if there isn t one ) . [CODESPLIT] def get_case_insensitive_dict_key ( d : Dict , k : str ) -> Optional [ str ] : for key in d . keys ( ) : if k . lower ( ) == key . lower ( ) : return key return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes all blank lines in @string [CODESPLIT] def remove_blank_lines ( string ) : return \"\\n\" . join ( line for line in string . split ( \"\\n\" ) if len ( line . strip ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a snake cased version of a string . [CODESPLIT] def snake_case ( a_string ) : partial = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , a_string ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , partial ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a CSV object to a numpy array . [CODESPLIT] def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Warn if nans exist in a numpy array . [CODESPLIT] def warn_if_nans_exist ( X ) : null_count = count_rows_with_nans ( X ) total = len ( X ) percent = 100 * null_count / total if null_count > 0 : warning_message = 'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' 'complete rows will be plotted.' . format ( null_count , total , percent ) warnings . warn ( warning_message , DataWarning )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return view of the recarray with all int32 cast to int64 . [CODESPLIT] def to_int64 ( a ) : # build new dtype and replace i4 --> i8 def promote_i4 ( typestr ) : if typestr [ 1 : ] == 'i4' : typestr = typestr [ 0 ] + 'i8' return typestr dtype = [ ( name , promote_i4 ( typestr ) ) for name , typestr in a . dtype . descr ] return a . astype ( dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if cnr or cns files are empty ( only have a header ) [CODESPLIT] def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the part of a 1d array covered by a block . [CODESPLIT] def blk_coverage_1d ( blk , size ) : rem = size % blk maxpix = size - rem return maxpix , rem", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Purely a debugging aid : Ascii - art picture of a tree descended from node [CODESPLIT] def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format numpy array as a string . [CODESPLIT] def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( \",\" ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + \"%s[%s]\" % ( arr . dtype , shape )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230 [CODESPLIT] def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the tanimoto set similarity . [CODESPLIT] def tanimoto_set_similarity ( x : Iterable [ X ] , y : Iterable [ X ] ) -> float : a , b = set ( x ) , set ( y ) union = a | b if not union : return 0.0 return len ( a & b ) / len ( union )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a datetime from GnuCash 2 . 6 date string [CODESPLIT] def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks if the response has been rate limited by CARTO APIs [CODESPLIT] def is_rate_limited ( response ) : if ( response . status_code == codes . too_many_requests and 'Retry-After' in response . headers and int ( response . headers [ 'Retry-After' ] ) >= 0 ) : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes trailing zeroes from indexable collection of numbers [CODESPLIT] def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield . [CODESPLIT] def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert string from snake case to camel case . [CODESPLIT] def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether flyweight object with specified key has already been created . [CODESPLIT] def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert an array like object to the NPY format . [CODESPLIT] def array_to_npy ( array_like ) : # type: (np.array or Iterable or int or float) -> object buffer = BytesIO ( ) np . save ( buffer , array_like ) return buffer . getvalue ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield all items from iterable except the last one . [CODESPLIT] def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Indent a piece of text . [CODESPLIT] def indent ( text : str , num : int = 2 ) -> str : lines = text . splitlines ( ) return \"\\n\" . join ( indent_iterable ( lines , num = num ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculates the value of a percent of a number ie : 5% of 20 is what -- > 1 Args : percent ( float ) : The percent of a number whole ( float ) : The whole of the number Returns : float : The value of a percent Example : >>> percent_of ( 25 100 ) 25 . 0 >>> percent_of ( 5 20 ) 1 . 0 [CODESPLIT] def percent_of ( percent , whole ) : percent = float ( percent ) whole = float ( whole ) return ( percent * whole ) / 100", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Guesses the mimetype of a file based on the given filename . [CODESPLIT] def guess_mimetype ( filename ) : fn = os . path . basename ( filename ) return mimetypes . guess_type ( fn ) [ 0 ] or 'application/octet-stream'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a generator over iterable that tells whether the current item is the last one . Usage : >>> iterable = range ( 10 ) >>> for index is_last item in enum_mark_last ( iterable ) : >>> print ( index item end = \\ n if is_last else ) [CODESPLIT] def enum_mark_last ( iterable , start = 0 ) : it = iter ( iterable ) count = start try : last = next ( it ) except StopIteration : return for val in it : yield count , False , last last = val count += 1 yield count , True , last", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generates RGB values from HSV values in line with a typical light spectrum . [CODESPLIT] def hsv2rgb_spectrum ( hsv ) : h , s , v = hsv return hsv2rgb_raw ( ( ( h * 192 ) >> 8 , s , v ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dict with swapped keys and values [CODESPLIT] def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get element with wdom_id . [CODESPLIT] def getElementByWdomId ( id : str ) -> Optional [ WebEventTarget ] : if not id : return None elif id == 'document' : return get_document ( ) elif id == 'window' : return get_document ( ) . defaultView elm = WdomElement . _elements_with_wdom_id . get ( id ) return elm", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a random walk and return True if the walker has returned to the origin after taking n steps . [CODESPLIT] def returned ( n ) : ## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk for pos in randwalk ( ) >> drop ( 1 ) >> takei ( xrange ( n - 1 ) ) : if pos == Origin : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "filter for dict note f should have signature : f :: key - > value - > bool [CODESPLIT] def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fast median operation for masked array using 50th - percentile [CODESPLIT] def fast_median ( a ) : a = checkma ( a ) #return scoreatpercentile(a.compressed(), 50) if a . count ( ) > 0 : out = np . percentile ( a . compressed ( ) , 50 ) else : out = np . ma . masked return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform point in viewport space to screen space . [CODESPLIT] def viewport_to_screen_space ( framebuffer_size : vec2 , point : vec4 ) -> vec2 : return ( framebuffer_size * point . xy ) / point . w", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . ) [CODESPLIT] def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if cnr or cns files are empty ( only have a header ) [CODESPLIT] def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses the Unix ps program to see if a process is running . [CODESPLIT] def is_running ( process_id : int ) -> bool : pstr = str ( process_id ) encoding = sys . getdefaultencoding ( ) s = subprocess . Popen ( [ \"ps\" , \"-p\" , pstr ] , stdout = subprocess . PIPE ) for line in s . stdout : strline = line . decode ( encoding ) if pstr in strline : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Does an index exist? ( Specific to MySQL . ) [CODESPLIT] def index_exists ( self , table : str , indexname : str ) -> bool : # MySQL: sql = ( \"SELECT COUNT(*) FROM information_schema.statistics\" \" WHERE table_name=? AND index_name=?\" ) row = self . fetchone ( sql , table , indexname ) return True if row [ 0 ] >= 1 else False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the moving overage over an array . [CODESPLIT] def moving_average ( arr : np . ndarray , n : int = 3 ) -> np . ndarray : ret = np . cumsum ( arr , dtype = float ) ret [ n : ] = ret [ n : ] - ret [ : - n ] return ret [ n - 1 : ] / n", "target": 1, "target_options": ["no_match", "match"]}
{"input": "string dict / object / value to JSON [CODESPLIT] def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230 [CODESPLIT] def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes trailing zeroes from indexable collection of numbers [CODESPLIT] def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate the first value in each row . [CODESPLIT] def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load JSON file [CODESPLIT] def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Right replaces count occurrences of old with new in string . For example :: [CODESPLIT] def right_replace ( string , old , new , count = 1 ) : if not string : return string return new . join ( string . rsplit ( old , count ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "rounds float to closest int : rtype : int : param n : float [CODESPLIT] def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exclude elements in list l containing any elements from list ex . Example : >>> l = [ bob r rob \\ r \\ r \\ nrobert ] >>> containing = [ \\ n \\ r ] >>> equal_to = [ r ] >>> exclude_from ( l containing equal_to ) [ bob ] [CODESPLIT] def exclude_from ( l , containing = [ ] , equal_to = [ ] ) : cont = lambda li : any ( c in li for c in containing ) eq = lambda li : any ( e == li for e in equal_to ) return [ li for li in l if not ( cont ( li ) or eq ( li ) ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrun True if x is a valid YYYYMMDD date ; otherwise return False . [CODESPLIT] def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "takes a list of lists l and returns a flat list [CODESPLIT] def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes all buckets from all hashes and their content . [CODESPLIT] def clean_all_buckets ( self ) : bucket_keys = self . redis_object . keys ( pattern = 'nearpy_*' ) if len ( bucket_keys ) > 0 : self . redis_object . delete ( * bucket_keys )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create an aiosqlite cursor wrapping a sqlite3 cursor object . [CODESPLIT] async def cursor ( self ) -> Cursor : return Cursor ( self , await self . _execute ( self . _conn . cursor ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if arg is valid value for the class . If the string value is wrong for the enumeration the encoding will fail . [CODESPLIT] def is_valid ( cls , arg ) : return ( isinstance ( arg , ( int , long ) ) and ( arg >= 0 ) ) or isinstance ( arg , basestring )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load JSON file [CODESPLIT] def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reads text file contents [CODESPLIT] def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Replace all ( frm to ) tuples in args in string s . [CODESPLIT] def replaceStrs ( s , * args ) : if args == ( ) : return s mapping = dict ( ( frm , to ) for frm , to in args ) return re . sub ( \"|\" . join ( map ( re . escape , mapping . keys ( ) ) ) , lambda match : mapping [ match . group ( 0 ) ] , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** . [CODESPLIT] def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get all the database column names for the specified table . [CODESPLIT] def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a text into a list of tokens . [CODESPLIT] def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to remove the links from the input text [CODESPLIT] def remove_links ( text ) : tco_link_regex = re . compile ( \"https?://t.co/[A-z0-9].*\" ) generic_link_regex = re . compile ( \"(https?://)?(\\w*[.]\\w+)+([/?=&]+\\w+)*\" ) remove_tco = re . sub ( tco_link_regex , \" \" , text ) remove_generic = re . sub ( generic_link_regex , \" \" , remove_tco ) return remove_generic", "target": 1, "target_options": ["no_match", "match"]}
{"input": "simple method to determine if a url is relative or absolute [CODESPLIT] def is_relative_url ( url ) : if url . startswith ( \"#\" ) : return None if url . find ( \"://\" ) > 0 or url . startswith ( \"//\" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper to make map () behave the same on Py2 and Py3 . [CODESPLIT] def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove the element from a set lists or dict . >>> L = [ Lucy ] ; S = set ( [ Sky ] ) ; D = { Diamonds : True } ; >>> remove_once ( L Lucy ) ; remove_once ( S Sky ) ; remove_once ( D Diamonds ) ; >>> print L S D [] set ( [] ) {} [CODESPLIT] def remove_once ( gset , elem ) : remove = getattr ( gset , 'remove' , None ) if remove is not None : remove ( elem ) else : del gset [ elem ] return elem", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the index of the earliest occurence of an item from a list in a string [CODESPLIT] def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates that the object itself is some kinda string [CODESPLIT] def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line . [CODESPLIT] def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add value to a set in a dictionary by key [CODESPLIT] def dict_of_sets_add ( dictionary , key , value ) : # type: (DictUpperBound, Any, Any) -> None set_objs = dictionary . get ( key , set ( ) ) set_objs . add ( value ) dictionary [ key ] = set_objs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Asks an SQLAlchemy class how its attribute names correspond to database column names . [CODESPLIT] def attrname_to_colname_dict ( cls ) -> Dict [ str , str ] : attr_col = { } # type: Dict[str, str] for attrname , column in gen_columns ( cls ) : attr_col [ attrname ] = column . name return attr_col", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Finds the longest path in a dag between two nodes [CODESPLIT] def dag_longest_path ( graph , source , target ) : if source == target : return [ source ] allpaths = nx . all_simple_paths ( graph , source , target ) longest_path = [ ] for l in allpaths : if len ( l ) > len ( longest_path ) : longest_path = l return longest_path", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip the whitespace from all column names in the given DataFrame and return the result . [CODESPLIT] def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Latest trading day w . r . t given dt [CODESPLIT] def trade_day ( dt , cal = 'US' ) : from xone import calendar dt = pd . Timestamp ( dt ) . date ( ) return calendar . trading_dates ( start = dt - pd . Timedelta ( '10D' ) , end = dt , calendar = cal ) [ - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simplified check to see if the text appears to be a URL . [CODESPLIT] def looks_like_url ( url ) : if not isinstance ( url , basestring ) : return False if not isinstance ( url , basestring ) or len ( url ) >= 1024 or not cre_url . match ( url ) : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes all buckets from all hashes and their content . [CODESPLIT] def clean_all_buckets ( self ) : bucket_keys = self . redis_object . keys ( pattern = 'nearpy_*' ) if len ( bucket_keys ) > 0 : self . redis_object . delete ( * bucket_keys )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ] [CODESPLIT] def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "* A datetime stamp in MySQL format : YYYY - MM - DDTHH : MM : SS * [CODESPLIT] def get_now_sql_datetime ( ) : ## > IMPORTS ## from datetime import datetime , date , time now = datetime . now ( ) now = now . strftime ( \"%Y-%m-%dT%H:%M:%S\" ) return now", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cast to float tensor [CODESPLIT] def fcast ( value : float ) -> TensorLike : newvalue = tf . cast ( value , FTYPE ) if DEVICE == 'gpu' : newvalue = newvalue . gpu ( ) # Why is this needed?  # pragma: no cover return newvalue", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper for pymongo . insert_many () and update_many () : param db : db connection : param collection : collection to update : param object : the modifications to apply : param match_params : a query that matches the documents to update : return : ids of inserted / updated document [CODESPLIT] def upsert_multi ( db , collection , object , match_params = None ) : if isinstance ( object , list ) and len ( object ) > 0 : return str ( db [ collection ] . insert_many ( object ) . inserted_ids ) elif isinstance ( object , dict ) : return str ( db [ collection ] . update_many ( match_params , { \"$set\" : object } , upsert = False ) . upserted_id )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all ( and only ) the chars in the given string . [CODESPLIT] def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all ( and only ) the chars in the given string . [CODESPLIT] def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a random walk and return True if the walker has returned to the origin after taking n steps . [CODESPLIT] def returned ( n ) : ## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk for pos in randwalk ( ) >> drop ( 1 ) >> takei ( xrange ( n - 1 ) ) : if pos == Origin : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the memory is too full for further caching . [CODESPLIT] def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists . [CODESPLIT] def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Matrix multiplication using binary [CODESPLIT] def __rmatmul__ ( self , other ) : return self . T . dot ( np . transpose ( other ) ) . T", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if values are not increasing . [CODESPLIT] def non_increasing ( values ) : return all ( x >= y for x , y in zip ( values , values [ 1 : ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rate limit a function . [CODESPLIT] def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Setup the flask - cache on a flask app [CODESPLIT] def setup_cache ( app : Flask , cache_config ) -> Optional [ Cache ] : if cache_config and cache_config . get ( 'CACHE_TYPE' ) != 'null' : return Cache ( app , config = cache_config ) return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return ast . Expression created from source code given in src . [CODESPLIT] def src2ast ( src : str ) -> Expression : try : return ast . parse ( src , mode = 'eval' ) except SyntaxError : raise ValueError ( \"Not a valid expression.\" ) from None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . ) [CODESPLIT] def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a scalar a to a list and all iterables to list as well . [CODESPLIT] def listify ( a ) : if a is None : return [ ] elif not isinstance ( a , ( tuple , list , np . ndarray ) ) : return [ a ] return list ( a )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dict with swapped keys and values [CODESPLIT] def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "string dict / object / value to JSON [CODESPLIT] def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements . [CODESPLIT] def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Under UNIX : is a keystroke available? [CODESPLIT] def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list produced by applying : func : multiple_replace to every string in stringlist . [CODESPLIT] def replace_in_list ( stringlist : Iterable [ str ] , replacedict : Dict [ str , str ] ) -> List [ str ] : newlist = [ ] for fromstring in stringlist : newlist . append ( multiple_replace ( fromstring , replacedict ) ) return newlist", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieves the creation date for a given key in a given bucket . : param bucket : the bucket the object resides in . : param key : the key of the object for which the creation date is being retrieved . : return : the creation date [CODESPLIT] def get_creation_date ( self , bucket : str , key : str , ) -> datetime . datetime : blob_obj = self . _get_blob_obj ( bucket , key ) return blob_obj . time_created", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** . [CODESPLIT] def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a CSV object to a numpy array . [CODESPLIT] def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a file exists and is non - empty . [CODESPLIT] def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns day number of the last day of the month : param t : datetime : return : int [CODESPLIT] def get_last_day_of_month ( t : datetime ) -> int : tn = t + timedelta ( days = 32 ) tn = datetime ( year = tn . year , month = tn . month , day = 1 ) tt = tn - timedelta ( hours = 1 ) return tt . day", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a str and transform it into a byte array . [CODESPLIT] def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine whether sh has any value [CODESPLIT] def is_empty_shape ( sh : ShExJ . Shape ) -> bool : return sh . closed is None and sh . expression is None and sh . extra is None and sh . semActs is None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all ( and only ) the chars in the given string . [CODESPLIT] def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the day name [CODESPLIT] def get_day_name ( self ) -> str : weekday = self . value . isoweekday ( ) - 1 return calendar . day_name [ weekday ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple helper hash function [CODESPLIT] def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the year . [CODESPLIT] def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Covert numpy array to tensorflow tensor [CODESPLIT] def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if n is a prime number [CODESPLIT] def is_prime ( n ) : if n % 2 == 0 and n > 2 : return False return all ( n % i for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for iterating only nonempty lines without line breaks [CODESPLIT] def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a value wrap it in a 0 - D numpy . ndarray . [CODESPLIT] def to_0d_array ( value : Any ) -> np . ndarray : if np . isscalar ( value ) or ( isinstance ( value , np . ndarray ) and value . ndim == 0 ) : return np . array ( value ) else : return to_0d_object_array ( value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrun True if x is a valid YYYYMMDD date ; otherwise return False . [CODESPLIT] def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format numpy array as a string . [CODESPLIT] def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( \",\" ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + \"%s[%s]\" % ( arr . dtype , shape )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clips UTC datetime in nanoseconds to seconds . [CODESPLIT] def clip_to_seconds ( m : Union [ int , pd . Series ] ) -> Union [ int , pd . Series ] : return m // pd . Timedelta ( 1 , unit = 's' ) . value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts an dict to a Enum . [CODESPLIT] def dict_to_enum_fn ( d : Dict [ str , Any ] , enum_class : Type [ Enum ] ) -> Enum : return enum_class [ d [ 'name' ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Context manager with threading lock for set locale on enter and set it back to original state on exit . [CODESPLIT] def setlocale ( name ) : with LOCALE_LOCK : old_locale = locale . setlocale ( locale . LC_ALL ) try : yield locale . setlocale ( locale . LC_ALL , name ) finally : locale . setlocale ( locale . LC_ALL , old_locale )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert the main dataframe to javascript code [CODESPLIT] def to_javascript_ ( self , table_name : str = \"data\" ) -> str : try : renderer = pytablewriter . JavaScriptTableWriter data = self . _build_export ( renderer , table_name ) return data except Exception as e : self . err ( e , \"Can not convert data to javascript code\" )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a file exists and is non - empty . [CODESPLIT] def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Writes text to a file . [CODESPLIT] def write_text ( filename : str , text : str ) -> None : with open ( filename , 'w' ) as f : # type: TextIO print ( text , file = f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the input filename with path is a file and is not empty . [CODESPLIT] def isfile_notempty ( inputfile : str ) -> bool : try : return isfile ( inputfile ) and getsize ( inputfile ) > 0 except TypeError : raise TypeError ( 'inputfile is not a valid type' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is a PDF - to - text tool available? [CODESPLIT] def availability_pdf ( ) -> bool : pdftotext = tools [ 'pdftotext' ] if pdftotext : return True elif pdfminer : log . warning ( \"PDF conversion: pdftotext missing; \" \"using pdfminer (less efficient)\" ) return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return dict mapping item - > indices . [CODESPLIT] def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Executes SQL ; returns list of first values of each row . [CODESPLIT] def fetchallfirstvalues ( self , sql : str , * args ) -> List [ Any ] : rows = self . fetchall ( sql , * args ) return [ row [ 0 ] for row in rows ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "safe version of pow [CODESPLIT] def safe_pow ( base , exp ) : if exp > MAX_EXPONENT : raise RuntimeError ( \"Invalid exponent, max exponent is {}\" . format ( MAX_EXPONENT ) ) return base ** exp", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Transform a simple index into a human - readable position in a string . [CODESPLIT] def text_coords ( string , position ) : line_start = string . rfind ( '\\n' , 0 , position ) + 1 line_end = string . find ( '\\n' , position ) lineno = string . count ( '\\n' , 0 , position ) columnno = position - line_start line = string [ line_start : line_end ] return ( lineno , columnno , line )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether flyweight object with specified key has already been created . [CODESPLIT] def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield . [CODESPLIT] def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rate limit a function . [CODESPLIT] def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the duplicates in a list . [CODESPLIT] def find_duplicates ( l : list ) -> set : return set ( [ x for x in l if l . count ( x ) > 1 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the memory is too full for further caching . [CODESPLIT] def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a datetime from GnuCash 2 . 6 date string [CODESPLIT] def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing [CODESPLIT] def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x . [CODESPLIT] def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Time execution of function . Returns ( res seconds ) . [CODESPLIT] def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a function that will call a named method on the target object with optional positional and keyword arguments . [CODESPLIT] def method_caller ( method_name , * args , * * kwargs ) : def call_method ( target ) : func = getattr ( target , method_name ) return func ( * args , * * kwargs ) return call_method", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last week as a period string [CODESPLIT] def get_period_last_3_months ( ) -> str : today = Datum ( ) today . today ( ) # start_date = today - timedelta(weeks=13) start_date = today . clone ( ) start_date . subtract_months ( 3 ) period = get_period ( start_date . date , today . date ) return period", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if a value is a finite number . [CODESPLIT] def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a new copied dictionary without the keys with None values from the given Mapping object . [CODESPLIT] def clean_map ( obj : Mapping [ Any , Any ] ) -> Mapping [ Any , Any ] : return { k : v for k , v in obj . items ( ) if v is not None }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a list of arrays of the same shape and take the element wise average . [CODESPLIT] def average_arrays ( arrays : List [ mx . nd . NDArray ] ) -> mx . nd . NDArray : if not arrays : raise ValueError ( \"arrays is empty.\" ) if len ( arrays ) == 1 : return arrays [ 0 ] check_condition ( all ( arrays [ 0 ] . shape == a . shape for a in arrays ) , \"nd array shapes do not match\" ) return mx . nd . add_n ( * arrays ) / len ( arrays )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise . [CODESPLIT] def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Writes text to a file . [CODESPLIT] def write_text ( filename : str , text : str ) -> None : with open ( filename , 'w' ) as f : # type: TextIO print ( text , file = f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check if day is after month s 3rd friday [CODESPLIT] def after_third_friday ( day = None ) : day = day if day is not None else datetime . datetime . now ( ) now = day . replace ( day = 1 , hour = 16 , minute = 0 , second = 0 , microsecond = 0 ) now += relativedelta . relativedelta ( weeks = 2 , weekday = relativedelta . FR ) return day > now", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Repeat each item in iterable n times . [CODESPLIT] def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Purely a debugging aid : Ascii - art picture of a tree descended from node [CODESPLIT] def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Locates the account by fullname [CODESPLIT] def get_account_id_by_fullname ( self , fullname : str ) -> str : account = self . get_by_fullname ( fullname ) return account . guid", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reshuffle the indicies of a bipartite matrix A [ ij kl ] - > A [ lj ki ] . [CODESPLIT] def _reshuffle ( mat , shape ) : return np . reshape ( np . transpose ( np . reshape ( mat , shape ) , ( 3 , 1 , 2 , 0 ) ) , ( shape [ 3 ] * shape [ 1 ] , shape [ 0 ] * shape [ 2 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get all the database column names for the specified table . [CODESPLIT] def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield all items from iterable except the last one . [CODESPLIT] def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if the response buffer is full and False otherwise . The buffer is full if either ( 1 ) the number of items in the value list is > = pageSize or ( 2 ) the total length of the serialised elements in the page is > = maxBufferSize . [CODESPLIT] def isFull ( self ) : return ( ( self . _pageSize > 0 and self . _numElements >= self . _pageSize ) or ( self . _bufferSize >= self . _maxBufferSize ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "check if day is after month s 3rd friday [CODESPLIT] def after_third_friday ( day = None ) : day = day if day is not None else datetime . datetime . now ( ) now = day . replace ( day = 1 , hour = 16 , minute = 0 , second = 0 , microsecond = 0 ) now += relativedelta . relativedelta ( weeks = 2 , weekday = relativedelta . FR ) return day > now", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Perform a simple check if the value is callable . [CODESPLIT] def callable_validator ( v : Any ) -> AnyCallable : if callable ( v ) : return v raise errors . CallableError ( value = v )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert string from snake case to camel case . [CODESPLIT] def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts string presented in camel case to snake case . [CODESPLIT] def camel_to_snake_case ( string ) : s = _1 . sub ( r'\\1_\\2' , string ) return _2 . sub ( r'\\1_\\2' , s ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False [CODESPLIT] def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "generate a lower - cased camelCase string from an underscore_string . For example : my_variable_name - > myVariableName [CODESPLIT] def lower_camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = components [ 0 ] for component in components [ 1 : ] : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is the SQLAlchemy column type an integer type? [CODESPLIT] def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "rounds float to closest int : rtype : int : param n : float [CODESPLIT] def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } ) [CODESPLIT] def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the longest common substring in a list of strings . Credit : http : // stackoverflow . com / questions / 2892931 / longest - common - substring - from - more - than - two - strings - python [CODESPLIT] def long_substr ( data ) : substr = '' if len ( data ) > 1 and len ( data [ 0 ] ) > 0 : for i in range ( len ( data [ 0 ] ) ) : for j in range ( len ( data [ 0 ] ) - i + 1 ) : if j > len ( substr ) and all ( data [ 0 ] [ i : i + j ] in x for x in data ) : substr = data [ 0 ] [ i : i + j ] elif len ( data ) == 1 : substr = data [ 0 ] return substr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print execution time of the function . For quick n dirty profiling . [CODESPLIT] def timeit ( func , log , limit ) : def newfunc ( * args , * * kwargs ) : \"\"\"Execute function and print execution time.\"\"\" t = time . time ( ) res = func ( * args , * * kwargs ) duration = time . time ( ) - t if duration > limit : print ( func . __name__ , \"took %0.2f seconds\" % duration , file = log ) print ( args , file = log ) print ( kwargs , file = log ) return res return update_func_meta ( newfunc , func )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "docstring for argparse [CODESPLIT] def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = \"What's the problem ?\" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield . [CODESPLIT] def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "target": 1, "target_options": ["no_match", "match"]}
{"input": ">>> date_to_datetime ( date ( 2000 1 2 )) datetime . datetime ( 2000 1 2 0 0 ) >>> date_to_datetime ( datetime ( 2000 1 2 3 4 5 )) datetime . datetime ( 2000 1 2 3 4 5 ) [CODESPLIT] def date_to_datetime ( d ) : if not isinstance ( d , datetime ) : d = datetime . combine ( d , datetime . min . time ( ) ) return d", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the duplicates in a list . [CODESPLIT] def find_duplicates ( l : list ) -> set : return set ( [ x for x in l if l . count ( x ) > 1 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a list into a space - separated string and puts it in a dictionary [CODESPLIT] def encode_list ( key , list_ ) : # type: (str, Iterable) -> Dict[str, str] if not list_ : return { } return { key : \" \" . join ( str ( i ) for i in list_ ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Take a str and transform it into a byte array . [CODESPLIT] def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pull a file directly from S3 . [CODESPLIT] def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a new copied dictionary without the keys with None values from the given Mapping object . [CODESPLIT] def clean_map ( obj : Mapping [ Any , Any ] ) -> Mapping [ Any , Any ] : return { k : v for k , v in obj . items ( ) if v is not None }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Alternate version of Spark s zipWithIndex that eagerly returns count . [CODESPLIT] def zip_with_index ( rdd ) : starts = [ 0 ] if rdd . getNumPartitions ( ) > 1 : nums = rdd . mapPartitions ( lambda it : [ sum ( 1 for _ in it ) ] ) . collect ( ) count = sum ( nums ) for i in range ( len ( nums ) - 1 ) : starts . append ( starts [ - 1 ] + nums [ i ] ) else : count = rdd . count ( ) def func ( k , it ) : for i , v in enumerate ( it , starts [ k ] ) : yield v , i return count , rdd . mapPartitionsWithIndex ( func )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if n is a prime number [CODESPLIT] def is_prime ( n ) : if n % 2 == 0 and n > 2 : return False return all ( n % i for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Performs an element - wise check to determine if the NDArray contains an infinite element or not . TODO : remove this funciton after upgrade to MXNet 1 . 4 . * in favor of mx . ndarray . contrib . isfinite () [CODESPLIT] def isfinite ( data : mx . nd . NDArray ) -> mx . nd . NDArray : is_data_not_nan = data == data is_data_not_infinite = data . abs ( ) != np . inf return mx . nd . logical_and ( is_data_not_infinite , is_data_not_nan )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert human readable string to datetime . datetime . [CODESPLIT] def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string to a list with sanitization . [CODESPLIT] def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shamelessly taken from Django . https : // github . com / django / django / blob / master / django / utils / text . py [CODESPLIT] def get_valid_filename ( s ) : s = str ( s ) . strip ( ) . replace ( ' ' , '_' ) return re . sub ( r'(?u)[^-\\w.]' , '' , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Warn if nans exist in a numpy array . [CODESPLIT] def warn_if_nans_exist ( X ) : null_count = count_rows_with_nans ( X ) total = len ( X ) percent = 100 * null_count / total if null_count > 0 : warning_message = 'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' 'complete rows will be plotted.' . format ( null_count , total , percent ) warnings . warn ( warning_message , DataWarning )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load JSON file [CODESPLIT] def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert human readable string to datetime . datetime . [CODESPLIT] def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a random python attribute name . [CODESPLIT] def random_name_gen ( size = 6 ) : return '' . join ( [ random . choice ( string . ascii_uppercase ) ] + [ random . choice ( string . ascii_uppercase + string . digits ) for i in range ( size - 1 ) ] ) if size > 0 else ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given [ A B C ] return A B or C . [CODESPLIT] def quoted_or_list ( items : List [ str ] ) -> Optional [ str ] : return or_list ( [ f\"'{item}'\" for item in items ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load JSON file [CODESPLIT] def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Joins given arguments into a url removing duplicate slashes Thanks http : // stackoverflow . com / a / 11326230 / 1267398 [CODESPLIT] def urljoin ( * args ) : value = \"/\" . join ( map ( lambda x : str ( x ) . strip ( '/' ) , args ) ) return \"/{}\" . format ( value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns its parameter as an integer or raises django . forms . ValidationError . [CODESPLIT] def clean_int ( x ) -> int : try : return int ( x ) except ValueError : raise forms . ValidationError ( \"Cannot convert to integer: {}\" . format ( repr ( x ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string to a list with sanitization . [CODESPLIT] def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "- > #float : func : numpy . std of the timing intervals [CODESPLIT] def stdev ( self ) : return round ( np . std ( self . array ) , self . precision ) if len ( self . array ) else None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "filter for dict note f should have signature : f :: key - > value - > bool [CODESPLIT] def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a string return a list of index positions where a blank space occurs . [CODESPLIT] def space_list ( line : str ) -> List [ int ] : spaces = [ ] for idx , car in enumerate ( list ( line ) ) : if car == \" \" : spaces . append ( idx ) return spaces", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last week as a period string [CODESPLIT] def get_period_last_3_months ( ) -> str : today = Datum ( ) today . today ( ) # start_date = today - timedelta(weeks=13) start_date = today . clone ( ) start_date . subtract_months ( 3 ) period = get_period ( start_date . date , today . date ) return period", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows . [CODESPLIT] def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes all blank lines in @string [CODESPLIT] def remove_blank_lines ( string ) : return \"\\n\" . join ( line for line in string . split ( \"\\n\" ) if len ( line . strip ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if the given node is an object from the __builtin__ module . [CODESPLIT] def is_builtin_object ( node : astroid . node_classes . NodeNG ) -> bool : return node and node . root ( ) . name == BUILTINS_NAME", "target": 1, "target_options": ["no_match", "match"]}
{"input": "( Point Point ) - > Point Return the point that lies in between the two input points . [CODESPLIT] def _mid ( pt1 , pt2 ) : ( x0 , y0 ) , ( x1 , y1 ) = pt1 , pt2 return 0.5 * ( x0 + x1 ) , 0.5 * ( y0 + y1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fail unless first equals second as determined by the == operator . [CODESPLIT] def assert_equal ( first , second , msg_fmt = \"{msg}\" ) : if isinstance ( first , dict ) and isinstance ( second , dict ) : assert_dict_equal ( first , second , msg_fmt ) elif not first == second : msg = \"{!r} != {!r}\" . format ( first , second ) fail ( msg_fmt . format ( msg = msg , first = first , second = second ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tries to work out the highlight . js language of a given file name or shebang . Returns an empty string if none match . [CODESPLIT] def get_language ( query : str ) -> str : query = query . lower ( ) for language in LANGUAGES : if query . endswith ( language ) : return language return ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "HTTP POST operation to API endpoint . [CODESPLIT] def post ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'POST' , endpoint , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dict with swapped keys and values [CODESPLIT] def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a value into a bool but handle truthy strings eg yes true ok y [CODESPLIT] def to_bool ( value ) : # type: (Any) -> bool if isinstance ( value , _compat . string_types ) : return value . upper ( ) in ( 'Y' , 'YES' , 'T' , 'TRUE' , '1' , 'OK' ) return bool ( value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a tuple from parsing a b c d - > ( a b c d ) [CODESPLIT] def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the year . [CODESPLIT] def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper for opj_version library routine . [CODESPLIT] def version ( ) : OPENJPEG . opj_version . restype = ctypes . c_char_p library_version = OPENJPEG . opj_version ( ) if sys . hexversion >= 0x03000000 : return library_version . decode ( 'utf-8' ) else : return library_version", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fail unless first equals second as determined by the == operator . [CODESPLIT] def assert_equal ( first , second , msg_fmt = \"{msg}\" ) : if isinstance ( first , dict ) and isinstance ( second , dict ) : assert_dict_equal ( first , second , msg_fmt ) elif not first == second : msg = \"{!r} != {!r}\" . format ( first , second ) fail ( msg_fmt . format ( msg = msg , first = first , second = second ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is the SQLAlchemy column type a string type that s more than one character long? [CODESPLIT] def is_sqlatype_text_over_one_char ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return is_sqlatype_text_of_length_at_least ( coltype , 2 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Concatenate a sequence of arrays . [CODESPLIT] def uconcatenate ( arrs , axis = 0 ) : v = np . concatenate ( arrs , axis = axis ) v = _validate_numpy_wrapper_units ( v , arrs ) return v", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if specified value exists in int enum ; otherwise False . [CODESPLIT] def has_value ( cls , value : int ) -> bool : return any ( value == item . value for item in cls )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pull a file directly from S3 . [CODESPLIT] def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes trailing zeroes from indexable collection of numbers [CODESPLIT] def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get actual tree selection object and all respective models of selected rows [CODESPLIT] def get_view_selection ( self ) : if not self . MODEL_STORAGE_ID : return None , None # avoid selection requests on empty tree views -> case warnings in gtk3 if len ( self . store ) == 0 : paths = [ ] else : model , paths = self . _tree_selection . get_selected_rows ( ) # get all related models for selection from respective tree store field selected_model_list = [ ] for path in paths : model = self . store [ path ] [ self . MODEL_STORAGE_ID ] selected_model_list . append ( model ) return self . _tree_selection , selected_model_list", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a variation from a base value [CODESPLIT] def _gauss ( mean : int , sigma : int ) -> int : return int ( random . gauss ( mean , sigma ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the number of processors on this machine . [CODESPLIT] def cpu_count ( ) -> int : if multiprocessing is None : return 1 try : return multiprocessing . cpu_count ( ) except NotImplementedError : pass try : return os . sysconf ( \"SC_NPROCESSORS_CONF\" ) except ( AttributeError , ValueError ) : pass gen_log . error ( \"Could not detect number of processors; assuming 1\" ) return 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** . [CODESPLIT] def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Closure of log for zero arguments . [CODESPLIT] def _protected_log ( x1 ) : with np . errstate ( divide = 'ignore' , invalid = 'ignore' ) : return np . where ( np . abs ( x1 ) > 0.001 , np . log ( np . abs ( x1 ) ) , 0. )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses hostname from URL . : param url : URL : return : hostname [CODESPLIT] def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Report whether another set contains this set . [CODESPLIT] def issubset ( self , other ) : if len ( self ) > len ( other ) : # Fast check for obvious cases return False return all ( item in other for item in self )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses hostname from URL . : param url : URL : return : hostname [CODESPLIT] def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The current position of the cursor . [CODESPLIT] def position ( self ) -> Position : return Position ( self . _index , self . _lineno , self . _col_offset )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a string to a list with sanitization . [CODESPLIT] def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Last time step available . [CODESPLIT] def last ( self ) : if self . _last is UNDETERMINED : # not necessarily the last one... self . _last = self . sdat . tseries . index [ - 1 ] return self [ self . _last ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Finds the index of an item in list which satisfies predicate : param predicateFn : predicate function to run on items of list : param items : list of tuples : return : first index for which predicate function returns True [CODESPLIT] def getIndex ( predicateFn : Callable [ [ T ] , bool ] , items : List [ T ] ) -> int : try : return next ( i for i , v in enumerate ( items ) if predicateFn ( v ) ) except StopIteration : return - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fibonacci example function [CODESPLIT] def fib ( n ) : assert n > 0 a , b = 1 , 1 for i in range ( n - 1 ) : a , b = b , a + b return a", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Context manager that suppresses stdout . [CODESPLIT] def suppress_stdout ( ) : save_stdout = sys . stdout sys . stdout = DevNull ( ) yield sys . stdout = save_stdout", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Like rotate but modifies l in - place . [CODESPLIT] def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the value of a float property . [CODESPLIT] def get_property_as_float ( self , name : str ) -> float : return float ( self . __instrument . get_property ( name ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "zfill ( x width ) - > string [CODESPLIT] def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get all the database column names for the specified table . [CODESPLIT] def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Properly kill Python process including zombie threads . [CODESPLIT] def _exit ( self , status_code ) : # If there are active threads still running infinite loops, sys.exit # won't kill them but os._exit will. os._exit skips calling cleanup # handlers, flushing stdio buffers, etc. exit_func = os . _exit if threading . active_count ( ) > 1 else sys . exit exit_func ( status_code )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return dict mapping item - > indices . [CODESPLIT] def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get all the database column names for the specified table . [CODESPLIT] def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read and discard data [CODESPLIT] def _skip ( self , cnt ) : while cnt > 0 : if cnt > 8192 : buf = self . read ( 8192 ) else : buf = self . read ( cnt ) if not buf : break cnt -= len ( buf )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if cnr or cns files are empty ( only have a header ) [CODESPLIT] def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": ">>> argmax ( [ 4 2 - 5 ] ) 0 >>> argmax ( [ 4 2 - 5 ] key = abs ) 2 >>> argmax ( [ 4 2 - 5 ] key = abs both = True ) ( 2 5 ) [CODESPLIT] def argmax ( iterable , key = None , both = False ) : if key is not None : it = imap ( key , iterable ) else : it = iter ( iterable ) score , argmax = reduce ( max , izip ( it , count ( ) ) ) if both : return argmax , score return argmax", "target": 1, "target_options": ["no_match", "match"]}
{"input": "! [CODESPLIT] def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows . [CODESPLIT] def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "simple method to determine if a url is relative or absolute [CODESPLIT] def is_relative_url ( url ) : if url . startswith ( \"#\" ) : return None if url . find ( \"://\" ) > 0 or url . startswith ( \"//\" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "return list item number or default if don t exist [CODESPLIT] def _get_or_default ( mylist , i , default = None ) : if i >= len ( mylist ) : return default else : return mylist [ i ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function to remove the links from the input text [CODESPLIT] def remove_links ( text ) : tco_link_regex = re . compile ( \"https?://t.co/[A-z0-9].*\" ) generic_link_regex = re . compile ( \"(https?://)?(\\w*[.]\\w+)+([/?=&]+\\w+)*\" ) remove_tco = re . sub ( tco_link_regex , \" \" , text ) remove_generic = re . sub ( generic_link_regex , \" \" , remove_tco ) return remove_generic", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Covert numpy array to tensorflow tensor [CODESPLIT] def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generates RGB values from HSV values in line with a typical light spectrum . [CODESPLIT] def hsv2rgb_spectrum ( hsv ) : h , s , v = hsv return hsv2rgb_raw ( ( ( h * 192 ) >> 8 , s , v ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "sometimes the exp . column can be too large [CODESPLIT] def format_exp_floats ( decimals ) : threshold = 10 ** 5 return ( lambda n : \"{:.{prec}e}\" . format ( n , prec = decimals ) if n > threshold else \"{:4.{prec}f}\" . format ( n , prec = decimals ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Log in to instagram with given username and password and internally store session object . [CODESPLIT] def login ( self , user : str , passwd : str ) -> None : self . context . login ( user , passwd )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise . [CODESPLIT] def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return imaginary part of quaternion . [CODESPLIT] def quaternion_imag ( quaternion ) : return np . array ( quaternion [ 1 : 4 ] , dtype = np . float64 , copy = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Skip a section [CODESPLIT] def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A non - negative integer . [CODESPLIT] def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create an empty array with appropriate shape . [CODESPLIT] def _create_empty_array ( self , frames , always_2d , dtype ) : import numpy as np if always_2d or self . channels > 1 : shape = frames , self . channels else : shape = frames , return np . empty ( shape , dtype , order = 'C' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if a value is an integer number . [CODESPLIT] def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if two pathes represent the same file . [CODESPLIT] def samefile ( a : str , b : str ) -> bool : try : return os . path . samefile ( a , b ) except OSError : return os . path . normpath ( a ) == os . path . normpath ( b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** . [CODESPLIT] def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230 [CODESPLIT] def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fetch all remaining rows . [CODESPLIT] async def fetchall ( self ) -> Iterable [ sqlite3 . Row ] : return await self . _execute ( self . _cursor . fetchall )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rate limit a function . [CODESPLIT] def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if a value is an integer number . [CODESPLIT] def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove any duplicate item preserving order [CODESPLIT] def de_duplicate ( items ) : result = [ ] for item in items : if item not in result : result . append ( item ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all ( and only ) the uppercase chars in the given string . [CODESPLIT] def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return dict mapping item - > indices . [CODESPLIT] def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the singular form of a word the reverse of : func : pluralize . [CODESPLIT] def singularize ( word ) : for inflection in UNCOUNTABLES : if re . search ( r'(?i)\\b(%s)\\Z' % inflection , word ) : return word for rule , replacement in SINGULARS : if re . search ( rule , word ) : return re . sub ( rule , replacement , word ) return word", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Index of the last occurrence of x in the sequence . [CODESPLIT] def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing [CODESPLIT] def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != \"\" ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a string related to a model name and extract its model number . [CODESPLIT] def detect_model_num ( string ) : match = re . match ( MODEL_NUM_REGEX , string ) if match : return int ( match . group ( ) ) return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is the SQLAlchemy column type an integer type? [CODESPLIT] def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a datetime from GnuCash 2 . 6 date string [CODESPLIT] def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a list of branches in the current repo . [CODESPLIT] def branches ( ) : # type: () -> List[str] out = shell . run ( 'git branch' , capture = True , never_pretend = True ) . stdout . strip ( ) return [ x . strip ( '* \\t\\n' ) for x in out . splitlines ( ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield all items from iterable except the last one . [CODESPLIT] def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the keys that maps to the top n max values in the given dict . [CODESPLIT] def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip the whitespace from all column names in the given DataFrame and return the result . [CODESPLIT] def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Index of the last occurrence of x in the sequence . [CODESPLIT] def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "simple method to determine if a url is relative or absolute [CODESPLIT] def is_relative_url ( url ) : if url . startswith ( \"#\" ) : return None if url . find ( \"://\" ) > 0 or url . startswith ( \"//\" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Executes SQL ; returns list of first values of each row . [CODESPLIT] def fetchallfirstvalues ( self , sql : str , * args ) -> List [ Any ] : rows = self . fetchall ( sql , * args ) return [ row [ 0 ] for row in rows ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "rounds float to closest int : rtype : int : param n : float [CODESPLIT] def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all ( and only ) the uppercase chars in the given string . [CODESPLIT] def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit this application [CODESPLIT] def do_quit ( self , _ : argparse . Namespace ) -> bool : self . _should_quit = True return self . _STOP_AND_EXIT", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list produced by applying : func : multiple_replace to every string in stringlist . [CODESPLIT] def replace_in_list ( stringlist : Iterable [ str ] , replacedict : Dict [ str , str ] ) -> List [ str ] : newlist = [ ] for fromstring in stringlist : newlist . append ( multiple_replace ( fromstring , replacedict ) ) return newlist", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper function for creating hash functions . [CODESPLIT] def _hash_the_file ( hasher , filename ) : BUF_SIZE = 65536 with open ( filename , 'rb' ) as f : buf = f . read ( BUF_SIZE ) while len ( buf ) > 0 : hasher . update ( buf ) buf = f . read ( BUF_SIZE ) return hasher", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple helper hash function [CODESPLIT] def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A non - negative integer . [CODESPLIT] def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a scalar a to a list and all iterables to list as well . [CODESPLIT] def listify ( a ) : if a is None : return [ ] elif not isinstance ( a , ( tuple , list , np . ndarray ) ) : return [ a ] return list ( a )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert obj to string eliminate newlines and truncate the string to max characters . If there are more characters in the string add ... to the string . With left = True the string can be truncated at the beginning . [CODESPLIT] def trunc ( obj , max , left = 0 ) : s = str ( obj ) s = s . replace ( '\\n' , '|' ) if len ( s ) > max : if left : return '...' + s [ len ( s ) - max + 3 : ] else : return s [ : ( max - 3 ) ] + '...' else : return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert string from snake case to camel case . [CODESPLIT] def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Concatenate a sequence of arrays . [CODESPLIT] def uconcatenate ( arrs , axis = 0 ) : v = np . concatenate ( arrs , axis = axis ) v = _validate_numpy_wrapper_units ( v , arrs ) return v", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper to make map () behave the same on Py2 and Py3 . [CODESPLIT] def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of elements equal to elem present in the queue [CODESPLIT] def count ( self , elem ) : return self . _left_list . count ( elem ) + self . _right_list . count ( elem )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Release the USB interface again . [CODESPLIT] def _close ( self ) : self . _usb_handle . releaseInterface ( ) try : # If we're using PyUSB >= 1.0 we can re-attach the kernel driver here. self . _usb_handle . dev . attach_kernel_driver ( 0 ) except : pass self . _usb_int = None self . _usb_handle = None return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get version information for components used by Spyder [CODESPLIT] def get_versions ( reporev = True ) : import sys import platform import qtpy import qtpy . QtCore revision = None if reporev : from spyder . utils import vcs revision , branch = vcs . get_git_revision ( os . path . dirname ( __dir__ ) ) if not sys . platform == 'darwin' : # To avoid a crash with our Mac app system = platform . system ( ) else : system = 'Darwin' return { 'spyder' : __version__ , 'python' : platform . python_version ( ) , # \"2.7.3\" 'bitness' : 64 if sys . maxsize > 2 ** 32 else 32 , 'qt' : qtpy . QtCore . __version__ , 'qt_api' : qtpy . API_NAME , # PyQt5 'qt_api_ver' : qtpy . PYQT_VERSION , 'system' : system , # Linux, Windows, ... 'release' : platform . release ( ) , # XP, 10.6, 2.2.0, etc. 'revision' : revision , # '9fdf926eccce' }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read 4 bytes from bytestream as an unsigned 32 - bit integer . [CODESPLIT] def read32 ( bytestream ) : dt = np . dtype ( np . uint32 ) . newbyteorder ( '>' ) return np . frombuffer ( bytestream . read ( 4 ) , dtype = dt ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "simple method to determine if a url is relative or absolute [CODESPLIT] def is_relative_url ( url ) : if url . startswith ( \"#\" ) : return None if url . find ( \"://\" ) > 0 or url . startswith ( \"//\" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convert GPU arras to numpy and return them [CODESPLIT] def to_np ( * args ) : if len ( args ) > 1 : return ( cp . asnumpy ( x ) for x in args ) else : return cp . asnumpy ( args [ 0 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a list of letters remove any blank spaces or empty strings . [CODESPLIT] def remove_blank_spaces ( syllables : List [ str ] ) -> List [ str ] : cleaned = [ ] for syl in syllables : if syl == \" \" or syl == '' : pass else : cleaned . append ( syl ) return cleaned", "target": 1, "target_options": ["no_match", "match"]}
{"input": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False [CODESPLIT] def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "input ( [ prompt ] ) - > value [CODESPLIT] def input ( prompt = \"\" ) : string = stdin_decode ( raw_input ( prompt ) ) caller_frame = sys . _getframe ( 1 ) globals = caller_frame . f_globals locals = caller_frame . f_locals return eval ( string , globals , locals )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Context manager that suppresses stdout . [CODESPLIT] def suppress_stdout ( ) : save_stdout = sys . stdout sys . stdout = DevNull ( ) yield sys . stdout = save_stdout", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transforms its input into an integer or returns default . [CODESPLIT] def convert_to_int ( x : Any , default : int = None ) -> int : try : return int ( x ) except ( TypeError , ValueError ) : return default", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Asks a question yes no style [CODESPLIT] def ask_bool ( question : str , default : bool = True ) -> bool : default_q = \"Y/n\" if default else \"y/N\" answer = input ( \"{0} [{1}]: \" . format ( question , default_q ) ) lower = answer . lower ( ) if not lower : return default return lower == \"y\"", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . ) [CODESPLIT] def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert string or other Python object to boolean . [CODESPLIT] def to_bool ( value : Any ) -> bool : return bool ( strtobool ( value ) if isinstance ( value , str ) else value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a text into a list of tokens . [CODESPLIT] def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "HTTP POST operation to API endpoint . [CODESPLIT] def post ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'POST' , endpoint , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of dimensions of a tensor [CODESPLIT] def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Concatenate url and argument dictionary regardless of whether url has existing query parameters . [CODESPLIT] def url_concat ( url , args ) : if not args : return url if url [ - 1 ] not in ( '?' , '&' ) : url += '&' if ( '?' in url ) else '?' return url + urllib . urlencode ( args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": see : doc of method on parent class [CODESPLIT] def getVectorFromType ( self , dtype ) -> Union [ bool , None , Tuple [ int , int ] ] : if dtype == BIT : return False elif isinstance ( dtype , Bits ) : return [ evalParam ( dtype . width ) - 1 , hInt ( 0 ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a datetime from GnuCash 2 . 6 date string [CODESPLIT] def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if cnr or cns files are empty ( only have a header ) [CODESPLIT] def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "HTTP request method of interface implementation . [CODESPLIT] def _request ( self , method : str , endpoint : str , params : dict = None , data : dict = None , headers : dict = None ) -> dict :", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run verbose PyLint on source . Optionally specify fmt = html for HTML output . [CODESPLIT] def lint ( fmt = 'colorized' ) : if fmt == 'html' : outfile = 'pylint_report.html' local ( 'pylint -f %s davies > %s || true' % ( fmt , outfile ) ) local ( 'open %s' % outfile ) else : local ( 'pylint -f %s davies || true' % fmt )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generates RGB values from HSV values in line with a typical light spectrum . [CODESPLIT] def hsv2rgb_spectrum ( hsv ) : h , s , v = hsv return hsv2rgb_raw ( ( ( h * 192 ) >> 8 , s , v ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert string from snake case to camel case . [CODESPLIT] def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert string from camel case to snake case . [CODESPLIT] def camel_to_snake ( s : str ) -> str : return CAMEL_CASE_RE . sub ( r'_\\1' , s ) . strip ( ) . lower ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "gets the dimensions depending on python version and os [CODESPLIT] def get_window_dim ( ) : version = sys . version_info if version >= ( 3 , 3 ) : return _size_36 ( ) if platform . system ( ) == 'Windows' : return _size_windows ( ) return _size_27 ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the longest string size for a string entry across data . [CODESPLIT] def _prm_get_longest_stringsize ( string_list ) : maxlength = 1 for stringar in string_list : if isinstance ( stringar , np . ndarray ) : if stringar . ndim > 0 : for string in stringar . ravel ( ) : maxlength = max ( len ( string ) , maxlength ) else : maxlength = max ( len ( stringar . tolist ( ) ) , maxlength ) else : maxlength = max ( len ( stringar ) , maxlength ) # Make the string Col longer than needed in order to allow later on slightly larger strings return int ( maxlength * 1.5 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } ) [CODESPLIT] def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Covert numpy array to tensorflow tensor [CODESPLIT] def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if specified value exists in int enum ; otherwise False . [CODESPLIT] def has_value ( cls , value : int ) -> bool : return any ( value == item . value for item in cls )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fast median operation for masked array using 50th - percentile [CODESPLIT] def fast_median ( a ) : a = checkma ( a ) #return scoreatpercentile(a.compressed(), 50) if a . count ( ) > 0 : out = np . percentile ( a . compressed ( ) , 50 ) else : out = np . ma . masked return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print execution time of the function . For quick n dirty profiling . [CODESPLIT] def timeit ( func , log , limit ) : def newfunc ( * args , * * kwargs ) : \"\"\"Execute function and print execution time.\"\"\" t = time . time ( ) res = func ( * args , * * kwargs ) duration = time . time ( ) - t if duration > limit : print ( func . __name__ , \"took %0.2f seconds\" % duration , file = log ) print ( args , file = log ) print ( kwargs , file = log ) return res return update_func_meta ( newfunc , func )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Finds the index of an item in list which satisfies predicate : param predicateFn : predicate function to run on items of list : param items : list of tuples : return : first index for which predicate function returns True [CODESPLIT] def getIndex ( predicateFn : Callable [ [ T ] , bool ] , items : List [ T ] ) -> int : try : return next ( i for i , v in enumerate ( items ) if predicateFn ( v ) ) except StopIteration : return - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a file exists and is non - empty . [CODESPLIT] def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get version information for components used by Spyder [CODESPLIT] def get_versions ( reporev = True ) : import sys import platform import qtpy import qtpy . QtCore revision = None if reporev : from spyder . utils import vcs revision , branch = vcs . get_git_revision ( os . path . dirname ( __dir__ ) ) if not sys . platform == 'darwin' : # To avoid a crash with our Mac app system = platform . system ( ) else : system = 'Darwin' return { 'spyder' : __version__ , 'python' : platform . python_version ( ) , # \"2.7.3\" 'bitness' : 64 if sys . maxsize > 2 ** 32 else 32 , 'qt' : qtpy . QtCore . __version__ , 'qt_api' : qtpy . API_NAME , # PyQt5 'qt_api_ver' : qtpy . PYQT_VERSION , 'system' : system , # Linux, Windows, ... 'release' : platform . release ( ) , # XP, 10.6, 2.2.0, etc. 'revision' : revision , # '9fdf926eccce' }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all ( and only ) the chars in the given string . [CODESPLIT] def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Setup the flask - cache on a flask app [CODESPLIT] def setup_cache ( app : Flask , cache_config ) -> Optional [ Cache ] : if cache_config and cache_config . get ( 'CACHE_TYPE' ) != 'null' : return Cache ( app , config = cache_config ) return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a file exists and is non - empty . [CODESPLIT] def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Greater than ordering . [CODESPLIT] def __gt__ ( self , other ) : if not isinstance ( other , Key ) : return NotImplemented return self . __tuple ( ) > other . __tuple ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse val into either None or a strictly positive integer . [CODESPLIT] def strictly_positive_int_or_none ( val ) : val = positive_int_or_none ( val ) if val is None or val > 0 : return val raise ValueError ( '\"{}\" must be strictly positive' . format ( val ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether flyweight object with specified key has already been created . [CODESPLIT] def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Partition a list of integers into a list of partitions [CODESPLIT] def integer_partition ( size : int , nparts : int ) -> Iterator [ List [ List [ int ] ] ] : for part in algorithm_u ( range ( size ) , nparts ) : yield part", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Checks that a function raises an error when given specific arguments . [CODESPLIT] def assert_raises ( ex_type , func , * args , * * kwargs ) : try : func ( * args , * * kwargs ) except Exception as ex : assert isinstance ( ex , ex_type ) , ( 'Raised %r but type should have been %r' % ( ex , ex_type ) ) return True else : raise AssertionError ( 'No error was raised' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a UUID object to a 22 - char BUID string [CODESPLIT] def uuid2buid ( value ) : if six . PY3 : # pragma: no cover return urlsafe_b64encode ( value . bytes ) . decode ( 'utf-8' ) . rstrip ( '=' ) else : return six . text_type ( urlsafe_b64encode ( value . bytes ) . rstrip ( '=' ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . ) [CODESPLIT] def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility method to run commands synchronously for testing . [CODESPLIT] def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( \"Event loop is already running.\" ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Truncate string values . [CODESPLIT] def truncate_string ( value , max_width = None ) : if isinstance ( value , text_type ) and max_width is not None and len ( value ) > max_width : return value [ : max_width ] return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Finds the longest path in a dag between two nodes [CODESPLIT] def dag_longest_path ( graph , source , target ) : if source == target : return [ source ] allpaths = nx . all_simple_paths ( graph , source , target ) longest_path = [ ] for l in allpaths : if len ( l ) > len ( longest_path ) : longest_path = l return longest_path", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return dict mapping item - > indices . [CODESPLIT] def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip the whitespace from all column names in the given DataFrame and return the result . [CODESPLIT] def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return view of the recarray with all int32 cast to int64 . [CODESPLIT] def to_int64 ( a ) : # build new dtype and replace i4 --> i8 def promote_i4 ( typestr ) : if typestr [ 1 : ] == 'i4' : typestr = typestr [ 0 ] + 'i8' return typestr dtype = [ ( name , promote_i4 ( typestr ) ) for name , typestr in a . dtype . descr ] return a . astype ( dtype )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a tuple from parsing a b c d - > ( a b c d ) [CODESPLIT] def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Verifies that a string path actually exists and is a file [CODESPLIT] def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line . [CODESPLIT] def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection", "target": 1, "target_options": ["no_match", "match"]}
{"input": "filter for dict note f should have signature : f :: key - > value - > bool [CODESPLIT] def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return imaginary part of quaternion . [CODESPLIT] def quaternion_imag ( quaternion ) : return numpy . array ( quaternion [ 1 : 4 ] , dtype = numpy . float64 , copy = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return dict mapping item - > indices . [CODESPLIT] def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a list of the top topn features in this : class : . Feature \\ . [CODESPLIT] def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the index of the earliest occurence of an item from a list in a string [CODESPLIT] def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return dict mapping item - > indices . [CODESPLIT] def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates that the object itself is some kinda string [CODESPLIT] def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "HTTP POST operation to API endpoint . [CODESPLIT] def post ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'POST' , endpoint , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print out a neat targets dependency tree based on requested targets . [CODESPLIT] def cmd_dot ( conf : Config ) : build_context = BuildContext ( conf ) populate_targets_graph ( build_context , conf ) if conf . output_dot_file is None : write_dot ( build_context , conf , sys . stdout ) else : with open ( conf . output_dot_file , 'w' ) as out_file : write_dot ( build_context , conf , out_file )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the name of the caller s module as a string . [CODESPLIT] def get_caller_module ( ) : stack = inspect . stack ( ) assert len ( stack ) > 1 caller = stack [ 2 ] [ 0 ] return caller . f_globals [ '__name__' ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "takes a list of lists l and returns a flat list [CODESPLIT] def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Index of the last occurrence of x in the sequence . [CODESPLIT] def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the negated mask . If elements of input mask have 0 and non - zero values then the returned matrix will have all elements 0 ( 1 ) where the original one has non - zero ( 0 ) . : param mask : Input mask : type mask : np . array : return : array of same shape and dtype = int8 as input array : rtype : np . array [CODESPLIT] def negate_mask ( mask ) : res = np . ones ( mask . shape , dtype = np . int8 ) res [ mask > 0 ] = 0 return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a list of the top topn features in this : class : . Feature \\ . [CODESPLIT] def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the memory is too full for further caching . [CODESPLIT] def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Closest values [CODESPLIT] def closest_values ( L ) : assert len ( L ) >= 2 L . sort ( ) valmin , argmin = min ( ( L [ i ] - L [ i - 1 ] , i ) for i in range ( 1 , len ( L ) ) ) return L [ argmin - 1 ] , L [ argmin ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Concatenate a sequence of arrays . [CODESPLIT] def uconcatenate ( arrs , axis = 0 ) : v = np . concatenate ( arrs , axis = axis ) v = _validate_numpy_wrapper_units ( v , arrs ) return v", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit execution with return code and message : param msg : Message displayed prior to exit : param code : code returned upon exiting [CODESPLIT] def Exit ( msg , code = 1 ) : print >> sys . stderr , msg sys . exit ( code )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the duplicates in a list . [CODESPLIT] def find_duplicates ( l : list ) -> set : return set ( [ x for x in l if l . count ( x ) > 1 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read 4 bytes from bytestream as an unsigned 32 - bit integer . [CODESPLIT] def read32 ( bytestream ) : dt = np . dtype ( np . uint32 ) . newbyteorder ( '>' ) return np . frombuffer ( bytestream . read ( 4 ) , dtype = dt ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses hostname from URL . : param url : URL : return : hostname [CODESPLIT] def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert string from snake case to camel case . [CODESPLIT] def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a CSV object to a numpy array . [CODESPLIT] def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False [CODESPLIT] def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected [CODESPLIT] def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "rounds float to closest int : rtype : int : param n : float [CODESPLIT] def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns all column names and their data types as a list . [CODESPLIT] def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the plural form of a word . [CODESPLIT] def pluralize ( word ) : if not word or word . lower ( ) in UNCOUNTABLES : return word else : for rule , replacement in PLURALS : if re . search ( rule , word ) : return re . sub ( rule , replacement , word ) return word", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run parallel execution of futures and return mapping of their results to the provided keys . Just a neat shortcut around asyncio . gather () [CODESPLIT] async def parallel_results ( future_map : Sequence [ Tuple ] ) -> Dict : ctx_methods = OrderedDict ( future_map ) fs = list ( ctx_methods . values ( ) ) results = await asyncio . gather ( * fs ) results = { key : results [ idx ] for idx , key in enumerate ( ctx_methods . keys ( ) ) } return results", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all ( and only ) the chars in the given string . [CODESPLIT] def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility function to print sqlite queries before executing . [CODESPLIT] def execute ( cur , * args ) : stmt = args [ 0 ] if len ( args ) > 1 : stmt = stmt . replace ( '%' , '%%' ) . replace ( '?' , '%r' ) print ( stmt % ( args [ 1 ] ) ) return cur . execute ( * args )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the signed area enclosed by a ring using the linear time algorithm . A value > = 0 indicates a counter - clockwise oriented ring . [CODESPLIT] def signed_area ( coords ) : xs , ys = map ( list , zip ( * coords ) ) xs . append ( xs [ 1 ] ) ys . append ( ys [ 1 ] ) return sum ( xs [ i ] * ( ys [ i + 1 ] - ys [ i - 1 ] ) for i in range ( 1 , len ( coords ) ) ) / 2.0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Analyzes the result of a classification algorithm s fitting . See also : func : fit for explanation of arguments . [CODESPLIT] def classify_fit ( fqdn , result , * argl , * * argd ) : if len ( argl ) > 2 : #Usually fit is called with fit(machine, Xtrain, ytrain). yP = argl [ 2 ] out = _generic_fit ( fqdn , result , classify_predict , yP , * argl , * * argd ) return out", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a file descriptor from stdin or opening a file from a given path . [CODESPLIT] def file_or_stdin ( ) -> Callable : def parse ( path ) : if path is None or path == \"-\" : return sys . stdin else : return data_io . smart_open ( path ) return parse", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a file exists and is non - empty . [CODESPLIT] def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "simple method to determine if a url is relative or absolute [CODESPLIT] def is_relative_url ( url ) : if url . startswith ( \"#\" ) : return None if url . find ( \"://\" ) > 0 or url . startswith ( \"//\" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple helper hash function [CODESPLIT] def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test for greater than . [CODESPLIT] def __gt__ ( self , other ) : if isinstance ( other , Address ) : return str ( self ) > str ( other ) raise TypeError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper to make map () behave the same on Py2 and Py3 . [CODESPLIT] def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for iterating only nonempty lines without line breaks [CODESPLIT] def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of dimensions of a tensor [CODESPLIT] def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1 [CODESPLIT] def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This will erase all but say 30 of the legend entries and remake the legend . You ll probably have to move it back into your favorite position at this point . [CODESPLIT] def impose_legend_limit ( limit = 30 , axes = \"gca\" , * * kwargs ) : if axes == \"gca\" : axes = _pylab . gca ( ) # make these axes current _pylab . axes ( axes ) # loop over all the lines_pylab. for n in range ( 0 , len ( axes . lines ) ) : if n > limit - 1 and not n == len ( axes . lines ) - 1 : axes . lines [ n ] . set_label ( \"_nolegend_\" ) if n == limit - 1 and not n == len ( axes . lines ) - 1 : axes . lines [ n ] . set_label ( \"...\" ) _pylab . legend ( * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse HTTP status line return status ( int ) and reason . [CODESPLIT] def header_status ( header ) : status_line = header [ : header . find ( '\\r' ) ] # 'HTTP/1.1 200 OK' -> (200, 'OK') fields = status_line . split ( None , 2 ) return int ( fields [ 1 ] ) , fields [ 2 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper to make map () behave the same on Py2 and Py3 . [CODESPLIT] def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the keys that maps to the top n max values in the given dict . [CODESPLIT] def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for iterating only nonempty lines without line breaks [CODESPLIT] def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Guesses the mimetype of a file based on the given filename . [CODESPLIT] def guess_mimetype ( filename ) : fn = os . path . basename ( filename ) return mimetypes . guess_type ( fn ) [ 0 ] or 'application/octet-stream'", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if a value is an integer number . [CODESPLIT] def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a list of the top topn features in this : class : . Feature \\ . [CODESPLIT] def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether flyweight object with specified key has already been created . [CODESPLIT] def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all ( and only ) the chars in the given string . [CODESPLIT] def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Like rotate but modifies l in - place . [CODESPLIT] def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return unique list of iterable items preserving order . [CODESPLIT] def uniqued ( iterable ) : seen = set ( ) return [ item for item in iterable if item not in seen and not seen . add ( item ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip the whitespace from all column names in the given DataFrame and return the result . [CODESPLIT] def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "rounds float to closest int : rtype : int : param n : float [CODESPLIT] def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "string dict / object / value to JSON [CODESPLIT] def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert human readable string to datetime . datetime . [CODESPLIT] def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn a quoted collection literal of Lisp forms into Python AST nodes . [CODESPLIT] def _collection_literal_to_py_ast ( ctx : GeneratorContext , form : Iterable [ LispForm ] ) -> Iterable [ GeneratedPyAST ] : yield from map ( partial ( _const_val_to_py_ast , ctx ) , form )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "takes a list of lists l and returns a flat list [CODESPLIT] def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists . [CODESPLIT] def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Verifies that a string path actually exists and is a file [CODESPLIT] def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns True if test is True for all array elements . Otherwise returns False . [CODESPLIT] def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This will return whatever kind of kernel we want to use . Must have signature ( ndarray size NxM ndarray size 1xM ) - > ndarray size Nx1 [CODESPLIT] def kernel ( self , spread = 1 ) : # TODO: use self.kernel_type to choose function def gaussian ( data , pixel ) : return mvn . pdf ( data , mean = pixel , cov = spread ) return gaussian", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is the SQLAlchemy column type a string type? [CODESPLIT] def is_sqlatype_string ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . String )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decode the contents of a value from a serialized stream . [CODESPLIT] def decode_value ( stream ) : length = decode_length ( stream ) ( value , ) = unpack_value ( \">{:d}s\" . format ( length ) , stream ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if a node is an intersection [CODESPLIT] def is_intersection ( g , n ) : return len ( set ( g . predecessors ( n ) + g . successors ( n ) ) ) > 2", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Warn if nans exist in a numpy array . [CODESPLIT] def warn_if_nans_exist ( X ) : null_count = count_rows_with_nans ( X ) total = len ( X ) percent = 100 * null_count / total if null_count > 0 : warning_message = 'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' 'complete rows will be plotted.' . format ( null_count , total , percent ) warnings . warn ( warning_message , DataWarning )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list of synsets of a word after lemmatization . [CODESPLIT] def has_synset ( word : str ) -> list : return wn . synsets ( lemmatize ( word , neverstem = True ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run verbose PyLint on source . Optionally specify fmt = html for HTML output . [CODESPLIT] def lint ( fmt = 'colorized' ) : if fmt == 'html' : outfile = 'pylint_report.html' local ( 'pylint -f %s davies > %s || true' % ( fmt , outfile ) ) local ( 'open %s' % outfile ) else : local ( 'pylint -f %s davies || true' % fmt )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if two objects are equal based on a comparison of the specified attributes attrs . [CODESPLIT] def simple_eq ( one : Instance , two : Instance , attrs : List [ str ] ) -> bool : return all ( getattr ( one , a ) == getattr ( two , a ) for a in attrs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Decode the contents of a value from a serialized stream . [CODESPLIT] def decode_value ( stream ) : length = decode_length ( stream ) ( value , ) = unpack_value ( \">{:d}s\" . format ( length ) , stream ) return value", "target": 1, "target_options": ["no_match", "match"]}
{"input": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } ) [CODESPLIT] def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows . [CODESPLIT] def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate the first value in each row . [CODESPLIT] def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns full ISO string for the given date [CODESPLIT] def to_iso_string ( self ) -> str : assert isinstance ( self . value , datetime ) return datetime . isoformat ( self . value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if a value is a finite number . [CODESPLIT] def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shifts floats so that the first 10 decimal digits are significant . [CODESPLIT] def shift ( self , m : Union [ float , pd . Series ] ) -> Union [ int , pd . Series ] : out = m % 1 * self . TEN_DIGIT_MODULUS // 1 if isinstance ( out , pd . Series ) : return out . astype ( int ) return int ( out )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine whether sh has any value [CODESPLIT] def is_empty_shape ( sh : ShExJ . Shape ) -> bool : return sh . closed is None and sh . expression is None and sh . extra is None and sh . semActs is None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Detects whether a line is present within a file . [CODESPLIT] def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Algorithm 5 . 10 . Dot product algorithm in K - fold working precision K > = 3 . [CODESPLIT] def kdot ( x , y , K = 2 ) : xx = x . reshape ( - 1 , x . shape [ - 1 ] ) yy = y . reshape ( y . shape [ 0 ] , - 1 ) xx = numpy . ascontiguousarray ( xx ) yy = numpy . ascontiguousarray ( yy ) r = _accupy . kdot_helper ( xx , yy ) . reshape ( ( - 1 , ) + x . shape [ : - 1 ] + y . shape [ 1 : ] ) return ksum ( r , K - 1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the keys that maps to the top n max values in the given dict . [CODESPLIT] def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pull a file directly from S3 . [CODESPLIT] def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all ( and only ) the lowercase chars in the given string . [CODESPLIT] def lowercase_chars ( string : any ) -> str : return '' . join ( [ c if c . islower ( ) else '' for c in str ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pad an n - dimensional numpy array with zeros along the zero - th dimension so that it is the desired length . Return it unchanged if it is greater than or equal to the desired length [CODESPLIT] def pad ( a , desiredlength ) : if len ( a ) >= desiredlength : return a islist = isinstance ( a , list ) a = np . array ( a ) diff = desiredlength - len ( a ) shape = list ( a . shape ) shape [ 0 ] = diff padded = np . concatenate ( [ a , np . zeros ( shape , dtype = a . dtype ) ] ) return padded . tolist ( ) if islist else padded", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wrapper around Django s get_language utility . For Django > = 1 . 8 get_language returns None in case no translation is activate . Here we patch this behavior e . g . for back - end functionality requiring access to translated fields [CODESPLIT] def get_language ( ) : from parler import appsettings language = dj_get_language ( ) if language is None and appsettings . PARLER_DEFAULT_ACTIVATE : return appsettings . PARLER_DEFAULT_LANGUAGE_CODE else : return language", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add Mac OS X support . [CODESPLIT] def _darwin_current_arch ( self ) : if sys . platform == \"darwin\" : if sys . maxsize > 2 ** 32 : # 64bits. return platform . mac_ver ( ) [ 2 ] # Both Darwin and Python are 64bits. else : # Python 32 bits return platform . processor ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a datetime from GnuCash 2 . 6 date string [CODESPLIT] def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return flattened dictionary from MultiDict . [CODESPLIT] def flatten_multidict ( multidict ) : return dict ( [ ( key , value if len ( value ) > 1 else value [ 0 ] ) for ( key , value ) in multidict . iterlists ( ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine current time depending on USE_TZ setting . [CODESPLIT] def usetz_now ( ) : USE_TZ = getattr ( settings , 'USE_TZ' , False ) if USE_TZ and DJANGO_VERSION >= '1.4' : return now ( ) else : return datetime . utcnow ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "zfill ( x width ) - > string [CODESPLIT] def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return extension identifying format of given filename [CODESPLIT] def infer_format ( filename : str ) -> str : _ , ext = os . path . splitext ( filename ) return ext", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Clean up whitespace in column names . See better version at pugnlp . clean_columns [CODESPLIT] def normalize_column_names ( df ) : columns = df . columns if hasattr ( df , 'columns' ) else df columns = [ c . lower ( ) . replace ( ' ' , '_' ) for c in columns ] return columns", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is the SQLAlchemy column type an integer type? [CODESPLIT] def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses hostname from URL . : param url : URL : return : hostname [CODESPLIT] def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": ">>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7 [CODESPLIT] def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for iterating only nonempty lines without line breaks [CODESPLIT] def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts an dict to a Enum . [CODESPLIT] def dict_to_enum_fn ( d : Dict [ str , Any ] , enum_class : Type [ Enum ] ) -> Enum : return enum_class [ d [ 'name' ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns all column names and their data types as a list . [CODESPLIT] def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "convent hex color to tuple #ffffff - > ( 255 255 255 ) #ffff00ff - > ( 255 255 0 255 ) [CODESPLIT] def hex_color_to_tuple ( hex ) : hex = hex [ 1 : ] length = len ( hex ) // 2 return tuple ( int ( hex [ i * 2 : i * 2 + 2 ] , 16 ) for i in range ( length ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set an attribute with a default value . [CODESPLIT] def setdefault ( self , name : str , default : Any = None ) -> Any : return self . __dict__ . setdefault ( name , default )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "HTTP POST operation to API endpoint . [CODESPLIT] def post ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'POST' , endpoint , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns database SQL datatype for a column : e . g . VARCHAR . [CODESPLIT] def get_datatype ( self , table : str , column : str ) -> str : return self . flavour . get_datatype ( self , table , column ) . upper ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for iterating only nonempty lines without line breaks [CODESPLIT] def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print out a neat targets dependency tree based on requested targets . [CODESPLIT] def cmd_dot ( conf : Config ) : build_context = BuildContext ( conf ) populate_targets_graph ( build_context , conf ) if conf . output_dot_file is None : write_dot ( build_context , conf , sys . stdout ) else : with open ( conf . output_dot_file , 'w' ) as out_file : write_dot ( build_context , conf , out_file )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Purely a debugging aid : Ascii - art picture of a tree descended from node [CODESPLIT] def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determines if a matrix is approximately orthogonal . [CODESPLIT] def is_orthogonal ( matrix : np . ndarray , * , rtol : float = 1e-5 , atol : float = 1e-8 ) -> bool : return ( matrix . shape [ 0 ] == matrix . shape [ 1 ] and np . all ( np . imag ( matrix ) == 0 ) and np . allclose ( matrix . dot ( matrix . T ) , np . eye ( matrix . shape [ 0 ] ) , rtol = rtol , atol = atol ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create an identical 2d array where the second row is filled with value [CODESPLIT] def layer_with ( self , sample : np . ndarray , value : int ) -> np . ndarray : b = np . full ( ( 2 , len ( sample ) ) , value , dtype = float ) b [ 0 ] = sample return b", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Input validation for strings . [CODESPLIT] def input_validate_str ( string , name , max_len = None , exact_len = None ) : if type ( string ) is not str : raise pyhsm . exception . YHSM_WrongInputType ( name , str , type ( string ) ) if max_len != None and len ( string ) > max_len : raise pyhsm . exception . YHSM_InputTooLong ( name , max_len , len ( string ) ) if exact_len != None and len ( string ) != exact_len : raise pyhsm . exception . YHSM_WrongInputSize ( name , exact_len , len ( string ) ) return string", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dict with swapped keys and values [CODESPLIT] def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected [CODESPLIT] def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "( str ) - > int All the digits in a given string are concatenated and converted into a single number . [CODESPLIT] def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Connects to an Access database via ODBC with the DSN prespecified . [CODESPLIT] def connect_to_database_odbc_access ( self , dsn : str , autocommit : bool = True ) -> None : self . connect ( engine = ENGINE_ACCESS , interface = INTERFACE_ODBC , dsn = dsn , autocommit = autocommit )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield all items from iterable except the last one . [CODESPLIT] def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the inner product between two tensors [CODESPLIT] def inner ( tensor0 : BKTensor , tensor1 : BKTensor ) -> BKTensor : # Note: Relying on fact that vdot flattens arrays return np . vdot ( tensor0 , tensor1 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sum the total number of cycles over a list of tokens . [CODESPLIT] def _sum_cycles_from_tokens ( self , tokens : List [ str ] ) -> int : return sum ( ( int ( self . _nonnumber_pattern . sub ( '' , t ) ) for t in tokens ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert string from snake case to camel case . [CODESPLIT] def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a list of strings to a list of integers . [CODESPLIT] def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if cnr or cns files are empty ( only have a header ) [CODESPLIT] def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read 4 bytes from bytestream as an unsigned 32 - bit integer . [CODESPLIT] def read32 ( bytestream ) : dt = np . dtype ( np . uint32 ) . newbyteorder ( '>' ) return np . frombuffer ( bytestream . read ( 4 ) , dtype = dt ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get all unique links in the html of the page source . Page links include those obtained from : a - > href img - > src link - > href and script - > src . [CODESPLIT] def get_unique_links ( self ) : page_url = self . get_current_url ( ) soup = self . get_beautiful_soup ( self . get_page_source ( ) ) links = page_utils . _get_unique_links ( page_url , soup ) return links", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if n is a prime number [CODESPLIT] def is_prime ( n ) : if n % 2 == 0 and n > 2 : return False return all ( n % i for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "HTTP POST operation to API endpoint . [CODESPLIT] def post ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'POST' , endpoint , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "mouse_event from Win32 . [CODESPLIT] def mouse_event ( dwFlags : int , dx : int , dy : int , dwData : int , dwExtraInfo : int ) -> None : ctypes . windll . user32 . mouse_event ( dwFlags , dx , dy , dwData , dwExtraInfo )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the conda executable robustly across conda versions . [CODESPLIT] def _find_conda ( ) : if 'CONDA_EXE' in os . environ : conda = os . environ [ 'CONDA_EXE' ] else : conda = util . which ( 'conda' ) return conda", "target": 1, "target_options": ["no_match", "match"]}
{"input": "string dict / object / value to JSON [CODESPLIT] def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "! [CODESPLIT] def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns its parameter as an integer or raises django . forms . ValidationError . [CODESPLIT] def clean_int ( x ) -> int : try : return int ( x ) except ValueError : raise forms . ValidationError ( \"Cannot convert to integer: {}\" . format ( repr ( x ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns all column names and their data types as a list . [CODESPLIT] def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is the SQLAlchemy column type an integer type? [CODESPLIT] def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a generator over iterable that tells whether the current item is the last one . Usage : >>> iterable = range ( 10 ) >>> for index is_last item in enum_mark_last ( iterable ) : >>> print ( index item end = \\ n if is_last else ) [CODESPLIT] def enum_mark_last ( iterable , start = 0 ) : it = iter ( iterable ) count = start try : last = next ( it ) except StopIteration : return for val in it : yield count , False , last last = val count += 1 yield count , True , last", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a list of all arguments for the function fn . [CODESPLIT] def get_all_args ( fn ) -> list : sig = inspect . signature ( fn ) return list ( sig . parameters )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Under UNIX : is a keystroke available? [CODESPLIT] def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Duplicates a requests . Session . [CODESPLIT] def copy_session ( session : requests . Session ) -> requests . Session : new = requests . Session ( ) new . cookies = requests . utils . cookiejar_from_dict ( requests . utils . dict_from_cookiejar ( session . cookies ) ) new . headers = session . headers . copy ( ) return new", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected [CODESPLIT] def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\\t' ) + string . count ( '\\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Purely a debugging aid : Ascii - art picture of a tree descended from node [CODESPLIT] def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "takes a list of lists l and returns a flat list [CODESPLIT] def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple helper hash function [CODESPLIT] def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize values . [CODESPLIT] def convert_column ( self , values ) : assert all ( values >= 0 ) , 'Cannot normalize a column with negatives' total = sum ( values ) if total > 0 : return values / total else : return values", "target": 1, "target_options": ["no_match", "match"]}
{"input": ": return : int [CODESPLIT] def __next__ ( self ) : self . current += 1 if self . current > self . total : raise StopIteration else : return self . iterable [ self . current - 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return unique list of items preserving order . [CODESPLIT] def uniqued ( iterable ) : seen = set ( ) add = seen . add return [ i for i in iterable if i not in seen and not add ( i ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Alias for Flask . run [CODESPLIT] def run_web ( self , flask , host = '127.0.0.1' , port = 5000 , * * options ) : # type: (Zsl, str, int, **Any)->None return flask . run ( host = flask . config . get ( 'FLASK_HOST' , host ) , port = flask . config . get ( 'FLASK_PORT' , port ) , debug = flask . config . get ( 'DEBUG' , False ) , * * options )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Delete all records from a table . Use caution! [CODESPLIT] def wipe_table ( self , table : str ) -> int : sql = \"DELETE FROM \" + self . delimit ( table ) return self . db_exec ( sql )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Writes text to a file . [CODESPLIT] def write_text ( filename : str , text : str ) -> None : with open ( filename , 'w' ) as f : # type: TextIO print ( text , file = f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last week as a period string [CODESPLIT] def get_period_last_3_months ( ) -> str : today = Datum ( ) today . today ( ) # start_date = today - timedelta(weeks=13) start_date = today . clone ( ) start_date . subtract_months ( 3 ) period = get_period ( start_date . date , today . date ) return period", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check filename extension to see if it s a video file . [CODESPLIT] def _is_video ( filepath ) -> bool : if os . path . exists ( filepath ) : # Could be broken symlink extension = os . path . splitext ( filepath ) [ 1 ] return extension in ( '.mkv' , '.mp4' , '.avi' ) else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert string from snake case to camel case . [CODESPLIT] def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shape of histogram s data . [CODESPLIT] def shape ( self ) -> Tuple [ int , ... ] : return tuple ( bins . bin_count for bins in self . _binnings )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts all strings in a column to uppercase . [CODESPLIT] def str_upper ( x ) : sl = _to_string_sequence ( x ) . upper ( ) return column . ColumnStringArrow ( sl . bytes , sl . indices , sl . length , sl . offset , string_sequence = sl )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return physical memory usage ( float ) Requires the cross - platform psutil ( > = v0 . 3 ) library ( https : // github . com / giampaolo / psutil ) [CODESPLIT] def psutil_phymem_usage ( ) : import psutil # This is needed to avoid a deprecation warning error with\n # newer psutil versions\n try : percent = psutil . virtual_memory ( ) . percent except : percent = psutil . phymem_usage ( ) . percent return percent", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Partition a list of integers into a list of partitions [CODESPLIT] def integer_partition ( size : int , nparts : int ) -> Iterator [ List [ List [ int ] ] ] : for part in algorithm_u ( range ( size ) , nparts ) : yield part", "target": 1, "target_options": ["no_match", "match"]}
{"input": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False [CODESPLIT] def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a list of the top topn features in this : class : . Feature \\ . [CODESPLIT] def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a random python attribute name . [CODESPLIT] def random_name_gen ( size = 6 ) : return '' . join ( [ random . choice ( string . ascii_uppercase ) ] + [ random . choice ( string . ascii_uppercase + string . digits ) for i in range ( size - 1 ) ] ) if size > 0 else ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Completer function for Python s readline / libedit implementation . [CODESPLIT] def repl_complete ( text : str , state : int ) -> Optional [ str ] : # Can't complete Keywords, Numerals if __NOT_COMPLETEABLE . match ( text ) : return None elif text . startswith ( \":\" ) : completions = kw . complete ( text ) else : ns = get_current_ns ( ) completions = ns . complete ( text ) return list ( completions ) [ state ] if completions is not None else None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Print at most limit elements of list . [CODESPLIT] def _brief_print_list ( lst , limit = 7 ) : lst = list ( lst ) if len ( lst ) > limit : return _brief_print_list ( lst [ : limit // 2 ] , limit ) + ', ..., ' + _brief_print_list ( lst [ - limit // 2 : ] , limit ) return ', ' . join ( [ \"'%s'\" % str ( i ) for i in lst ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the keys that maps to the top n max values in the given dict . [CODESPLIT] def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "( str ) - > int All the digits in a given string are concatenated and converted into a single number . [CODESPLIT] def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ] [CODESPLIT] def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for iterating only nonempty lines without line breaks [CODESPLIT] def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes all non - printable characters from a text string [CODESPLIT] def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a list of ranges to a set of numbers :: [CODESPLIT] def ranges_to_set ( lst ) : return set ( itertools . chain ( * ( range ( x [ 0 ] , x [ 1 ] + 1 ) for x in lst ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ">>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7 [CODESPLIT] def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } ) [CODESPLIT] def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return imaginary part of quaternion . [CODESPLIT] def quaternion_imag ( quaternion ) : return numpy . array ( quaternion [ 1 : 4 ] , dtype = numpy . float64 , copy = True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simultaneously replace multiple strigns in a string [CODESPLIT] def multiple_replace ( string , replacements ) : # type: (str, Dict[str,str]) -> str pattern = re . compile ( \"|\" . join ( [ re . escape ( k ) for k in sorted ( replacements , key = len , reverse = True ) ] ) , flags = re . DOTALL ) return pattern . sub ( lambda x : replacements [ x . group ( 0 ) ] , string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read and return an entire section [CODESPLIT] def _read_section ( self ) : lines = [ self . _last [ self . _last . find ( \":\" ) + 1 : ] ] self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : lines . append ( self . _last ) self . _last = self . _f . readline ( ) return lines", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn a list into a comma - and / or and - separated string . [CODESPLIT] def list_to_str ( lst ) : if len ( lst ) == 1 : str_ = lst [ 0 ] elif len ( lst ) == 2 : str_ = ' and ' . join ( lst ) elif len ( lst ) > 2 : str_ = ', ' . join ( lst [ : - 1 ] ) str_ += ', and {0}' . format ( lst [ - 1 ] ) else : raise ValueError ( 'List of length 0 provided.' ) return str_", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate a random walk and return True if the walker has returned to the origin after taking n steps . [CODESPLIT] def returned ( n ) : ## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk for pos in randwalk ( ) >> drop ( 1 ) >> takei ( xrange ( n - 1 ) ) : if pos == Origin : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right . [CODESPLIT] def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a generator over iterable that tells whether the current item is the last one . Usage : >>> iterable = range ( 10 ) >>> for index is_last item in enum_mark_last ( iterable ) : >>> print ( index item end = \\ n if is_last else ) [CODESPLIT] def enum_mark_last ( iterable , start = 0 ) : it = iter ( iterable ) count = start try : last = next ( it ) except StopIteration : return for val in it : yield count , False , last last = val count += 1 yield count , True , last", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the item that appears most frequently in the given list . [CODESPLIT] def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a new copied dictionary without the keys with None values from the given Mapping object . [CODESPLIT] def clean_map ( obj : Mapping [ Any , Any ] ) -> Mapping [ Any , Any ] : return { k : v for k , v in obj . items ( ) if v is not None }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is the SQLAlchemy column type an integer type? [CODESPLIT] def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "True if values are not increasing . [CODESPLIT] def non_increasing ( values ) : return all ( x >= y for x , y in zip ( values , values [ 1 : ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last week as a period string [CODESPLIT] def get_period_last_3_months ( ) -> str : today = Datum ( ) today . today ( ) # start_date = today - timedelta(weeks=13) start_date = today . clone ( ) start_date . subtract_months ( 3 ) period = get_period ( start_date . date , today . date ) return period", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Report whether another set contains this set . [CODESPLIT] def issubset ( self , other ) : if len ( self ) > len ( other ) : # Fast check for obvious cases return False return all ( item in other for item in self )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r This function chooses whether to use ascii characters to represent a symbolic expression in the notebook or to use sympy s pprint . [CODESPLIT] def fprint ( expr , print_ascii = False ) : if print_ascii : pprint ( expr , use_unicode = False , num_columns = 120 ) else : return expr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a set of triples representing the 3 - cycles from a directional graph . [CODESPLIT] def get_triangles ( graph : DiGraph ) -> SetOfNodeTriples : return { tuple ( sorted ( [ a , b , c ] , key = str ) ) for a , b in graph . edges ( ) for c in graph . successors ( b ) if graph . has_edge ( c , a ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "! [CODESPLIT] def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fail if first is not in collection second . [CODESPLIT] def assert_in ( first , second , msg_fmt = \"{msg}\" ) : if first not in second : msg = \"{!r} not in {!r}\" . format ( first , second ) fail ( msg_fmt . format ( msg = msg , first = first , second = second ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Within the dictionary d find a key that matches ( in case - insensitive fashion ) the key k and return it ( or None if there isn t one ) . [CODESPLIT] def get_case_insensitive_dict_key ( d : Dict , k : str ) -> Optional [ str ] : for key in d . keys ( ) : if k . lower ( ) == key . lower ( ) : return key return None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit this application [CODESPLIT] def do_quit ( self , _ : argparse . Namespace ) -> bool : self . _should_quit = True return self . _STOP_AND_EXIT", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get domain part of an url . [CODESPLIT] def get_domain ( url ) : parse_result = urlparse ( url ) domain = \"{schema}://{netloc}\" . format ( schema = parse_result . scheme , netloc = parse_result . netloc ) return domain", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Moves the cursor one place to the left erasing the character at the current position . Cannot move beyond column zero nor onto the previous line . [CODESPLIT] def backspace ( self ) : if self . _cx + self . _cw >= 0 : self . erase ( ) self . _cx -= self . _cw self . flush ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Shamelessly taken from Django . https : // github . com / django / django / blob / master / django / utils / text . py [CODESPLIT] def get_valid_filename ( s ) : s = str ( s ) . strip ( ) . replace ( ' ' , '_' ) return re . sub ( r'(?u)[^-\\w.]' , '' , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a list of strings to a list of integers . [CODESPLIT] def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a tuple from parsing a b c d - > ( a b c d ) [CODESPLIT] def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert string from snake case to camel case . [CODESPLIT] def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format numpy array as a string . [CODESPLIT] def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( \",\" ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + \"%s[%s]\" % ( arr . dtype , shape )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Index of the last occurrence of x in the sequence . [CODESPLIT] def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "! [CODESPLIT] def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Executes SQL ; returns list of first values of each row . [CODESPLIT] def fetchallfirstvalues ( self , sql : str , * args ) -> List [ Any ] : rows = self . fetchall ( sql , * args ) return [ row [ 0 ] for row in rows ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert string from snake case to camel case . [CODESPLIT] def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the properties of this : class : Sample as JSON serializable . [CODESPLIT] def to_json ( self ) -> Mapping : return { str ( x ) : str ( y ) for x , y in self . items ( ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fibonacci example function [CODESPLIT] def fib ( n ) : assert n > 0 a , b = 1 , 1 for i in range ( n - 1 ) : a , b = b , a + b return a", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a view into the memory [CODESPLIT] def read ( self , start_position : int , size : int ) -> memoryview : return memoryview ( self . _bytes ) [ start_position : start_position + size ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove leading needle string ( if exists ) . [CODESPLIT] def remove_leading ( needle , haystack ) : if haystack [ : len ( needle ) ] == needle : return haystack [ len ( needle ) : ] return haystack", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a CSV object to a numpy array . [CODESPLIT] def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the memory is too full for further caching . [CODESPLIT] def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Index of the last occurrence of x in the sequence . [CODESPLIT] def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Purely a debugging aid : Ascii - art picture of a tree descended from node [CODESPLIT] def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a datetime from GnuCash 2 . 6 date string [CODESPLIT] def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Asynchronously run the worker does not close connections . Useful when testing . [CODESPLIT] async def async_run ( self ) -> None : self . main_task = self . loop . create_task ( self . main ( ) ) await self . main_task", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return dict mapping item - > indices . [CODESPLIT] def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the longest common substring in a list of strings . Credit : http : // stackoverflow . com / questions / 2892931 / longest - common - substring - from - more - than - two - strings - python [CODESPLIT] def long_substr ( data ) : substr = '' if len ( data ) > 1 and len ( data [ 0 ] ) > 0 : for i in range ( len ( data [ 0 ] ) ) : for j in range ( len ( data [ 0 ] ) - i + 1 ) : if j > len ( substr ) and all ( data [ 0 ] [ i : i + j ] in x for x in data ) : substr = data [ 0 ] [ i : i + j ] elif len ( data ) == 1 : substr = data [ 0 ] return substr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "! [CODESPLIT] def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . ) [CODESPLIT] def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is a PDF - to - text tool available? [CODESPLIT] def availability_pdf ( ) -> bool : pdftotext = tools [ 'pdftotext' ] if pdftotext : return True elif pdfminer : log . warning ( \"PDF conversion: pdftotext missing; \" \"using pdfminer (less efficient)\" ) return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a file exists and is non - empty . [CODESPLIT] def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether any old service periods intersect with any new ones . [CODESPLIT] def CheckDisjointCalendars ( self ) : # TODO: Do an exact check here. a_service_periods = self . feed_merger . a_schedule . GetServicePeriodList ( ) b_service_periods = self . feed_merger . b_schedule . GetServicePeriodList ( ) for a_service_period in a_service_periods : a_start , a_end = a_service_period . GetDateRange ( ) for b_service_period in b_service_periods : b_start , b_end = b_service_period . GetDateRange ( ) overlap_start = max ( a_start , b_start ) overlap_end = min ( a_end , b_end ) if overlap_end >= overlap_start : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a list of the top topn features in this : class : . Feature \\ . [CODESPLIT] def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test for greater than . [CODESPLIT] def __gt__ ( self , other ) : if isinstance ( other , Address ) : return str ( self ) > str ( other ) raise TypeError", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Connects to an Access database via ODBC with the DSN prespecified . [CODESPLIT] def connect_to_database_odbc_access ( self , dsn : str , autocommit : bool = True ) -> None : self . connect ( engine = ENGINE_ACCESS , interface = INTERFACE_ODBC , dsn = dsn , autocommit = autocommit )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Very simple grep that returns the first matching line in a file . String matching only does not do REs as currently implemented . [CODESPLIT] def grep ( pattern , filename ) : try : # for line in file # if line matches pattern: #    return line return next ( ( L for L in open ( filename ) if L . find ( pattern ) >= 0 ) ) except StopIteration : return ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield . [CODESPLIT] def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if the queue is full False otherwise ( not reliable! ) . [CODESPLIT] def full ( self ) : return self . maxsize and len ( self . list ) >= self . maxsize or False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This will return whatever kind of kernel we want to use . Must have signature ( ndarray size NxM ndarray size 1xM ) - > ndarray size Nx1 [CODESPLIT] def kernel ( self , spread = 1 ) : # TODO: use self.kernel_type to choose function def gaussian ( data , pixel ) : return mvn . pdf ( data , mean = pixel , cov = spread ) return gaussian", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Reshuffle the indicies of a bipartite matrix A [ ij kl ] - > A [ lj ki ] . [CODESPLIT] def _reshuffle ( mat , shape ) : return np . reshape ( np . transpose ( np . reshape ( mat , shape ) , ( 3 , 1 , 2 , 0 ) ) , ( shape [ 3 ] * shape [ 1 ] , shape [ 0 ] * shape [ 2 ] ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple helper hash function [CODESPLIT] def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Strip the whitespace from all column names in the given DataFrame and return the result . [CODESPLIT] def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove the element from a set lists or dict . >>> L = [ Lucy ] ; S = set ( [ Sky ] ) ; D = { Diamonds : True } ; >>> remove_once ( L Lucy ) ; remove_once ( S Sky ) ; remove_once ( D Diamonds ) ; >>> print L S D [] set ( [] ) {} [CODESPLIT] def remove_once ( gset , elem ) : remove = getattr ( gset , 'remove' , None ) if remove is not None : remove ( elem ) else : del gset [ elem ] return elem", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validates that the object itself is some kinda string [CODESPLIT] def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise . [CODESPLIT] def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a dict with swapped keys and values [CODESPLIT] def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if gate tensor is ( almost ) Hermitian [CODESPLIT] def almost_hermitian ( gate : Gate ) -> bool : return np . allclose ( asarray ( gate . asoperator ( ) ) , asarray ( gate . H . asoperator ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper method to check if a set of types is the { AnyObject } singleton [CODESPLIT] def is_any_type_set ( sett : Set [ Type ] ) -> bool : return len ( sett ) == 1 and is_any_type ( min ( sett ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1 [CODESPLIT] def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Finds the index of an item in list which satisfies predicate : param predicateFn : predicate function to run on items of list : param items : list of tuples : return : first index for which predicate function returns True [CODESPLIT] def getIndex ( predicateFn : Callable [ [ T ] , bool ] , items : List [ T ] ) -> int : try : return next ( i for i , v in enumerate ( items ) if predicateFn ( v ) ) except StopIteration : return - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return True if the queue is full False otherwise ( not reliable! ) . [CODESPLIT] def full ( self ) : return self . maxsize and len ( self . list ) >= self . maxsize or False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the index of the earliest occurence of an item from a list in a string [CODESPLIT] def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a parser for CLI arguments and options . [CODESPLIT] def default_parser ( ) -> argparse . ArgumentParser : parser = argparse . ArgumentParser ( prog = CONSOLE_SCRIPT , formatter_class = argparse . ArgumentDefaultsHelpFormatter , ) build_parser ( parser ) return parser", "target": 1, "target_options": ["no_match", "match"]}
{"input": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False [CODESPLIT] def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Detects whether a line is present within a file . [CODESPLIT] def is_line_in_file ( filename : str , line : str ) -> bool : assert \"\\n\" not in line with open ( filename , \"r\" ) as file : for fileline in file : if fileline == line : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last week as a period string [CODESPLIT] def get_period_last_3_months ( ) -> str : today = Datum ( ) today . today ( ) # start_date = today - timedelta(weeks=13) start_date = today . clone ( ) start_date . subtract_months ( 3 ) period = get_period ( start_date . date , today . date ) return period", "target": 1, "target_options": ["no_match", "match"]}
{"input": "filter for dict note f should have signature : f :: key - > value - > bool [CODESPLIT] def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "filter for dict note f should have signature : f :: key - > value - > bool [CODESPLIT] def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return extension identifying format of given filename [CODESPLIT] def infer_format ( filename : str ) -> str : _ , ext = os . path . splitext ( filename ) return ext", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Executes SQL ; returns the first value of the first row or None . [CODESPLIT] def fetchvalue ( self , sql : str , * args ) -> Optional [ Any ] : row = self . fetchone ( sql , * args ) if row is None : return None return row [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "string dict / object / value to JSON [CODESPLIT] def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Purely a debugging aid : Ascii - art picture of a tree descended from node [CODESPLIT] def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements . [CODESPLIT] def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns distance given distance modulus . [CODESPLIT] def dfromdm ( dm ) : if np . size ( dm ) > 1 : dm = np . atleast_1d ( dm ) return 10 ** ( 1 + dm / 5 )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the last weekday in a given month . e . g : [CODESPLIT] def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230 [CODESPLIT] def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the longest common substring in a list of strings . Credit : http : // stackoverflow . com / questions / 2892931 / longest - common - substring - from - more - than - two - strings - python [CODESPLIT] def long_substr ( data ) : substr = '' if len ( data ) > 1 and len ( data [ 0 ] ) > 0 : for i in range ( len ( data [ 0 ] ) ) : for j in range ( len ( data [ 0 ] ) - i + 1 ) : if j > len ( substr ) and all ( data [ 0 ] [ i : i + j ] in x for x in data ) : substr = data [ 0 ] [ i : i + j ] elif len ( data ) == 1 : substr = data [ 0 ] return substr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add colons after every second digit . [CODESPLIT] def add_colons ( s ) : return ':' . join ( [ s [ i : i + 2 ] for i in range ( 0 , len ( s ) , 2 ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert string from snake case to camel case . [CODESPLIT] def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of unique spanning trees of a graph using Kirchhoff s matrix tree theorem . [CODESPLIT] def spanning_tree_count ( graph : nx . Graph ) -> int : laplacian = nx . laplacian_matrix ( graph ) . toarray ( ) comatrix = laplacian [ : - 1 , : - 1 ] det = np . linalg . det ( comatrix ) count = int ( round ( det ) ) return count", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230 [CODESPLIT] def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a text into a list of tokens . [CODESPLIT] def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read 4 bytes from bytestream as an unsigned 32 - bit integer . [CODESPLIT] def read32 ( bytestream ) : dt = np . dtype ( np . uint32 ) . newbyteorder ( '>' ) return np . frombuffer ( bytestream . read ( 4 ) , dtype = dt ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add value to a set in a dictionary by key [CODESPLIT] def dict_of_sets_add ( dictionary , key , value ) : # type: (DictUpperBound, Any, Any) -> None set_objs = dictionary . get ( key , set ( ) ) set_objs . add ( value ) dictionary [ key ] = set_objs", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Yield all items from iterable except the last one . [CODESPLIT] def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second", "target": 1, "target_options": ["no_match", "match"]}
{"input": "( str ) - > int All the digits in a given string are concatenated and converted into a single number . [CODESPLIT] def try_cast_int ( s ) : try : temp = re . findall ( '\\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x . [CODESPLIT] def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the last weekday in a given month . e . g : [CODESPLIT] def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Purely a debugging aid : Ascii - art picture of a tree descended from node [CODESPLIT] def debugTreePrint ( node , pfx = \"->\" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , \"  \" + pfx )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a datetime from GnuCash 2 . 6 date string [CODESPLIT] def get_from_gnucash26_date ( date_str : str ) -> date : date_format = \"%Y%m%d\" result = datetime . strptime ( date_str , date_format ) . date ( ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns database SQL datatype for a column : e . g . VARCHAR . [CODESPLIT] def get_datatype ( self , table : str , column : str ) -> str : return self . flavour . get_datatype ( self , table , column ) . upper ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** . [CODESPLIT] def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns annotated attribute names : return : List [ str ] [CODESPLIT] def attr_names ( cls ) -> List [ str ] : return [ k for k , v in cls . attr_types ( ) . items ( ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Very simple grep that returns the first matching line in a file . String matching only does not do REs as currently implemented . [CODESPLIT] def grep ( pattern , filename ) : try : # for line in file # if line matches pattern: #    return line return next ( ( L for L in open ( filename ) if L . find ( pattern ) >= 0 ) ) except StopIteration : return ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "rounds float to closest int : rtype : int : param n : float [CODESPLIT] def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Matrix multiplication using binary [CODESPLIT] def __rmatmul__ ( self , other ) : return self . T . dot ( np . transpose ( other ) ) . T", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a text into a list of tokens . [CODESPLIT] def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right . [CODESPLIT] def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of dimensions of a tensor [CODESPLIT] def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if a character is a blankspace . [CODESPLIT] def is_blankspace ( self , char ) : if len ( char ) > 1 : raise TypeError ( \"Expected a char.\" ) if char in self . blankspaces : return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Discover the current time zone and it s standard string representation ( for source { d } ) . [CODESPLIT] def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( \"%z\" ) tzstr = tzstr [ : - 2 ] + \":\" + tzstr [ - 2 : ] return dt . tzinfo , tzstr", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** . [CODESPLIT] def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows . [CODESPLIT] def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the number of processors on this machine . [CODESPLIT] def cpu_count ( ) -> int : if multiprocessing is None : return 1 try : return multiprocessing . cpu_count ( ) except NotImplementedError : pass try : return os . sysconf ( \"SC_NPROCESSORS_CONF\" ) except ( AttributeError , ValueError ) : pass gen_log . error ( \"Could not detect number of processors; assuming 1\" ) return 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Asynchronously run the worker does not close connections . Useful when testing . [CODESPLIT] async def async_run ( self ) -> None : self . main_task = self . loop . create_task ( self . main ( ) ) await self . main_task", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper for iterating only nonempty lines without line breaks [CODESPLIT] def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\\r\\n' ) if line : yield line", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a folder on S3 . [CODESPLIT] def mkdir ( self , target_folder ) : self . printv ( \"Making directory: %s\" % target_folder ) self . k . key = re . sub ( r\"^/|/$\" , \"\" , target_folder ) + \"/\" self . k . set_contents_from_string ( '' ) self . k . close ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Executes SQL ; returns list of first values of each row . [CODESPLIT] def fetchallfirstvalues ( self , sql : str , * args ) -> List [ Any ] : rows = self . fetchall ( sql , * args ) return [ row [ 0 ] for row in rows ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Very simple grep that returns the first matching line in a file . String matching only does not do REs as currently implemented . [CODESPLIT] def grep ( pattern , filename ) : try : # for line in file # if line matches pattern: #    return line return next ( ( L for L in open ( filename ) if L . find ( pattern ) >= 0 ) ) except StopIteration : return ''", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Finds the index of an item in list which satisfies predicate : param predicateFn : predicate function to run on items of list : param items : list of tuples : return : first index for which predicate function returns True [CODESPLIT] def getIndex ( predicateFn : Callable [ [ T ] , bool ] , items : List [ T ] ) -> int : try : return next ( i for i , v in enumerate ( items ) if predicateFn ( v ) ) except StopIteration : return - 1", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert a CSV object to a numpy array . [CODESPLIT] def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cast to float tensor [CODESPLIT] def fcast ( value : float ) -> TensorLike : newvalue = tf . cast ( value , FTYPE ) if DEVICE == 'gpu' : newvalue = newvalue . gpu ( ) # Why is this needed?  # pragma: no cover return newvalue", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate the first value in each row . [CODESPLIT] def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if cnr or cns files are empty ( only have a header ) [CODESPLIT] def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return datetime object from timestamp in Excel serial format . [CODESPLIT] def excel_datetime ( timestamp , epoch = None ) : if epoch is None : epoch = datetime . datetime . fromordinal ( 693594 ) return epoch + datetime . timedelta ( timestamp )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate simple moving average [CODESPLIT] def simple_moving_average ( x , n = 10 ) : if x . ndim > 1 and len ( x [ 0 ] ) > 1 : x = np . average ( x , axis = 1 ) a = np . ones ( n ) / float ( n ) return np . convolve ( x , a , 'valid' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements . [CODESPLIT] def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )", "target": 1, "target_options": ["no_match", "match"]}
{"input": ">>> argmax ( [ 4 2 - 5 ] ) 0 >>> argmax ( [ 4 2 - 5 ] key = abs ) 2 >>> argmax ( [ 4 2 - 5 ] key = abs both = True ) ( 2 5 ) [CODESPLIT] def argmax ( iterable , key = None , both = False ) : if key is not None : it = imap ( key , iterable ) else : it = iter ( iterable ) score , argmax = reduce ( max , izip ( it , count ( ) ) ) if both : return argmax , score return argmax", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Closure of log for zero arguments . [CODESPLIT] def _protected_log ( x1 ) : with np . errstate ( divide = 'ignore' , invalid = 'ignore' ) : return np . where ( np . abs ( x1 ) > 0.001 , np . log ( np . abs ( x1 ) ) , 0. )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calculate the moving overage over an array . [CODESPLIT] def moving_average ( arr : np . ndarray , n : int = 3 ) -> np . ndarray : ret = np . cumsum ( arr , dtype = float ) ret [ n : ] = ret [ n : ] - ret [ : - n ] return ret [ n - 1 : ] / n", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Truncates a value to a number of decimals places [CODESPLIT] def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Covert numpy array to tensorflow tensor [CODESPLIT] def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes all blank lines in @string [CODESPLIT] def remove_blank_lines ( string ) : return \"\\n\" . join ( line for line in string . split ( \"\\n\" ) if len ( line . strip ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes all non - printable characters from a text string [CODESPLIT] def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Merge two dicts and return a new dict . Much like subclassing works . [CODESPLIT] def extend ( a : dict , b : dict ) -> dict : res = a . copy ( ) res . update ( b ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the last location of the minimal value of x . The position is calculated relatively to the length of x . [CODESPLIT] def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists . [CODESPLIT] def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Closure of log for zero arguments . [CODESPLIT] def _protected_log ( x1 ) : with np . errstate ( divide = 'ignore' , invalid = 'ignore' ) : return np . where ( np . abs ( x1 ) > 0.001 , np . log ( np . abs ( x1 ) ) , 0. )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simple helper hash function [CODESPLIT] def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Is the SQLAlchemy column type a string type? [CODESPLIT] def is_sqlatype_string ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . String )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check for the presence of the given metadata item [CODESPLIT] def has_obstory_metadata ( self , status_id ) : self . con . execute ( 'SELECT 1 FROM archive_metadata WHERE publicId=%s;' , ( status_id , ) ) return len ( self . con . fetchall ( ) ) > 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check whether flyweight object with specified key has already been created . [CODESPLIT] def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of dimensions of a tensor [CODESPLIT] def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "r Return a list with all elements in seq2 removed from seq1 order preserved . [CODESPLIT] def without ( seq1 , seq2 ) : if isSet ( seq2 ) : d2 = seq2 else : d2 = set ( seq2 ) return [ elt for elt in seq1 if elt not in d2 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read 4 bytes from bytestream as an unsigned 32 - bit integer . [CODESPLIT] def read32 ( bytestream ) : dt = np . dtype ( np . uint32 ) . newbyteorder ( '>' ) return np . frombuffer ( bytestream . read ( 4 ) , dtype = dt ) [ 0 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the timeout has been reached and raise a StopIteration if so . [CODESPLIT] def _check_stream_timeout ( started , timeout ) : if timeout : elapsed = datetime . datetime . utcnow ( ) - started if elapsed . seconds > timeout : raise StopIteration", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if cnr or cns files are empty ( only have a header ) [CODESPLIT] def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes all blank lines in @string [CODESPLIT] def remove_blank_lines ( string ) : return \"\\n\" . join ( line for line in string . split ( \"\\n\" ) if len ( line . strip ( ) ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deletes all files whose filename matches the glob pattern ( via : func : glob . glob ) . [CODESPLIT] def rmglob ( pattern : str ) -> None : for f in glob . glob ( pattern ) : os . remove ( f )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The current position of the cursor . [CODESPLIT] def position ( self ) -> Position : return Position ( self . _index , self . _lineno , self . _col_offset )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes trailing zeroes from indexable collection of numbers [CODESPLIT] def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a text into a list of tokens . [CODESPLIT] def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normal cumulative density function . [CODESPLIT] def normcdf ( x , log = False ) : y = np . atleast_1d ( x ) . copy ( ) flib . normcdf ( y ) if log : if ( y > 0 ) . all ( ) : return np . log ( y ) return - np . inf return y", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Split a text into a list of tokens . [CODESPLIT] def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \\t' ) ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A non - negative integer . [CODESPLIT] def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert human readable string to datetime . datetime . [CODESPLIT] def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If string comes next return True and advance offset . [CODESPLIT] def test_string ( self , string : str ) -> bool : if self . input . startswith ( string , self . offset ) : self . offset += len ( string ) return True return False", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Exit execution with return code and message : param msg : Message displayed prior to exit : param code : code returned upon exiting [CODESPLIT] def Exit ( msg , code = 1 ) : print >> sys . stderr , msg sys . exit ( code )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Truncates a value to a number of decimals places [CODESPLIT] def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Turn a list into a comma - and / or and - separated string . [CODESPLIT] def list_to_str ( lst ) : if len ( lst ) == 1 : str_ = lst [ 0 ] elif len ( lst ) == 2 : str_ = ' and ' . join ( lst ) elif len ( lst ) > 2 : str_ = ', ' . join ( lst [ : - 1 ] ) str_ += ', and {0}' . format ( lst [ - 1 ] ) else : raise ValueError ( 'List of length 0 provided.' ) return str_", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Pull a file directly from S3 . [CODESPLIT] def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( \"s3\" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read and return a view of size bytes from memory starting at start_position . [CODESPLIT] def memory_read ( self , start_position : int , size : int ) -> memoryview : return self . _memory . read ( start_position , size )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the number of unique spanning trees of a graph using Kirchhoff s matrix tree theorem . [CODESPLIT] def spanning_tree_count ( graph : nx . Graph ) -> int : laplacian = nx . laplacian_matrix ( graph ) . toarray ( ) comatrix = laplacian [ : - 1 , : - 1 ] det = np . linalg . det ( comatrix ) count = int ( round ( det ) ) return count", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the given string converted to a string that can be used for a clean filename . Specifically leading and trailing spaces are removed ; other spaces are converted to underscores ; and anything that is not a unicode alphanumeric dash underscore or dot is removed . >>> get_valid_filename ( john s portrait in 2004 . jpg ) johns_portrait_in_2004 . jpg [CODESPLIT] def get_valid_filename ( s ) : s = s . strip ( ) . replace ( \" \" , \"_\" ) return re . sub ( r\"(?u)[^-\\w.]\" , \"\" , s )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A non - negative integer . [CODESPLIT] def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the duplicates in a list . [CODESPLIT] def find_duplicates ( l : list ) -> set : return set ( [ x for x in l if l . count ( x ) > 1 ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load JSON file [CODESPLIT] def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check to be sure values are numbers before doing numerical operations . [CODESPLIT] def _is_numeric ( self , values ) : if len ( values ) > 0 : assert isinstance ( values [ 0 ] , ( float , int ) ) , \"values must be numbers to perform math operations. Got {}\" . format ( type ( values [ 0 ] ) ) return True", "target": 1, "target_options": ["no_match", "match"]}
{"input": ">>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False [CODESPLIT] def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return true if a value is an integer number . [CODESPLIT] def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . ) [CODESPLIT] def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the keys that maps to the top n max values in the given dict . [CODESPLIT] def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts a list into a space - separated string and puts it in a dictionary [CODESPLIT] def encode_list ( key , list_ ) : # type: (str, Iterable) -> Dict[str, str] if not list_ : return { } return { key : \" \" . join ( str ( i ) for i in list_ ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fail unless first equals second as determined by the == operator . [CODESPLIT] def assert_equal ( first , second , msg_fmt = \"{msg}\" ) : if isinstance ( first , dict ) and isinstance ( second , dict ) : assert_dict_equal ( first , second , msg_fmt ) elif not first == second : msg = \"{!r} != {!r}\" . format ( first , second ) fail ( msg_fmt . format ( msg = msg , first = first , second = second ) )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add colons after every second digit . [CODESPLIT] def add_colons ( s ) : return ':' . join ( [ s [ i : i + 2 ] for i in range ( 0 , len ( s ) , 2 ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Verifies that a string path actually exists and is a file [CODESPLIT] def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( \"checking if %s is a valid file\" , path ) return path . exists ( ) and path . is_file ( )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "filter for dict note f should have signature : f :: key - > value - > bool [CODESPLIT] def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Finds the longest path in a dag between two nodes [CODESPLIT] def dag_longest_path ( graph , source , target ) : if source == target : return [ source ] allpaths = nx . all_simple_paths ( graph , source , target ) longest_path = [ ] for l in allpaths : if len ( l ) > len ( longest_path ) : longest_path = l return longest_path", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return all ( and only ) the uppercase chars in the given string . [CODESPLIT] def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Covert numpy array to tensorflow tensor [CODESPLIT] def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if the input filename with path is a file and is not empty . [CODESPLIT] def isfile_notempty ( inputfile : str ) -> bool : try : return isfile ( inputfile ) and getsize ( inputfile ) > 0 except TypeError : raise TypeError ( 'inputfile is not a valid type' )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "filter for dict note f should have signature : f :: key - > value - > bool [CODESPLIT] def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "HTTP POST operation to API endpoint . [CODESPLIT] def post ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'POST' , endpoint , * * kwargs )", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return a json array as a list [CODESPLIT] def __as_list ( value : List [ JsonObjTypes ] ) -> List [ JsonTypes ] : return [ e . _as_dict if isinstance ( e , JsonObj ) else e for e in value ]", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tries to convert a text value to a bool . If unsuccessful returns if value is None or not [CODESPLIT] def text_to_bool ( value : str ) -> bool : try : return bool ( strtobool ( value ) ) except ( ValueError , AttributeError ) : return value is not None", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Utility method to run commands synchronously for testing . [CODESPLIT] def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( \"Event loop is already running.\" ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check Environment Variable to verify that it is set and not empty . [CODESPLIT] def _check_env_var ( envvar : str ) -> bool : if os . getenv ( envvar ) is None : raise KeyError ( \"Required ENVVAR: {0} is not set\" . format ( envvar ) ) if not os . getenv ( envvar ) : # test if env var is empty raise KeyError ( \"Required ENVVAR: {0} is empty\" . format ( envvar ) ) return True", "target": 1, "target_options": ["no_match", "match"]}
