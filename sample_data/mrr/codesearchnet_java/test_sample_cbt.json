{"input": "method to inspect the cache [SEP] public static synchronized void reportCache() {\n\t\tTools.log(\"   PictureCache.reportCache: cache contains: \" \n\t\t\t+ Integer.toString( pictureCache.size() )\n\t\t\t+ \" max: \" \n\t\t\t+ Integer.toString( maxCache ) );\n\t\t//Tools.freeMem();\n\t\tEnumeration e = pictureCache.keys();\n\t\twhile ( e.hasMoreElements() ) {\n\t\t\tTools.log(\"   Cache contains: \" + ((String) e.nextElement()) );\n\t\t} \n\t\tTools.log(\"  End of cache contents\");\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Rename the GeoPackage metadata to the new name\n\n@param metadata GeoPackage metadata\n@param newName  new name\n@return renamed flag [SEP] public boolean rename(GeoPackageMetadata metadata, String newName) {\n        boolean renamed = rename(metadata.getName(), newName);\n        if (renamed) {\n            metadata.setName(newName);\n        }\n        return renamed;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Binds a name to an object, overwriting any existing binding. All intermediate contexts and the target context\n(that named by all but terminal atomic component of the name) must already exist.\n\n<p/>If the object is a DirContext, any existing attributes associated with the name are replaced with those of\nthe object. Otherwise, any existing attributes associated with the name remain unchanged.\n\n@param  name The name to bind; may not be empty.\n@param  obj  The object to bind; possibly null.\n\n@throws NamingException If the name is illegal. [SEP] public void rebind(String name, Object obj) throws NamingException\n    {\n        if (\"\".equals(name))\n        {\n            throw new InvalidNameException(\"Cannot bind empty name\");\n        }\n\n        bindings.put(name, obj);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Defines the gravity for geometry-based operations. See documentation for more details, as this option works in\nconjunction with various options in different ways.\n\n@param value\nGravity value to use, defining the coordinate system to use.\n@return Builder object for chained options setup. [SEP] public GMOperation gravity(final Gravity value) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"Gravity value must be defined\");\n        }\n        gravity(value.toString());\n        return this;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initializes the Cipher for use. [SEP] public static void initCipher(Cipher cipher, int mode, SecretKey secretKey) {\n\t\tinitCipher(cipher, mode, secretKey, null);\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create an instance using {@code gson} for conversion. Encoding to JSON and\ndecoding from JSON (when no charset is specified by a header) will use UTF-8. [SEP] @SuppressWarnings(\"ConstantConditions\") // Guarding public API nullability.\n  public static GsonConverterFactory create(Gson gson) {\n    if (gson == null) throw new NullPointerException(\"gson == null\");\n    return new GsonConverterFactory(gson);\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create an instance of {@link JAXBElement }{@code <}{@link String }{@code >}} [SEP] @XmlElementDecl(namespace = \"http://www.immoxml.de\", name = \"x_fache\")\n    public JAXBElement<String> createXFache(String value) {\n        return new JAXBElement<String>(_XFache_QNAME, String.class, null, value);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the indexed types that are currently indexed\n\n@return indexed types\n@since 2.0.0 [SEP] public List<FeatureIndexType> getIndexedTypes() {\n        List<FeatureIndexType> indexed = new ArrayList<>();\n        for (FeatureIndexType type : indexLocationQueryOrder) {\n            if (isIndexed(type)) {\n                indexed.add(type);\n            }\n        }\n        return indexed;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the currently selected Variable.\n\n@param v select this Variable, must be already in the tree. [SEP] public void setSelected( VariableIF v ) {\r\n        if (v == null) { return; }\r\n\r\n        // construct chain of variables\r\n        final List<VariableIF> vchain = new ArrayList<>();\r\n        vchain.add( v);\r\n\r\n        VariableIF vp = v;\r\n        while (vp.isMemberOfStructure()) {\r\n            vp = vp.getParentStructure();\r\n            vchain.add( 0, vp); // reverse\r\n        }\r\n\r\n        // construct chain of groups\r\n        final List<Group> gchain = new ArrayList<>();\r\n        Group gp = vp.getParentGroup();\r\n\r\n        gchain.add( gp);\r\n        while (gp.getParentGroup() != null) {\r\n            gp = gp.getParentGroup();\r\n            gchain.add( 0, gp); // reverse\r\n        }\r\n\r\n        final List<Object> pathList = new ArrayList<>();\r\n\r\n        // start at root, work down through the nested groups, if any\r\n        GroupNode gnode = (GroupNode) model.getRoot();\r\n        pathList.add( gnode);\r\n        Group parentGroup = gchain.get(0); // always the root group\r\n\r\n        for (int i=1; i < gchain.size(); i++) {\r\n            parentGroup = gchain.get(i);\r\n            gnode = gnode.findNestedGroup( parentGroup);\r\n            assert gnode != null;\r\n            pathList.add( gnode);\r\n        }\r\n\r\n        vp = vchain.get(0);\r\n        VariableNode vnode = gnode.findNestedVariable( vp);\r\n        if (vnode == null) { return; } // not found\r\n        pathList.add( vnode);\r\n\r\n        // now work down through the structure members, if any\r\n        for (int i=1; i < vchain.size(); i++) {\r\n            vp = vchain.get(i);\r\n            vnode = vnode.findNestedVariable( vp);\r\n            if (vnode == null) { return; } // not found\r\n            pathList.add(vnode);\r\n        }\r\n\r\n        // convert to TreePath, and select it\r\n        final Object[] paths = pathList.toArray();\r\n        final TreePath treePath = new TreePath(paths);\r\n        tree.setSelectionPath( treePath);\r\n        tree.scrollPathToVisible( treePath);\r\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "<p>\nReturns the method roles as a set of {@code Principal} instances. All roles specified in the method-permissions or\nvia {@code RolesAllowed} for this method are wrapped by a {@code SimplePrincipal}. If the method has been added to\nthe exclude-list or annotated with {@code DenyAll}, a NOBODY_PRINCIPAL is returned. If the method has been added\nto the unchecked list or annotated with {@code PermitAll}, an ANYBODY_PRINCIPAL is returned.\n</p>\n\n@return the constructed set of role principals. [SEP] protected Set<Principal> getMethodRolesAsPrincipals() {\n        Set<Principal> methodRoles = new HashSet<Principal>();\n        if (this.ejbMethodSecurityMetaData.isDenyAll())\n            methodRoles.add(NobodyPrincipal.NOBODY_PRINCIPAL);\n        else if (this.ejbMethodSecurityMetaData.isPermitAll())\n            methodRoles.add(AnybodyPrincipal.ANYBODY_PRINCIPAL);\n        else {\n            for (String role : this.ejbMethodSecurityMetaData.getRolesAllowed())\n                methodRoles.add(new SimplePrincipal(role));\n        }\n        return methodRoles;\n    }\n\n    /**\n     * <p>\n     * Gets the {@code MethodInterfaceType} that corresponds to the specified {@code MethodIntf}.\n     * </p>\n     *\n     * @param viewType the {@code MethodIntf} type to be converted.\n     * @return the converted type or {@code null} if the type cannot be converted.\n     */\n    protected MethodInterfaceType getMethodInterfaceType(MethodIntf viewType) {\n        switch (viewType) {\n            case HOME:\n                return MethodInterfaceType.Home;\n            case LOCAL_HOME:\n                return MethodInterfaceType.LocalHome;\n            case SERVICE_ENDPOINT:\n                return MethodInterfaceType.ServiceEndpoint;\n            case LOCAL:\n                return MethodInterfaceType.Local;\n            case REMOTE:\n                return MethodInterfaceType.Remote;\n            case TIMER:\n                return MethodInterfaceType.Timer;\n            case MESSAGE_ENDPOINT:\n                return MethodInterfaceType.MessageEndpoint;\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * <p>\n     * Sets the JACC contextID using a privileged action and returns the previousID from the {@code PolicyContext}.\n     * </p>\n     *\n     * @param contextID the JACC contextID to be set.\n     * @return the previous contextID as retrieved from the {@code PolicyContext}.\n     */\n    protected String setContextID(final String contextID) {\n        if (! WildFlySecurityManager.isChecking()) {\n            final String previousID = PolicyContext.getContextID();\n            PolicyContext.setContextID(contextID);\n            return previousID;\n        } else {\n            final PrivilegedAction<String> action = new SetContextIDAction(contextID);\n            return AccessController.doPrivileged(action);\n        }\n    }\n\n    /**\n     * PrivilegedAction that sets the {@code PolicyContext} id.\n     */\n    private static class SetContextIDAction implements PrivilegedAction<String> {\n\n        private String contextID;\n\n        SetContextIDAction(final String contextID) {\n            this.contextID = contextID;\n        }\n\n        @Override\n        public String run() {\n            final String previousID = PolicyContext.getContextID();\n            PolicyContext.setContextID(this.contextID);\n            return previousID;\n        }\n    }\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a new {@link LinkedBlockingDeque} with the given {@code capacity}.\nIn case the given capacity is smaller than one it will automatically be\nconverted to one.\n\n@param capacity the capacity to use for the queue\n@param <E> the type of elements held in the queue\n@return a new instance of {@link ArrayBlockingQueue} [SEP] public <E> LinkedBlockingDeque<E> newLinkedBlockingDeque(int capacity) {\n    final int actualCapacity = capacity < 1 ? 1 : capacity;\n    return new LinkedBlockingDeque<E>(actualCapacity);\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create an instance of {@link JAXBElement }{@code <}{@link String }{@code >}} [SEP] @XmlElementDecl(namespace = \"\", name = \"bundesland\")\n    public JAXBElement<String> createBundesland(String value) {\n        return new JAXBElement<String>(_Bundesland_QNAME, String.class, null, value);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Binds request data to this form - that is, handles form submission.\n\n@param request the request to bind data from.\n@param allowedFields the fields that should be bound to the form, all fields if not specified.\n@return a copy of this form filled with the new data [SEP] public Form<T> bindFromRequest(Http.Request request, String... allowedFields) {\n    return bind(\n        this.messagesApi.preferred(request).lang(),\n        request.attrs(),\n        requestData(request),\n        requestFileData(request),\n        allowedFields);\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Safe {@code charAt} that returns 0 when ndx is out of boundaries. [SEP] private static char charAt(final String string, final int ndx) {\n\t\tif (ndx >= string.length()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn string.charAt(ndx);\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Initialize the scheme for this URI from a URI string spec.\n\n@param p_uriSpec the URI specification (cannot be null)\n\n@exception MalformedURIException if URI does not have a conformant\nscheme [SEP] private void initializeScheme(String p_uriSpec)\r\n\t\tthrows MalformedURIException {\r\n\t\tint uriSpecLen = p_uriSpec.length();\r\n\t\tint index = p_uriSpec.indexOf(':');\r\n\r\n\t\tif (index < 1)\r\n\t\t\tthrow new MalformedURIException(\"No scheme found in URI.\");\r\n\r\n\t\tif (index == uriSpecLen - 1)\r\n\t\t\tthrow new MalformedURIException(\"A bare scheme name is not a URI.\");\r\n\r\n\t\tsetScheme(p_uriSpec.substring(0, index));\r\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Escapes HTML Special characters present in the string.\n@param string\n@return HTML Escaped String representation [SEP] public static String escapeHTML(String string) {\n        if(string == null) {\n            return null;\n        }\n        StringBuilder sb = new StringBuilder();\n        boolean lastCharacterWasSpace = false;\n        char[] chars = string.toCharArray();\n        for(char c : chars) {\n            if(c == ' ') {\n                if(lastCharacterWasSpace){\n                    lastCharacterWasSpace = false;\n                    sb.append(\"&nbsp;\");\n                }else {\n                    lastCharacterWasSpace=true;\n                    sb.append(\" \");\n                }\n            }else {\n                lastCharacterWasSpace = false;\n                switch(c) {\n                    case '<': sb.append(\"&lt;\"); break;\n                    case '>': sb.append(\"&gt;\"); break;\n                    case '&': sb.append(\"&amp;\"); break;\n                    case '\"': sb.append(\"&quot;\"); break;\n                    default : sb.append(c);break;\n                }\n            }\n        }\n\n        return sb.toString();\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get the coverage data tile results by zooming in from the provided tile\nmatrix\n\n@param requestProjectedBoundingBox request projected bounding box\n@param tileMatrix                  tile matrix\n@param overlappingPixels           overlapping request pixels\n@return tile matrix results [SEP] private CoverageDataTileMatrixResults getResultsZoomIn(\n            BoundingBox requestProjectedBoundingBox, TileMatrix tileMatrix,\n            int overlappingPixels) {\n\n        CoverageDataTileMatrixResults results = null;\n        for (long zoomLevel = tileMatrix.getZoomLevel() + 1; zoomLevel <= tileDao\n                .getMaxZoom(); zoomLevel++) {\n            TileMatrix zoomTileMatrix = tileDao.getTileMatrix(zoomLevel);\n            if (zoomTileMatrix != null) {\n                results = getResults(requestProjectedBoundingBox,\n                        zoomTileMatrix, overlappingPixels);\n                if (results != null) {\n                    break;\n                }\n            }\n        }\n        return results;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns different name of a property if set by annotation. [SEP] public String resolveJsonName(final Class type, final String name) {\n\t\tTypeData typeData = lookupTypeData(type);\n\n\t\treturn typeData.resolveJsonName(name);\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prepares parameters for further processing.\n@param paramValues\tstring array of param values\n@param treatEmptyParamsAsNull\tempty parameters should be treated as <code>null</code>\n@param ignoreEmptyRequestParams\tif all parameters are empty, return <code>null</code> [SEP] public static String[] prepareParameters(\n\t\tfinal String[] paramValues,\n\t\tfinal boolean treatEmptyParamsAsNull,\n\t\tfinal boolean ignoreEmptyRequestParams) {\n\n\t\tif (treatEmptyParamsAsNull || ignoreEmptyRequestParams) {\n\t\t\tint emptyCount = 0;\n\t\t\tint total = paramValues.length;\n\t\t\tfor (int i = 0; i < paramValues.length; i++) {\n\t\t\t\tString paramValue = paramValues[i];\n\t\t\t\tif (paramValue == null) {\n\t\t\t\t\temptyCount++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (paramValue.length() == 0) {\n\t\t\t\t\temptyCount++;\n\t\t\t\t\tif (treatEmptyParamsAsNull) {\n\t\t\t\t\t\tparamValue = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tparamValues[i] = paramValue;\n\t\t\t}\n\t\t\tif ((ignoreEmptyRequestParams) && (emptyCount == total)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn paramValues;\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Collects the attributes of this method into the given set of attribute prototypes.\n\n@param attributePrototypes a set of attribute prototypes. [SEP] final void collectAttributePrototypes(final Attribute.Set attributePrototypes) {\n    attributePrototypes.addAttributes(firstAttribute);\n    attributePrototypes.addAttributes(firstCodeAttribute);\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "/* (non-Javadoc)\n@see org.eclipse.gef.commands.Command#canExecute() [SEP] public boolean canExecute() {\n        Object type = request.getType();\n        return (RequestConstants.REQ_MOVE.equals( type ) || RequestConstants.REQ_MOVE_CHILDREN.equals( type ));\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a Flowable that mirrors the source Publisher, except that it drops items emitted by the\nsource Publisher that are followed by newer items before a timeout value expires on a specified\nScheduler. The timer resets on each emission.\n<p>\n<em>Note:</em> If items keep being emitted by the source Publisher faster than the timeout then no items\nwill be emitted by the resulting Publisher.\n<p>\n<img width=\"640\" height=\"310\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/debounce.s.png\" alt=\"\">\n<p>\nDelivery of the item after the grace period happens on the given {@code Scheduler}'s\n{@code Worker} which if takes too long, a newer item may arrive from the upstream, causing the\n{@code Worker}'s task to get disposed, which may also interrupt any downstream blocking operation\n(yielding an {@code InterruptedException}). It is recommended processing items\nthat may take long time to be moved to another thread via {@link #observeOn} applied after\n{@code debounce} itself.\n<dl>\n<dt><b>Backpressure:</b></dt>\n<dd>This operator does not support backpressure as it uses time to control data flow.</dd>\n<dt><b>Scheduler:</b></dt>\n<dd>You specify which {@link Scheduler} this operator will use.</dd>\n</dl>\n\n@param timeout\nthe time each item has to be \"the most recent\" of those emitted by the source Publisher to\nensure that it's not dropped\n@param unit\nthe unit of time for the specified {@code timeout}\n@param scheduler\nthe {@link Scheduler} to use internally to manage the timers that handle the timeout for each\nitem\n@return a Flowable that filters out items from the source Publisher that are too quickly followed by\nnewer items\n@see <a href=\"http://reactivex.io/documentation/operators/debounce.html\">ReactiveX operators documentation: Debounce</a>\n@see <a href=\"https://github.com/ReactiveX/RxJava/wiki/Backpressure\">RxJava wiki: Backpressure</a>\n@see #throttleWithTimeout(long, TimeUnit, Scheduler) [SEP] @CheckReturnValue\n    @NonNull\n    @BackpressureSupport(BackpressureKind.ERROR)\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public final Flowable<T> debounce(long timeout, TimeUnit unit, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaPlugins.onAssembly(new FlowableDebounceTimed<T>(this, timeout, unit, scheduler));\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Divide two complex numbers, in-place\n\n@param c\n@param result [SEP] @Override\n    public IComplexNumber divi(IComplexNumber c, IComplexNumber result) {\n        float d = c.realComponent().floatValue() * c.realComponent().floatValue()\n                        + c.imaginaryComponent().floatValue() * c.imaginaryComponent().floatValue();\n        float newR = (realComponent() * c.realComponent().floatValue()\n                        + imaginaryComponent() * c.imaginaryComponent().floatValue()) / d;\n        float newI = (imaginaryComponent() * c.realComponent().floatValue()\n                        - realComponent() * c.imaginaryComponent().floatValue()) / d;\n        return result.set(newR, newI);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "call this method if the trackInfo object in the playlist was updated. Only the trackinfo object will be sent via\nEvent\n@param playlist the playlist\n@param info the new trackInfo object [SEP] @SuppressWarnings(\"unused\")\n    public void trackInfoUpdate(Playlist playlist, TrackInfo info) {\n        this.playlist = playlist;\n        updatePlayInfo(info);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set the data values from a list of Strings.\n\n@param v      for this variable\n@param values list of Strings\n@throws IllegalArgumentException if values array not correct size, or values wont parse to the correct type\n@deprecated use Variable.setValues() [SEP] public void setValues(Variable v, List<String> values) throws IllegalArgumentException {\n    Array data = Array.makeArray(v.getDataType(), values);\n\n    if (data.getSize() != v.getSize())\n      throw new IllegalArgumentException(\"Incorrect number of values specified for the Variable \" + v.getFullName() +\n              \" needed= \" + v.getSize() + \" given=\" + data.getSize());\n\n    if (v.getRank() != 1) // dont have to reshape for rank 1\n      data = data.reshape(v.getShape());\n\n    v.setCachedData(data, true);\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Write a raw string.\n\n@param s\n@throws org.xml.sax.SAXException If there is an error writing the string, this method will\nthrow an IOException wrapped in a SAXException [SEP] private void write(String s) throws SAXException {\n        try {\n            output.write(s);\n        } catch (IOException e) {\n            throw new SAXException(e);\n        }\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "{@inheritDoc} [SEP] public boolean proofStep(ResolutionState state)\n    {\n        Functor goalTerm = state.getGoalStack().peek().getFunctor();\n        Functor matchTerm = state.getCurrentClause().getHead();\n\n        // This is used to record variables bound on the domain side of the unificiation. This information seems\n        // like is does not need to be kept because usually all of these bindings are in the stack frame.\n        // However, this is not always the case as unification can capture a variable on the domain side.\n        // These variables need to be unbound on backtracking too.\n        List<Variable> domainVariables = new LinkedList<Variable>();\n\n        // This is used to record variables bound on the query goal side of the unification. This information\n        // must be kept so that the undo operation can unbind these variables before placing the goal back\n        // onto the stack when backtracking.\n        List<Variable> boundVariables = new LinkedList<Variable>();\n\n        // Unify the current query goal with the possibly matching clause, creating variable bindings.\n        boolean matched = state.getUnifier().unifyInternal(goalTerm, matchTerm, boundVariables, domainVariables);\n\n        // Even if unification fails, any partial bindings created are remembered, to ensure that they are cleaned\n        // up when this proof steps state is undone.\n        for (Variable binding : boundVariables)\n        {\n            state.getVariableBindings().offer(binding);\n        }\n\n        for (Variable binding : domainVariables)\n        {\n            state.getVariableBindings().offer(binding);\n        }\n\n        // If the unification succeeded, establish a new state with the unified query removed from the goal stack, the\n        // body of the unified with clause added to it for resolution, and the variable binding trail extended with\n        // any additional bindings resulting from the unification.\n        if (matched)\n        {\n            if (TRACE)\n            {\n                /*trace.fine(state.getTraceIndenter().generateTraceIndent() + \"Unify \" +\n                    goalTerm.toString(state.getInterner(), true, true) + \" against \" +\n                    matchTerm.toString(state.getInterner(), true, true) + \", ok.\");*/\n            }\n\n            // Consume the successfully unified goal from the goal stack.\n            state.getGoalStack().poll();\n\n            // Add all functors on the body side of the unified clause onto the goal stack for resolution.\n            Functor[] body = state.getCurrentClause().getBody();\n\n            if ((body != null) && (body.length != 0))\n            {\n                // The new goals are placed onto the goal stack backwards. It is a stack, hence they get\n                // explored first, depth first, but their insertion order is reversed for an intuitive\n                // left-to-right evaluation order.\n                for (int i = body.length - 1; i >= 0; i--)\n                {\n                    BuiltInFunctor newGoal = state.getBuiltInTransform().apply(body[i]);\n                    newGoal.setParentChoicePointState(state.getLastChoicePoint());\n                    state.getGoalStack().offer(newGoal);\n                }\n            }\n\n            return true;\n        }\n        else\n        {\n            if (TRACE)\n            {\n                /*trace.fine(state.getTraceIndenter().generateTraceIndent() + \"Failed to unify \" +\n                    goalTerm.toString(state.getInterner(), true, true) + \" against \" +\n                    matchTerm.toString(state.getInterner(), true, true) + \".\");*/\n            }\n\n            return false;\n        }\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a new value to the list but don't employ a wrapper.\n\n@param integer new value\n@return was able to add. [SEP] public FloatList add(float integer) {\n        if (end + 1 >= values.length) {\n            values = grow(values);\n        }\n        values[end] = integer;\n        end++;\n        return this;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calls the shared consumer with the error sent via onError for each\nMaybeObserver that subscribes to the current Maybe.\n<p>\n<img width=\"640\" height=\"358\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnError.m.png\" alt=\"\">\n<dl>\n<dt><b>Scheduler:</b></dt>\n<dd>{@code doOnError} does not operate by default on a particular {@link Scheduler}.</dd>\n</dl>\n@param onError the consumer called with the success value of onError\n@return the new Maybe instance [SEP] @CheckReturnValue\n    @NonNull\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Maybe<T> doOnError(Consumer<? super Throwable> onError) {\n        return RxJavaPlugins.onAssembly(new MaybePeek<T>(this,\n                Functions.emptyConsumer(), // onSubscribe\n                Functions.emptyConsumer(), // onSuccess\n                ObjectHelper.requireNonNull(onError, \"onError is null\"),\n                Functions.EMPTY_ACTION,    // onComplete\n                Functions.EMPTY_ACTION,    // (onSuccess | onError | onComplete)\n                Functions.EMPTY_ACTION     // dispose\n        ));\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns either new {@link FileInputStream} or new {@link UnicodeInputStream}.\n\n@return either {@link FileInputStream} or {@link UnicodeInputStream}.\n@throws IOException if something went wrong.\n@see #unicodeInputStreamOf(InputStream, String) [SEP] private static InputStream streamOf(final File file, final String encoding) throws IOException {\n\t\tInputStream in = new FileInputStream(file);\n\t\tif (encoding.startsWith(\"UTF\")) {\n\t\t\tin = unicodeInputStreamOf(in, encoding);\n\t\t}\n\t\treturn in;\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "/*\nCursor wrapper methods which bind to primitive type columns\nand return the corresponding wrapper type which may be null [SEP] protected byte[] getBlobOrNull(Cursor c, int col) {\n\t\treturn c.isNull(col) ? null : c.getBlob(col);\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parse properties instead of String arguments.  Any additional arguments need to be passed some other way.\nThis is often used in a second pass when the property filename is passed on the command line.  Because of\nrequired properties you must be careful to set them all in the property file.\n\n@param target    Either an instance or a class\n@param arguments The properties that contain the arguments [SEP] public static void parse(Object target, Properties arguments) {\n        Class clazz;\n        if (target instanceof Class) {\n            clazz = (Class) target;\n        } else {\n            clazz = target.getClass();\n        }\n        for (Field field : clazz.getDeclaredFields()) {\n            processField(target, field, arguments);\n        }\n        try {\n            BeanInfo info = Introspector.getBeanInfo(clazz);\n            for (PropertyDescriptor pd : info.getPropertyDescriptors()) {\n                processProperty(target, pd, arguments);\n            }\n        } catch (IntrospectionException e) {\n            // If its not a JavaBean we ignore it\n        }\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "designed to be lightweight operation [SEP] private User findById(Long id) {\n    if (id > 3) return null;\n    User user = new User();\n    user.id = id;\n    user.name = \"User \" + String.valueOf(id);\n    return user;\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Detects the longest character reference name on given position in char array. [SEP] public static String detectName(final char[] input, int ndx) {\n\t\tfinal Ptr ptr = new Ptr();\n\n\t\tint firstIndex = 0;\n\t\tint lastIndex = ENTITY_NAMES.length - 1;\n\t\tint len = input.length;\n\t\tchar[] lastName = null;\n\n\t\tfinal BinarySearchBase binarySearch = new BinarySearchBase() {\n\t\t\t@Override\n\t\t\tprotected int compare(final int index) {\n\t\t\t\tchar[] name = ENTITY_NAMES[index];\n\n\t\t\t\tif (ptr.offset >= name.length) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\treturn name[ptr.offset] - ptr.c;\n\t\t\t}\n\t\t};\n\n\t\twhile (true) {\n\t\t\tptr.c = input[ndx];\n\n\t\t\tif (!CharUtil.isAlphaOrDigit(ptr.c)) {\n\t\t\t\treturn lastName != null ? new String(lastName) : null;\n\t\t\t}\n\n\t\t\tfirstIndex = binarySearch.findFirst(firstIndex, lastIndex);\n\t\t\tif (firstIndex < 0) {\n\t\t\t\treturn lastName != null ? new String(lastName) : null;\n\t\t\t}\n\n\t\t\tchar[] element = ENTITY_NAMES[firstIndex];\n\n\t\t\tif (element.length == ptr.offset + 1) {\n\t\t\t\t// total match, remember position, continue for finding the longer name\n\t\t\t\tlastName = ENTITY_NAMES[firstIndex];\n\t\t\t}\n\n\t\t\tlastIndex = binarySearch.findLast(firstIndex, lastIndex);\n\n\t\t\tif (firstIndex == lastIndex) {\n\t\t\t\t// only one element found, check the rest\n\t\t\t\tfor (int i = ptr.offset; i < element.length; i++) {\n\t\t\t\t\tif (element[i] != input[ndx]) {\n\t\t\t\t\t\treturn lastName != null ? new String(lastName) : null;\n\t\t\t\t\t}\n\t\t\t\t\tndx++;\n\t\t\t\t}\n\t\t\t\treturn new String(element);\n\t\t\t}\n\n\t\t\tptr.offset++;\n\n\t\t\tndx++;\n\t\t\tif (ndx == len) {\n\t\t\t\treturn lastName != null ? new String(lastName) : null;\n\t\t\t}\n\t\t}\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "ArtifactId is used for setting a resource name (service, pod,...) in Kubernetes resource.\nThe problem is that a Kubernetes resource name must start by a char.\nThis method returns a valid string to be used as Kubernetes name.\n@return Sanitized Kubernetes name. [SEP] public String getSanitizedArtifactId() {\n        if (this.artifactId != null && !this.artifactId.isEmpty() && Character.isDigit(this.artifactId.charAt(0))) {\n            return PREFIX + this.artifactId;\n        }\n\n        return this.artifactId;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets value for placeholder defined in query. Placeholder name should\nnot start with <b>:</b>, it is stripped off. Based on passed object type,\nappropriate JDBC type is chosen.\n\n@see org.polyjdbc.core.type.ColumnTypeMapper [SEP] public UpdateQuery withArgument(String argumentName, Object object) {\n        query.setArgument(argumentName, object);\n        return this;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a channel provider shared by each subscriber. It is basically the default ChannelProvider with the\nexception that it can be configured with a custom endpoint, for example when running against the PubSub Emulator.\n\n@return channel provider based on the stage configuration. [SEP] private InstantiatingGrpcChannelProvider getChannelProvider() {\n    return SubscriptionAdminSettings\n        .defaultGrpcTransportProviderBuilder()\n        .setMaxInboundMessageSize(MAX_INBOUND_MESSAGE_SIZE)\n        .setEndpoint(Strings.isNullOrEmpty(conf.advanced.customEndpoint) ? SubscriptionAdminSettings\n            .getDefaultEndpoint() : conf.advanced.customEndpoint)\n        .build();\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Cuts prefix if exists. [SEP] public static String cutPrefix(String string, final String prefix) {\n\t\tif (string.startsWith(prefix)) {\n\t\t\tstring = string.substring(prefix.length());\n\t\t}\n\t\treturn string;\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Modifies the source {@code Publisher} so that it invokes the given action when it is subscribed from\nits subscribers. Each subscription will result in an invocation of the given action except when the\nsource {@code Publisher} is reference counted, in which case the source {@code Publisher} will invoke\nthe given action for the first subscription.\n<p>\n<img width=\"640\" height=\"390\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnSubscribe.png\" alt=\"\">\n<dl>\n<dt><b>Backpressure:</b></dt>\n<dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s\nbackpressure behavior.</dd>\n<dt><b>Scheduler:</b></dt>\n<dd>{@code doOnSubscribe} does not operate by default on a particular {@link Scheduler}.</dd>\n</dl>\n\n@param onSubscribe\nthe Consumer that gets called when a Subscriber subscribes to the current {@code Flowable}\n@return the source {@code Publisher} modified so as to call this Consumer when appropriate\n@see <a href=\"http://reactivex.io/documentation/operators/do.html\">ReactiveX operators documentation: Do</a> [SEP] @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.PASS_THROUGH)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> doOnSubscribe(Consumer<? super Subscription> onSubscribe) {\n        return doOnLifecycle(onSubscribe, Functions.EMPTY_LONG_CONSUMER, Functions.EMPTY_ACTION);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "For a JMX MBean idenfitied by an ObjectName, copy the values of the given attributes into the target object\nusing the specified setter methods mapped by attribute name.\n\n@param target object into which values are injected.\n@param jmxAttributeValues values of the attributes to inject.\n@param attributeSetters map of attribute name to setter used to determine how to inject each attribute's value.\n@param objectName name of the MBean involved - used only for logging. [SEP] public void copyOutAttributes(Object target, List<Attribute> jmxAttributeValues,\n                                  Map<String, Method> attributeSetters, ObjectName objectName) {\n\n        this.copyOutAttributes(target, jmxAttributeValues, attributeSetters, \"oname\", objectName);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds object instance to the container as singleton bean. [SEP] public void addBean(final String name, final Object bean, WiringMode wiringMode) {\n\t\twiringMode = petiteConfig.resolveWiringMode(wiringMode);\n\t\tregisterPetiteBean(bean.getClass(), name, SingletonScope.class, wiringMode, false, null);\n\t\tBeanDefinition def = lookupExistingBeanDefinition(name);\n\t\tregisterBeanAndWireAndInjectParamsAndInvokeInitMethods(new BeanData(this, def, bean));\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a {@link HollowTypeStateListener} to this type.\n@param listener the listener to add [SEP] public void addListener(HollowTypeStateListener listener) {\n        HollowTypeStateListener[] newListeners = Arrays.copyOf(stateListeners, stateListeners.length + 1);\n        newListeners[newListeners.length - 1] = listener;\n        stateListeners = newListeners;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Given a DAP (attribute) string, insert backslashes\nbefore '\"' and '/' characters. This code also escapes\ncontrol characters, although the spec does not call for it;\nmake that code conditional. [SEP] static public String backslashEscapeDapString(String s) {\n    StringBuilder buf = new StringBuilder();\n    for(int i=0;i<s.length();i++) {\n\tint c = s.charAt(i);\n        if(true) {\n            if(c < ' ') {\n                switch (c) {\n                case '\\n': case '\\r': case '\\t': case '\\f':\n                    buf.append((char)c);\n                    break;\n                default:\n                    buf.append(String.format(\"\\\\x%02x\",(c&0xff)));\n                    break;\n                }\n                continue;\n            }\n        }\n        if(c == '\"') {\n            buf.append(\"\\\\\\\"\");\n        } else if(c == '\\\\') {\n            buf.append(\"\\\\\\\\\");\n        } else\n            buf.append((char)c);\n    }\n    return buf.toString();\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Deregisters JMX bean for current manager.\n\n@param storageName Name of storage of given manager\n@param storageId   Id of storage of given manager\n\n@see OStorage#getName()\n@see OIdentifiableStorage#getId() [SEP] public void unregisterMBean(String storageName, int storageId) {\n    if (storageName == null) {\n      OLogManager.instance().warnNoDb(this, \"Can not unregister MBean for performance statistics, storage name is null\");\n    }\n    if (mbeanIsRegistered.compareAndSet(true, false)) {\n      try {\n        final MBeanServer server = ManagementFactory.getPlatformMBeanServer();\n        final ObjectName mbeanName = new ObjectName(getMBeanName(storageName, storageId));\n        server.unregisterMBean(mbeanName);\n      } catch (MalformedObjectNameException | InstanceNotFoundException | MBeanRegistrationException e) {\n        throw OException.wrapException(new OStorageException(\"Error during unregistration of profiler MBean\"), e);\n      }\n    }\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "/*\nCheck if file has changed, and reread metadata if needed.\nAll previous object references (variables, dimensions, etc) may become invalid - you must re-obtain.\nDO NOT USE THIS ROUTINE YET - NOT FULLY TESTED\n\n@return true if file was changed.\n@throws IOException if error\n\npublic boolean sync() throws IOException {\nunlocked = false;\nreturn (spi != null) && spi.sync();\n} [SEP] @Override\n  public long getLastModified() {\n    if (spi != null && spi instanceof AbstractIOServiceProvider) {\n      AbstractIOServiceProvider aspi = (AbstractIOServiceProvider) spi;\n      return aspi.getLastModified();\n    }\n    return 0;\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Helper method for setting properties.\n\n@param  propname The name of the system property to set.\n@param  value    The value to set it to.\n\n@return The value of the property after this method call. [SEP] public float setProperty(String propname, float value)\n    {\n        setProperty(propname, Float.toString(value));\n\n        return value;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If the argument is a primitive class, replaces the object\non the top of the stack with the unwrapped (primitive)\nequivalent. For example, Character -> char.\n@param type the class indicating the desired type of the top stack value\n@return true if the value was unboxed [SEP] public void unbox(Type type) {\n        Type t = Constants.TYPE_NUMBER;\n        Signature sig = null;\n        switch (type.getSort()) {\n        case Type.VOID:\n            return;\n        case Type.CHAR:\n            t = Constants.TYPE_CHARACTER;\n            sig = CHAR_VALUE;\n            break;\n        case Type.BOOLEAN:\n            t = Constants.TYPE_BOOLEAN;\n            sig = BOOLEAN_VALUE;\n            break;\n        case Type.DOUBLE:\n            sig = DOUBLE_VALUE;\n            break;\n        case Type.FLOAT:\n            sig = FLOAT_VALUE;\n            break;\n        case Type.LONG:\n            sig = LONG_VALUE;\n            break;\n        case Type.INT:\n        case Type.SHORT:\n        case Type.BYTE:\n            sig = INT_VALUE;\n        }\n\n        if (sig == null) {\n            checkcast(type);\n        } else {\n            checkcast(t);\n            invoke_virtual(t, sig);\n        }\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets the value of the anhang property.\n\n<p>\nThis accessor method returns a reference to the live list,\nnot a snapshot. Therefore any modification you make to the\nreturned list will be present inside the JAXB object.\nThis is why there is not a <CODE>set</CODE> method for the anhang property.\n\n<p>\nFor example, to add a new item, do as follows:\n<pre>\ngetAnhang().add(newItem);\n</pre>\n\n\n<p>\nObjects of the following type(s) are allowed in the list\n{@link Anhang } [SEP] @Generated(value = \"com.sun.tools.xjc.Driver\", date = \"2018-10-12T02:50:55+02:00\", comments = \"JAXB RI v2.2.11\")\n    public List<Anhang> getAnhang() {\n        if (anhang == null) {\n            anhang = new ArrayList<Anhang>();\n        }\n        return this.anhang;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "returns true if the query is minimal, ie. no WHERE condition, no SKIP/LIMIT, no UNWIND, no GROUP/ORDER BY, no LET\n\n@return [SEP] private boolean isMinimalQuery(QueryPlanningInfo info) {\n    return info.projectionAfterOrderBy == null && info.globalLetClause == null && info.perRecordLetClause == null\n        && info.whereClause == null && info.flattenedWhereClause == null && info.groupBy == null && info.orderBy == null\n        && info.unwind == null && info.skip == null;\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "/* (non-Javadoc)\n@see javax.validation.ConstraintValidator#isValid(java.lang.Object, javax.validation.ConstraintValidatorContext) [SEP] @Override\n\tpublic boolean isValid(NcssPointParamsBean params, ConstraintValidatorContext constraintValidatorContext) {\n\n\t\tconstraintValidatorContext.disableDefaultConstraintViolation();\n\t\tboolean isValid =true;\n\n    boolean isStnRequest =  params.hasLatLonPoint() && params.hasStations();\n    boolean isPointRequest =  params.hasLatLonPoint() && !params.hasStations();\n\n\t\t// if no stn param is provided ignore all the others, it must be a point request\n\t\t// if stn == all --> all stations\t\t\n\t\tif( !isStnRequest && !isPointRequest ){\n\t\t\t\tisValid = false;\n\t\t\t\tconstraintValidatorContext\n\t\t\t\t.buildConstraintViolationWithTemplate(\"{thredds.server.ncSubset.validation.lat_or_lon_missing}\")\n\t\t\t\t.addConstraintViolation();\t\t\t\t\n\t\t}\n\t\t\n\t\t/* if( params.getSubset() != null && !params.getSubset().equals(\"stns\") && !params.getSubset().equals(\"all\") && !params.getSubset().equals(\"bb\")  ){\n\t\t\tisValid = false;\n\t\t\tconstraintValidatorContext\n\t\t\t.buildConstraintViolationWithTemplate(\"{thredds.server.ncSubset.validation.subsettypeerror}\")\n\t\t\t.addConstraintViolation();\t\t\t\n\t\t}\t\t\n\t\t\n\t\tif( params.getSubset() != null && params.getSubset().equals(\"stns\") && params.getStns() == null ){\n\t\t\tisValid = false;\n\t\t\tconstraintValidatorContext\n\t\t\t.buildConstraintViolationWithTemplate(\"{thredds.server.ncSubset.validation.subsettypeerror.no_stns_param}\")\n\t\t\t.addConstraintViolation();\t\t\t\n\t\t}\n\t\t\n\t\tif( params.getSubset() != null && params.getSubset().equals(\"bb\") && (params.getNorth()  == null || params.getSouth() == null || params.getEast() == null || params.getWest() == null  )){\n\t\t\tisValid = false;\n\t\t\tconstraintValidatorContext\n\t\t\t.buildConstraintViolationWithTemplate(\"{thredds.server.ncSubset.validation.subsettypeerror.no_bounding_box}\")\n\t\t\t.addConstraintViolation();\t\t\t\n\t\t}\t\t*/\n\t\t\n\t\t\n\t\treturn isValid;\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Use factory to obtain a EsriShapefileRenderer.  This caches the EsriShapefile for reuse.\n<p/>\nImplementation note: should switch to weak references. [SEP] static public EsriShapefileRenderer factory(String filename) {\r\n    if (sfileHash == null)\r\n      sfileHash = new HashMap<String, EsriShapefileRenderer>();\r\n\r\n    if (sfileHash.containsKey(filename))\r\n      return sfileHash.get(filename);\r\n\r\n    try {\r\n      EsriShapefileRenderer sfile = new EsriShapefileRenderer(filename);\r\n      sfileHash.put(filename, sfile);\r\n      return sfile;\r\n    } catch (Exception ex) {\r\n      //System.err.println(\"EsriShapefileRenderer failed on \" + filename + \"\\n\" + ex);\r\n      //ex.printStackTrace();\r\n      return null;\r\n    }\r\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "/*\nAllBody ::=       ( '<%--'              JSPCommentBody     )\n| ( '<%@'               DirectiveBody      )\n| ( '<jsp:directive.'   XMLDirectiveBody   )\n| ( '<%!'               DeclarationBody    )\n| ( '<jsp:declaration'  XMLDeclarationBody )\n| ( '<%='               ExpressionBody     )\n| ( '<jsp:expression'   XMLExpressionBody  )\n| ( '${'                ELExpressionBody   )\n| ( '<%'                ScriptletBody      )\n| ( '<jsp:scriptlet'    XMLScriptletBody   )\n| ( '<jsp:text'         XMLTemplateText    )\n| ( '<jsp:'             StandardAction     )\n| ( '<'                 CustomAction\nCustomActionBody   )\n| TemplateText [SEP] private void parseElements(Node parent) \n        throws JasperException \n    {\n        if( scriptlessCount > 0 ) {\n            // vc: ScriptlessBody\n            // We must follow the ScriptlessBody production if one of\n            // our parents is ScriptlessBody.\n            parseElementsScriptless( parent );\n            return;\n        }\n        \n\tstart = reader.mark();\n\tif (reader.matches(\"<%--\")) {\n\t    parseComment(parent);\n\t} else if (reader.matches(\"<%@\")) {\n\t    parseDirective(parent);\n        } else if (reader.matches(\"<jsp:directive.\")) {\n            parseXMLDirective(parent);\n\t} else if (reader.matches(\"<%!\")) {\n\t    parseDeclaration(parent);\n        } else if (reader.matches(\"<jsp:declaration\")) {\n            parseXMLDeclaration(parent);\n        } else if (reader.matches(\"<%=\")) {\n            parseExpression(parent);\n        } else if (reader.matches(\"<jsp:expression\")) {\n            parseXMLExpression(parent);\n\t} else if (reader.matches(\"<%\")) {\n\t    parseScriptlet(parent);\n        } else if (reader.matches(\"<jsp:scriptlet\")) {\n            parseXMLScriptlet(parent);\n        } else if (reader.matches(\"<jsp:text\")) {\n            parseXMLTemplateText(parent);\n        } else if (reader.matches(\"${\")) {\n            parseELExpression(parent, \"${\");\n        } else if (reader.matches(\"#{\")) {\n            parseELExpression(parent, \"#{\");\n\t} else if (reader.matches(\"<jsp:\")) {\n\t    parseStandardAction(parent);\n\t} else if (!parseCustomTag(parent)) {\n            checkUnbalancedEndTag();\n            parseTemplateText(parent);\n\t}\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "obtain methods list of specified class If recursively is true, obtain\nmethods from all class hierarchy\n\n@param clazz class\nwhere fields are searching\n@param recursively\nparam\n@return array of methods [SEP] public static Method[] getDeclaredMethods(Class<?> clazz,\n\t\t\tboolean recursively) {\n\t\tList<Method> methods = new LinkedList<Method>();\n\t\tMethod[] declaredMethods = clazz.getDeclaredMethods();\n\t\tCollections.addAll(methods, declaredMethods);\n\n\t\tClass<?> superClass = clazz.getSuperclass();\n\n\t\tif (superClass != null && recursively) {\n\t\t\tMethod[] declaredMethodsOfSuper = getDeclaredMethods(superClass,\n\t\t\t\t\ttrue);\n\t\t\tif (declaredMethodsOfSuper.length > 0)\n\t\t\t\tCollections.addAll(methods, declaredMethodsOfSuper);\n\t\t}\n\t\treturn methods.toArray(new Method[methods.size()]);\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Triggers the WS deployment aspects, which process the deployment and\ninstall the endpoint services.\n\n@param target\n@param unit [SEP] protected void doDeploy(ServiceTarget target, DeploymentUnit unit) {\n        List<DeploymentAspect> aspects = getDeploymentAspects();\n        ClassLoader origClassLoader = WildFlySecurityManager.getCurrentContextClassLoaderPrivileged();\n        Deployment dep = null;\n        try {\n            WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(ClassLoaderProvider.getDefaultProvider().getServerIntegrationClassLoader());\n            dep = unit.getAttachment(WSAttachmentKeys.DEPLOYMENT_KEY);\n            dep.addAttachment(ServiceTarget.class, target);\n            DeploymentAspectManager dam = new DeploymentAspectManagerImpl();\n            dam.setDeploymentAspects(aspects);\n            dam.deploy(dep);\n        } finally {\n            if (dep != null) {\n                dep.removeAttachment(ServiceTarget.class);\n            }\n            WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(origClassLoader);\n        }\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns raw class for given <code>type</code> when implementation class is known\nand it makes difference.\n\n@param type - given type\n@param implClass - implementation clas\n@return raw class\n@see #resolveVariable(java.lang.reflect.TypeVariable, Class) [SEP] public static Class<?> getRawType(Type type, Class<?> implClass) {\n        if (type instanceof Class) {\n            return (Class<?>) type;\n        }\n        if (type instanceof ParameterizedType) {\n            ParameterizedType pType = (ParameterizedType) type;\n            return getRawType(pType.getRawType(), implClass);\n        }\n        if (type instanceof WildcardType) {\n            WildcardType wType = (WildcardType) type;\n\n            Type[] lowerTypes = wType.getLowerBounds();\n            if (lowerTypes.length > 0) {\n                return getRawType(lowerTypes[0], implClass);\n            }\n\n            Type[] upperTypes = wType.getUpperBounds();\n            if (upperTypes.length != 0) {\n                return getRawType(upperTypes[0], implClass);\n            }\n\n            return Object.class;\n        }\n        if (type instanceof GenericArrayType) {\n            Type genericComponentType = ((GenericArrayType) type).getGenericComponentType();\n            Class<?> rawType = getRawType(genericComponentType, implClass);\n\n            return Array.newInstance(rawType, 0).getClass();\n        }\n        if (type instanceof TypeVariable) {\n            TypeVariable<?> varType = (TypeVariable<?>) type;\n            if (implClass != null) {\n                Type resolvedType = resolveVariable(varType, implClass);\n                if (resolvedType != null) {\n                    return getRawType(resolvedType, null);\n                }\n            }\n            Type[] boundsTypes = varType.getBounds();\n            if (boundsTypes.length == 0) {\n                return Object.class;\n            }\n            return getRawType(boundsTypes[0], implClass);\n        }\n        return null;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "TODO UT [SEP] @NonNull\n  public static <T> Set<T> setOf(final Class<T> type, final InlineConstrainedGenerator<T> omittedValues) {\n    assertIsNotParameterized(type, ErrorMessages.msgInline(\"setOf\"));\n    return PrivateGenerate.manyAsSetOf(TypeToken.of(type), omittedValues);\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Integrate the function from a to b using the trapezoidal algorithm, and\nreturn an approximation to the area. (Integrator implementation.)\n\n@param a\nthe lower limit\n@param b\nthe upper limit\n@param intervals\nthe number of equal-width intervals\n@return an approximation to the area [SEP] public float integrate (final float a, final float b, final int intervals)\n  {\n    if (b <= a)\n      return 0;\n\n    final float h = (b - a) / intervals; // interval width\n    float totalArea = 0;\n\n    // Compute the area using the current number of intervals.\n    for (int i = 0; i < intervals; ++i)\n    {\n      final float x1 = a + i * h;\n      totalArea += _areaOf (x1, h);\n    }\n\n    return totalArea;\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Search for facet values, explicitly targeting the online API, not the offline mirror.\nSame parameters as {@link Index#searchForFacetValues(String, String, Query, CompletionHandler)}. [SEP] public Request searchForFacetValuesOnline(@NonNull String facetName, @NonNull String text, @Nullable Query query, @NonNull final CompletionHandler completionHandler) {\n        return searchForFacetValuesOnline(facetName, text, query, /* requestOptions: */ null, completionHandler);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "{@inheritDoc}\n\n<p/>Applies color changes to the background of a row. [SEP] public void changeColor(C color)\n    {\n        AttributeSet aset = new AttributeSet();\n        aset.put(AttributeSet.BACKGROUND_COLOR, color);\n        grid.insertRowAttribute(aset, row);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Instructs a Maybe to emit an item (returned by a specified function) rather than invoking\n{@link MaybeObserver#onError onError} if it encounters an error.\n<p>\n<img width=\"640\" height=\"310\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturn.png\" alt=\"\">\n<p>\nYou can use this to prevent errors from propagating or to supply fallback data should errors be\nencountered.\n<dl>\n<dt><b>Scheduler:</b></dt>\n<dd>{@code onErrorReturn} does not operate by default on a particular {@link Scheduler}.</dd>\n</dl>\n\n@param valueSupplier\na function that returns a single value that will be emitted as success value\nthe current Maybe signals an onError event\n@return the new Maybe instance\n@see <a href=\"http://reactivex.io/documentation/operators/catch.html\">ReactiveX operators documentation: Catch</a> [SEP] @CheckReturnValue\n    @NonNull\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Maybe<T> onErrorReturn(Function<? super Throwable, ? extends T> valueSupplier) {\n        ObjectHelper.requireNonNull(valueSupplier, \"valueSupplier is null\");\n        return RxJavaPlugins.onAssembly(new MaybeOnErrorReturn<T>(this, valueSupplier));\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds a timeout interceptor factory to every method on the component.\n\n@param method   The method to add it to\n@param factory  The interceptor factory to add\n@param priority The interceptors relative order [SEP] public void addTimeoutViewInterceptor(final Method method, InterceptorFactory factory, int priority) {\n        OrderedItemContainer<InterceptorFactory> interceptors = timeoutInterceptors.get(method);\n        if (interceptors == null) {\n            timeoutInterceptors.put(method, interceptors = new OrderedItemContainer<InterceptorFactory>());\n        }\n        interceptors.add(factory, priority);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Desserializes a {@link BidRequest} from JSON, streamed from an {@link InputStream}. [SEP] public BidRequest readBidRequest(InputStream is) throws IOException {\n    try {\n      return ProtoUtils.built(readBidRequest(factory().getJsonFactory().createParser(is)));\n    } finally {\n      Closeables.closeQuietly(is);\n    }\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieves a map copy of the aci attributes set\n\n@return [SEP] @SuppressWarnings(\"unchecked\")\n\tpublic Map getCmpAttributesCopy() {\n\t\tfinal Node node = getCmpAttributesNode(false);\n\t\tif(node == null) {\n\t\t\treturn Collections.emptyMap();\n\t\t}\n\t\telse {\n\t\t\tMap result = new HashMap();\n\t\t\tNode cmpNode = null;\n\t\t\tfor (Object obj : node.getChildren()) {\n\t\t\t\tcmpNode = (Node) obj;\n\t\t\t\tresult.put(cmpNode.getFqn().getLastElement(), cmpNode\n\t\t\t\t\t\t.get(CMP_ATTRIBUTES_NODE_MAP_KEY));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Adds one or more facts into the Rule.\n@param   facts one or more facts\n@return  the current builder object [SEP] @SafeVarargs\n  public final GivenRuleBuilder<T, U> given(NameValueReferable... facts) {\n    _rule.addFacts(facts);\n    return this;\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add the variables to the netCDF file\n\n@param ncfile the netCDF file [SEP] void addToNetcdfFile(NetcdfFile ncfile) {\n\n    if (isLatLon) {\n      double dy;\n      if (gds.getDouble(GridDefRecord.DY) == GridDefRecord.UNDEFINED) {\n        dy = setLatLonDxDy();\n      } else {\n        dy = (gds.getDouble(GridDefRecord.LA2) < gds.getDouble(GridDefRecord.LA1))\n            ? -gds.getDouble(GridDefRecord.DY) : gds.getDouble(GridDefRecord.DY);\n      }\n\n      // lat\n      if (isGaussian) {\n        addGaussianLatAxis(ncfile, \"lat\", \"degrees_north\", \"latitude coordinate\", \"latitude\", AxisType.Lat);\n\n      } else {\n        addCoordAxis(ncfile, \"lat\", gds.getInt(GridDefRecord.NY), gds.getDouble(GridDefRecord.LA1), dy,\n                \"degrees_north\", \"latitude coordinate\", \"latitude\", AxisType.Lat);\n      }\n\n      // lon\n      addCoordAxis(ncfile, \"lon\", gds.getInt(GridDefRecord.NX), gds.getDouble(GridDefRecord.LO1), gds.getDouble(GridDefRecord.DX),\n              \"degrees_east\", \"longitude coordinate\", \"longitude\", AxisType.Lon);\n\n      // add dummy variable for lat/lon coord system\n      addCoordSystemVariable(ncfile, \"latLonCoordSys\", \"time lat lon\");\n\n    } else {\n      int projType = lookup.getProjectionType(gds);\n      if (makeProjection(ncfile, projType)) {\n\n        double[] yData, xData;\n        if (projType == GridTableLookup.RotatedLatLon) {\n          double dy = (gds.getDouble(\"La2\") < gds.getDouble(GridDefRecord.LA1)\n              ? -gds.getDouble(GridDefRecord.DY) : gds.getDouble(GridDefRecord.DY));\n\n          yData = addCoordAxis(ncfile, \"y\", gds.getInt(GridDefRecord.NY),\n              gds.getDouble(GridDefRecord.LA1), dy, \"degrees\",\n              \"y coordinate of projection\", \"projection_y_coordinate\", AxisType.GeoY);\n          xData = addCoordAxis(ncfile, \"x\", gds.getInt(GridDefRecord.NX),\n              gds.getDouble(GridDefRecord.LO1), gds.getDouble(GridDefRecord.DX), \"degrees\",\n              \"x coordinate of projection\", \"projection_x_coordinate\", AxisType.GeoX);\n\n        } else if (projType == GridTableLookup.Orthographic) {\n          yData = addCoordAxis(ncfile, \"y\", gds.getInt(GridDefRecord.NY), starty, incry, \"km\",  // fake km - really pixel\n              \"y coordinate of projection\", \"projection_y_coordinate\", AxisType.GeoY);     // dunno what the 3 is\n          xData = addCoordAxis(ncfile, \"x\", gds.getInt(GridDefRecord.NX), startx, incrx, \"km\",\n              \"x coordinate of projection\", \"projection_x_coordinate\", AxisType.GeoX);\n\n        } else if (projType ==  GridTableLookup.Curvilinear ) {\n          yData = null;\n          xData = null;\n\n        } else {\n          yData = addCoordAxis(ncfile, \"y\", gds.getInt(GridDefRecord.NY), starty, getDyInKm(), \"km\", \"y coordinate of projection\",\n              \"projection_y_coordinate\", AxisType.GeoY);\n          xData = addCoordAxis(ncfile, \"x\", gds.getInt(GridDefRecord.NX), startx, getDxInKm(), \"km\", \"x coordinate of projection\",\n              \"projection_x_coordinate\", AxisType.GeoX);\n        }\n\n        // optional 2D lat/lon\n        if (GridServiceProvider.addLatLon && (projType != GridTableLookup.Curvilinear))\n          addLatLon2D(ncfile, xData, yData);\n      }\n    }\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get all components in the application that have the given name\n\n@param componentName  The name of the component\n@param deploymentRoot The deployment root of the component doing the lookup\n@return A set of all views for the given component name and type [SEP] public Set<ComponentDescription> getComponents(final String componentName, final VirtualFile deploymentRoot) {\n        if (componentName.contains(\"#\")) {\n            final String[] parts = componentName.split(\"#\");\n            String path = parts[0];\n            if (!path.startsWith(\"../\")) {\n                path = \"../\" + path;\n            }\n            final VirtualFile virtualPath = deploymentRoot.getChild(path);\n            final String name = parts[1];\n            final List<Description> info = componentsByName.get(name);\n            if (info == null) {\n                return Collections.emptySet();\n            }\n            final Set<ComponentDescription> ret = new HashSet<ComponentDescription>();\n            for (Description i : info) {\n                //now we need to check the path\n                if (virtualPath.equals(i.deploymentRoot)) {\n                    ret.add(i.componentDescription);\n                }\n            }\n            return ret;\n        } else {\n            final List<Description> info = componentsByName.get(componentName);\n            if (info == null) {\n                return Collections.emptySet();\n            }\n            final Set<ComponentDescription> all = new HashSet<ComponentDescription>();\n            final Set<ComponentDescription> thisDeployment = new HashSet<ComponentDescription>();\n            for (Description i : info) {\n                all.add(i.componentDescription);\n                if (i.deploymentRoot.equals(deploymentRoot)) {\n                    thisDeployment.add(i.componentDescription);\n                }\n            }\n            //if there are multiple e\n            if (all.size() > 1) {\n                return thisDeployment;\n            }\n            return all;\n        }\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates the email flags on the server. [SEP] public void updateEmailFlags(final ReceivedEmail receivedEmail) {\n\t\tuseAndOpenFolderIfNotSet();\n\t\ttry {\n\t\t\tfolder.setFlags(new int[] {receivedEmail.messageNumber()}, receivedEmail.flags(),true);\n\t\t} catch (MessagingException mex) {\n\t\t\tthrow new MailException(\"Failed to fetch messages\", mex);\n\t\t}\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create an instance of {@link JAXBElement }{@code <}{@link String }{@code >}} [SEP] @XmlElementDecl(namespace = \"http://www.immoxml.de\", name = \"kennung_ursprung\")\n    public JAXBElement<String> createKennungUrsprung(String value) {\n        return new JAXBElement<String>(_KennungUrsprung_QNAME, String.class, null, value);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates an object pool for the specified profile table. If a\ntransaction manager is used then, and if the tx rollbacks, the pool will\nbe removed.\n\n@param\n@param sleeTransactionManager [SEP] public void createObjectPool(final ProfileTableImpl profileTable,\n\t\t\tfinal SleeTransactionManager sleeTransactionManager) {\n\n\t\tif (logger.isTraceEnabled()) {\n            logger.trace(\"Creating Pool for \" + profileTable);\n\t\t}\n\n\t\tcreateObjectPool(profileTable);\n\n\t\tif (sleeTransactionManager != null) {\n\t\t\t// add a rollback action to remove sbb object pool\n\t\t\tTransactionalAction action = new TransactionalAction() {\n\t\t\t\tpublic void execute() {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger\n\t\t\t\t\t\t\t\t.debug(\"Due to tx rollback, removing pool for \" + profileTable);\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tremoveObjectPool(profileTable);\n\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\tlogger.error(\"Failed to remove table's \" + profileTable + \" object pool\", e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tsleeTransactionManager.getTransactionContext().getAfterRollbackActions().add(action);\t\t\t\n\t\t}\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "{@inheritDoc} [SEP] public void internalCreate(OrientDBConfig config, OSharedContext ctx) {\n    this.sharedContext = ctx;\n    this.status = STATUS.OPEN;\n    // THIS IF SHOULDN'T BE NEEDED, CREATE HAPPEN ONLY IN EMBEDDED\n    applyAttributes(config);\n    applyListeners(config);\n    metadata = new OMetadataDefault(this);\n    installHooksEmbedded();\n    createMetadata(ctx);\n\n    if (this.getMetadata().getCommandCache().isEnabled())\n      registerHook(new OCommandCacheHook(this), ORecordHook.HOOK_POSITION.REGULAR);\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Close the connection if the received handshake was not correct\n\n@param exception the InvalidDataException causing this problem [SEP] private void closeConnectionDueToWrongHandshake( InvalidDataException exception ) {\n\t\twrite( generateHttpResponseDueToError( 404 ) );\n\t\tflushAndClose( exception.getCloseCode(), exception.getMessage(), false );\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Replaces the very first occurrence of a substring with supplied string.\n\n@param s      source string\n@param sub    substring to replace\n@param with   substring to replace with [SEP] public static String replaceFirst(final String s, final String sub, final String with) {\n\t\tint i = s.indexOf(sub);\n\t\tif (i == -1) {\n\t\t\treturn s;\n\t\t}\n\t\treturn s.substring(0, i) + with + s.substring(i + sub.length());\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns entity descriptor for provided table reference. [SEP] public DbEntityDescriptor getTableDescriptor(final String tableRef) {\n\t\tif (tableRefs == null) {\n\t\t\treturn null;\n\t\t}\n\t\tTableRefData t = tableRefs.get(tableRef);\n\t\treturn t == null ? null : t.desc;\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "getter for sectionLabels - gets Section labels in the document, e.g. sections.0, sections1, etc.\n@generated\n@return value of the feature [SEP] public StringArray getSectionLabels() {\n    if (Document_Type.featOkTst && ((Document_Type)jcasType).casFeat_sectionLabels == null)\n      jcasType.jcas.throwFeatMissing(\"sectionLabels\", \"edu.cmu.lti.oaqa.type.retrieval.Document\");\n    return (StringArray)(jcasType.ll_cas.ll_getFSForRef(jcasType.ll_cas.ll_getRefValue(addr, ((Document_Type)jcasType).casFeatCode_sectionLabels)));}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "{@inheritDoc} [SEP] public void visit(Functor functor)\n    {\n        if (isEnteringContext())\n        {\n            SymbolKey key = currentSymbolTable.getSymbolKey(currentPosition);\n            functor.setSymbolKey(key);\n\n            /*log.fine(functor.toString(interner, true, false) + \" assigned \" + key);*/\n        }\n        else if (isLeavingContext())\n        {\n            functor.setTermTraverser(null);\n        }\n\n        if (delegate != null)\n        {\n            delegate.visit(functor);\n        }\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Associates the specified value with the specified key in this\nmap.\n\n@param key key with which the specified value is to be\nassociated.\n@param value value to be associated with the specified key.\n\n@return null\n\n@throws ClassCastException if the class of the specified key\nor value prevents it from being\nstored in this map.\n@throws NullPointerException if the specified key or value\nis null\n@throws IllegalArgumentException if the key duplicates an\nexisting key, or if the\nvalue duplicates an\nexisting value [SEP] @Override\r\n    public V put(final K key, final V value)\r\n            throws ClassCastException, NullPointerException,\r\n                   IllegalArgumentException, ConcurrentModificationException {\r\n\r\n        checkKeyAndValue(key, value);\r\n\r\n        Node<K,V> node = rootNode[KEY];\r\n\r\n        String thread_id = getCurrentThreadId();\r\n\r\n        if (node == null) {\r\n            Node<K,V> root = new Node<K,V>(key, value);\r\n\r\n            rootNode[KEY]   = root;\r\n            rootNode[VALUE] = root;\r\n\r\n            if (!auto_commit)\r\n                root.setStatus(Node.ADDED, thread_id);\r\n\r\n            grow();\r\n        } else {\r\n            while (true) {\r\n                int cmp = compare(Node.ADDED, key, node.getStatus(), node.getData(KEY), KEY);\r\n\r\n                if (cmp == 0) {\r\n                    if (nextEqualValid(getFloorEqualNode(node, KEY), KEY, thread_id) != null)\r\n                    {\r\n                        String debug_message = \"Cannot store a duplicate key (\\\"\" + key + \"\\\") in this Map\";\r\n                        log.debug (debug_message);             \r\n                        throw new IllegalArgumentException(debug_message); \r\n                    }\r\n                    \r\n                    if (node.is(Node.ADDED, null))\r\n                        throw new ConcurrentModificationException();\r\n                    \r\n                    if (node.getRight(KEY) != null) {\r\n                        node = node.getRight(KEY);\r\n                    } else if (node.getLeft(KEY) != null) {\r\n                        node = node.getLeft(KEY);\r\n                    } else {\r\n                        Node<K,V> newNode = new Node<K,V>(key, value);\r\n\r\n                        insertValue(newNode, thread_id);\r\n                        node.setRight(newNode, KEY);\r\n                        newNode.setParent(node, KEY);\r\n                        doRedBlackInsert(newNode, KEY);\r\n                        grow();\r\n\r\n                        if (!auto_commit)\r\n                            newNode.setStatus(Node.ADDED, thread_id);\r\n\r\n                        break;\r\n                    }\r\n                } else if (cmp < 0) {\r\n                    if (node.getLeft(KEY) != null) {\r\n                        node = node.getLeft(KEY);\r\n                    } else {\r\n                        Node<K,V> newNode = new Node<K,V>(key, value);\r\n\r\n                        insertValue(newNode, thread_id);\r\n                        node.setLeft(newNode, KEY);\r\n                        newNode.setParent(node, KEY);\r\n                        doRedBlackInsert(newNode, KEY);\r\n                        grow();\r\n\r\n                        if (!auto_commit)\r\n                            newNode.setStatus(Node.ADDED, thread_id);\r\n\r\n                        break;\r\n                    }\r\n                } else {    // cmp > 0\r\n                    if (node.getRight(KEY) != null) {\r\n                        node = node.getRight(KEY);\r\n                    } else {\r\n                        Node<K,V> newNode = new Node<K,V>(key, value);\r\n\r\n                        insertValue(newNode, thread_id);\r\n                        node.setRight(newNode, KEY);\r\n                        newNode.setParent(node, KEY);\r\n                        doRedBlackInsert(newNode, KEY);\r\n                        grow();\r\n\r\n                        if (!auto_commit)\r\n                            newNode.setStatus(Node.ADDED, thread_id);\r\n\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "<p>\nAdds a list of SHA256 hashed pins for the pin- directive of the Public-Key-Pins header.\n</p>\n\n<p>\nThe pin directive specifies a way for web host operators to indicate\na cryptographic identity that should be bound to a given web host.\nSee <a href=\"https://tools.ietf.org/html/rfc7469#section-2.1.1\">Section 2.1.1</a> for additional details.\n</p>\n\n<p>\nTo get a pin of\n\nPublic-Key-Pins-Report-Only:\npin-sha256=\"d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=\";\npin-sha256=\"E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=\"\n\nUse\n\nHpkpHeaderWriter hpkpHeaderWriter = new HpkpHeaderWriter();\nhpkpHeaderWriter.addSha256Pins(\"d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM\", \"E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=\");\n</p>\n\n@param pins a list of base64-encoded SPKI fingerprints.\n@throws IllegalArgumentException if a pin is null [SEP] public void addSha256Pins(String ... pins) {\n\t\tfor (String pin : pins) {\n\t\t\tAssert.notNull(pin, \"pin cannot be null\");\n\t\t\tthis.pins.put(pin, \"sha256\");\n\t\t}\n\t\tupdateHpkpHeaderValue();\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Search for entries inside a given area defined by the points of a polygon. [SEP] public @NonNull\n    Query setInsidePolygon(@Nullable LatLng... points) {\n        set(KEY_INSIDE_POLYGON, points == null ? null : new Polygon(points).toString());\n        return this;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Applies a 3D special euclidean transform to a list of points.\n\n@param se\t The transform.\n@param points List of points which are to be transformed.  Modified. [SEP] public static void transform( Se3_F64 se, List<Point3D_F64> points ) {\n\t\tfor( Point3D_F64 p : points ) {\n\t\t\ttransform(se,p,p);\n\t\t}\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates new {@link PropertyDescriptor}. Note that this method may be called\nup to three times (depends on use case) for the same property. Each time when\na property is updated, a new definition is created with updated information. [SEP] protected PropertyDescriptor createPropertyDescriptor(final String name, final MethodDescriptor getterMethod, final MethodDescriptor setterMethod) {\n\t\treturn new PropertyDescriptor(classDescriptor, name, getterMethod, setterMethod);\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Lookup an object and supply a default value.\n@param objectExpression\n@param defaultValue\n@return [SEP] private Object doLookup(String objectExpression, Object defaultValue, boolean searchChildren) {\n\n        if (Str.isEmpty(objectExpression)) {\n            return defaultValue;\n        }\n\n        char firstChar = Str.idx(objectExpression, 0);\n        char secondChar = Str.idx(objectExpression, 1);\n        char lastChar = Str.idx(objectExpression, -1);\n\n        boolean escape = false;\n\n        switch(firstChar) {\n            case '$':\n                if (lastChar=='}') {\n                    objectExpression = slc(objectExpression, 2, -1);\n                } else {\n                    objectExpression = slc(objectExpression, 1);\n                }\n                break;\n            case '{':\n                if (secondChar=='{' && lastChar=='}') {\n                    char thirdChar = Str.idx(objectExpression, 2);\n\n                    if (thirdChar == '{') {\n                        escape = true;\n                        objectExpression = slc(objectExpression, 3, -3);\n                    }else {\n                        objectExpression = slc(objectExpression, 2, -2);\n                    }\n                }\n                else {\n                    if (lastChar == '}') {\n                        return jsonParser.parse(objectExpression);\n                    } else {\n                        escape = true;\n                        objectExpression = slc(objectExpression, 1);\n                    }\n                }\n                break;\n            case '[':\n                return jsonParser.parse(objectExpression);\n            case '.':\n                if (secondChar=='.') {\n\n                    String newExp = slc(objectExpression, 2);\n                    return parent.doLookup(newExp, newExp, false);\n                }\n        }\n\n        Object value;\n        lastChar = Str.idx(objectExpression, -1);\n        if (lastChar==')') {\n            value = handleFunction(objectExpression, searchChildren);\n        } else {\n\n\n            value = findProperty(objectExpression, searchChildren);\n\n            value = value == null ? defaultValue : value;\n\n        }\n\n        if (!escape) {\n            return value;\n        } else {\n            return StandardFunctions.escapeXml(value);\n        }\n\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "* Finish constructing after all elements have been added.\n@return true if successful. [SEP] public boolean finish() {\n    if (serviceName != null) {\n      this.service = dataset.findService(serviceName);\n      if (this.service == null)\n        log.append(\"**InvAccess in (\").append(dataset.getFullName()).append(\"): has unknown service named (\").append(serviceName).append(\")\\n\");\n    }\n\n      // check urlPath is ok\n    try {\n      new java.net.URI(urlPath);\n    } catch (java.net.URISyntaxException e) {\n      log.append(\"**InvAccess in (\").append(dataset.getFullName()).append(\"):\\n\" + \"   urlPath= \").append(urlPath).append(\")\\n  URISyntaxException=\").append(e.getMessage());\n    }\n\n    return true;\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the optional double value of the specified {@link ModelNode}.\n@param value the model node\n@return an optional value [SEP] public static OptionalDouble optionalDouble(ModelNode value) {\n        return value.isDefined() ? OptionalDouble.of(value.asDouble()) : OptionalDouble.empty();\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "结束当前流程实例，如果存在父流程，则触发父流程继续执行 [SEP] public void handle(Execution execution) {\n\t\tSnakerEngine engine = execution.getEngine();\n\t\tOrder order = execution.getOrder();\n\t\tList<Task> tasks = engine.query().getActiveTasks(new QueryFilter().setOrderId(order.getId()));\n\t\tfor(Task task : tasks) {\n\t\t\tif(task.isMajor()) throw new SnakerException(\"存在未完成的主办任务,请确认.\");\n\t\t\tengine.task().complete(task.getId(), SnakerEngine.AUTO);\n\t\t}\n\t\t/**\n\t\t * 结束当前流程实例\n\t\t */\n\t\tengine.order().complete(order.getId());\n\t\t\n\t\t/**\n\t\t * 如果存在父流程，则重新构造Execution执行对象，交给父流程的SubProcessModel模型execute\n\t\t */\n\t\tif(StringHelper.isNotEmpty(order.getParentId())) {\n\t\t\tOrder parentOrder = engine.query().getOrder(order.getParentId());\n\t\t\tif(parentOrder == null) return;\n\t\t\tProcess process = engine.process().getProcessById(parentOrder.getProcessId());\n\t\t\tProcessModel pm = process.getModel();\n\t\t\tif(pm == null) return;\n\t\t\tSubProcessModel spm = (SubProcessModel)pm.getNode(order.getParentNodeName());\n            Execution newExecution = new Execution(engine, process, parentOrder, execution.getArgs());\n            newExecution.setChildOrderId(order.getId());\n            newExecution.setTask(execution.getTask());\n\t\t\tspm.execute(newExecution);\n\t\t\t/**\n\t\t\t * SubProcessModel执行结果的tasks合并到当前执行对象execution的tasks列表中\n\t\t\t */\n\t\t\texecution.addTasks(newExecution.getTasks());\n\t\t}\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set data in the upload with a recorder.\n@param objectKey key\n@param recorder recorder [SEP] private void setData(String objectKey, Recorder recorder) {\n        if (recorder == null) return;\n        String upload = new Gson().toJson(uploadModel);\n        recorder.set(objectKey, upload.getBytes());\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run multiple queries on this index, explicitly targeting the offline mirror.\n\n@param queries Queries to run.\n@param strategy Strategy to use.\n@param completionHandler The listener that will be notified of the request's outcome.\n@return A cancellable request.\n@throws IllegalStateException if mirroring is not activated on this index. [SEP] public Request multipleQueriesOfflineAsync(final @NonNull List<Query> queries, final Client.MultipleQueriesStrategy strategy, @NonNull CompletionHandler completionHandler) {\n        if (!mirrored) {\n            throw new IllegalStateException(\"Offline requests are only available when the index is mirrored\");\n        }\n        final List<Query> queriesCopy = new ArrayList<>(queries.size());\n        for (Query query: queries) {\n            queriesCopy.add(new Query(query));\n        }\n        return getClient().new AsyncTaskRequest(completionHandler, getClient().localSearchExecutorService) {\n            @NonNull\n            @Override\n            protected JSONObject run() throws AlgoliaException {\n                return _multipleQueriesOffline(queriesCopy, strategy == null ? null : strategy.toString());\n            }\n        }.start();\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Double value formatting with minimum number of significant figures in a specified width.\nThis will try to do a reasonable job of getting\na representation that has min_sigfig significant figures in the specified width.\nRight now, all it does is call d( double d, int min_sigfig) and left pad out to width chars.\n\n@param d          the number to format.\n@param min_sigfig minimum number of significant figures\n@param width      width of the result\n@return string representation, right justified in field of specified width [SEP] public static String d(double d, int min_sigfig, int width) {\n    String s = Format.d(d, min_sigfig);\n    return pad(s, width, true);\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This method allocates required chunk of memory in specific location\n<p>\nPLEASE NOTE: Do not use this method, unless you're 100% sure what you're doing\n\n@param requiredMemory\n@param location [SEP] @Override\n    public AllocationPoint allocateMemory(DataBuffer buffer, AllocationShape requiredMemory, AllocationStatus location,\n                    boolean initialize) {\n        AllocationPoint point = new AllocationPoint();\n\n        useTracker.set(System.currentTimeMillis());\n\n        // we use these longs as tracking codes for memory tracking\n        Long allocId = objectsTracker.getAndIncrement();\n        //point.attachBuffer(buffer);\n        point.setObjectId(allocId);\n        point.setShape(requiredMemory);\n        /*\n        if (buffer instanceof CudaIntDataBuffer) {\n            buffer.setConstant(true);\n            point.setConstant(true);\n        }\n        */\n        int numBuckets = configuration.getNumberOfGcThreads();\n        int bucketId = RandomUtils.nextInt(0, numBuckets);\n\n        GarbageBufferReference reference =\n                        new GarbageBufferReference((BaseDataBuffer) buffer, queueMap.get(bucketId), point);\n        point.attachReference(reference);\n        point.setDeviceId(-1);\n\n        if (buffer.isAttached()) {\n            long reqMem = AllocationUtils.getRequiredMemory(requiredMemory);\n            //log.info(\"Allocating {} bytes from attached memory...\", reqMem);\n\n            // workaround for init order\n            getMemoryHandler().getCudaContext();\n            point.setDeviceId(Nd4j.getAffinityManager().getDeviceForCurrentThread());\n\n            CudaWorkspace workspace = (CudaWorkspace) Nd4j.getMemoryManager().getCurrentWorkspace();\n\n            PointersPair pair = new PointersPair();\n\n            PagedPointer ptrDev = workspace.alloc(reqMem, MemoryKind.DEVICE, requiredMemory.getDataType(), initialize);\n            PagedPointer ptrHost = workspace.alloc(reqMem, MemoryKind.HOST, requiredMemory.getDataType(), initialize);\n\n            pair.setHostPointer(ptrHost);\n            if (ptrDev != null) {\n                pair.setDevicePointer(ptrDev);\n                point.setAllocationStatus(AllocationStatus.DEVICE);\n            } else {\n                pair.setDevicePointer(ptrHost);\n                point.setAllocationStatus(AllocationStatus.HOST);\n            }\n\n\n            //if (!ptrDev.isLeaked())\n            point.setAttached(true);\n\n            point.setPointers(pair);\n        } else {\n            // we stay naive on PointersPair, we just don't know on this level, which pointers are set. MemoryHandler will be used for that\n            PointersPair pair = memoryHandler.alloc(location, point, requiredMemory, initialize);\n            point.setPointers(pair);\n        }\n\n        allocationsMap.put(allocId, point);\n        point.tickHostRead();\n        point.tickDeviceWrite();\n        return point;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates a UserDetailsResourceFactoryBean with a resource from the provided String\n\n@param users the string representing the users\n@return the UserDetailsResourceFactoryBean [SEP] public static UserDetailsResourceFactoryBean fromString(String users) {\n\t\tInMemoryResource resource = new InMemoryResource(users);\n\t\treturn fromResource(resource);\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This {@code doFilter} implementation stores a request attribute for\n\"already filtered\", proceeding without filtering again if the attribute is already\nthere.\n@param request the request\n@param response the response\n@param filterChain the filter chain\n@throws ServletException if request is not HTTP request\n@throws IOException in case of I/O operation exception [SEP] @Override\n\tpublic final void doFilter(ServletRequest request, ServletResponse response,\n\t\t\tFilterChain filterChain) throws ServletException, IOException {\n\n\t\tif (!(request instanceof HttpServletRequest)\n\t\t\t\t|| !(response instanceof HttpServletResponse)) {\n\t\t\tthrow new ServletException(\n\t\t\t\t\t\"OncePerRequestFilter just supports HTTP requests\");\n\t\t}\n\t\tHttpServletRequest httpRequest = (HttpServletRequest) request;\n\t\tHttpServletResponse httpResponse = (HttpServletResponse) response;\n\t\tboolean hasAlreadyFilteredAttribute = request\n\t\t\t\t.getAttribute(this.alreadyFilteredAttributeName) != null;\n\n\t\tif (hasAlreadyFilteredAttribute) {\n\n\t\t\t// Proceed without invoking this filter...\n\t\t\tfilterChain.doFilter(request, response);\n\t\t}\n\t\telse {\n\t\t\t// Do invoke this filter...\n\t\t\trequest.setAttribute(this.alreadyFilteredAttributeName, Boolean.TRUE);\n\t\t\ttry {\n\t\t\t\tdoFilterInternal(httpRequest, httpResponse, filterChain);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\t// Remove the \"already filtered\" request attribute for this request.\n\t\t\t\trequest.removeAttribute(this.alreadyFilteredAttributeName);\n\t\t\t}\n\t\t}\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Find the buffer size that would be necessary to store an image<br>\nwith the given qualities. [SEP] public static int getBufferSizeNeeded(int width, int height, PixelFormat.Type pix_fmt) {\n    return VideoJNI.PixelFormat_getBufferSizeNeeded(width, height, pix_fmt.swigValue());\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "判断当前数据库的名称里是否包含hsql（忽略大小写）。\n\n@param c 数据库连接\n@return 如果数据库名称包含hsql，则返回true；否则返回false。 [SEP] @Override\n  public boolean accept(Connection c) {\n    try {\n      DatabaseMetaData d = c.getMetaData();\n      String name = d.getDatabaseProductName(); // HSQL Database Engine\n      return name.toLowerCase().contains(\"hsql\");\n    } catch (SQLException e) {\n      throw new DBOpenException(e);\n    }\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create an instance of {@link JAXBElement }{@code <}{@link VermarktungGrundstueckGewerbeTyp.Pacht }{@code >}} [SEP] @XmlElementDecl(namespace = \"http://www.immobilienscout24.de/immobilientransfer\", name = \"Pacht\", scope = VermarktungGrundstueckGewerbeTyp.class)\n    public JAXBElement<VermarktungGrundstueckGewerbeTyp.Pacht> createVermarktungGrundstueckGewerbeTypPacht(VermarktungGrundstueckGewerbeTyp.Pacht value) {\n        return new JAXBElement<VermarktungGrundstueckGewerbeTyp.Pacht>(_VermarktungGrundstueckWohnenMieteTypPacht_QNAME, VermarktungGrundstueckGewerbeTyp.Pacht.class, VermarktungGrundstueckGewerbeTyp.class, value);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create a URL lister for the supplied protocol\n@param protocol the protocol\n@return a URLLister capable of listing URLs of that protocol\n@throws MalformedURLException if no lister could be found for the protocol [SEP] public URLLister createURLLister(String protocol) throws MalformedURLException {\n      try {\n         String className = (String) classes.get(protocol);\n         if (className == null) {\n            throw new MalformedURLException(\"No lister class defined for protocol \"+protocol);\n         }\n\n         Class<?> clazz = Thread.currentThread().getContextClassLoader().loadClass(className);\n         return (URLLister) clazz.newInstance();\n      } catch (ClassNotFoundException e) {\n         throw new MalformedURLException(e.getMessage());\n      } catch (InstantiationException e) {\n         throw new MalformedURLException(e.getMessage());\n      } catch (IllegalAccessException e) {\n         throw new MalformedURLException(e.getMessage());\n      }\n   }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Detects limit of limit of open files.\n\n@param recommended recommended value of limit of open files.\n@param defLimit    default value for limit of open files.\n\n@return limit of open files, available for the system. [SEP] public int getOpenFilesLimit(boolean verbose, int recommended, int defLimit) {\n    if (Platform.isLinux()) {\n      final OCLibrary.Rlimit rlimit = new OCLibrary.Rlimit();\n      final int result = C_LIBRARY.getrlimit(OCLibrary.RLIMIT_NOFILE, rlimit);\n\n      if (result == 0 && rlimit.rlim_cur > 0) {\n        if (verbose) {\n          OLogManager.instance().infoNoDb(this, \"Detected limit of amount of simultaneously open files is %d, \"\n              + \" limit of open files for disk cache will be set to %d\", rlimit.rlim_cur, rlimit.rlim_cur / 2 - 512);\n        }\n\n        if (rlimit.rlim_cur < recommended) {\n          OLogManager.instance()\n              .warnNoDb(this, \"Value of limit of simultaneously open files is too small, recommended value is %d\", recommended);\n        }\n\n        return (int) rlimit.rlim_cur / 2 - 512;\n      } else {\n        if (verbose) {\n          OLogManager.instance().infoNoDb(this, \"Can not detect value of limit of open files.\");\n        }\n      }\n    } else if (Platform.isWindows()) {\n      if (verbose) {\n        OLogManager.instance()\n            .infoNoDb(this, \"Windows OS is detected, %d limit of open files will be set for the disk cache.\", recommended);\n      }\n\n      return recommended;\n    }\n\n    if (verbose) {\n      OLogManager.instance().infoNoDb(this, \"Default limit of open files (%d) will be used.\", defLimit);\n    }\n\n    return defLimit;\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts value to <code>BigDecimal</code>. [SEP] public BigDecimal toBigDecimal(final Object value) {\n\t\tfinal TypeConverter<BigDecimal> tc = TypeConverterManager.get().lookup(BigDecimal.class);\n\t\treturn tc.convert(value);\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Start [SEP] @Override\n    public void start(StartContext context) throws StartException {\n        try {\n            Connector cmd = mdr.getValue().getResourceAdapter(deployment);\n            File root = mdr.getValue().getRoot(deployment);\n\n            Activation localRaXml = getRaxml();\n            cmd = (new Merger()).mergeConnectorWithCommonIronJacamar(localRaXml, cmd);\n\n            String id = ((ModifiableResourceAdapter) raxml).getId();\n            final ServiceName raServiceName;\n            if (id == null || id.trim().isEmpty()) {\n                raServiceName = ConnectorServices.getResourceAdapterServiceName(raName);\n                this.connectorServicesRegistrationName = raName;\n            } else {\n                raServiceName = ConnectorServices.getResourceAdapterServiceName(id);\n                this.connectorServicesRegistrationName = id;\n            }\n            final WildFlyRaXmlDeployer raDeployer = new WildFlyRaXmlDeployer(context.getChildTarget(), connectorXmlDescriptor.getUrl(),\n                raName, root, module.getClassLoader(), cmd, localRaXml, deploymentServiceName);\n\n            raDeployer.setConfiguration(config.getValue());\n\n            WritableServiceBasedNamingStore.pushOwner(duServiceName);\n            ClassLoader old = WildFlySecurityManager.getCurrentContextClassLoaderPrivileged();\n            try {\n                WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(module.getClassLoader());\n                raxmlDeployment = raDeployer.doDeploy();\n            } finally {\n                WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(old);\n                WritableServiceBasedNamingStore.popOwner();\n            }\n            value = new ResourceAdapterDeployment(raxmlDeployment, raName, raServiceName);\n            managementRepository.getValue().getConnectors().add(value.getDeployment().getConnector());\n            registry.getValue().registerResourceAdapterDeployment(value);\n            final ServiceBuilder raServiceSB = context.getChildTarget()\n                .addService(raServiceName,\n                        new ResourceAdapterService(raServiceName, value.getDeployment().getResourceAdapter()));\n            raServiceSB.requires(deploymentServiceName);\n            raServiceSB.setInitialMode(ServiceController.Mode.ACTIVE).install();\n        } catch (Throwable t) {\n            cleanupStartAsync(context, raName, deploymentServiceName, t);\n        }\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Asserts that the given object is not <code>null</code>. If this\nis not the case, some kind of unchecked exception is thrown.\nThe given message is included in that exception, to aid debugging. [SEP] static public void isNotNull(Object o, String message) {\n        if (o == null)\n            throw new AssertionFailedException(Policy.bind(\"assert.null\", message)); //$NON-NLS-1$\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Determine if the url has x, y, or z variables\n\n@param url\n@return [SEP] private boolean hasXYZ(String url) {\n\n        String replacedUrl = replaceXYZ(url, 0, 0, 0);\n        boolean hasXYZ = !replacedUrl.equals(url);\n\n        return hasXYZ;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add a destination to this image so it can merge streams.\n\n@param transportIndex from which packets will arrive.\n@param transport      from which packets will arrive. [SEP] void addDestination(final int transportIndex, final ReceiveDestinationUdpTransport transport)\n    {\n        imageConnections = ArrayUtil.ensureCapacity(imageConnections, transportIndex + 1);\n\n        if (transport.isMulticast())\n        {\n            imageConnections[transportIndex] = new ImageConnection(\n                cachedNanoClock.nanoTime(), transport.udpChannel().remoteControl());\n        }\n        else if (transport.hasExplicitControl())\n        {\n            imageConnections[transportIndex] = new ImageConnection(\n                cachedNanoClock.nanoTime(), transport.explicitControlAddress());\n        }\n    }", "target": 1, "target_options": ["no_match", "match"]}
