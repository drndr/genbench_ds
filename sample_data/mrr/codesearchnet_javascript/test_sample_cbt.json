{"input": "Fetches the given branch's tree, from its SHA, and __resets any\nWorkingState for it__\n@param {RepositoryState}\n@param {Driver}\n@param {Branch}\n@return {Promise<RepositoryState>} [SEP] function fetchTree(repoState, driver, branch) {\n    // Fetch a working tree for this branch\n    return WorkingUtils.fetch(driver, branch)\n    .then((newWorkingState) => {\n        return updateWorkingState(repoState, branch, newWorkingState);\n    });\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Require extension vue hook\n@param {Module} module\n@param {String} filePath file path\n@export {Vue} Vue Component after compile [SEP] function loader ( module, filePath ) {\n\n    let content = fs.readFileSync(filePath, 'utf8');\n    let moduleId = `data-v-${ hash(filePath) }`;\n\n    let vueTemplate = '';\n    let vueComponent = compiler.parseComponent(stripBom(content));\n\n    let script = vueComponent.script;\n    let styles = vueComponent.styles;\n    let template = vueComponent.template;\n\n    let scoped = styles.some(({ attrs }) => attrs.scoped);\n\n    [].concat(script, template, styles).forEach(( tag, index ) => {\n        if (tag) {\n            let type = tag.type;\n            let content = tag.content;\n            let lang = tag.attrs.lang || store[type].defaults;\n            let handler = store[type].langs[lang];\n            if (handler) {\n                content = handler(content, filePath, index, module);\n            }\n            switch (type) {\n                case 'style':\n                    if (browserEnv) {\n                        /**\n                         * Only in Browser Environment, append style to head\n                         */\n                        if (tag.attrs.scoped) {\n                            let ast = css.parse(content);\n                            ast.stylesheet.rules.forEach(( rule ) => {\n                                rule.selectors = rule.selectors.map(( selector ) => {\n                                    let [ patterns ] = cssWhat(selector);\n                                    let index = patterns.length - 1;\n                                    for (; index >= 0; index--) {\n                                        let { type } = patterns[index];\n                                        if (type !== 'pseudo' && type !== 'pseudo-element') {\n                                            break;\n                                        }\n                                    }\n                                    patterns.splice(index + 1, 0, {\n                                        value : '',\n                                        name : moduleId,\n                                        action : 'exists',\n                                        type : 'attribute',\n                                        ignoreCase : false,\n                                    });\n                                    return cssWhat.stringify([patterns]);\n                                });\n                            });\n                            content = css.stringify(ast);\n                        }\n                        let style = document.createElement('style');\n                        style.innerHTML = content;\n                        store.style.exports.call(module.exports, style, {\n                            index,\n                            styles,\n                            filePath,\n                        });\n                    }\n                    break;\n                case 'script':\n                    module._compile(content, filePath);\n                    break;\n                case 'template':\n                    if (browserEnv) {\n                        /**\n                         * Only in Browser Environment, set Attribute for each element\n                         */\n                        if (scoped) {\n                            let div = document.createElement('div');\n                            div.innerHTML = content;\n                            let root = div.firstElementChild;\n                            let walk = function walk ( element, handler ) {\n                                handler(element);\n                                let children = element.children || [];\n                                [].forEach.call(children, ( child ) => {\n                                    walk(child, handler);\n                                });\n                            };\n                            walk(root, ( element ) => {\n                                element.setAttribute(moduleId, '');\n                            });\n                            content = div.innerHTML;\n                        }\n                    }\n                    vueTemplate = content;\n                    break;\n            }\n        }\n    });\n\n    module.exports.vueComponent = vueComponent;\n    module.exports.template = vueTemplate;\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "how many arguments should we consume, based on the nargs option? [SEP] function eatNargs (i, key, args) {\n        var toEat = checkAllAliases(key, opts.narg)\n    \n        if (args.length - (i + 1) < toEat) error = Error(__('Not enough arguments following: %s', key))\n    \n        for (var ii = i + 1; ii < (toEat + i + 1); ii++) {\n          setArg(key, args[ii])\n        }\n    \n        return (i + toEat)\n      }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "/*\nClassify dataset and return the scored result in sorted list [SEP] function(dataset) {\n\t\tlist_of_scores = [];\n\t\tFN=0\n\t\tfor (var i=0; i<dataset.length; ++i) \n\t\t{\n \t\t\tvar scoresVector = this.multiclassClassifier.classify(dataset[i].input, false, true);\n\n \t\t\tfor (score in scoresVector)\n \t\t\t{\n \t\t\t\tif (dataset[i].output.indexOf(scoresVector[score][0])>-1)\n \t\t\t\t{\n \t\t\t\t\tscoresVector[score].push(\"+\")\n \t\t\t\t\tFN+=1\n \t\t\t\t}\n \t\t\t\telse {scoresVector[score].push(\"-\")}\n\n \t\t\t\tscoresVector[score].push(i)\t\n\t\t\t}\n\n \t\t\tlist_of_scores = list_of_scores.concat(scoresVector)\n  \t\t}\t\n\n  \t\t// list_of_scores = [['d',4],['b',2],['a',1],['c',3]]\n\n\t\tlist_of_scores.sort((function(index){\n\t\t    return function(a, b){\n\t        return (a[index] === b[index] ? 0 : (a[index] < b[index] ? 1 : -1));\n\t\t    };\n\t\t})(1))\n\n\t\treturn [list_of_scores, FN]\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "https://dom.spec.whatwg.org/#queue-a-mutation-record [SEP] function queueMutationRecord(\n  type,\n  target,\n  name,\n  namespace,\n  oldValue,\n  addedNodes,\n  removedNodes,\n  previousSibling,\n  nextSibling\n) {\n  const interestedObservers = new Map();\n\n  const nodes = domSymbolTree.ancestorsToArray(target);\n\n  for (const node of nodes) {\n    for (const registered of node._registeredObserverList) {\n      const { options, observer: mo } = registered;\n\n      if (\n        !(node !== target && options.subtree === false) &&\n        !(type === MUTATION_TYPE.ATTRIBUTES && options.attributes !== true) &&\n        !(type === MUTATION_TYPE.ATTRIBUTES && options.attributeFilter &&\n          !options.attributeFilter.some(value => value === name || value === namespace)) &&\n        !(type === MUTATION_TYPE.CHARACTER_DATA && options.characterData !== true) &&\n        !(type === MUTATION_TYPE.CHILD_LIST && options.childList === false)\n      ) {\n        if (!interestedObservers.has(mo)) {\n          interestedObservers.set(mo, null);\n        }\n\n        if (\n          (type === MUTATION_TYPE.ATTRIBUTES && options.attributeOldValue === true) ||\n          (type === MUTATION_TYPE.CHARACTER_DATA && options.characterDataOldValue === true)\n        ) {\n          interestedObservers.set(mo, oldValue);\n        }\n      }\n    }\n  }\n\n  for (const [observer, mappedOldValue] of interestedObservers.entries()) {\n    const record = MutationRecord.createImpl([], {\n      type,\n      target,\n      attributeName: name,\n      attributeNamespace: namespace,\n      oldValue: mappedOldValue,\n      addedNodes,\n      removedNodes,\n      previousSibling,\n      nextSibling\n    });\n\n    observer._recordQueue.push(record);\n    activeMutationObservers.add(observer);\n  }\n\n  queueMutationObserverMicrotask();\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "-- Helpers -- [SEP] function _listen(qb) {\n  qb.on('error', function (err, next) {\n    qb.log.error(err)\n    next()\n  })\n\n  qb.on('process', function (type, task, next) {\n    try {\n      qb._types[type](task, callback);\n    } catch (err) {\n      callback(err);\n    }\n\n    function callback(err) {\n      next(err) // We don't pass errors through because that is not for \"task failure\" errors\n      if (err) {\n        qb.emit('fail', err, type, task, errcallback(qb));\n      } else {\n        qb.emit('finish', type, task, errcallback(qb));\n      }\n    }\n  });\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "internal method to delegate DOM events and triggers [SEP] function(eventsArg) {\n      var events = Marionette._getValue(eventsArg || this.events, this);\n  \n      // normalize ui keys\n      events = this.normalizeUIKeys(events);\n      if (_.isUndefined(eventsArg)) {this.events = events;}\n  \n      var combinedEvents = {};\n  \n      // look up if this view has behavior events\n      var behaviorEvents = _.result(this, 'behaviorEvents') || {};\n      var triggers = this.configureTriggers();\n      var behaviorTriggers = _.result(this, 'behaviorTriggers') || {};\n  \n      // behavior events will be overriden by view events and or triggers\n      _.extend(combinedEvents, behaviorEvents, events, triggers, behaviorTriggers);\n  \n      Backbone.View.prototype.delegateEvents.call(this, combinedEvents);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "VATCountry\n\n@param {string} name\n@param {string} code\n@param {string} countryCode\n@param {VATPeriod[]} periods\n@param {Date} [date] [SEP] function VATCountry(name, code, countryCode, periods, date) {\n  this._name = name;\n  this._code = code;\n  this._countryCode = countryCode;\n  this._periods = periods;\n\n  this.setDate(date);\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Serializes an object's properties into JSON string then URI encoded\n@method utilitarian.obj.util#toParam\n@param {object} obj A JSON object to serialize into a query string parameter\n@param {boolean} [dontEncode] An optional boolean value to control whether or not to URI encode the resulting query parameter (defaults to `false`)\n@returns {string} A query string parameter representation of the original object [SEP] function toParam(obj, dontEncode) {\n    const arr = [];\n    let vals;\n\n    if (isObject(obj) && !isArray(obj)) {\n        Object.keys(obj).forEach((val) => {\n            if (isArray(obj[val])) {\n                vals = `[${\n                    obj[val].map(v => (isNaN(v) ? `\"${v}\"` : v)).join(',')\n                }]`;\n            } else {\n                vals = isNaN(obj[val]) ? `\"${obj[val]}\"` : obj[val];\n            }\n            arr.push(`${val}:${vals}`);\n        });\n\n        if (dontEncode) {\n            return `{${arr.join(',')}}`;\n        }\n\n        return encodeURIComponent(`{${arr.join(',')}}`);\n    }\n\n    return '';\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "bind sliceThen() with file argument \nConfig scanner according to dictionary attributes. [SEP] function config() {\n      attrs.Encoding = attrs.Encoding || 'UTF-16';\n      \n      _searchTextLen = (attrs.Encoding === 'UTF-16') \n                          ?   function(dv, offset) {\n                                offset = offset;\n                                var mark = offset;\n                                while (dv.getUint16(offset++)) { /* scan for NUL */ };\n                                return offset - mark;\n                          } : function(dv, offset) {\n                                offset = offset;\n                                var mark = offset;\n                                while (dv.getUint8(offset++)) { /* scan for NUL */ }\n                                return offset - mark - 1;\n                          };\n      \n      _decoder = new TextDecoder(attrs.Encoding || 'UTF-16LE');\n\n      _bpu = (attrs.Encoding === 'UTF-16') ? 2 : 1;\n      \n      if (parseInt(attrs.GeneratedByEngineVersion, 10) >= 2.0) {\n        _v2 = true;\n        _tail = _bpu;\n\n          // HUGE dictionary file (>4G) is not supported, take only lower 32-bit\n        _readNum     = function(scanner) { return scanner.forward(4), scanner.readInt(); };\n        _readShort   = function(scanner) { return scanner.readUint16(); };\n        _checksum_v2 = function(scanner) { return scanner.checksum(); };\n      } else {\n        _tail = 0;\n      }\n      \n      // keyword index decrypted?\n      if (attrs.Encrypted & 0x02) {\n        _decryptors[1] = decrypt; \n      }\n      \n      var regexp = common.REGEXP_STRIPKEY[ext];\n      if (isTrue(attrs.KeyCaseSensitive)) {\n        _adaptKey = isTrue(attrs.StripKey) \n                      ? function(key) { return key.replace(regexp, '$1'); }\n                      : function(key) { return key; };\n      } else {\n        _adaptKey = isTrue(attrs.StripKey || (_v2 ? '' : 'yes')) \n                      ? function(key) { return key.toLowerCase().replace(regexp, '$1'); }\n                      : function(key) { return key.toLowerCase(); };\n      }\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a buffer of length 6 representing the clock identifier\n@param {String|Buffer} nodeId\n@returns {Buffer}\n@private [SEP] function getNodeId(nodeId) {\n  let buffer = nodeId;\n  if (typeof nodeId === 'string') {\n    buffer = utils.allocBufferFromString(nodeId, 'ascii');\n  }\n  if (!(buffer instanceof Buffer)) {\n    //Generate\n    buffer = getRandomBytes(6);\n  }\n  else if (buffer.length !== 6) {\n    throw new Error('Node identifier must have 6 bytes');\n  }\n  return buffer;\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "parses the dependency logical expression of each agent and populates the auxiliary structures used by the agency to control the flow of execution [SEP] function parseExpression(expr) {\n    var parentList = [];\n    var parsedTokenizedExpression = [];\n    var parsedExpression = '';\n    var testInvalidChar;\n\n    if (expr && expr.trim()) {\n      parsedExpression = expr.replace(/\\040/g, '');\n      testInvalidChar = /[^a-zA-Z0-9_&|!()_]/.test(parsedExpression); //valid characters\n\n      if (!testInvalidChar) {\n          var pos = '0';\n          var prevprev = '?';\n          var prev = '?';\n          var head = '';\n          var key = '';\n          var rbrackets = 0;\n          var tmpparent = '';\n          var tmpexpression = '';\n          \n          // parser rules:\n          //\n          // left hand side of rule determines the rule to apply to the current element of the expression:\n          //\n          //   first element of key indicates the position of the expression element being evaluated:\n          //    1 - first position\n          //    n - other position\n          //   second element of key represents the position before the previous position:\n          //    ? - don't care\n          //    & - logical AND\n          //    | - logical OR\n          //   third element of key represents the previous position on the expression:\n          //    ? - don't care\n          //    ( - opening parenthesis\n          //    # - alpha numeric characters and underscore\n          //    ) - closing parenthesis\n          //    ! - logical NOT\n          //\n          // right hand side of rule represents valid symbols for that key\n          //\n          // example:\n          //\n          //  parsing expression 'a&&b' (one position at a time):\n          //  \n          //  - 'a' element is evaluated by first rule:\n          //    key: 1st position, before previous and previous positions elements don't care\n          //    validation: any alpha numeric character or open parenthesis or underscore or NOT \n          //  - '&' element is evaluated by the third rule:\n          //    key: (any position but first, indiferent before previous element, any valid previous element)\n          //    validation: any alpha numeric character or closing parenthesis or underscore or AND or OR \n          //  - '&' element is evaluated by sixth rule:\n          //    key: any position but first, indiferent before previous element, OR previous element\n          //    validation: value has to be '&'\n          //  - 'b' element is evaluated by the seventh rule:\n          //    key: any position but first, '&' before previous element, '&' previous element\n          //    validation: any alpha numeric character or open parenthesis or underscore or NOT or opening parenthesis\n          //  \n          var rules = {\n            '1??': /[a-zA-Z0-9_(!]/,\n            'n?(': /[a-zA-Z0-9_(!]/,\n            'n?#': /[a-zA-Z0-9_)&|]/,\n            'n?!': /[a-zA-Z0-9_(]/,\n            'n?)': /[&|)]/,\n            'n?&': /[&]/,\n            'n&&': /[a-zA-Z0-9_(!]/,\n            'n&#': /[a-zA-Z0-9_)&|]/,\n            'n&(': /[a-zA-Z0-9_(!]/,\n            'n?|': /[|]/,\n            'n||': /[a-zA-Z0-9_(!]/,\n            'n|(': /[a-zA-Z0-9_(!]/,\n            'n|#': /[a-zA-Z0-9_)&|]/,\n            'n|&': /[]/,\n            'n&|': /[]/,\n          };\n\n          for (var i = 0; i < parsedExpression.length; i += 1) {\n            pos = (i === 0 ? '1' : 'n');\n            head = parsedExpression.charAt(i);\n            key = pos + prevprev + prev;\n\n            if (!rules[key].test(head)) {\n              err.code = 'InvalidCharacter';\n              err.message = 'failed dependency expression validation (invalid character at position ' + (i + 1) + ')'; \n              return err;\n            }\n\n            if (head === '(') {\n              rbrackets += 1;\n            }\n\n            if (head === ')') {\n              if (rbrackets <= 0) {\n                err.code = 'UnopenedParentheses';\n                err.message = 'failed dependency expression validation (unopened parenthesis)'; \n                return err;\n              } else {\n                rbrackets -= 1;\n              }\n            }\n\n            // last character\n            if (i === parsedExpression.length - 1) {\n              // ), # -> expression terminators\n              if (/[a-zA-Z0-9)]/.test(head)) {\n                if (rbrackets !== 0) {\n                  err.code = 'UnclosedParentheses';\n                  err.message = 'failed dependency expression validation (unclosed parenthesis)';\n                  return err;\n                }\n              } else {\n                err.code = 'InvalidTerminator';\n                err.message = 'failed dependency expression validation (invalid expression terminator)';\n                return err;\n              }\n            } else {\n              if (prev === '&' || prev === '|') {\n                prevprev = prev;\n              } else {\n                prevprev = '?'; // ? -> don't care\n              }\n\n              if (/[a-zA-Z0-9_]/.test(head)) {\n                prev = '#'; // # -> valid identifier character\n              } else {\n                prev = head;\n              }\n\n            }\n            \n            // handle parent list and tokenized expression\n            if (/[a-zA-Z0-9_]/.test(head)) {\n              \n              if (tmpexpression !== '') {\n                parsedTokenizedExpression.push(tmpexpression);\n                tmpexpression = '';\n              }\n              \n              if (parsedExpression.length === 1) {\n                if (id === head) {\n                  err.name = 'SelfDependency';\n                  err.message = 'failed dependency expression validation (agent self dependency)';\n                  return err;\n                } else {\n                  parentList.push(head); \n                  parsedTokenizedExpression.push(head);\n                }\n              } else {\n                if (i === parsedExpression.length - 1) {\n                  tmpparent = tmpparent + head;\n                  if (id === tmpparent) {\n                    err.name = 'SelfDependency';\n                    err.message = 'failed dependency expression validation (agent self dependency)';\n                    return err;\n                  } else {  \n                    parentList.push(tmpparent); \n                    parsedTokenizedExpression.push(tmpparent);\n                  }\n                } else {\n                  tmpparent = tmpparent + head;\n                }\n              }\n              \n            } else {\n              if (tmpparent !== '') {\n                if (id === tmpparent) {\n                  err.name = 'SelfDependency';\n                  err.message = 'failed dependency expression validation (agent self dependency)';\n                  return err;\n                } else {\n                  parentList.push(tmpparent);\n                  parsedTokenizedExpression.push(tmpparent);\n                  tmpparent = '';\n                }\n              }\n              tmpexpression = tmpexpression + head;\n              if (i === parsedExpression.length - 1) {\n                parsedTokenizedExpression.push(tmpexpression);\n              }\n            }\n          \n          }\n        expression = parsedExpression;\n        tokenizedExpression = parsedTokenizedExpression;\n        dependencies = arrayGetUniques(parentList); \n      } else {\n        err.name = 'InvalidExpression';\n        err.message = 'failed dependency expression validation (please use underscore, alphanumeric and logical chars)';\n        return err;\n      }\n    } else {\n      expression = '';\n      dependencies = []; \n      tokenizedExpression = [];\n    }\n\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "If you hit return in the main input field, create new **Todo** model, persisting it to *localStorage*. [SEP] function( e ) {\n        if ( e.which !== common.ENTER_KEY || !this.input.val().trim() ) {\n            return;\n        }\n\n        todos.create( this.newAttributes() );\n        this.input.val('');\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "/--- API [SEP] function Parser(options) {\n  assert.object(options);\n  assert.object(options.log);\n\n  EventEmitter.call(this);\n\n  this.buffer = null;\n  this.log = options.log;\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get balance\n\n@param callback\n@param currency [SEP] function getBalance(callback, currency){\n    if (currency === undefined) {\n        var url = 'balance';\n    } else {\n        var url =  'balance/' + currency.toUpperCase();\n    }\n    sendRequest( url, 'GET', {}, true, callback );\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The main function. Pass an array of filepaths,\nand a string or array of glob patterns\n\n@param  {Array|String} `files`\n@param  {Array|String} `patterns`\n@param  {Object} `opts`\n@return {Array} Array of matches [SEP] function micromatch(files, patterns, opts) {\n  if (!files || !patterns) return [];\n  opts = opts || {};\n\n  if (typeof opts.cache === 'undefined') {\n    opts.cache = true;\n  }\n\n  if (!Array.isArray(patterns)) {\n    return match(files, patterns, opts);\n  }\n\n  var len = patterns.length, i = 0;\n  var omit = [], keep = [];\n\n  while (len--) {\n    var glob = patterns[i++];\n    if (typeof glob === 'string' && glob.charCodeAt(0) === 33 /* ! */) {\n      omit.push.apply(omit, match(files, glob.slice(1), opts));\n    } else {\n      keep.push.apply(keep, match(files, glob, opts));\n    }\n  }\n  return utils.diff(keep, omit);\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Uses variable sandbox for create replacement map\n\n@param {Object} ast toplevel AST\n\n@return {Object} {name: replaceName} map [SEP] function getSandboxMap(ast) {\n        var map = {};\n\n        walker.with_walkers({\n            // looking for first var with sandbox item;\n            \"var\" : function (vars) {\n                for (var i = 0, c = vars.length, varItem; i < c; i++) {\n                    varItem = vars[i];\n                    if (varItem[0] === 'sandbox') {\n                        varItem[1][1].forEach(function (objectVar) {\n                            map[objectVar[0]] = objectVar[1][1];\n                        });\n                        throw 0;\n                    }\n                }\n            }\n        }, function () {\n            try {\n                return walker.walk(ast);\n            } catch (e) {}\n        });\n\n        return map;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize and reduce `keyContents` to an `id`, for easier comparison\n@param {String|Number|Backbone.Model} keyContents [SEP] function( keyContents ) {\n\t\t\tthis.keyContents = keyContents;\n\t\t\tthis.keyId = Backbone.Relational.store.resolveIdForItem( this.relatedModel, this.keyContents );\n\t\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Visit `node` with the given `fn` [SEP] function visit(node, fn) {\n  if (!node.visited) {\n    define(node, 'visited', true);\n    return node.nodes ? mapVisit(node.nodes, fn) : fn(node);\n  }\n  return node;\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates the sliders thumbs with their new value(s) [SEP] function(newValue, oldValue) {\n        var thumbs = this.getThumbs(),\n            ln = newValue.length,\n            minValue = this.getMinValue(),\n            offset = this.offsetValueRatio,\n            i;\n\n        this.setThumbsCount(ln);\n\n        for (i = 0; i < ln; i++) {\n            thumbs[i].getDraggable().setExtraConstraint(null).setOffset((newValue[i] - minValue) * offset);\n        }\n\n        for (i = 0; i < ln; i++) {\n            this.refreshThumbConstraints(thumbs[i]);\n        }\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Parses the generator fields and get the latest values.\n@private [SEP] function() {\n\t\treturn {\n\t\t\theader:    titleTab.getTabData(),\n\t\t\tfooter:    footerTab.getTabData(),\n\t\t\tsize:      sizeTab.getTabData(),\n\t\t\tdata:      dataTab.getTabData(),\n\t\t\tlabels:    labelsTab.getTabData(),\n\t\t\ttooltips:  tooltipsTab.getTabData(),\n\t\t\teffects:   effectsTab.getTabData(),\n\t\t\tcallbacks: eventsTab.getTabData(),\n\t\t\tmisc:      miscTab.getTabData()\n\t\t};\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Set up the child view event forwarding. Uses a \"childview:\" prefix in front of all forwarded events. [SEP] function(view) {\n      var prefix = this.getOption('childViewEventPrefix');\n  \n      // Forward all child view events through the parent,\n      // prepending \"childview:\" to the event name\n      this.listenTo(view, 'all', function() {\n        var args = _.toArray(arguments);\n        var rootEvent = args[0];\n        var childEvents = this.normalizeMethods(_.result(this, 'childEvents'));\n  \n        args[0] = prefix + ':' + rootEvent;\n        args.splice(1, 0, view);\n  \n        // call collectionView childEvent if defined\n        if (typeof childEvents !== 'undefined' && _.isFunction(childEvents[rootEvent])) {\n          childEvents[rootEvent].apply(this, args.slice(1));\n        }\n  \n        this.triggerMethod.apply(this, args);\n      });\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Public: Parses a string containing a number.  s - The string to parse.  Returns a number or `null` if parsing fails. [SEP] function parseNumber(s) {\n  s = String(s).replace(/[^\\d-.]/g, '').replace(/\\.$/, '');\n  if (!s.match(NUMBER_RE)) {\n    return null;\n  }\n  return parseFloat(s, 10);\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": ".......................................................... ARRAY OBSERVERS  \nAdds an array observer to the receiving array. The array observer object\nnormally must implement two methods:\n\n`arrayWillChange(observedObj, start, removeCount, addCount)` - This method will be\ncalled just before the array is modified.\n`arrayDidChange(observedObj, start, removeCount, addCount)` - This method will be\ncalled just after the array is modified.\n\nBoth callbacks will be passed the observed object, starting index of the\nchange as well a a count of the items to be removed and added. You can use\nthese callbacks to optionally inspect the array during the change, clear\ncaches, or do any other bookkeeping necessary.\n\nIn addition to passing a target, you can also include an options hash\nwhich you can use to override the method names that will be invoked on the\ntarget.\n\n@method addArrayObserver\n@param {Object} target The observer object.\n@param {Hash} opts Optional hash of configuration options including\n`willChange` and `didChange` option.\n@return {Ember.Array} receiver [SEP] function(target, opts) {\n    var willChange = (opts && opts.willChange) || 'arrayWillChange',\n        didChange  = (opts && opts.didChange) || 'arrayDidChange';\n\n    var hasObservers = get(this, 'hasArrayObservers');\n    if (!hasObservers) Ember.propertyWillChange(this, 'hasArrayObservers');\n    Ember.addListener(this, '@array:before', target, willChange);\n    Ember.addListener(this, '@array:change', target, didChange);\n    if (!hasObservers) Ember.propertyDidChange(this, 'hasArrayObservers');\n    return this;\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load visible elements [SEP] function checkLazyElements() {\n        if (!elements.length) {\n            return;\n        }\n\n        topLazy = Infinity;\n        calcViewport();\n\n        var i = elements.length - 1,\n            srcAttr = options.srcAttr;\n        for (; i >= 0; i--) {\n            var $el = elements[i],\n                el = $el[0];\n\n            // remove items that are not in DOM\n            if (!$.contains(document.documentElement, el)) {\n                elements.splice(i, 1);\n            } else if (!options.visibleOnly || el.offsetWidth > 0 || el.offsetHeight > 0) {\n                var offset = $el.offset(),\n                    elTop = offset.top,\n                    elLeft = offset.left;\n\n                if ((elTop < viewportBottom) && (elTop + $el.height() > viewportTop) &&\n                    (elLeft < viewportRight) && (elLeft + $el.width() > viewportLeft)) {\n\n                    var src = $el.attr(srcAttr);\n                    if (src) {\n                        el.src = src;\n                    }\n\n                    elements.splice(i, 1);\n                } else {\n                    if (elTop < topLazy) {\n                        topLazy = elTop;\n                    }\n                }\n            }\n        }\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "pos is passed in as 0 to 7, 0 on the left, 7 on the right [SEP] function showNumber(addr, num, decimalplaces, mindigits, leftjustified, pos, dontclear) { \n\n\t    if(addr<0 || addr>=maxDevices)\n\t\t\tthrow 'address out of range';\n\t\t\n\t\tnum = formatNumber(num, decimalplaces, mindigits); \n\t\n\t\t// internally, pos is 0 on the right, so we set defaults, and convert\n\t\tif(typeof pos === 'undefined') { \n\t\t\tif(leftjustified) { \n\t\t\t\tpos = 7; \n\t\t\t} else { \n\t\t\t\tpos = 0; \n\t\t\t}\n\t\t} else pos = 7-pos; \n\t\t\n\t\t// get rid of the decimal place but remember where it was\n\t\tvar decimalplace; \n\t\tif(num.indexOf('.')<0) decimalplace = -1; \n\t\telse {\n\t\t\tdecimalplace = num.length - num.indexOf('.') -1; \n\t\t\tnum = num.split('.').join('');\n\t\t}\n\t\tif(leftjustified) { \n\t\t\tpos-=(num.length-1); \n\t\t}\n\t\n\t\tfor(var i = 0; i<8; i++) { \n\t\t\tvar offset = i+pos; \n\t\t\tvar char = num.charAt(num.length-1-i); \n\t\t\t\n\t\t\tif((offset<8 && offset>=0) && (!dontclear || char!='')) \n\t\t\t{\n\t\t\t\tif(char=='-') setChar(addr, offset, char, i>0 && i==decimalplace); \n\t\t\t\telse setDigit(addr, offset, parseInt(char), i>0 && i==decimalplace); \n\t\t\t}\n\t\t}\n\t\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Use 'strong quoting' using single quotes so that we only need\nto deal with nested single quote characters.\nhttp://wiki.bash-hackers.org/syntax/quoting#strong_quoting [SEP] function (value) {\n    var safe = /^[a-z0-9-_/.@%^=:]+$/i\n\n    // Unless `value` is a simple shell-safe string, quote it.\n    if (!safe.test(value)) {\n      return util.format('\\'%s\\'', value.replace(/'/g, \"'\\\\''\"))\n    }\n\n    return value\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Logs a message to help with debugging.\n@param {String} message  Message to log.\n@param {Number} priority Priority of the log message. [SEP] function(message, priority, callerId) {\n        if (!this.getEnabled()) {\n            return this;\n        }\n\n        var statics = Logger,\n            priorities = statics.priorities,\n            priorityValue = priorities[priority],\n            caller = this.log.caller,\n            callerDisplayName = '',\n            writers = this.getWriters(),\n            event, i, originalCaller;\n\n        if (!priority) {\n            priority = 'info';\n        }\n\n        if (priorities[this.getMinPriority()] > priorityValue) {\n            return this;\n        }\n\n        if (!callerId) {\n            callerId = 1;\n        }\n\n        if (Ext.isArray(message)) {\n            message = message.join(\" \");\n        }\n        else {\n            message = String(message);\n        }\n\n        if (typeof callerId == 'number') {\n            i = callerId;\n\n            do {\n                i--;\n\n                caller = caller.caller;\n\n                if (!caller) {\n                    break;\n                }\n\n                if (!originalCaller) {\n                    originalCaller = caller.caller;\n                }\n\n                if (i <= 0 && caller.displayName) {\n                    break;\n                }\n            }\n            while (caller !== originalCaller);\n\n            callerDisplayName = Ext.getDisplayName(caller);\n        }\n        else {\n            caller = caller.caller;\n            callerDisplayName = Ext.getDisplayName(callerId) + '#' + caller.$name;\n        }\n\n        event = {\n            time: Ext.Date.now(),\n            priority: priorityValue,\n            priorityName: priority,\n            message: message,\n            caller: caller,\n            callerDisplayName: callerDisplayName\n        };\n\n        for (i in writers) {\n            if (writers.hasOwnProperty(i)) {\n                writers[i].write(Ext.merge({}, event));\n            }\n        }\n\n        return this;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Simultaneously processes all items in the given array.\n\n@param {array} array - The array to iterate over\n@param {function} iterator - The function to call for each item in the array\n@param {function} done - The function to call when all iterators have completed [SEP] function asyncForEach (array, iterator, done) {\n  if (array.length === 0) {\n    // NOTE: Normally a bad idea to mix sync and async, but it's safe here because\n    // of the way that this method is currently used by DirectoryReader.\n    done();\n    return;\n  }\n\n  // Simultaneously process all items in the array.\n  let pending = array.length;\n  array.forEach(item => {\n    iterator(item, () => {\n      if (--pending === 0) {\n        done();\n      }\n    });\n  });\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Represents a connection to a Cassandra node\n@param {String} endpoint An string containing ip address and port of the host\n@param {Number|null} protocolVersion\n@param {ClientOptions} options\n@extends EventEmitter\n@constructor [SEP] function Connection(endpoint, protocolVersion, options) {\n  events.EventEmitter.call(this);\n  this.setMaxListeners(0);\n\n  if (!options) {\n    throw new Error('options is not defined');\n  }\n\n  /**\n   * Gets the ip and port of the server endpoint.\n   * @type {String}\n   */\n  this.endpoint = endpoint;\n\n  /**\n   * Gets the friendly name of the host, used to identify the connection in log messages.\n   * With direct connect, this is the address and port.\n   * @type {String}\n   */\n  this.endpointFriendlyName = endpoint;\n\n  if (!this.endpoint || this.endpoint.indexOf(':') < 0) {\n    throw new Error('EndPoint must contain the ip address and port separated by : symbol');\n  }\n\n  const portSeparatorIndex = this.endpoint.lastIndexOf(':');\n  this.address = this.endpoint.substr(0, portSeparatorIndex);\n  this.port = this.endpoint.substr(portSeparatorIndex + 1);\n\n  Object.defineProperty(this, \"options\", { value: options, enumerable: false, writable: false});\n\n  if (protocolVersion === null) {\n    // Set initial protocol version\n    protocolVersion = types.protocolVersion.maxSupported;\n    if (options.protocolOptions.maxVersion) {\n      // User provided the protocol version\n      protocolVersion = options.protocolOptions.maxVersion;\n    }\n    // Allow to check version using this connection instance\n    this._checkingVersion = true;\n  }\n\n  this.protocolVersion = protocolVersion;\n  /** @type {Object.<String, OperationState>} */\n  this._operations = {};\n  this._pendingWrites = [];\n  this._preparing = {};\n\n  /**\n   * The timeout state for the idle request (heartbeat)\n   */\n  this._idleTimeout = null;\n  this.timedOutOperations = 0;\n  this._streamIds = new StreamIdStack(this.protocolVersion);\n  this._metrics = options.metrics;\n\n  this.encoder = new Encoder(protocolVersion, options);\n  this.keyspace = null;\n  this.emitDrain = false;\n  /**\n   * Determines if the socket is open and startup succeeded, whether the connection can be used to send requests / \n   * receive events\n   */\n  this.connected = false;\n  /**\n   * Determines if the socket can be considered as open\n   */\n  this.isSocketOpen = false;\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Prepare pipeline by replacing keys with functions or function objects from\nthe collection object, and remove anything that is not functions or function\nobjects.\n@param {array} pipeline - The pipeline definition\n@param {Object} collection - Object with pipeline functions\n@returns {array} Prepared pipeline [SEP] function preparePipeline (pipeline, collection = {}) {\n  pipeline = [].concat(pipeline)\n\n  const replaceWithFunction = (key) => (typeof key === 'string') ? collection[key] : key\n  const isFunctionOrObject = (obj) => obj && ['function', 'object'].includes(typeof obj)\n\n  return pipeline\n    .map(replaceWithFunction)\n    .filter(isFunctionOrObject)\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Enlarge by some integer factor\n\n@param {Number} factor\n@return {Pingy} self [SEP] function(factor) {\n      factor = clamp(to_int(factor), 1);\n\n      var width = this.getWidth() * factor;\n      var height = this.getHeight() * factor;\n\n      var buf = new buffer(width, height);\n\n      for (var y = 0; y < height; y++) {\n        for (var x = 0; x < width; x++) {\n\n          var i = get_index(width, x, y);\n          var rgba = this.getColor(to_int(x / factor), to_int(y / factor));\n\n          buf[i + 0] = rgba.r;\n          buf[i + 1] = rgba.g;\n          buf[i + 2] = rgba.b;\n          buf[i + 3] = rgba.a;\n        }\n      }\n\n      this._png.width = width;\n      this._png.height = height;\n      this._png.data = buf;\n\n      return this;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the list of properties of the given type, augmented with properties from Function if the type has call or construct signatures [SEP] function getAugmentedPropertiesOfType(type) {\n            type = getApparentType(type);\n            var propsByName = createSymbolTable(getPropertiesOfType(type));\n            if (getSignaturesOfType(type, 0 /* Call */).length || getSignaturesOfType(type, 1 /* Construct */).length) {\n                ts.forEach(getPropertiesOfType(globalFunctionType), function (p) {\n                    if (!ts.hasProperty(propsByName, p.name)) {\n                        propsByName[p.name] = p;\n                    }\n                });\n            }\n            return getNamedMembers(propsByName);\n        }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "the heart of the beast [SEP] function() {\n  this.dones = [];\n  this.doneArgs = [];\n  this.fails = [];\n  this.failArgs = [];\n  this.pendings = [];\n  this.pendingArgs = [];\n  this.state = 'pending';\n\n  // expose the promise\n  this.promise = iPromise.call( this );\n\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "LMD require.js() and shortcuts example [SEP] function drawImageOnCanvas(img) {\n    var ctx = $('canvas')[0].getContext('2d');\n\n    ctx.drawImage(img, 0, 0);\n    ctx.rotate(-Math.PI / 12);\n    ctx.translate(0, 150);\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Translate native top level events into event types.\n\n@param {string} topLevelType\n@return {object} [SEP] function getCompositionEventType(topLevelType) {\n  switch (topLevelType) {\n    case TOP_COMPOSITION_START:\n      return eventTypes.compositionStart;\n    case TOP_COMPOSITION_END:\n      return eventTypes.compositionEnd;\n    case TOP_COMPOSITION_UPDATE:\n      return eventTypes.compositionUpdate;\n  }\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Based on http://www.openprocessing.org/visuals/?visualID=6910 [SEP] function() {\n\t\tvar vector = new THREE.Vector3(),\n\t\t\t_acceleration, _width = 500, _height = 500, _depth = 200, _goal, _neighborhoodRadius = 100,\n\t\t\t_maxSpeed = 4, _maxSteerForce = 0.1, _avoidWalls = false;\n\n\t\tthis.position = new THREE.Vector3();\n\t\tthis.velocity = new THREE.Vector3();\n\t\t_acceleration = new THREE.Vector3();\n\n\t\tthis.setGoal = function(target) {\n\t\t\t_goal = target;\n\t\t};\n\n\t\tthis.setAvoidWalls = function(value) {\n\t\t\t_avoidWalls = value;\n\t\t};\n\n\t\tthis.setWorldSize = function(width, height, depth) {\n\t\t\t_width = width;\n\t\t\t_height = height;\n\t\t\t_depth = depth;\n\t\t};\n\n\t\tthis.run = function ( boids ) {\n\t\t\tif (_avoidWalls) {\n\t\t\t\tvector.set(-_width, this.position.y, this.position.z);\n\t\t\t\tvector = this.avoid(vector);\n\t\t\t\tvector.multiplyScalar(5);\n\t\t\t\t_acceleration.add(vector);\n\n\t\t\t\tvector.set(_width, this.position.y, this.position.z);\n\t\t\t\tvector = this.avoid(vector);\n\t\t\t\tvector.multiplyScalar(5);\n\t\t\t\t_acceleration.add(vector);\n\n\t\t\t\tvector.set( this.position.x, - _height, this.position.z);\n\t\t\t\tvector = this.avoid(vector);\n\t\t\t\tvector.multiplyScalar(5);\n\t\t\t\t_acceleration.add(vector);\n\n\t\t\t\tvector.set(this.position.x, _height, this.position.z);\n\t\t\t\tvector = this.avoid(vector);\n\t\t\t\tvector.multiplyScalar(5);\n\t\t\t\t_acceleration.add(vector);\n\n\t\t\t\tvector.set(this.position.x, this.position.y, - _depth);\n\t\t\t\tvector = this.avoid(vector);\n\t\t\t\tvector.multiplyScalar(5);\n\t\t\t\t_acceleration.add(vector);\n\n\t\t\t\tvector.set(this.position.x, this.position.y, _depth);\n\t\t\t\tvector = this.avoid(vector);\n\t\t\t\tvector.multiplyScalar(5);\n\t\t\t\t_acceleration.add(vector);\n\t\t\t}\n\n\t\t\tif (Math.random() > 0.5) {\n\t\t\t\tthis.flock(boids);\n\t\t\t}\n\n\t\t\tthis.move();\n\t\t}\n\n\t\tthis.flock = function(boids) {\n\t\t\tif (_goal) {\n\t\t\t\t_acceleration.add(this.reach(_goal, 0.005));\n\t\t\t}\n\t\t\t_acceleration.add(this.alignment(boids));\n\t\t\t_acceleration.add(this.cohesion(boids));\n\t\t\t_acceleration.add(this.separation(boids));\n\t\t}\n\n\t\tthis.move = function() {\n\t\t\tthis.velocity.add(_acceleration);\n\n\t\t\tvar l = this.velocity.length();\n\t\t\tif (l > _maxSpeed) {\n\t\t\t\tthis.velocity.divideScalar(l / _maxSpeed);\n\t\t\t}\n\n\t\t\tthis.position.add(this.velocity);\n\t\t\t_acceleration.set(0, 0, 0);\n\t\t}\n\n\t\tthis.checkBounds = function() {\n\t\t\tif (this.position.x >   _width) this.position.x = - _width;\n\t\t\tif (this.position.x < - _width) this.position.x =   _width;\n\t\t\tif (this.position.y >   _height) this.position.y = - _height;\n\t\t\tif (this.position.y < - _height) this.position.y =  _height;\n\t\t\tif (this.position.z >  _depth) this.position.z = - _depth;\n\t\t\tif (this.position.z < - _depth) this.position.z =  _depth;\n\t\t}\n\n\t\tthis.avoid = function(target) {\n\t\t\tvar steer = new THREE.Vector3();\n\t\t\tsteer.copy(this.position);\n\t\t\tsteer.sub(target);\n\t\t\tsteer.multiplyScalar( 1 / this.position.distanceToSquared(target));\n\n\t\t\treturn steer;\n\t\t}\n\n\t\tthis.repulse = function(target) {\n\t\t\tvar distance = this.position.distanceTo(target);\n\n\t\t\tif (distance < 150) {\n\t\t\t\tvar steer = new THREE.Vector3();\n\n\t\t\t\tsteer.subVectors( this.position, target );\n\t\t\t\tsteer.multiplyScalar( 0.5 / distance );\n\n\t\t\t\t_acceleration.add( steer );\n\t\t\t}\n\t\t}\n\n\t\tthis.reach = function(target, amount) {\n\t\t\tvar steer = new THREE.Vector3();\n\t\t\tsteer.subVectors(target, this.position);\n\t\t\tsteer.multiplyScalar(amount);\n\n\t\t\treturn steer;\n\t\t}\n\n\t\tthis.alignment = function(boids) {\n\t\t\tvar boid, velSum = new THREE.Vector3(),\n\t\t\t\tcount = 0;\n\n\t\t\tfor (var i = 0, il = boids.length; i < il; i++) {\n\t\t\t\tif ( Math.random() > 0.6) continue;\n\n\t\t\t\tboid = boids[i];\n\t\t\t\tdistance = boid.position.distanceTo(this.position);\n\n\t\t\t\tif (distance > 0 && distance <= _neighborhoodRadius) {\n\t\t\t\t\tvelSum.add(boid.velocity);\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (count > 0) {\n\t\t\t\tvelSum.divideScalar(count);\n\n\t\t\t\tvar l = velSum.length();\n\t\t\t\tif (l > _maxSteerForce) {\n\t\t\t\t\tvelSum.divideScalar(l / _maxSteerForce);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn velSum;\n\t\t}\n\n\t\tthis.cohesion = function(boids) {\n\t\t\tvar boid, distance,\n\t\t\t\tposSum = new THREE.Vector3(),\n\t\t\t\tsteer = new THREE.Vector3(),\n\t\t\t\tcount = 0;\n\n\t\t\tfor (var i = 0, il = boids.length; i < il; i++) {\n\t\t\t\tif (Math.random() > 0.6) continue;\n\n\t\t\t\tboid = boids[i];\n\t\t\t\tdistance = boid.position.distanceTo( this.position);\n\n\t\t\t\tif (distance > 0 && distance <= _neighborhoodRadius) {\n\t\t\t\t\tposSum.add( boid.position );\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (count > 0) {\n\t\t\t\tposSum.divideScalar( count );\n\t\t\t}\n\n\t\t\tsteer.subVectors( posSum, this.position );\n\n\t\t\tvar l = steer.length();\n\t\t\tif (l > _maxSteerForce) {\n\t\t\t\tsteer.divideScalar(l / _maxSteerForce);\n\t\t\t}\n\n\t\t\treturn steer;\n\t\t}\n\n\t\tthis.separation = function(boids) {\n\t\t\tvar boid, distance,\n\t\t\t\tposSum = new THREE.Vector3(),\n\t\t\t\trepulse = new THREE.Vector3();\n\n\t\t\tfor (var i = 0, il = boids.length; i < il; i++) {\n\t\t\t\tif (Math.random() > 0.6) continue;\n\n\t\t\t\tboid = boids[i];\n\t\t\t\tdistance = boid.position.distanceTo(this.position);\n\n\t\t\t\tif (distance > 0 && distance <= _neighborhoodRadius) {\n\t\t\t\t\trepulse.subVectors( this.position, boid.position );\n\t\t\t\t\trepulse.normalize();\n\t\t\t\t\trepulse.divideScalar( distance );\n\t\t\t\t\tposSum.add( repulse );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn posSum;\n\t\t}\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Internal: Processes recorded property changes by traversing the property dependency graph and forwarding changes to proxy objects. [SEP] function propagateChanges() {\n  var seen = {};\n  var head = void 0;\n\n  for (var id in changedObjects) {\n    var _changedObjects$id = changedObjects[id],\n        object = _changedObjects$id.object,\n        props = _changedObjects$id.props;\n\n    for (var k in props) {\n      head = { object: object, name: k, next: head };\n      seen[id + k] = true;\n    }\n  }\n\n  while (head) {\n    var _head = head,\n        name = _head.name,\n        object = _head.object,\n        _head$object = _head.object,\n        _objectId = _head$object.objectId,\n        __deps__ = _head$object.__deps__,\n        __proxies__ = _head$object.__proxies__;\n\n    var deps = __deps__ && __deps__[name];\n\n    head = head.next;\n\n    registerChange(object, name);\n\n    if (object.__cache__) {\n      var val = object.__cache__[name];\n      if (val && typeof val.unproxy === 'function') {\n        val.unproxy(object, name);\n      }\n      delete object.__cache__[name];\n    }\n\n    if (deps) {\n      for (var i = 0, n = deps.length; i < n; i++) {\n        var seenKey = _objectId + deps[i];\n\n        if (!seen[seenKey]) {\n          head = { object: object, name: deps[i], next: head };\n          seen[seenKey] = true;\n        }\n      }\n    }\n\n    if (__proxies__ && name.indexOf('.') === -1) {\n      for (var _k in __proxies__) {\n        var proxy = __proxies__[_k];\n        var proxyObject = proxy.object;\n        var proxyName = proxy.name + '.' + name;\n        var proxySeenKey = proxyObject.objectId + proxyName;\n\n        if (!seen[proxySeenKey]) {\n          head = { object: proxyObject, name: proxyName, next: head };\n          seen[proxySeenKey] = true;\n        }\n      }\n    }\n  }\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "maximum bit length of any code [SEP] function InfTree() {\n\t\tvar that = this;\n\n\t\tvar hn; // hufts used in space\n\t\tvar v; // work area for huft_build\n\t\tvar c; // bit length count table\n\t\tvar r; // table entry for structure assignment\n\t\tvar u; // table stack\n\t\tvar x; // bit offsets, then code stack\n\n\t\tfunction huft_build(b, // code lengths in bits (all assumed <=\n\t\t// BMAX)\n\t\tbindex, n, // number of codes (assumed <= 288)\n\t\ts, // number of simple-valued codes (0..s-1)\n\t\td, // list of base values for non-simple codes\n\t\te, // list of extra bits for non-simple codes\n\t\tt, // result: starting table\n\t\tm, // maximum lookup bits, returns actual\n\t\thp,// space for trees\n\t\thn,// hufts used in space\n\t\tv // working area: values in order of bit length\n\t\t) {\n\t\t\t// Given a list of code lengths and a maximum table size, make a set of\n\t\t\t// tables to decode that set of codes. Return Z_OK on success,\n\t\t\t// Z_BUF_ERROR\n\t\t\t// if the given code set is incomplete (the tables are still built in\n\t\t\t// this\n\t\t\t// case), Z_DATA_ERROR if the input is invalid (an over-subscribed set\n\t\t\t// of\n\t\t\t// lengths), or Z_MEM_ERROR if not enough memory.\n\n\t\t\tvar a; // counter for codes of length k\n\t\t\tvar f; // i repeats in table every f entries\n\t\t\tvar g; // maximum code length\n\t\t\tvar h; // table level\n\t\t\tvar i; // counter, current code\n\t\t\tvar j; // counter\n\t\t\tvar k; // number of bits in current code\n\t\t\tvar l; // bits per table (returned in m)\n\t\t\tvar mask; // (1 << w) - 1, to avoid cc -O bug on HP\n\t\t\tvar p; // pointer into c[], b[], or v[]\n\t\t\tvar q; // points to current table\n\t\t\tvar w; // bits before this table == (l * h)\n\t\t\tvar xp; // pointer into x\n\t\t\tvar y; // number of dummy codes added\n\t\t\tvar z; // number of entries in current table\n\n\t\t\t// Generate counts for each bit length\n\n\t\t\tp = 0;\n\t\t\ti = n;\n\t\t\tdo {\n\t\t\t\tc[b[bindex + p]]++;\n\t\t\t\tp++;\n\t\t\t\ti--; // assume all entries <= BMAX\n\t\t\t} while (i !== 0);\n\n\t\t\tif (c[0] == n) { // null input--all zero length codes\n\t\t\t\tt[0] = -1;\n\t\t\t\tm[0] = 0;\n\t\t\t\treturn Z_OK;\n\t\t\t}\n\n\t\t\t// Find minimum and maximum length, bound *m by those\n\t\t\tl = m[0];\n\t\t\tfor (j = 1; j <= BMAX; j++)\n\t\t\t\tif (c[j] !== 0)\n\t\t\t\t\tbreak;\n\t\t\tk = j; // minimum code length\n\t\t\tif (l < j) {\n\t\t\t\tl = j;\n\t\t\t}\n\t\t\tfor (i = BMAX; i !== 0; i--) {\n\t\t\t\tif (c[i] !== 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tg = i; // maximum code length\n\t\t\tif (l > i) {\n\t\t\t\tl = i;\n\t\t\t}\n\t\t\tm[0] = l;\n\n\t\t\t// Adjust last length count to fill out codes, if needed\n\t\t\tfor (y = 1 << j; j < i; j++, y <<= 1) {\n\t\t\t\tif ((y -= c[j]) < 0) {\n\t\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((y -= c[i]) < 0) {\n\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t}\n\t\t\tc[i] += y;\n\n\t\t\t// Generate starting offsets into the value table for each length\n\t\t\tx[1] = j = 0;\n\t\t\tp = 1;\n\t\t\txp = 2;\n\t\t\twhile (--i !== 0) { // note that i == g from above\n\t\t\t\tx[xp] = (j += c[p]);\n\t\t\t\txp++;\n\t\t\t\tp++;\n\t\t\t}\n\n\t\t\t// Make a table of values in order of bit lengths\n\t\t\ti = 0;\n\t\t\tp = 0;\n\t\t\tdo {\n\t\t\t\tif ((j = b[bindex + p]) !== 0) {\n\t\t\t\t\tv[x[j]++] = i;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t} while (++i < n);\n\t\t\tn = x[g]; // set n to length of v\n\n\t\t\t// Generate the Huffman codes and for each, make the table entries\n\t\t\tx[0] = i = 0; // first Huffman code is zero\n\t\t\tp = 0; // grab values in bit order\n\t\t\th = -1; // no tables yet--level -1\n\t\t\tw = -l; // bits decoded == (l * h)\n\t\t\tu[0] = 0; // just to keep compilers happy\n\t\t\tq = 0; // ditto\n\t\t\tz = 0; // ditto\n\n\t\t\t// go through the bit lengths (k already is bits in shortest code)\n\t\t\tfor (; k <= g; k++) {\n\t\t\t\ta = c[k];\n\t\t\t\twhile (a-- !== 0) {\n\t\t\t\t\t// here i is the Huffman code of length k bits for value *p\n\t\t\t\t\t// make tables up to required level\n\t\t\t\t\twhile (k > w + l) {\n\t\t\t\t\t\th++;\n\t\t\t\t\t\tw += l; // previous table always l bits\n\t\t\t\t\t\t// compute minimum size table less than or equal to l bits\n\t\t\t\t\t\tz = g - w;\n\t\t\t\t\t\tz = (z > l) ? l : z; // table size upper limit\n\t\t\t\t\t\tif ((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table\n\t\t\t\t\t\t\t// too few codes for\n\t\t\t\t\t\t\t// k-w bit table\n\t\t\t\t\t\t\tf -= a + 1; // deduct codes from patterns left\n\t\t\t\t\t\t\txp = k;\n\t\t\t\t\t\t\tif (j < z) {\n\t\t\t\t\t\t\t\twhile (++j < z) { // try smaller tables up to z bits\n\t\t\t\t\t\t\t\t\tif ((f <<= 1) <= c[++xp])\n\t\t\t\t\t\t\t\t\t\tbreak; // enough codes to use up j bits\n\t\t\t\t\t\t\t\t\tf -= c[xp]; // else deduct codes from patterns\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tz = 1 << j; // table entries for j-bit table\n\n\t\t\t\t\t\t// allocate new table\n\t\t\t\t\t\tif (hn[0] + z > MANY) { // (note: doesn't matter for fixed)\n\t\t\t\t\t\t\treturn Z_DATA_ERROR; // overflow of MANY\n\t\t\t\t\t\t}\n\t\t\t\t\t\tu[h] = q = /* hp+ */hn[0]; // DEBUG\n\t\t\t\t\t\thn[0] += z;\n\n\t\t\t\t\t\t// connect to last table, if there is one\n\t\t\t\t\t\tif (h !== 0) {\n\t\t\t\t\t\t\tx[h] = i; // save pattern for backing up\n\t\t\t\t\t\t\tr[0] = /* (byte) */j; // bits in this table\n\t\t\t\t\t\t\tr[1] = /* (byte) */l; // bits to dump before this table\n\t\t\t\t\t\t\tj = i >>> (w - l);\n\t\t\t\t\t\t\tr[2] = /* (int) */(q - u[h - 1] - j); // offset to this table\n\t\t\t\t\t\t\thp.set(r, (u[h - 1] + j) * 3);\n\t\t\t\t\t\t\t// to\n\t\t\t\t\t\t\t// last\n\t\t\t\t\t\t\t// table\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tt[0] = q; // first table is returned result\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// set up table entry in r\n\t\t\t\t\tr[1] = /* (byte) */(k - w);\n\t\t\t\t\tif (p >= n) {\n\t\t\t\t\t\tr[0] = 128 + 64; // out of values--invalid code\n\t\t\t\t\t} else if (v[p] < s) {\n\t\t\t\t\t\tr[0] = /* (byte) */(v[p] < 256 ? 0 : 32 + 64); // 256 is\n\t\t\t\t\t\t// end-of-block\n\t\t\t\t\t\tr[2] = v[p++]; // simple code is just the value\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr[0] = /* (byte) */(e[v[p] - s] + 16 + 64); // non-simple--look\n\t\t\t\t\t\t// up in lists\n\t\t\t\t\t\tr[2] = d[v[p++] - s];\n\t\t\t\t\t}\n\n\t\t\t\t\t// fill code-like entries with r\n\t\t\t\t\tf = 1 << (k - w);\n\t\t\t\t\tfor (j = i >>> w; j < z; j += f) {\n\t\t\t\t\t\thp.set(r, (q + j) * 3);\n\t\t\t\t\t}\n\n\t\t\t\t\t// backwards increment the k-bit code i\n\t\t\t\t\tfor (j = 1 << (k - 1); (i & j) !== 0; j >>>= 1) {\n\t\t\t\t\t\ti ^= j;\n\t\t\t\t\t}\n\t\t\t\t\ti ^= j;\n\n\t\t\t\t\t// backup over finished tables\n\t\t\t\t\tmask = (1 << w) - 1; // needed on HP, cc -O bug\n\t\t\t\t\twhile ((i & mask) != x[h]) {\n\t\t\t\t\t\th--; // don't need to update q\n\t\t\t\t\t\tw -= l;\n\t\t\t\t\t\tmask = (1 << w) - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Return Z_BUF_ERROR if we were given an incomplete table\n\t\t\treturn y !== 0 && g != 1 ? Z_BUF_ERROR : Z_OK;\n\t\t}\n\n\t\tfunction initWorkArea(vsize) {\n\t\t\tvar i;\n\t\t\tif (!hn) {\n\t\t\t\thn = []; // []; //new Array(1);\n\t\t\t\tv = []; // new Array(vsize);\n\t\t\t\tc = new Int32Array(BMAX + 1); // new Array(BMAX + 1);\n\t\t\t\tr = []; // new Array(3);\n\t\t\t\tu = new Int32Array(BMAX); // new Array(BMAX);\n\t\t\t\tx = new Int32Array(BMAX + 1); // new Array(BMAX + 1);\n\t\t\t}\n\t\t\tif (v.length < vsize) {\n\t\t\t\tv = []; // new Array(vsize);\n\t\t\t}\n\t\t\tfor (i = 0; i < vsize; i++) {\n\t\t\t\tv[i] = 0;\n\t\t\t}\n\t\t\tfor (i = 0; i < BMAX + 1; i++) {\n\t\t\t\tc[i] = 0;\n\t\t\t}\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tr[i] = 0;\n\t\t\t}\n\t\t\t// for(int i=0; i<BMAX; i++){u[i]=0;}\n\t\t\tu.set(c.subarray(0, BMAX), 0);\n\t\t\t// for(int i=0; i<BMAX+1; i++){x[i]=0;}\n\t\t\tx.set(c.subarray(0, BMAX + 1), 0);\n\t\t}\n\n\t\tthat.inflate_trees_bits = function(c, // 19 code lengths\n\t\tbb, // bits tree desired/actual depth\n\t\ttb, // bits tree result\n\t\thp, // space for trees\n\t\tz // for messages\n\t\t) {\n\t\t\tvar result;\n\t\t\tinitWorkArea(19);\n\t\t\thn[0] = 0;\n\t\t\tresult = huft_build(c, 0, 19, 19, null, null, tb, bb, hp, hn, v);\n\n\t\t\tif (result == Z_DATA_ERROR) {\n\t\t\t\tz.msg = \"oversubscribed dynamic bit lengths tree\";\n\t\t\t} else if (result == Z_BUF_ERROR || bb[0] === 0) {\n\t\t\t\tz.msg = \"incomplete dynamic bit lengths tree\";\n\t\t\t\tresult = Z_DATA_ERROR;\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\n\t\tthat.inflate_trees_dynamic = function(nl, // number of literal/length codes\n\t\tnd, // number of distance codes\n\t\tc, // that many (total) code lengths\n\t\tbl, // literal desired/actual bit depth\n\t\tbd, // distance desired/actual bit depth\n\t\ttl, // literal/length tree result\n\t\ttd, // distance tree result\n\t\thp, // space for trees\n\t\tz // for messages\n\t\t) {\n\t\t\tvar result;\n\n\t\t\t// build literal/length tree\n\t\t\tinitWorkArea(288);\n\t\t\thn[0] = 0;\n\t\t\tresult = huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);\n\t\t\tif (result != Z_OK || bl[0] === 0) {\n\t\t\t\tif (result == Z_DATA_ERROR) {\n\t\t\t\t\tz.msg = \"oversubscribed literal/length tree\";\n\t\t\t\t} else if (result != Z_MEM_ERROR) {\n\t\t\t\t\tz.msg = \"incomplete literal/length tree\";\n\t\t\t\t\tresult = Z_DATA_ERROR;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// build distance tree\n\t\t\tinitWorkArea(288);\n\t\t\tresult = huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);\n\n\t\t\tif (result != Z_OK || (bd[0] === 0 && nl > 257)) {\n\t\t\t\tif (result == Z_DATA_ERROR) {\n\t\t\t\t\tz.msg = \"oversubscribed distance tree\";\n\t\t\t\t} else if (result == Z_BUF_ERROR) {\n\t\t\t\t\tz.msg = \"incomplete distance tree\";\n\t\t\t\t\tresult = Z_DATA_ERROR;\n\t\t\t\t} else if (result != Z_MEM_ERROR) {\n\t\t\t\t\tz.msg = \"empty distance tree with lengths\";\n\t\t\t\t\tresult = Z_DATA_ERROR;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\treturn Z_OK;\n\t\t};\n\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fix Raphael display:none tspan dy attribute bug [SEP] function setDy(elem, fontSize, txtYpos) {\n  if ((!ie || ie > 9) && elem.node.firstChild.attributes.dy) {\n    elem.node.firstChild.attributes.dy.value = 0;\n  }\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Max 400k for chartProps [SEP] function validateDataInput(chartProps) {\n\tvar input = chartProps.input.raw;\n\tvar series = chartProps.data;\n\tvar hasDate = chartProps.scale.hasDate;\n\tvar isNumeric = chartProps.scale.isNumeric;\n\tvar type = chartProps.input.type;\n\tvar scale = chartProps.scale;\n\n\tvar inputErrors = [];\n\n\t// Check whether we have input\n\tif (input.length === 0) {\n\t\tinputErrors.push(\"EMPTY\");\n\t\treturn inputErrors;\n\t}\n\n\tif (series.length && !series[0].values[0].entry) {\n\t\t// Check that we have at least 1 value col (i.e. minimum header + 1 data col)\n\t\tinputErrors.push(\"TOO_FEW_SERIES\");\n\t} else if (series.length > 12) {\n\t\t// Check whether there are too many series\n\t\tinputErrors.push(\"TOO_MANY_SERIES\");\n\t}\n\n\t// Whether a column has a different number of values\n\tvar unevenSeries = dataPointTest(\n\t\t\tseries,\n\t\t\tfunction(val) { return val.value !== null ? (val.value === undefined || val.value.length === 0) : false;},\n\t\t\tfunction(empty,vals) { return empty.length !== vals[0].length;}\n\t\t);\n\n\tif (unevenSeries) {\n\t\tinputErrors.push(\"UNEVEN_SERIES\");\n\t}\n\n\t// Whether a column has something that is NaN but is not nothing (blank) or `null`\n\tvar nanSeries = somePointTest(\n\t\t\tseries,\n\t\t\tfunction(val) {\n\t\t\t\treturn (isNaN(val.value) && val.value !== undefined && val.value !== \"\");\n\t\t\t}\n\t\t);\n\n\tif (nanSeries) {\n\t\tinputErrors.push(\"NAN_VALUES\");\n\t}\n\n\t// Are there multiple types of axis entries\n\tvar entryTypes = unique(series[0].values.map(function(d){return typeof d.entry;}));\n\tif(entryTypes.length > 1 && !chartProps.input.type) {\n\t\tinputErrors.push(\"CANT_AUTO_TYPE\");\n\t}\n\n\t//Whether an entry column that is supposed to be a Number is not in fact a number\n\tif(isNumeric || chartProps.input.type == \"numeric\") {\n\t\tvar badNumSeries = somePointTest(\n\t\t\t\tseries,\n\t\t\t\tfunction(val) { return isNaN(val.entry); }\n\t\t\t);\n\n\t\tif (badNumSeries) {\n\t\t\tinputErrors.push(\"NAN_VALUES\");\n\t\t}\n\t}\n\n\t// Whether an entry column that is supposed to be a date is not in fact a date\n\tif(hasDate || chartProps.input.type == \"date\") {\n\t\tvar badDateSeries = somePointTest(\n\t\t\t\tseries,\n\t\t\t\tfunction(val) { return !val.entry.getTime || isNaN(val.entry.getTime()); }\n\t\t\t);\n\n\t\tif (badDateSeries) {\n\t\t\tinputErrors.push(\"NOT_DATES\");\n\t\t}\n\n\t\tvar tz_pattern = /([+-]\\d\\d:*\\d\\d)/gi;\n\t\tvar found_timezones = input.match(tz_pattern);\n\t\tif(found_timezones && found_timezones.length != series[0].values.length) {\n\t\t\tinputErrors.push(\"UNEVEN_TZ\");\n\t\t}\n\t}\n\n\t// Whether a column has numbers that should be divided\n\tvar largeNumbers = somePointTest(\n\t\t\tseries,\n\t\t\tfunction(val) { return Math.floor(val.value).toString().length > 4; },\n\t\t\tfunction(largeNums, vals) { return largeNums.length > 0;}\n\t\t);\n\n\tif (largeNumbers) {\n\t\tinputErrors.push(\"LARGE_NUMBERS\");\n\t}\n\n\t// Whether the number of bytes in chartProps exceeds our defined maximum\n\tif (catchChartMistakes.tooMuchData(chartProps)) {\n\t\tinputErrors.push(\"TOO_MUCH_DATA\");\n\t}\n\n\t// Whether axis ticks divide evenly\n\tif (!catchChartMistakes.axisTicksEven(scale.primaryScale)) {\n\t\tinputErrors.push(\"UNEVEN_TICKS\");\n\t}\n\n\t// Whether axis is missing pref and suf\n\tif (catchChartMistakes.noPrefixSuffix(scale.primaryScale)) {\n\t\tinputErrors.push(\"NO_PREFIX_SUFFIX\");\n\t}\n\n\treturn inputErrors;\n\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Removes absolute paths from JSON output and inject some relevant metadata, e.g. language. [SEP] function(objects, inch_args) {\n  var cwd = process.cwd();\n  var excluded = config.files().excluded || [];\n  var data = {\n    language: 'javascript',\n    client_name: 'inchjs',\n    args: inch_args,\n    client_version: \"\"+inch_config.version,\n    git_repo_url: getGitRepoURL()\n  };\n  if( process.env.TRAVIS ) {\n    data['travis'] = true;\n    data['travis_job_id'] = process.env.TRAVIS_JOB_ID;\n    data['travis_commit'] = process.env.TRAVIS_COMMIT;\n    data['travis_repo_slug'] = process.env.TRAVIS_REPO_SLUG;\n  }\n  data['branch_name'] = getGitBranchName();\n  data['objects'] = objects.filter(includeObjectFilter).map(function(item) {\n        return prepareCodeObject(item, cwd);\n      }).filter(function(item) {\n        return !excludeObjectIfMatch(item, excluded);\n      });\n  return data;\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "An image is a graphic representation of something.\n@see Icon [SEP] function Image(props) {\n  const {\n    avatar,\n    bordered,\n    centered,\n    children,\n    circular,\n    className,\n    content,\n    dimmer,\n    disabled,\n    floated,\n    fluid,\n    hidden,\n    href,\n    inline,\n    label,\n    rounded,\n    size,\n    spaced,\n    verticalAlign,\n    wrapped,\n    ui,\n  } = props\n\n  const classes = cx(\n    useKeyOnly(ui, 'ui'),\n    size,\n    useKeyOnly(avatar, 'avatar'),\n    useKeyOnly(bordered, 'bordered'),\n    useKeyOnly(circular, 'circular'),\n    useKeyOnly(centered, 'centered'),\n    useKeyOnly(disabled, 'disabled'),\n    useKeyOnly(fluid, 'fluid'),\n    useKeyOnly(hidden, 'hidden'),\n    useKeyOnly(inline, 'inline'),\n    useKeyOnly(rounded, 'rounded'),\n    useKeyOrValueAndKey(spaced, 'spaced'),\n    useValueAndKey(floated, 'floated'),\n    useVerticalAlignProp(verticalAlign, 'aligned'),\n    'image',\n    className,\n  )\n  const rest = getUnhandledProps(Image, props)\n  const [imgTagProps, rootProps] = partitionHTMLProps(rest, { htmlProps: htmlImageProps })\n  const ElementType = getElementType(Image, props, () => {\n    if (\n      !_.isNil(dimmer) ||\n      !_.isNil(label) ||\n      !_.isNil(wrapped) ||\n      !childrenUtils.isNil(children)\n    ) {\n      return 'div'\n    }\n  })\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n  if (!childrenUtils.isNil(content)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {content}\n      </ElementType>\n    )\n  }\n\n  if (ElementType === 'img') {\n    return <ElementType {...rootProps} {...imgTagProps} className={classes} />\n  }\n  return (\n    <ElementType {...rootProps} className={classes} href={href}>\n      {Dimmer.create(dimmer, { autoGenerateKey: false })}\n      {Label.create(label, { autoGenerateKey: false })}\n      <img {...imgTagProps} />\n    </ElementType>\n  )\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "清掉 url 的 query 后缀\n\n@inner\n@param {string} url\n@return {string} [SEP] function cleanQuery(url) {\n\n    var query = path.extname(url).split('?')[1];\n\n    if (query && query.length > 0) {\n\n        return url.substr(\n            0,\n            url.length - (query.length + 1)\n        );\n\n    }\n\n    return url;\n\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "heart beat [SEP] function heartBeat(){\n        var isEmpty = true;\n        //process event queue\n        var eventChanges = false;\n        for(var device_id in eventQueue){\n            if(eventQueue[device_id].length > 0){\n                eventChanges = true;\n                if(eventQueue[device_id].length <= conf.max_events){\n                    self.add_request({device_id:device_id, events: eventQueue[device_id]});\n                    eventQueue[device_id] = [];\n                }\n                else{\n                    var events = eventQueue[device_id].splice(0, conf.max_events);\n                    self.add_request({device_id:device_id, events: events});\n                }\n            }\n        }\n        if(eventChanges){\n            isEmpty = false;\n            storeSet(\"cly_bulk_event\", eventQueue);\n        }\n        \n        //process request queue into bulk requests\n        if(requestQueue.length > 0){\n            isEmpty = false;\n            if(requestQueue.length <= conf.bulk_size){\n                toBulkRequestQueue({app_key:conf.app_key, requests: JSON.stringify(requestQueue)});\n                requestQueue = [];\n            }\n            else{\n                var requests = requestQueue.splice(0, conf.bulk_size);\n                toBulkRequestQueue({app_key:conf.app_key, requests: JSON.stringify(requests)});\n            }\n            storeSet(\"cly_req_queue\", requestQueue);\n        }\n        \n        //process bulk request queue\n        if(bulkQueue.length > 0 && readyToProcess && getTimestamp() > failTimeout){\n            isEmpty = false;\n            readyToProcess = false;\n            var params = bulkQueue.shift();\n            log(\"Processing request\", params);\n            makeRequest(params, function(err, params){\n                log(\"Request Finished\", params, err);\n                if(err){\n                    bulkQueue.unshift(params);\n                    failTimeout = getTimestamp() + conf.fail_timeout;\n                }\n                storeSet(\"cly_bulk_queue\", bulkQueue);\n                readyToProcess = true;\n            });\n        }\n        \n        if(isEmpty){\n            empty_count++;\n            if(empty_count === 3){\n                empty_count = 0;\n                if(empty_queue_callback){\n                    empty_queue_callback();\n                }\n            }\n        }\n        \n        if(initiated){\n            setTimeout(heartBeat, conf.interval);\n        }\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A mothod to create a result object out of a resolved object in the db [SEP] function(obj) {\n\t\tvar result = {type : obj.type};\n\t\tthis.getDb().validateFields(obj.type, this.fields);\n\t\tfor(var i = 0; i < this.fields.length; i++) {\n\t\t\tvar fName = this.fields[i];\n\t\t\tresult[fName] = obj[fName];\n\t\t}\n\t\treturn result\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Mix in template helper methods. Looks for a `templateHelpers` attribute, which can either be an object literal, or a function that returns an object literal. All methods and attributes from this object are copies to the object passed in. [SEP] function(target) {\n      target = target || {};\n      var templateHelpers = this.getOption('templateHelpers');\n      templateHelpers = Marionette._getValue(templateHelpers, this);\n      return _.extend(target, templateHelpers);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "/*\ngiven device's describe message figure out if it has\nmissing modules. Rejected value contains missing\ndependencies\n\n@param Object describe - describe message\n@param Promise [SEP] function(describe) {\n\t\tif (!Array.isArray(describe.m)) {\n\t\t\treturn when.reject('no modules in describe message');\n\t\t}\n\n\t\tvar modules = [];\n\t\tvar userModule = null;\n\t\tfor (var i = 0; i < describe.m.length; i++) {\n\t\t\tvar module = new FirmwareModule(describe.m[i]);\n\t\t\t//modules.push(module);\n\n\t\t\tif (module.isUserModule() && module.isMainLocation()) {\n\t\t\t\tuserModule = describe.m[i];\n\t\t\t}\n\t\t}\n\n\t\tif (!userModule) {\n\t\t\treturn when.resolve(\"no user module\");\n\t\t}\n\n\t\t//return this._getModuleFirstDependecy(modules, userModule);\n\n\t\tfor(var i=0;i<userModule.d.length;i++) {\n\t\t\tvar dep = userModule.d[i];\n\n\t\t\tvar deps = this._walkChain(describe.m, dep);\n\t\t\tif (deps && (deps.length > 0)) {\n\t\t\t\t// this function only originally returned one dependency.\n\t\t\t\treturn when.reject([new FirmwareModule(deps[0])]);\n\t\t\t}\n\t\t}\n\n\n//\t\tif (deps && (deps.length > 0)) {\n//\t\t\treturn when.reject(new FirmwareModule(deps[0]));\n//\t\t}\n//\t\telse {\n\t\t\treturn when.resolve(\"nothing missing\");\n//\t\t}\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "(protected) this % n, n < 2^26 [SEP] function bnpModInt(n) {\n  if (n <= 0) return 0\n  var d = this.DV % n,\n    r = (this.s < 0) ? n - 1 : 0\n  if (this.t > 0)\n    if (d == 0) r = this[0] % n\n    else\n      for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n\n  return r\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a Promise that returns a flat list of all the Elm files the given Elm file depends on, based on the modules it loads via `import`. [SEP] function findAllDependencies(file, knownDependencies, sourceDirectories, knownFiles) {\n  if (!knownDependencies) {\n    knownDependencies = [];\n  }\n\n  if (typeof knownFiles === \"undefined\"){\n    knownFiles = [];\n  } else if (knownFiles.indexOf(file) > -1){\n    return knownDependencies;\n  }\n\n  if (sourceDirectories) {\n    return findAllDependenciesHelp(file, knownDependencies, sourceDirectories, knownFiles).then(function(thing){\n      return thing.knownDependencies;\n    });\n  } else {\n    return getBaseDir(file)\n      .then(getElmPackageSourceDirectories)\n      .then(function(newSourceDirs) {\n        return findAllDependenciesHelp(file, knownDependencies, newSourceDirs, knownFiles).then(function(thing){\n          return thing.knownDependencies;\n        });\n      });\n  }\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Takes a plugin sub-class and returns a factory function for generating\ninstances of it.\n\nThis factory function will replace itself with an instance of the requested\nsub-class of Plugin.\n\n@private\n@param   {string} name\nThe name of the plugin.\n\n@param   {Plugin} PluginSubClass\nThe advanced plugin.\n\n@returns {Function} [SEP] function createPluginFactory(name, PluginSubClass) {\n\n  // Add a `name` property to the plugin prototype so that each plugin can\n  // refer to itself by name.\n  PluginSubClass.prototype.name = name;\n\n  return function () {\n    triggerSetupEvent(this, { name: name, plugin: PluginSubClass, instance: null }, true);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var instance = new (Function.prototype.bind.apply(PluginSubClass, [null].concat([this].concat(args))))();\n\n    // The plugin is replaced by a function that returns the current instance.\n    this[name] = function () {\n      return instance;\n    };\n\n    triggerSetupEvent(this, instance.getEventHash());\n\n    return instance;\n  };\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load data from 'url' and store at 'key'\n@param {DataStore} store\n@param {String} key\n@param {String} url\n@param {Object} options\n- {Boolean} abort\n- {Boolean} ignoreQuery\n- {Number} minExpiry\n- {Number} retry\n- {Boolean} staleIfError\n- {Number} timeout\n@returns {Promise} [SEP] function load(store, key, url, options) {\n  const { cacheControl, rejectOnError, retry, timeout } = options;\n\n  options.id = key;\n\n  store.debug('load %s from %s', key, url);\n\n  return agent\n    .get(url, options)\n    .timeout(timeout)\n    .retry(retry)\n    .then(res => {\n      // Abort if already destroyed\n      if (store.destroyed) {\n        throw Error('store destroyed');\n      }\n\n      store.debug('loaded \"%s\" in %dms', key, res.duration);\n\n      // Guard against empty data\n      if (res.body) {\n        // Parse cache-control headers\n        if (res.headers && 'expires' in res.headers) {\n          res.body[store.EXPIRY_KEY] = generateExpiry(res.headers, cacheControl);\n        }\n\n        // Enable handling by not calling inner set()\n        store.set(key, res.body, options);\n      }\n\n      return res;\n    })\n    .catch(err => {\n      // Abort if already destroyed\n      if (store.destroyed) {\n        throw err;\n      }\n\n      store.debug('unable to load \"%s\" from %s', key, url);\n\n      if (rejectOnError) {\n        store.set(key, undefined, options);\n      }\n\n      throw err;\n    });\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Converts configuration declaration to yargs options\n\n@param {ConfigDeclaration} configDeclaration [SEP] function configDeclarationToYargs (yargs, configDeclaration) {\n  _.forOwn(configDeclaration, (parameter, parameterName) => {\n    parameterDeclarationToYargs(yargs, parameterName, parameter)\n  })\n  return yargs\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "detect the pixels that would be scrolled by this wheel event [SEP] function d3_behavior_zoomDelta() {\n\n  // mousewheel events are totally broken!\n  // https://bugs.webkit.org/show_bug.cgi?id=40441\n  // not only that, but Chrome and Safari differ in re. to acceleration!\n  if (!d3_behavior_zoomDiv) {\n    d3_behavior_zoomDiv = d3.select(\"body\").append(\"div\")\n        .style(\"visibility\", \"hidden\")\n        .style(\"top\", 0)\n        .style(\"height\", 0)\n        .style(\"width\", 0)\n        .style(\"overflow-y\", \"scroll\")\n      .append(\"div\")\n        .style(\"height\", \"2000px\")\n      .node().parentNode;\n  }\n\n  var e = d3.event, delta;\n  try {\n    d3_behavior_zoomDiv.scrollTop = 1000;\n    d3_behavior_zoomDiv.dispatchEvent(e);\n    delta = 1000 - d3_behavior_zoomDiv.scrollTop;\n  } catch (error) {\n    delta = e.wheelDelta || (-e.detail * 5);\n  }\n\n  return delta * .005;\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Calls the map function on the passed object with a specified callback. This\nuses `Ember.ArrayPolyfill`'s-map method when necessary.\n\n@method map\n@param {Object} obj The object that should be mapped\n@param {Function} callback The callback to execute\n@param {Object} thisArg Value to use as this when executing *callback*\n\n@return {Array} An array of mapped values. [SEP] function(obj, callback, thisArg) {\n    return obj.map ? obj.map.call(obj, callback, thisArg) : map.call(obj, callback, thisArg);\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A statistic can contain a label to help provide context for the presented value. [SEP] function StatisticLabel(props) {\n  const { children, className, content } = props\n  const classes = cx('label', className)\n  const rest = getUnhandledProps(StatisticLabel, props)\n  const ElementType = getElementType(StatisticLabel, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return the type implied by an object binding pattern [SEP] function getTypeFromObjectBindingPattern(pattern, includePatternInType) {\n            var members = {};\n            ts.forEach(pattern.elements, function (e) {\n                var flags = 4 /* Property */ | 67108864 /* Transient */ | (e.initializer ? 536870912 /* Optional */ : 0);\n                var name = e.propertyName || e.name;\n                var symbol = createSymbol(flags, name.text);\n                symbol.type = getTypeFromBindingElement(e, includePatternInType);\n                symbol.bindingElement = e;\n                members[symbol.name] = symbol;\n            });\n            var result = createAnonymousType(undefined, members, emptyArray, emptyArray, undefined, undefined);\n            if (includePatternInType) {\n                result.pattern = pattern;\n            }\n            return result;\n        }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Public: Creates a controller file & appends any type of controller needed. If no options are passed in it will create all router and CRUD controllers  resName - The {String} name of the resource passed in from command line opts -    The options generated from a Commander command entry. [SEP] function(resName, opts) {\n\n    // TODO ensure resName is always snake case\n    this.contrFile = this.controllerPath + resName + '.js';\n    this.resName = resName;\n    this.opts = opts;\n\n    // if no args passed in, created all routes\n    if (!opts.index && !opts.new && !opts.show && !opts.edit &&\n        !opts.create && !opts.update && !opts.destroy) {\n      this.opts.all = true;\n    }\n\n    this._createBaseController();\n\n    // add a comment line before adding new routes\n    require('./router').appendRoute(resName, 'comment_line');\n\n    // print 'created' if file doesn't exist yet (created on first append)\n    if (!fs.existsSync(this.contrFile)) {\n      console.log('    Created: ' + this.contrFile);\n    }\n\n    // Append Iron Router Controllers\n\n    if (opts.index || opts.all) {\n      this._appendController('index');\n      require('./page').run(this.resName, {index: true});\n    }\n\n    if (opts.new || opts.all) {\n      this._appendController('new');\n      require('./page').run(resName, {'new': true});\n    }\n\n    if (opts.show || opts.all) {\n      this._appendController('show');\n      require('./page').run(resName, {show: true});\n    }\n\n    if (opts.edit || opts.all) {\n      this._appendController('edit');\n      require('./page').run(resName, {edit: true});\n    }\n\n    // Append data Controllers\n\n    if (opts.create || opts.all) {\n      this._appendController('create');\n    }\n\n    if (opts.update || opts.all) {\n      this._appendController('update');\n    }\n\n    if (opts.destroy || opts.all) {\n      this._appendController('destroy');\n    }\n\n    // add blank line to routes.js after controller routes\n    require('./router').appendRoute(null, 'blank_line');\n\n    // instantiate and add namespace for this resource if needed\n    new (require('./namespace'))().add(resName);\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "child_process.execFile(file[, args][, options][, callback]) [SEP] function execFile(options, callback) {\n  return cmd(_.assign(options, { type:'execFile' } ), _.cb(callback))\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generates the Name-Based UUID hashes v3 and v5 according to RFC-4122\nhttps://tools.ietf.org/html/rfc4122#section-4.3\n@param {string} target Hashing target\n@param {string} [namespace] Some name space within which generation occurs\n@param {3|5} [version=5] Version of UUID. Available versions is 3 and 5\naccording to RFC-4122. The version is responsible for the hashing algorithm:\nversion 3 uses MD5, and version 5 uses SHA-1. Default is 5.\n@returns {string} UUID [SEP] function generateUuid(target, namespace, version) {\n  if (typeof target !== 'string') {\n    throw TypeError('Value must be string');\n  }\n\n  if (typeof namespace === 'number') {\n    return generateUuid(target, undefined, namespace);\n  }\n\n  if (version == null) {\n    return generateUuid(target, namespace, 5);\n  }\n\n  if (version !== 3 && version !== 5) {\n    throw TypeError('Version of UUID can be only 3 or 5');\n  }\n\n  // Parsing target chars\n  var charBuffer = lib.stringToCharBuffer(target);\n\n  // TODO: Test namespace for uuid and parse to buffer\n  var namespaceCharBuffer = typeof namespace === 'string' ? lib.stringToCharBuffer(namespace) : EMPTY_UINT8_ARRAY;\n\n  // Concatenation two buffers of strings to one\n  var buffer = lib.concatBuffers(namespaceCharBuffer, charBuffer);\n\n  // Getting hash\n  var hash = version === 3 ? lib.md5Hash(buffer) : lib.sha1Hash(buffer);\n\n  return lib.hashToUuid(hash, version);\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates new Audio node and with necessary event listeners attached\n@param  {Media} media Media object\n@return {Audio}       Audio element [SEP] function createNode (media) {\n    var node = new Audio();\n\n    node.onplay = function () {\n        Media.onStatus(media.id, Media.MEDIA_STATE, Media.MEDIA_STARTING);\n    };\n\n    node.onplaying = function () {\n        Media.onStatus(media.id, Media.MEDIA_STATE, Media.MEDIA_RUNNING);\n    };\n\n    node.ondurationchange = function (e) {\n        Media.onStatus(media.id, Media.MEDIA_DURATION, e.target.duration || -1);\n    };\n\n    node.onerror = function (e) {\n        // Due to media.spec.15 It should return MediaError for bad filename\n        var err = e.target.error.code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED ?\n            { code: MediaError.MEDIA_ERR_ABORTED } :\n            e.target.error;\n\n        Media.onStatus(media.id, Media.MEDIA_ERROR, err);\n    };\n\n    node.onended = function () {\n        Media.onStatus(media.id, Media.MEDIA_STATE, Media.MEDIA_STOPPED);\n    };\n\n    if (media.src) {\n        node.src = media.src;\n    }\n\n    return node;\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The token on the left of the position is the token that strictly includes the position\nor sits to the left of the cursor if it is on a boundary. For example\n\nfo|o               -> will return foo\nfoo <comment> |bar -> will return foo [SEP] function findTokenOnLeftOfPosition(file, position) {\n        // Ideally, getTokenAtPosition should return a token. However, it is currently\n        // broken, so we do a check to make sure the result was indeed a token.\n        var tokenAtPosition = getTokenAtPosition(file, position);\n        if (isToken(tokenAtPosition) && position > tokenAtPosition.getStart(file) && position < tokenAtPosition.getEnd()) {\n            return tokenAtPosition;\n        }\n        return findPrecedingToken(position, file);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "----------- [SEP] function alter_query_object(mode, query_object, alter_params) {\n        const altered_object = Object.assign({}, query_object);\n        const query_keys = Object.keys(query_object);\n        const alter_keys = Object.keys(alter_params);\n        for (const key of alter_keys) {\n            if (query_keys.includes(key)) {\n                const alter_value = alter_params[key];\n                /* eslint-disable indent */\n                const perform_alteration\n                    = 'parse' === mode ? 'function' === typeof alter_value\n                        ? alter_value\n                        : 'function' === typeof alter_value.parse\n                            ? alter_value.parse\n                            : dont_alter\n                    : 'compose' === mode\n                        ? 'function' === typeof alter_value.compose\n                            ? alter_value.compose\n                            : dont_alter\n                    : dont_alter\n                    ;\n                /* eslint-ensable indent */\n                altered_object[key] = perform_alteration(altered_object[key]);\n            }\n        }\n        return altered_object;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A fixed-length storage mechanism for a value (ideally a number) with some statistics methods. Expires oldest values to Input is not type checked, but non-numeric input will be considered NULL WRT the statistical methods. [SEP] function FixedValueHistory(maxLength, initial) {\n  if (!(this instanceof FixedValueHistory))\n    return new FixedValueHistory(maxLength, initial)\n  if (!isNumber(maxLength) || maxLength == 0) {\n    throw new Error(\"maxLength must be a positive number.\")\n  }\n  this.maxLength = Math.floor(+maxLength)\n  if (initial != null) {\n    this.push(initial)\n  }\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Compiles the provided field path to a function that retrieves the value of\nthe field denoted by the field path from the object passed to the function,\nor {@code undefined} if the field does not exist in the object.\n\n@param {string} fieldPath The field path to compile.\n@return {function(*): *} The compiled field getter. [SEP] function compileFieldGetter(fieldPath) {\n  let fields = fieldPath.split(\".\")\n  \n  return (record) => {\n    let value = record\n    \n    for (let field of fields) {\n      if (!(value instanceof Object) || !value.hasOwnProperty(field)) {\n        return undefined\n      }\n      \n      value = value[field]\n    }\n    \n    return value\n  }\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Called automatically by JsDoc Toolkit. [SEP] function publish(symbolSet) {\n\tpublish.conf = {  // trailing slash expected for dirs\n\t\text:         \".html\",\n\t\toutDir:      JSDOC.opt.d || SYS.pwd+\"../out/jsdoc/\",\n\t\ttemplatesDir: JSDOC.opt.t || SYS.pwd+\"../templates/jsdoc/\",\n\t\tstaticDir:   \"static/\",\n\t\tsymbolsDir:  \"symbols/\",\n\t\tsrcDir:      \"symbols/src/\",\n\t\tcssDir:      \"css/\",\n\t\tfontsDir:    \"css/fonts/\",\n\t\tjsDir:       \"javascript/\",\n\t\ttemplateName: \"Codeview\",\n\t\ttemplateVersion: \"1.2\",\n\t\ttemplateLink: \"http://www.thebrightlines.com/2010/05/06/new-template-for-jsdoctoolkit-codeview/\"\n\t};\n\t\n\t// is source output is suppressed, just display the links to the source file\n\tif (JSDOC.opt.s && defined(Link) && Link.prototype._makeSrcLink) {\n\t\tLink.prototype._makeSrcLink = function(srcFilePath) {\n\t\t\treturn \"&lt;\"+srcFilePath+\"&gt;\";\n\t\t}\n\t}\n\t\n\t// create the folders and subfolders to hold the output\n\tIO.mkPath((publish.conf.outDir+publish.conf.cssDir));\n\tIO.mkPath((publish.conf.outDir+publish.conf.fontsDir));\n\tIO.mkPath((publish.conf.outDir+publish.conf.jsDir));\n\tIO.mkPath((publish.conf.outDir+\"symbols/src\").split(\"/\"));\n\t\n\t// used to allow Link to check the details of things being linked to\n\tLink.symbolSet = symbolSet;\n\n\t// create the required templates\n\ttry {\n\t\tvar classTemplate = new JSDOC.JsPlate(publish.conf.templatesDir+\"class.tmpl\");\n\t}\n\tcatch(e) {\n\t\tprint(\"Couldn't create the required templates: \"+e);\n\t\tquit();\n\t}\n\t\n\t// some utility filters\n\tfunction hasNoParent($) {return ($.memberOf == \"\")}\n\tfunction isaFile($) {return ($.is(\"FILE\"))}\n\tfunction isaClass($) {return (($.is(\"CONSTRUCTOR\") || $.isNamespace) && ($.alias != \"_global_\" || !JSDOC.opt.D.noGlobal))}\n\t\n\t// get an array version of the symbolset, useful for filtering\n\tvar symbols = symbolSet.toArray();\n\t\n\t// create the hilited source code files\n\tvar files = JSDOC.opt.srcFiles;\n \tfor (var i = 0, l = files.length; i < l; i++) {\n \t\tvar file = files[i];\n \t\tvar srcDir = publish.conf.outDir + publish.conf.srcDir;\n\t\tmakeSrcFile(file, srcDir);\n \t}\n \t\n \t// get a list of all the classes in the symbolset\n \tpublish.classes = symbols.filter(isaClass).sort(makeSortby(\"alias\"));\n\t\n\t// create a filemap in which outfiles must be to be named uniquely, ignoring case\n\tif (JSDOC.opt.u) {\n\t\tvar filemapCounts = {};\n\t\tLink.filemap = {};\n\t\tfor (var i = 0, l = publish.classes.length; i < l; i++) {\n\t\t\tvar lcAlias = publish.classes[i].alias.toLowerCase();\n\t\t\t\n\t\t\tif (!filemapCounts[lcAlias]) filemapCounts[lcAlias] = 1;\n\t\t\telse filemapCounts[lcAlias]++;\n\t\t\t\n\t\t\tLink.filemap[publish.classes[i].alias] = \n\t\t\t\t(filemapCounts[lcAlias] > 1)?\n\t\t\t\tlcAlias+\"_\"+filemapCounts[lcAlias] : lcAlias;\n\t\t}\n\t}\n\t\n\t// create each of the class pages\n\tfor (var i = 0, l = publish.classes.length; i < l; i++) {\n\t\tvar symbol = publish.classes[i];\n\t\t\n\t\tsymbol.events = symbol.getEvents();   // 1 order matters\n\t\tsymbol.methods = symbol.getMethods(); // 2\n\t\t\n\t\tvar output = \"\";\n\t\toutput = classTemplate.process(symbol);\n\t\t\n\t\tIO.saveFile(publish.conf.outDir+publish.conf.symbolsDir, ((JSDOC.opt.u)? Link.filemap[symbol.alias] : symbol.alias) + publish.conf.ext, output);\n\t}\n\t\n\t// create the class index page\n\ttry {\n\t\tvar classesindexTemplate = new JSDOC.JsPlate(publish.conf.templatesDir+\"allclasses.tmpl\");\n\t}\n\tcatch(e) { print(e.message); quit(); }\n\t\n\tvar classesIndex = classesindexTemplate.process(publish.classes);\n\tIO.saveFile(publish.conf.outDir, (JSDOC.opt.D.index==\"files\"?\"allclasses\":\"index\")+publish.conf.ext, classesIndex);\n\tclassesindexTemplate = classesIndex = classes = null;\n\t\n\t// create the file index page\n\ttry {\n\t\tvar fileindexTemplate = new JSDOC.JsPlate(publish.conf.templatesDir+\"allfiles.tmpl\");\n\t}\n\tcatch(e) { print(e.message); quit(); }\n\t\n\tvar documentedFiles = symbols.filter(isaFile); // files that have file-level docs\n\tvar allFiles = []; // not all files have file-level docs, but we need to list every one\n\t\n\tfor (var i = 0; i < files.length; i++) {\n\t\tallFiles.push(new JSDOC.Symbol(files[i], [], \"FILE\", new JSDOC.DocComment(\"/** */\")));\n\t}\n\t\n\tfor (var i = 0; i < documentedFiles.length; i++) {\n\t\tvar offset = files.indexOf(documentedFiles[i].alias);\n\t\tallFiles[offset] = documentedFiles[i];\n\t}\n\t\t\n\tallFiles = allFiles.sort(makeSortby(\"name\"));\n\n\t// output the file index page\n\tvar filesIndex = fileindexTemplate.process(allFiles);\n\tIO.saveFile(publish.conf.outDir, (JSDOC.opt.D.index==\"files\"?\"index\":\"files\")+publish.conf.ext, filesIndex);\n\tfileindexTemplate = filesIndex = files = null;\n\t\n\t// copy static files\n\tIO.copyFile(publish.conf.templatesDir+\"/\"+publish.conf.cssDir+\"all.css\", publish.conf.outDir+\"/\"+publish.conf.cssDir);\n\tIO.copyFile(publish.conf.templatesDir+\"/\"+publish.conf.cssDir+\"screen.css\", publish.conf.outDir+\"/\"+publish.conf.cssDir);\n\tIO.copyFile(publish.conf.templatesDir+\"/\"+publish.conf.cssDir+\"handheld.css\", publish.conf.outDir+\"/\"+publish.conf.cssDir);\n\tIO.copyFile(publish.conf.templatesDir+\"/\"+publish.conf.jsDir+\"all.js\", publish.conf.outDir+\"/\"+publish.conf.jsDir);\n\tIO.copyFile(publish.conf.templatesDir+\"/\"+publish.conf.jsDir+\"html5.js\", publish.conf.outDir+\"/\"+publish.conf.jsDir);\n\tIO.copyFile(publish.conf.templatesDir+\"/\"+publish.conf.fontsDir+\"mplus-1m-regular-webfont.eot\", publish.conf.outDir+\"/\"+publish.conf.fontsDir);\n\tIO.copyFile(publish.conf.templatesDir+\"/\"+publish.conf.fontsDir+\"mplus-1m-regular-webfont.svg\", publish.conf.outDir+\"/\"+publish.conf.fontsDir);\n\tIO.copyFile(publish.conf.templatesDir+\"/\"+publish.conf.fontsDir+\"mplus-1m-regular-webfont.ttf\", publish.conf.outDir+\"/\"+publish.conf.fontsDir);\n\tIO.copyFile(publish.conf.templatesDir+\"/\"+publish.conf.fontsDir+\"mplus-1m-regular-webfont.woff\", publish.conf.outDir+\"/\"+publish.conf.fontsDir);\n\tIO.copyFile(publish.conf.templatesDir+\"/\"+publish.conf.fontsDir+\"mplus-1m-bold-webfont.eot\", publish.conf.outDir+\"/\"+publish.conf.fontsDir);\n\tIO.copyFile(publish.conf.templatesDir+\"/\"+publish.conf.fontsDir+\"mplus-1m-bold-webfont.svg\", publish.conf.outDir+\"/\"+publish.conf.fontsDir);\n\tIO.copyFile(publish.conf.templatesDir+\"/\"+publish.conf.fontsDir+\"mplus-1m-bold-webfont.ttf\", publish.conf.outDir+\"/\"+publish.conf.fontsDir);\n\tIO.copyFile(publish.conf.templatesDir+\"/\"+publish.conf.fontsDir+\"mplus-1m-bold-webfont.woff\", publish.conf.outDir+\"/\"+publish.conf.fontsDir);\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Public: Parses a string containing a date in the following formats: - YYYY-MM-DD (ISO8601) - MM/DD - MM?DD?YY, where ? is a non-digit character - MM?DD?YYYY, where ? is a non-digit character - MMDDYY - MMDDYYYY  s - The string to parse.  Returns a `Date` or `null` if parsing fails. [SEP] function parseDate(s) {\n  var m, d, y, date, parts;\n\n  s = String(s).replace(/\\s/g, '');\n\n  if (parts = s.match(ISO8601_DATE_RE)) {\n    y = parseInt(parts[1], 10);\n    m = parseInt(parts[2], 10) - 1;\n    d = parseInt(parts[3], 10);\n    date = new Date(y, m, d);\n    return date.getMonth() === m ? date : null;\n  } else if (parts = s.match(MDY_DATE_RE)) {\n    m = parseInt(parts[1], 10) - 1;\n    d = parseInt(parts[2], 10);\n    y = parts[3] ? parseInt(parts[3], 10) : new Date().getFullYear();\n    if (0 <= y && y <= 68) {\n      y += 2000;\n    }\n    if (69 <= y && y <= 99) {\n      y += 1900;\n    }\n    date = new Date(y, m, d);\n    return date.getMonth() === m ? date : null;\n  } else {\n    return null;\n  }\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Coords must be lineSpace-local [SEP] function coordsChar(cm, x, y) {\n    var doc = cm.view.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) return {line: 0, ch: 0, outside: true};\n    var lineNo = lineAtHeight(doc, y);\n    if (lineNo >= doc.size) return {line: doc.size - 1, ch: getLine(doc, doc.size - 1).text.length};\n    if (x < 0) x = 0;\n\n    for (;;) {\n      var lineObj = getLine(doc, lineNo);\n      var found = coordsCharInner(cm, lineObj, lineNo, x, y);\n      var merged = collapsedSpanAtEnd(lineObj);\n      if (merged && found.ch == lineRight(lineObj))\n        lineNo = merged.find().to.line;\n      else\n        return found;\n    }\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "no: adapt, all, size, batch [SEP] function fakeOccamsrazor (hiddenPropertyName, objectPropertyName, globalObj, customAttrs) {\n  return buildFakeObject(hiddenPropertyName, objectPropertyName, globalObj, defaultAttrs.concat(customAttrs))\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Public Functions [SEP] function (tileLayer) {\n    if (this.options.changingMap) {\n      return false;\n    }\n\n    // Check for existing layer\n    if (this._usingTileProjection(tileLayer)) {\n      console.log(\"That tile layer is already active.\");\n    } else {\n      // Drop base tile layers\n      this._dropTileLayers();\n      this._update(tileLayer);\n    }\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Transform a given input value, using a property spec object. propSpec: an object that defines a Backprop property. Supported keys (see the README for explanations) include: 'coerce', 'choices', 'trim', 'max', 'min' inputVal: the value that the caller has assigned to the property fallbackValue (optional): a default value to use if the input is invalid [SEP] function transformValue(propSpec, inputVal, fallbackValue) {\n        var value = inputVal;\n        if (typeof propSpec.coerce === 'function') value = propSpec.coerce(value);\n\n        // If an array of choices was passed in, validate that the input is one of\n        // the valid choices:\n        var choices = propSpec.choices;\n        if (choices && choices.constructor && choices.constructor.name === 'Array') {\n            if (choices.indexOf(value) === -1) {\n                if (fallbackValue !== undefined) value = fallbackValue;\n                else return undefined;\n            }\n        }\n\n        if (propSpec.trim && (typeof value.trim === 'function')) value = value.trim();\n        if (propSpec.max && (value > propSpec.max)) value = propSpec.max;\n        if (propSpec.min && (value < propSpec.min)) value = propSpec.min;\n        return value;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "TODO: make this keyed funcs that accept a `type` param (like \"ordinal\", \"time\", \"linear\") so that we dont have to check every time [SEP] function _ordinalAdjust(scale, value) {\n\tvar isOrdinal = scale.hasOwnProperty(\"bandwidth\");\n\tif (isOrdinal) {\n\t\treturn scale(value) + scale.bandwidth() / 2;\n\t} else {\n\t\treturn scale(value);\n\t}\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Wipes lmd_on, lmd_trigger, lmd_events variables from source\n\n@param {Object} ast\n\n@return {Object} modified ast [SEP] function wipeLmdEvents(ast) {\n        var itemsToWipe = ['lmd_on', 'lmd_trigger', 'lmd_events'];\n\n        return walker.with_walkers({\n            // wipe lmdEvents variables\n            \"var\": function () {\n                if (!itemsToWipe.length) {\n                    return;\n                }\n\n                for (var i = 0, c = this[1].length, varItem; i < c; i++) {\n                    varItem = this[1][i];\n                    if (varItem) {\n                        var itemIndex = itemsToWipe.indexOf(varItem[0]);\n                        if (itemIndex !== -1) {\n                            itemsToWipe.splice(itemIndex, 1);\n                            this[1].splice(i, 1);\n                            i--;\n                        }\n                    }\n                }\n            }\n        }, function () {\n            return walker.walk(ast);\n        });\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks for lib using ldconfig if present, or searching SYSTEM_PATHS\notherwise.\n@param String library name, e.g. 'jpeg' in 'libjpeg64.so' (see first line)\n@return Boolean exists [SEP] function hasSystemLib (lib) {\n  var libName = 'lib' + lib + '.+(so|dylib)'\n  var libNameRegex = new RegExp(libName)\n\n    // Try using ldconfig on linux systems\n  if (hasLdconfig()) {\n    try {\n      if (childProcess.execSync('ldconfig -p 2>/dev/null | grep -E \"' + libName + '\"').length) {\n        return true\n      }\n    } catch (err) {\n      // noop -- proceed to other search methods\n    }\n  }\n\n    // Try checking common library locations\n  return SYSTEM_PATHS.some(function (systemPath) {\n    try {\n      var dirListing = fs.readdirSync(systemPath)\n      return dirListing.some(function (file) {\n        return libNameRegex.test(file)\n      })\n    } catch (err) {\n      return false\n    }\n  })\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tries to create a HooksRunner for passed project root.\n@constructor [SEP] function HooksRunner (projectRoot) {\n    var root = cordovaUtil.isCordova(projectRoot);\n    if (!root) throw new CordovaError('Not a Cordova project (\"' + projectRoot + '\"), can\\'t use hooks.');\n    else this.projectRoot = root;\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a lodash chain that calls .value() automatically after the first .method()  It also returns a promise or value  For example: lowChain(_, array, save).method()  is the same as: _.chain(array).method().value() [SEP] function lowChain(_, array, save) {\n  var chain = _.chain(array);\n\n  _.functionsIn(chain).forEach(function (method) {\n    chain[method] = _.flow(chain[method], function (arg) {\n      var v = void 0;\n      if (arg) {\n        v = _.isFunction(arg.value) ? arg.value() : arg;\n      }\n\n      var s = save();\n\n      if (s) return s.then(function () {\n        return Promise.resolve(v);\n      });\n      return v;\n    });\n  });\n\n  return chain;\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Aggregates all module wrappers\n\n@param code\n@param moduleOptions\n@param moduleType\n\n@return {String} [SEP] function (code, moduleOptions, moduleType) {\n    switch (moduleType) {\n        case \"3-party\":\n            // create lmd module from non-lmd module\n            code = wrap3partyModule(code, moduleOptions);\n            break;\n\n        case \"plain\":\n            // wrap plain module\n            code = wrapPlainModule(code);\n            break;\n\n        case \"amd\":\n            // AMD RequireJS\n            code = wrapAmdModule(code);\n            break;\n\n        case \"fd\":\n        case \"fe\":\n            // wipe tail ;\n            code = removeTailSemicolons(code);\n    }\n\n    return code;\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "@typedef {Object} tabOverride.utils~listenersObj\n\n@property {Function} add     Adds all the event listeners to the\nspecified element\n@property {Function} remove  Removes all the event listeners from\nthe specified element\n \nCreates functions to add and remove event listeners in a cross-browser\ncompatible way.\n\n@param  {tabOverride.utils~handlerObj[]} handlerList  an array of {@link tabOverride.utils~handlerObj handlerObj} objects\n@return {tabOverride.utils~listenersObj}              a listenersObj object used to add and remove the event listeners\n\n@method tabOverride.utils.createListeners [SEP] function createListeners(handlerList) {\n        var i,\n            len = handlerList.length,\n            remove,\n            add;\n\n        function loop(func) {\n            for (i = 0; i < len; i += 1) {\n                func(handlerList[i].type, handlerList[i].handler);\n            }\n        }\n\n        // use the standard event handler registration method when available\n        if (document.addEventListener) {\n            remove = function (elem) {\n                loop(function (type, handler) {\n                    elem.removeEventListener(type, handler, false);\n                });\n            };\n            add = function (elem) {\n                // remove listeners before adding them to make sure they are not\n                // added more than once\n                remove(elem);\n                loop(function (type, handler) {\n                    elem.addEventListener(type, handler, false);\n                });\n            };\n        } else if (document.attachEvent) {\n            // support IE 6-8\n            remove = function (elem) {\n                loop(function (type, handler) {\n                    elem.detachEvent('on' + type, handler);\n                });\n            };\n            add = function (elem) {\n                remove(elem);\n                loop(function (type, handler) {\n                    elem.attachEvent('on' + type, handler);\n                });\n            };\n        }\n\n        return {\n            add: add,\n            remove: remove\n        };\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Construct a `MockDate` using a `Date` constructor value. [SEP] function MockDate (value) {\n  // A MockDate constructs an inner date and exposes its methods.\n  var innerDate\n  // If a value is specified, use it to construct a real date.\n  if (arguments.length) {\n    innerDate = new timers.Date(value)\n\n  // If time isn't currently mocked, construct a real date for the real time.\n  } else if (global.Date === timers.Date) {\n    innerDate = new timers.Date()\n\n  // If there's no value and time is mocked, use the current mock time.\n  } else {\n    innerDate = new timers.Date(mock.time._CURRENT_TIME)\n  }\n  Object.defineProperty(this, '_INNER_DATE', {\n    enumerable: false,\n    value: innerDate\n  })\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Retrieves a list of channels the document belongs to based on its specified type [SEP] function getAllDocChannels(docDefinition) {\n    var docChannelMap = utils.resolveDocumentConstraint(docDefinition.channels);\n\n    var allChannels = [ ];\n    if (docChannelMap) {\n      appendToAuthorizationList(allChannels, docChannelMap.view);\n      appendToAuthorizationList(allChannels, docChannelMap.write);\n      appendToAuthorizationList(allChannels, docChannelMap.add);\n      appendToAuthorizationList(allChannels, docChannelMap.replace);\n      appendToAuthorizationList(allChannels, docChannelMap.remove);\n    }\n\n    return allChannels;\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Remove the child view and destroy it. This function also updates the indices of later views in the collection in order to keep the children in sync with the collection. [SEP] function(view) {\n      if (!view) { return view; }\n  \n      this.triggerMethod('before:remove:child', view);\n  \n      if (!view.supportsDestroyLifecycle) {\n        Marionette.triggerMethodOn(view, 'before:destroy', view);\n      }\n      // call 'destroy' or 'remove', depending on which is found\n      if (view.destroy) {\n        view.destroy();\n      } else {\n        view.remove();\n      }\n      if (!view.supportsDestroyLifecycle) {\n        Marionette.triggerMethodOn(view, 'destroy', view);\n      }\n  \n      delete view._parent;\n      this.stopListening(view);\n      this.children.remove(view);\n      this.triggerMethod('remove:child', view);\n  \n      // decrement the index of views after this one\n      this._updateIndices(view, false);\n  \n      return view;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Scopes the url to the season\n\n@param {Object} options\n@returns {String}\n@api public [SEP] function scopeUrl(options, inst) {\n    options = _.extend({}, inst, options)\n    if (!options.season_id)\n      throw new Error('season_id required to make division instance api calls')\n\n    return ngin.Season.urlRoot() + '/' + options.season_id + Division.urlRoot()\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "helper method for deprecating a property [SEP] function(property, obj, newProperty) {\n                if (config.hasOwnProperty(property)) {\n                    if (obj) {\n                        config[obj] = config[obj] || {};\n                        config[obj][(newProperty) ? newProperty : property] = config[obj][(newProperty) ? newProperty : property] || config[property];\n                    } else {\n                        config[newProperty] = config[property];\n                    }\n\n                    delete config[property];\n\n                    //<debug warn>\n                    Ext.Logger.deprecate(\"'\" + property + \"' config is deprecated, use the '\" + ((obj) ? obj + \".\" : \"\") + ((newProperty) ? newProperty : property) + \"' config instead\", 2);\n                    //</debug>\n                }\n            }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "设置 Editor.md 的整体主题，主要是工具栏\nSetting Editor.md theme\n\n@returns {editormd}  返回editormd的实例对象 [SEP] function(theme) {\r\n            var editor      = this.editor;\r\n            var oldTheme    = this.settings.theme;\r\n            var themePrefix = this.classPrefix + \"theme-\";\r\n            \r\n            editor.removeClass(themePrefix + oldTheme).addClass(themePrefix + theme);\r\n            \r\n            this.settings.theme = theme;\r\n            \r\n            return this;\r\n        }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Bind all dropdown [SEP] function init() {\n    $(document).on('click', '.toggle-dropdown', toggleDropdown);\n    $(document).on('click', '.dropdown-menu', function(e){ e.stopPropagation(); });\n    $(document).on('click', closeDropdown);\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "constructor: \nApplies a box blur to DisplayObjects. Note that this filter is fairly CPU intensive, particularly if the quality is\nset higher than 1.\n\n<h4>Example</h4>\nThis example creates a red circle, and then applies a 5 pixel blur to it. It uses the {{#crossLink \"Filter/getBounds\"}}{{/crossLink}}\nmethod to account for the spread that the blur causes.\n\nvar shape = new createjs.Shape().set({x:100,y:100});\nshape.graphics.beginFill(\"#ff0000\").drawCircle(0,0,50);\n\nvar blurFilter = new createjs.BlurFilter(5, 5, 1);\nshape.filters = [blurFilter];\nvar bounds = blurFilter.getBounds();\n\nshape.cache(-50+bounds.x, -50+bounds.y, 100+bounds.width, 100+bounds.height);\n\nSee {{#crossLink \"Filter\"}}{{/crossLink}} for an more information on applying filters.\n@class BlurFilter\n@extends Filter\n@constructor\n@param {Number} [blurX=0] The horizontal blur radius in pixels.\n@param {Number} [blurY=0] The vertical blur radius in pixels.\n@param {Number} [quality=1] The number of blur iterations. [SEP] function BlurFilter( blurX, blurY, quality) {\n\t\tthis.Filter_constructor();\n\n\t\t// public properties:\n\t\t/**\n\t\t * Horizontal blur radius in pixels\n\t\t * @property blurX\n\t\t * @default 0\n\t\t * @type Number\n\t\t **/\n\t\tthis._blurX = blurX;\n\t\tthis._blurXTable = [];\n\n\t\t/**\n\t\t * Vertical blur radius in pixels\n\t\t * @property blurY\n\t\t * @default 0\n\t\t * @type Number\n\t\t **/\n\t\tthis._blurY = blurY;\n\t\tthis._blurYTable = [];\n\n\t\t/**\n\t\t * Number of blur iterations. For example, a value of 1 will produce a rough blur. A value of 2 will produce a\n\t\t * smoother blur, but take twice as long to run.\n\t\t * @property quality\n\t\t * @default 1\n\t\t * @type Number\n\t\t **/\n\t\tthis._quality;\n\n\t\t/**\n\t\t * This is a template to generate the shader for {{#crossLink FRAG_SHADER_BODY}}{{/crossLink}}\n\t\t */\n\t\tthis.FRAG_SHADER_TEMPLATE = (\n\t\t\t\"uniform float xWeight[{{blurX}}];\" +\n\t\t\t\"uniform float yWeight[{{blurY}}];\" +\n\t\t\t\"uniform vec2 textureOffset;\" +\n\t\t\t\"void main(void) {\" +\n\t\t\t\t\"vec4 color = vec4(0.0);\" +\n\n\t\t\t\t\"float xAdj = ({{blurX}}.0-1.0)/2.0;\" +\n\t\t\t\t\"float yAdj = ({{blurY}}.0-1.0)/2.0;\" +\n\t\t\t\t\"vec2 sampleOffset;\" +\n\n\t\t\t\t\"for(int i=0; i<{{blurX}}; i++) {\" +\n\t\t\t\t\t\"for(int j=0; j<{{blurY}}; j++) {\" +\n\t\t\t\t\t\t\"sampleOffset = vRenderCoord + (textureOffset * vec2(float(i)-xAdj, float(j)-yAdj));\" +\n\t\t\t\t\t\t\"color += texture2D(uSampler, sampleOffset) * (xWeight[i] * yWeight[j]);\" +\n\t\t\t\t\t\"}\" +\n\t\t\t\t\"}\" +\n\n\t\t\t\t\"gl_FragColor = color.rgba;\" +\n\t\t\t\"}\"\n\t\t);\n\n\t\t// update the filter using the setters\n\t\tif(isNaN(quality) || quality < 1){ quality = 1; }\n\t\tthis.setQuality(quality|0);\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Filter summary with a list of path [SEP] function filterSummary(paths) {\n    var $summary = $('.book-summary');\n\n    $summary.find('li').each(function() {\n        var path = $(this).data('path');\n        var st = paths == null || paths.indexOf(path) !== -1;\n\n        $(this).toggle(st);\n        if (st) $(this).parents('li').show();\n    });\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Read keyword entries inside a keyword block and fill KEY_TABLE.\n@param scanner scanner object to read key entries, which starts at begining of target key block\n@param kdx corresponding keyword index object\nNOTE: no need to read keyword block anymore, for debug only. [SEP] function read_key_block(scanner, kdx) {\n      var scanner = scanner.readBlock(kdx.comp_size, kdx.decomp_size);\n      for (var i = 0; i < kdx.num_entries; i++) {\n//        scanner.readNum(); scanner.readText();\n        var kk = [scanner.readNum(), scanner.readText()];\n      }\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Promise wrapper for exec, execFile\n\n@param {String} method\n@param {...*} args\n@return {Promise} [SEP] function doExec(method, args) {\n    var cp;\n    var cpPromise = new ChildProcessPromise();\n    var reject = cpPromise._cpReject;\n    var resolve = cpPromise._cpResolve;\n\n    var finalArgs = slice.call(args, 0);\n    finalArgs.push(callback);\n\n    cp = child_process[method].apply(child_process, finalArgs);\n\n    function callback(err, stdout, stderr) {\n        if (err) {\n            var commandStr = args[0] + (Array.isArray(args[1]) ? (' ' + args[1].join(' ')) : '');\n            err.message += ' `' + commandStr + '` (exited with error code ' + err.code + ')';\n            err.stdout = stdout;\n            err.stderr = stderr;\n            var cpError = new ChildProcessError(err.message, err.code, child_process, stdout, stderr);\n            reject(cpError);\n        } else {\n            resolve({\n                childProcess: cp,\n                stdout: stdout,\n                stderr: stderr\n            });\n        }\n    }\n\n    cpPromise.childProcess = cp;\n\n    return cpPromise;\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Search within node \"container\" for references for a search value, where the search value is defined as a\ntuple of(searchSymbol, searchText, searchLocation, and searchMeaning).\nsearchLocation: a node where the search value [SEP] function getReferencesInNode(container, searchSymbol, searchText, searchLocation, searchMeaning, findInStrings, findInComments, result, symbolToIndex) {\n                var sourceFile = container.getSourceFile();\n                var tripleSlashDirectivePrefixRegex = /^\\/\\/\\/\\s*</;\n                var possiblePositions = getPossibleSymbolReferencePositions(sourceFile, searchText, container.getStart(), container.getEnd());\n                if (possiblePositions.length) {\n                    // Build the set of symbols to search for, initially it has only the current symbol\n                    var searchSymbols = populateSearchSymbolSet(searchSymbol, searchLocation);\n                    ts.forEach(possiblePositions, function (position) {\n                        cancellationToken.throwIfCancellationRequested();\n                        var referenceLocation = ts.getTouchingPropertyName(sourceFile, position);\n                        if (!isValidReferencePosition(referenceLocation, searchText)) {\n                            // This wasn't the start of a token.  Check to see if it might be a\n                            // match in a comment or string if that's what the caller is asking\n                            // for.\n                            if ((findInStrings && ts.isInString(sourceFile, position)) ||\n                                (findInComments && isInNonReferenceComment(sourceFile, position))) {\n                                // In the case where we're looking inside comments/strings, we don't have\n                                // an actual definition.  So just use 'undefined' here.  Features like\n                                // 'Rename' won't care (as they ignore the definitions), and features like\n                                // 'FindReferences' will just filter out these results.\n                                result.push({\n                                    definition: undefined,\n                                    references: [{\n                                        fileName: sourceFile.fileName,\n                                        textSpan: ts.createTextSpan(position, searchText.length),\n                                        isWriteAccess: false\n                                    }]\n                                });\n                            }\n                            return;\n                        }\n                        if (!(getMeaningFromLocation(referenceLocation) & searchMeaning)) {\n                            return;\n                        }\n                        var referenceSymbol = typeChecker.getSymbolAtLocation(referenceLocation);\n                        if (referenceSymbol) {\n                            var referenceSymbolDeclaration = referenceSymbol.valueDeclaration;\n                            var shorthandValueSymbol = typeChecker.getShorthandAssignmentValueSymbol(referenceSymbolDeclaration);\n                            var relatedSymbol = getRelatedSymbol(searchSymbols, referenceSymbol, referenceLocation);\n                            if (relatedSymbol) {\n                                var referencedSymbol = getReferencedSymbol(relatedSymbol);\n                                referencedSymbol.references.push(getReferenceEntryFromNode(referenceLocation));\n                            }\n                            else if (!(referenceSymbol.flags & 67108864 /* Transient */) && searchSymbols.indexOf(shorthandValueSymbol) >= 0) {\n                                var referencedSymbol = getReferencedSymbol(shorthandValueSymbol);\n                                referencedSymbol.references.push(getReferenceEntryFromNode(referenceSymbolDeclaration.name));\n                            }\n                        }\n                    });\n                }\n                return;\n                function getReferencedSymbol(symbol) {\n                    var symbolId = ts.getSymbolId(symbol);\n                    var index = symbolToIndex[symbolId];\n                    if (index === undefined) {\n                        index = result.length;\n                        symbolToIndex[symbolId] = index;\n                        result.push({\n                            definition: getDefinition(symbol),\n                            references: []\n                        });\n                    }\n                    return result[index];\n                }\n                function isInNonReferenceComment(sourceFile, position) {\n                    return ts.isInCommentHelper(sourceFile, position, isNonReferenceComment);\n                    function isNonReferenceComment(c) {\n                        var commentText = sourceFile.text.substring(c.pos, c.end);\n                        return !tripleSlashDirectivePrefixRegex.test(commentText);\n                    }\n                }\n            }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handles errors if authentication from access_token provider fails [SEP] function tokenAuthErrorHandler(err,req,res,next) {\n    var status;\n    if(req.user && req.user._id) {\n      status = 403;\n    } else {\n      status = 401;\n    }\n    console.error(err);\n    if(err.stack) {\n      console.error(err.stack);\n      delete err.stack;\n    }\n    res.status(status).json(err);\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Format padding, taking leading `-` into account [SEP] function formatPadding(ch, pad) {\n  var res = pad ? pad + ch : ch;\n  if (pad && ch.toString().charAt(0) === '-') {\n    res = '-' + pad + ch.toString().substr(1);\n  }\n  return res.toString();\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "开启实时预览\nEnable real-time watching\n\n@returns {editormd}         返回editormd的实例对象 [SEP] function(callback) {     \r\n            var settings        = this.settings;\r\n            \r\n            if ($.inArray(settings.mode, [\"gfm\", \"markdown\"]) < 0)\r\n            {\r\n                return this;\r\n            }\r\n            \r\n            this.state.watching = settings.watch = true;\r\n            this.preview.show();\r\n            \r\n            if (this.toolbar)\r\n            {\r\n                var watchIcon   = settings.toolbarIconsClass.watch;\r\n                var unWatchIcon = settings.toolbarIconsClass.unwatch;\r\n                \r\n                var icon        = this.toolbar.find(\".fa[name=watch]\");\r\n                icon.parent().attr(\"title\", settings.lang.toolbar.watch);\r\n                icon.removeClass(unWatchIcon).addClass(watchIcon);\r\n            }\r\n            \r\n            this.codeMirror.css(\"border-right\", \"1px solid #ddd\").width(this.editor.width() / 2); \r\n            \r\n            timer = 0;\r\n            \r\n            this.save().resize();\r\n            \r\n            if (!settings.onwatch)\r\n            {\r\n                settings.onwatch = callback || function() {};\r\n            }\r\n            \r\n            $.proxy(settings.onwatch, this)();\r\n            \r\n            return this;\r\n        }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "After connect, register socket event handlers and run any setup actions [SEP] function setupClient(cb) {\n    cb = once(cb);\n\n    // Indicate failure if anything goes awry during setup\n    function bail(err) {\n      socket.destroy();\n      cb(err || new Error('client error during setup'));\n    }\n    // Work around lack of close event on tls.socket in node < 0.11\n    ((socket.socket) ? socket.socket : socket).once('close', bail);\n    socket.once('error', bail);\n    socket.once('end', bail);\n    socket.once('timeout', bail);\n\n    self._socket = socket;\n    self._tracker = tracker;\n\n    // Run any requested setup (such as automatically performing a bind) on\n    // socket before signalling successful connection.\n    // This setup needs to bypass the request queue since all other activity is\n    // blocked until the connection is considered fully established post-setup.\n    // Only allow bind/search/starttls for now.\n    var basicClient = {\n      bind: function bindBypass(name, credentials, controls, callback) {\n        return self.bind(name, credentials, controls, callback, true);\n      },\n      search: function searchBypass(base, options, controls, callback) {\n        return self.search(base, options, controls, callback, true);\n      },\n      starttls: function starttlsBypass(options, controls, callback) {\n        return self.starttls(options, controls, callback, true);\n      },\n      unbind: self.unbind.bind(self)\n    };\n    vasync.forEachPipeline({\n      func: function (f, callback) {\n        f(basicClient, callback);\n      },\n      inputs: self.listeners('setup')\n    }, function (err, res) {\n      if (err) {\n        self.emit('setupError', err);\n      }\n      cb(err);\n    });\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Inline the styles for a source file. Simply search for instances of `styleUrls: [...]` and\nreplace with `styles: [...]` (with the content of the file included).\n@param urlResolver {Function} A resolver that takes a URL and return a path.\n@param content {string} The source file's content.\n@return {string} The content with all styles inlined. [SEP] function inlineStyle(content, urlResolver) {\n  return content.replace(/styleUrls\\s*:\\s*(\\[[\\s\\S]*?\\])/gm, function (m, styleUrls) {\n    const urls = eval(styleUrls);\n    return 'styles: ['\n      + urls.map(styleUrl => {\n        const styleFile = urlResolver(styleUrl);\n        const originContent = fs.readFileSync(styleFile, 'utf-8');\n        const styleContent = styleFile.endsWith('.scss') ? buildSass(originContent, styleFile) : originContent;\n        const shortenedStyle = styleContent\n          .replace(/([\\n\\r]\\s*)+/gm, ' ')\n          .replace(/\"/g, '\\\\\"');\n        return `\"${shortenedStyle}\"`;\n      })\n        .join(',\\n')\n      + ']';\n  });\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "compile hogan template and open index.html [SEP] function compileIndex() {\n    fs.readFile(path.join(__dirname, 'templates', 'index.hogan'), function(err, data) {\n        if (err) throw err;\n        // write rendered result to index.html\n        fs.writeFile(path.join(__dirname, 'index.html'),\n                    hogan.compile(data.toString()).render({\n                        'schemes': schemes, \n                        'variations': variations, \n                        'colors': colors, \n                        'variants': variants,\n                        }),\n                    function(err) {if (err) throw err});\n        \n        // open index.html in browser\n        open(path.join(__dirname, 'index.html'));\n    });\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Lists all the entries in the directory.\n\n@param {Object} config\nThe object which contains the following config options:\n\n@param {Function} config.success This is required.\nThe callback to be called when the entries has been successfully read.\n\n@param {Ext.device.filesystem.Entry[]} config.success.entries\nThe array of entries of the directory.\n\n@param {Function} config.failure This is optional.\nThe callback to be called when an error occurred.\n\n@param {Object} config.failure.error\nThe occurred error.\n\n@param {Object} config.scope\nThe scope object [SEP] function(config) {\n                if (!config.success) {\n                    Ext.Logger.error('Ext.device.filesystem.DirectoryEntry#readEntries: You must specify a `success` callback.');\n                    return null;\n                }\n\n                var me = this;\n                this.getEntry(\n                    {\n                        success: function(dirEntry) {\n                            var directoryReader = dirEntry.createReader();\n                            directoryReader.readEntries(\n                                function(entryInfos) {\n                                    var entries = [],\n                                        i = 0,\n                                        len = entryInfos.length;\n\n                                    for (; i < len; i++) {\n                                        entryInfo = entryInfos[i];\n                                        entries[i] = entryInfo.isDirectory\n                                            ? Ext.create('Ext.device.filesystem.DirectoryEntry', entryInfo.fullPath, me.fileSystem)\n                                            : Ext.create('Ext.device.filesystem.FileEntry', entryInfo.fullPath, me.fileSystem);\n                                    }\n                                    config.success.call(config.scope || this, entries);\n                                },\n                                function(error) {\n                                    if (config.failure) {\n                                        config.failure.call(config.scope || this, error);\n                                    }\n                                }\n                            );\n                        },\n                        failure: config.failure\n                    }\n                );\n            }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "_bound: Bound index to allow negatives, throw when out of range [SEP] function(ix, count, message){\n        var ixNew = ix < 0 ? ix + count : ix\n        if (!(0 <= ixNew && ixNew < count))\n          _e(this.typeName, message + \" is out of bounds (\" + ix + \" in [0,\" + (count - 1) + \"])\")\n        return ixNew\n      }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "getPlatformApi() should be the only method of instantiating the PlatformProject classes for now. [SEP] function getPlatformApi (platform, platformRootDir) {\n    // if platformRootDir is not specified, try to detect it first\n    if (!platformRootDir) {\n        var projectRootDir = util.isCordova();\n        platformRootDir = projectRootDir && path.join(projectRootDir, 'platforms', platform);\n    }\n    if (!platformRootDir) {\n        // If platformRootDir is still undefined, then we're probably is not inside of cordova project\n        throw new Error('Current location is not a Cordova project');\n    }\n    // CB-11174 Resolve symlinks first before working with root directory\n    platformRootDir = util.convertToRealPathSafe(platformRootDir);\n\n    // Make sure the platforms/platform folder exists\n    if (!fs.existsSync(platformRootDir)) {\n        throw new Error('The platform \"' + platform + '\" does not appear to have been added to this project.');\n    }\n\n    var platformApi;\n    var cached = cachedApis[platformRootDir];\n    var libDir = path.join(platformRootDir, 'cordova', 'Api.js');\n    if (cached && cached.platform === platform) {\n        platformApi = cached;\n    } else {\n        var PlatformApi = util.getPlatformApiFunction(libDir, platform);\n        platformApi = new PlatformApi(platform, platformRootDir, events);\n        cachedApis[platformRootDir] = platformApi;\n    }\n    return platformApi;\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Framework to register OAuth providers with passport [SEP] function registerProvider(provider, configFunction) {\n    provider = provider.toLowerCase();\n    var configRef = 'providers.' + provider;\n    if (config.getItem(configRef + '.credentials')) {\n      var credentials = config.getItem(configRef + '.credentials');\n      credentials.passReqToCallback = true;\n      var options = config.getItem(configRef + '.options') || {};\n      configFunction.call(null, credentials, passport, authHandler);\n      router.get('/' + provider, passportCallback(provider, options, 'login'));\n      router.get('/' + provider + '/callback', passportCallback(provider, options, 'login'), initSession, oauthErrorHandler);\n      if(!config.getItem('security.disableLinkAccounts')) {\n        router.get('/link/' + provider, passport.authenticate('bearer', {session: false}), passportCallback(provider, options, 'link'));\n        router.get('/link/' + provider + '/callback', passport.authenticate('bearer', {session: false}),\n          passportCallback(provider, options, 'link'), linkSuccess, oauthErrorHandler);\n      }\n      console.log(provider + ' loaded.');\n    }\n  }", "target": 1, "target_options": ["no_match", "match"]}
