{"input": "Sets the facets to operate on\n\n@param  FacetInterface $facets     types to query\n@param  FacetInterface $facets,... types to query\n\n@return SearchRequest [SEP] public function facets($facets)\n    {\n        $this->params['facets'] = array();\n        if (is_array($facets)){\n            $args = $facets;\n        }else{\n            $args = func_get_args();\n        }\n        foreach ($args as $arg) {\n            if ($arg instanceof FacetInterface) {\n                $this->params['facets'][] = $arg;\n            }\n        }\n\n        return $this;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Double-quote encapsulation.\n\n@since 160708 Quotes.\n\n@param mixed $value   Input value.\n@param bool  $for_csv Changes quote-style for CSV compat.\nCSV quoting requires the use of a double-quote as the escape char.\n\n@return string|array|object Output value.\n\n@WARNING Double-quotes, in most languages, result in evaluation. [SEP] public function doubleQuote($value, bool $for_csv = false)\n    {\n        if (is_array($value) || is_object($value)) {\n            foreach ($value as $_key => &$_value) {\n                $_value = $this->doubleQuote($_value);\n            } // unset($_key, $_value);\n            return $value;\n        }\n        return '\"'.str_replace('\"', $for_csv ? '\"\"' : '\\\\\"', (string) $value).'\"';\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Detach objects.\n\n@param object|iterable $objects\n\n@throws \\InvalidArgumentException [SEP] public function detach($objects)\n    {\n        $backupAutoFlush = $this->autoFlush;\n\n        $this->autoFlush = false;\n        $this->runManagerAction('detach', $objects, false);\n\n        $this->autoFlush = $backupAutoFlush;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "{@inheritdoc} [SEP] public function html()\n    {\n        if (!app('antares.acl')->make('antares/acl')->can('roles-list')) {\n            $this->filters = [];\n        }\n        return $this\n                        ->setName('Administrators List')\n                        ->addColumn(['data' => 'id', 'name' => 'id', 'title' => trans('antares/foundation::label.users.id')])\n                        ->addColumn(['data' => 'firstname', 'name' => 'firstname', 'title' => trans('antares/foundation::label.users.firstname'), 'className' => 'bolded'])\n                        ->addColumn(['data' => 'lastname', 'name' => 'lastname', 'title' => trans('antares/foundation::label.users.lastname'), 'className' => 'bolded'])\n                        ->addColumn(['data' => 'email', 'name' => 'email', 'title' => trans('antares/foundation::label.users.email'), 'className' => 'bolded'])\n                        ->addColumn(['data' => 'role', 'name' => 'role', 'title' => trans('antares/foundation::label.users.role')])\n                        ->addColumn(['data' => 'created_at', 'name' => 'created_at', 'title' => trans('antares/foundation::label.users.created_at')])\n                        ->addColumn(['data' => 'status', 'name' => 'status', 'title' => trans('antares/foundation::label.users.status')])\n                        ->addAction(['name' => 'edit', 'title' => '', 'class' => 'mass-actions dt-actions', 'orderable' => false, 'searchable' => false])\n                        ->setDeferedData()\n                        ->addGroupSelect($this->statuses(), 6, 'all');\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Escapes special characters in a string for use in an SQL statement.\n\n@param string $text\n\n@return string [SEP] public function addSlashes($text)\n    {\n        if (isset($this->sqlLink) && method_exists($this->sqlLink,\n                'real_escape_string')) {\n            $slashed = $this->sqlLink->real_escape_string($text);\n        } else {\n            $slashed = addslashes($text);\n        }\n\n        return $slashed;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Load configuration.\n\n@param string $json      JSON data\n@param bool   $jsonIsUrl If JSON data is URL? (default: false)\n\n@return array\n@throws \\Berlioz\\Config\\Exception\\ConfigException If unable to load configuration file [SEP] protected function load(string $json, bool $jsonIsUrl = false): array\n    {\n        if ($jsonIsUrl) {\n            return $this->loadUrl($json);\n        }\n\n        return $this->loadJson($json);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generate v4 UUID.\n\nWe're generating uuids according to the official v4 spec.\n\n@return string [SEP] private static function uuid4(): string\n    {\n        $hash   = \\bin2hex(\\random_bytes(16));\n        $timeHi = \\hexdec(\\substr($hash, 12, 4)) & 0x0fff;\n        $timeHi &= ~0xf000;\n        $timeHi |= 4 << 12;\n\n        $clockSeqHi = \\hexdec(\\substr($hash, 16, 2)) & 0x3f;\n        $clockSeqHi &= ~0xc0;\n        $clockSeqHi |= 0x80;\n\n        $params = [\\substr($hash, 0, 8), \\substr($hash, 8, 4), \\sprintf('%04x', $timeHi), \\sprintf('%02x', $clockSeqHi), \\substr($hash, 18, 2), \\substr($hash, 20, 12)];\n\n        return \\vsprintf('%08s-%04s-%04s-%02s%02s-%012s', $params);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Filters the list of ReflectionMethods down to those actually proxyable.\n\nProxyable methods are those which are NOT:\n- constructor\n- final method\n- static method\n- members of the self::blacklist\n\n@param array $methods\n\n@return \\ReflectionMethod[] [SEP] protected static function canProxyMethods(array $methods)\n    {\n        $proxyMethods = array();\n\n        foreach ($methods as $method) {\n            if (self::canProxyMethod($method)) {\n                $proxyMethods[] = $method;\n            }\n        }\n\n        return $proxyMethods;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Send a request to the server, receive a response\n\n@param  string   $apiPath       Request API path\n@param  array    $parameters    Parameters\n@param  string   $httpMethod    HTTP method to use\n\n@return string   HTTP response [SEP] protected function doRequest($url, array $parameters = array(), $httpMethod = 'GET', array $options = array())\n    {\n        $curlOptions = array();\n        $headers = isset($options['headers']) ? $options['headers'] : array();\n\n        if ('POST' === $httpMethod) {\n            $curlOptions += array(\n                CURLOPT_POST  => true,\n            );\n        }\n        elseif ('PUT' === $httpMethod) {\n            $curlOptions += array(\n                CURLOPT_POST  => true, // This is so cURL doesn't strip CURLOPT_POSTFIELDS\n                CURLOPT_CUSTOMREQUEST => 'PUT',\n            );\n        }\n        elseif ('DELETE' === $httpMethod) {\n            $curlOptions += array(\n                CURLOPT_CUSTOMREQUEST => 'DELETE',\n            );\n        }\n\n        if ($auth = $this->getAuthService()) {\n            $options['url'] = $url;\n            $options['http_method'] = $httpMethod;\n            list($headers, $parameters) = $auth->setAuthHeadersAndParameters($headers, $parameters, $options);\n        }\n\n        if (!empty($parameters))\n        {\n            if('GET' === $httpMethod)\n            {\n                $queryString = utf8_encode($this->buildQuery($parameters));\n                $url .= '?' . $queryString;\n            }\n            else\n            {\n                switch ($options['content-type']) {\n                    case 'form':\n                        $headers[] = 'Content-Type: application/x-www-form-urlencoded';\n                        $parameters = http_build_query($parameters);\n                        break;\n                    case 'json':\n                    default:\n                        $headers[] = 'Content-Type: application/json';\n                        $parameters = json_encode($parameters);\n                        break;\n                }\n\n                $curlOptions += array(\n                    CURLOPT_POSTFIELDS  => $parameters,\n                );\n            }\n        } else {\n            $headers[] = 'Content-Length: 0';\n        }\n\n        switch ($options['format']) {\n            case 'json':\n                $headers[] = 'Accept: application/json';\n                break;\n            case 'xml':\n                $headers[] = 'Accept: text/xml';\n                break;\n        }\n\n        $this->debug('send '.$httpMethod.' request: '.$url);\n\n        // format headers\n        foreach ($headers as $i => $header) {\n            if (is_string($i)) {\n                $headers[] = \"{$i}: $header\";\n                unset($headers[$i]);\n            }\n        }\n\n        $curlOptions += array(\n            CURLOPT_URL             => $url,\n            CURLOPT_PORT            => $options['http_port'],\n            CURLOPT_USERAGENT       => $options['user_agent'],\n            CURLOPT_FOLLOWLOCATION  => $options['follow-location'],\n            CURLOPT_RETURNTRANSFER  => true,\n            CURLOPT_HTTPHEADER      => $headers,\n            CURLOPT_SSL_VERIFYPEER  => !isset($options['verifyssl']) || $options['verifyssl'],\n        );\n\n        // handle timeout values less than 1 second\n        if (is_int($options['timeout'])) {\n            $curlOptions[CURLOPT_TIMEOUT] = $options['timeout'];\n        } else if ($options['timeout'] > 0 && $options['timeout'] < 1) {\n            $curlOptions[CURLOPT_TIMEOUT_MS] = $options['timeout'] * 1000;\n        }\n\n        if (isset($options['curlopts']) && is_array($options['curlopts'])) {\n            $curlOptions += $options['curlopts'];\n        }\n\n        if (isset($options['proxy'])) {\n            $curlOptions[CURLOPT_PROXY] = $options['proxy'];\n        }\n\n        if (isset($options['sslversion'])) {\n            $curlOptions[CURLOPT_SSLVERSION] = $options['sslversion'];\n        } else {\n            $curlOptions[CURLOPT_SSLVERSION] = 0;\n        }\n\n        $response = $this->doCurlCall($curlOptions);\n\n        return $response;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert errors into ErrorException objects\n\n@param  int            $err_no\n@param  string         $err_str\n@param  string         $err_file\n@param  int            $err_line\n@return bool\n@throws \\ErrorException [SEP] public static function handle_errors($err_no, $err_str = '', $err_file = '', $err_line = '')\n    {\n        if (!($err_no & error_reporting())) {\n            return;\n        }\n        throw new \\ErrorException($err_str, $err_no, 0, $err_file, $err_line);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Validate a user object.\n\nInvokes User::validate(),\nand additionally tests that the User's email address and username (if set) are unique across all users.'.\n\n@param User $user\n@return array An array of error messages, or an empty array if the User is valid. [SEP] public function validate(User $user)\n    {\n        $errors = $user->validate();\n\n        // Ensure email address is unique.\n        $duplicates = $this->findBy(array($this->getUserColumns('email') => $user->getEmail()));\n        if (!empty($duplicates)) {\n            foreach ($duplicates as $dup) {\n                if ($user->getId() && $dup->getId() == $user->getId()) {\n                    continue;\n                }\n                $errors['email'] = 'An account with that email address already exists.';\n            }\n        }\n\n        // Ensure username is unique.\n        $duplicates = $this->findBy(array($this->getUserColumns('username') => $user->getRealUsername()));\n        if (!empty($duplicates)) {\n            foreach ($duplicates as $dup) {\n                if ($user->getId() && $dup->getId() == $user->getId()) {\n                    continue;\n                }\n                $errors['username'] = 'An account with that username already exists.';\n            }\n        }\n\n        // If username is required, ensure it is set.\n        if ($this->isUsernameRequired && !$user->getRealUsername()) {\n            $errors['username'] = 'Username is required.';\n        }\n\n        return $errors;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "A convenience method that grabs the raw input stream and decodes\nthe JSON into an array.\n\nIf $assoc == true, then all objects in the response will be converted\nto associative arrays.\n\n@param boolean $assoc   Whether to return objects as associative arrays\n@param integer $depth   How many levels deep to decode\n@param integer $options Bitmask of options\n\n@see http://php.net/manual/en/function.json-decode.php\n\n@return mixed [SEP] public function getJSON(bool $assoc = false, int $depth = 512, int $options = 0)\n\t{\n\t\treturn json_decode($this->body, $assoc, $depth, $options);\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get URL form config.\n\n@param array $config\n\n@return string [SEP] private function getUrl(array $config): string\n    {\n        if (null !== $config['dsn']) {\n            return $config['dsn'];\n        }\n\n        return sprintf(\n            '%s://%s:%s@%s:%d',\n            $config['scheme'],\n            $config['username'],\n            $config['password'],\n            $config['host'],\n            $this->getPort($config)\n        );\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Convert bytes to a word.\n\n@param int $bytes\n@param int $decimals\n@param int $mod\n\n@return string [SEP] public function bytes($bytes, $decimals = 2, $mod = 1024)\n    {\n        $factor = floor((strlen($bytes) - 1) / 3);\n        $byte_name = $this->units_of_bytes[$factor];\n        if ($mod == 1000) {\n            $byte_name = str_replace('B', 'bit', $byte_name);\n        }\n\n        return sprintf(\"%.{$decimals}f %s\", $bytes / pow($mod, $factor), $byte_name);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Create the object.\n\nThis will call validate functions on columns if they exist. These should\nbe used to validate data that is dependent on other data.\n\n@since 1.0\n\n@return int|string PK of new record.\n@throws Exception [SEP] protected function create() {\n\n\t\tforeach ( $this->data as $col => $val ) {\n\n\t\t\tif ( method_exists( $this, \"validate_$col\" ) ) {\n\t\t\t\t$this->data[ $col ] = $this->{\"validate_$col\"}( $val );\n\t\t\t}\n\t\t}\n\n\t\treturn Manager::make_simple_query_object( $this->get_table()->get_slug() )\n\t\t              ->insert( $this->data );\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Writes data to the stream.\n\n@param  string $data\n@return void [SEP] public function send($data)\r\n  {\r\n    $this->connect();\r\n\r\n    @stream_socket_sendto($this->stream, $data);\r\n\r\n    \\ManiaLivePlugins\\Standard\\TeamSpeak\\TeamSpeak3\\Helper\\Signal::getInstance()->emit(strtolower($this->getAdapterType()) . \"DataSend\", $data);\r\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute the console command. [SEP] public function fire()\n    {\n        $this->line('');\n\n        $message = 'This will execute indiscriminately all methods which '\n            . 'subscribe to the `toolbox.build` event.';\n        $this->comment($message);\n        $this->line('');\n        Event::fire('toolbox.build', [$this]);\n\n        // Done!\n        $this->line('');\n        $this->info('Compilation completed!');\n        $this->line('');\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Escapes and inserts any binds into the finalQueryString object.\n\n@return null|void [SEP] protected function compileBinds()\n\t{\n\t\t$sql = $this->finalQueryString;\n\n\t\t$hasNamedBinds = strpos($sql, ':') !== false;\n\n\t\tif (empty($this->binds) || empty($this->bindMarker) ||\n\t\t\t\t(strpos($sql, $this->bindMarker) === false &&\n\t\t\t\t$hasNamedBinds === false)\n\t\t)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (! is_array($this->binds))\n\t\t{\n\t\t\t$binds     = [$this->binds];\n\t\t\t$bindCount = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$binds     = $this->binds;\n\t\t\t$bindCount = count($binds);\n\t\t}\n\n\t\t// Reverse the binds so that duplicate named binds\n\t\t// will be processed prior to the original binds.\n\t\tif (! is_numeric(key(array_slice($binds, 0, 1))))\n\t\t{\n\t\t\t$binds = array_reverse($binds);\n\t\t}\n\n\t\t// We'll need marker length later\n\t\t$ml = strlen($this->bindMarker);\n\n\t\tif ($hasNamedBinds)\n\t\t{\n\t\t\t$sql = $this->matchNamedBinds($sql, $binds);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$sql = $this->matchSimpleBinds($sql, $binds, $bindCount, $ml);\n\t\t}\n\n\t\t$this->finalQueryString = $sql;\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Same as php's core move_uploaded_file extended with optional destination file exists check.\n\n@throws FileException when exists check is requested and destination already exists\n\n@return boolean [SEP] public function moveFile(): bool\n    {\n        if ($this->check_exists == true && file_exists($this->destination)) {\n            Throw new FileException(sprintf('Destinationfile \"%s\" already exits.', $this->destination));\n        }\n\n        return move_uploaded_file($this->filename, $this->destination);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Return categories available for filtering\n@param int $moduleId The module ID\n@return array|null [SEP] public function getFilterableCategories($moduleId): array\n    {\n        $categories = array();\n        $showAllCategories = get_field('mod_event_categories_show', $moduleId);\n\n        $moduleCategories = get_field('mod_event_categories_list', $moduleId);\n        if ($showAllCategories === false && !empty($moduleCategories) && is_array($moduleCategories)) {\n            $categories = $moduleCategories;\n            foreach ($categories as $key => &$category) {\n                $category = get_term($category, 'event_categories');\n                // If category is missing, remove it from the list\n                if (!$category) {\n                    unset($categories[$key]);\n                }\n            }\n        } else {\n            $categories = get_terms(\n                'event_categories',\n                array(\n                    'hide_empty' => false,\n                )\n            );\n        }\n\n        $categories = \\EventManagerIntegration\\Helper\\Translations::filterTermsByLanguage($categories);\n\n        foreach ($categories as &$category) {\n            $category = array(\n                'id' => $category->term_id,\n                'title' => $category->name,\n                'checked' => false,\n            );\n        }\n\n        return $categories;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Generates files. [SEP] public function generate(array $config): void\n    {\n        $baseClass = [\n            'constants' => [],\n            'fields' => [],\n            'uses' => [],\n            'hasConstructor' => false,\n            'parentHasConstructor' => false,\n            'hasChild' => false,\n            'abstract' => false,\n        ];\n\n        $typesToGenerate = [];\n\n        if (!$config['types']) {\n            foreach ($this->graphs as $graph) {\n                $typesToGenerate = $graph->allOfType('rdfs:Class');\n            }\n        } else {\n            foreach ($config['types'] as $typeName => $typeConfig) {\n                $resource = null;\n                foreach ($this->graphs as $graph) {\n                    $resources = $graph->resources();\n\n                    if (isset($resources[$typeConfig['vocabularyNamespace'].$typeName])) {\n                        $resource = $graph->resource($typeConfig['vocabularyNamespace'].$typeName, 'rdfs:Class');\n                        break;\n                    }\n                }\n\n                if ($resource) {\n                    $typesToGenerate[$typeName] = $resource;\n                } elseif (empty($graph)) {\n                    $this->logger->warning('Type \"{typeName}\" cannot be found and there is no graph to generate entity.');\n                } else {\n                    $this->logger->warning('Type \"{typeName}\" cannot be found. Using \"{guessFrom}\" type to generate entity.', ['typeName' => $typeName, 'guessFrom' => $typeConfig['guessFrom']]);\n                    $type = $graph->resource($typeConfig['vocabularyNamespace'].$typeConfig['guessFrom'], 'rdfs:Class');\n                    $typesToGenerate[$typeName] = $type;\n                }\n            }\n        }\n\n        $classes = [];\n        $propertiesMap = $this->createPropertiesMap($typesToGenerate);\n\n        foreach ($typesToGenerate as $typeName => $type) {\n            $typeName = is_string($typeName) ? $typeName : $type->localName();\n            $typeConfig = $config['types'][$typeName] ?? null;\n            $class = $baseClass;\n\n            $comment = $type->get('rdfs:comment');\n\n            $class['name'] = $typeName;\n            $class['label'] = $comment ? $comment->getValue() : '';\n            $class['resource'] = $type;\n            $class['config'] = $typeConfig;\n\n            $class['isEnum'] = $this->isEnum($type);\n            if ($class['isEnum']) {\n                $class['namespace'] = $typeConfig['namespace'] ?? $config['namespaces']['enum'];\n                $class['parent'] = 'Enum';\n                $class['uses'][] = Enum::class;\n\n                // Constants\n                foreach ($this->graphs as $graph) {\n                    foreach ($graph->allOfType($type->getUri()) as $instance) {\n                        $class['constants'][$instance->localName()] = [\n                            'name' => strtoupper(substr(preg_replace('/([A-Z])/', '_$1', $instance->localName()), 1)),\n                            'resource' => $instance,\n                            'value' => $instance->getUri(),\n                        ];\n                    }\n                }\n            } else {\n                // Entities\n                $class['namespace'] = $typeConfig['namespaces']['class'] ?? $config['namespaces']['entity'];\n\n                // Parent\n                $class['parent'] = $typeConfig['parent'] ?? null;\n                if (null === $class['parent']) {\n                    $numberOfSupertypes = count($type->all('rdfs:subClassOf'));\n\n                    if ($numberOfSupertypes > 1) {\n                        $this->logger->warning(sprintf('The type \"%s\" has several supertypes. Using the first one.', $type->localName()));\n                    }\n\n                    $class['parent'] = $numberOfSupertypes ? $type->all('rdfs:subClassOf')[0]->localName() : false;\n                }\n\n                if (isset($class['parent']) && isset($config['types'][$class['parent']]['namespaces']['class'])) {\n                    $parentNamespace = $config['types'][$class['parent']]['namespaces']['class'];\n\n                    if ($parentNamespace !== $class['namespace']) {\n                        $class['uses'][] = $parentNamespace.'\\\\'.$class['parent'];\n                    }\n                }\n\n                // Embeddable\n                $class['embeddable'] = $typeConfig['embeddable'] ?? false;\n\n                if (!$config['types'] && $class['parent'] && !isset($config['types'][$class['parent']])) {\n                    $this->logger->error(sprintf('The type \"%s\" (parent of \"%s\") doesn\\'t exist', $class['parent'], $type->localName()));\n                }\n\n                // Interfaces\n                if ($config['useInterface']) {\n                    $class['interfaceNamespace'] = isset($typeConfig['namespaces']['interface']) && $typeConfig['namespaces']['interface'] ? $typeConfig['namespaces']['interface'] : $config['namespaces']['interface'];\n                    $class['interfaceName'] = sprintf('%sInterface', $typeName);\n                }\n            }\n\n            // Fields\n            if (!$typeConfig['allProperties'] && isset($typeConfig['properties']) && is_array($typeConfig['properties'])) {\n                foreach ($typeConfig['properties'] as $key => $value) {\n                    foreach ($propertiesMap[$type->getUri()] as $property) {\n                        if ($key !== $property->localName()) {\n                            continue;\n                        }\n\n                        $class = $this->generateField($config, $class, $type, $typeName, $property->localName(), $property);\n                        continue 2;\n                    }\n\n                    // Add custom fields (non schema.org)\n                    $this->logger->info(sprintf('The property \"%s\" (type \"%s\") is a custom property.', $key, $type->localName()));\n                    $class = $this->generateField($config, $class, $type, $typeName, $key);\n                }\n            } else {\n                // All properties\n                foreach ($propertiesMap[$type->getUri()] as $property) {\n                    $class = $this->generateField($config, $class, $type, $typeName, $property->localName(), $property);\n                }\n            }\n\n            $classes[$typeName] = $class;\n        }\n\n        // Second pass\n        foreach ($classes as &$class) {\n            if ($class['parent'] && isset($classes[$class['parent']])) {\n                $classes[$class['parent']]['hasChild'] = true;\n                $class['parentHasConstructor'] = $classes[$class['parent']]['hasConstructor'];\n            }\n\n            foreach ($class['fields'] as &$field) {\n                $field['isEnum'] = isset($classes[$field['range']]) && $classes[$field['range']]['isEnum'];\n                $field['typeHint'] = $this->fieldToTypeHint($config, $field, $classes) ?? false;\n\n                if ($field['isArray']) {\n                    $field['adderRemoverTypeHint'] = $this->fieldToAdderRemoverTypeHint($field, $classes) ?? false;\n                }\n            }\n        }\n\n        // Third pass\n        foreach ($classes as &$class) {\n            $class['abstract'] = $config['types'][$class['name']]['abstract'] ?? $class['hasChild'];\n\n            // When including all properties, ignore properties already set on parent\n            if (isset($config['types'][$class['name']]['allProperties']) && $config['types'][$class['name']]['allProperties'] && isset($classes[$class['parent']])) {\n                $type = $class['resource'];\n\n                foreach ($propertiesMap[$type->getUri()] as $property) {\n                    if (!isset($class['fields'][$property->localName()])) {\n                        continue;\n                    }\n\n                    $parentConfig = $config['types'][$class['parent']] ?? null;\n                    $parentClass = $classes[$class['parent']];\n\n                    while ($parentClass) {\n                        if (!isset($parentConfig['properties']) || !is_array($parentConfig['properties'])) {\n                            // Unset implicit property\n                            $parentType = $parentClass['resource'];\n                            if (in_array($property, $propertiesMap[$parentType->getUri()], true)) {\n                                unset($class['fields'][$property->localName()]);\n                                continue 2;\n                            }\n                        } else {\n                            // Unset explicit property\n                            if (array_key_exists($property->localName(), $parentConfig['properties'])) {\n                                unset($class['fields'][$property->localName()]);\n                                continue 2;\n                            }\n                        }\n\n                        $parentConfig = $parentClass['parent'] ? ($config['types'][$parentClass['parent']] ?? null) : null;\n                        $parentClass = $parentClass['parent'] ? $classes[$parentClass['parent']] : null;\n                    }\n                }\n            }\n        }\n\n        // Generate ID\n        if ($config['id']['generate']) {\n            foreach ($classes as &$class) {\n                if ($class['hasChild'] || $class['isEnum'] || $class['embeddable']) {\n                    continue;\n                }\n\n                switch ($config['id']['generationStrategy']) {\n                    case 'auto':\n                        $range = 'Integer';\n                        $typeHint = 'int';\n                        $writable = false;\n                        $nullable = true;\n                        break;\n                    case 'uuid':\n                        $range = 'Text';\n                        $typeHint = 'string';\n                        $writable = $config['id']['writable'];\n                        $nullable = !$writable;\n                        break;\n                    case 'mongoid':\n                        $range = 'Text';\n                        $typeHint = 'string';\n                        $writable = false;\n                        $nullable = true;\n                        break;\n                    default:\n                        $range = 'Text';\n                        $typeHint = 'string';\n                        $writable = true;\n                        $nullable = false;\n                        break;\n                }\n\n                $class['fields'] = [\n                    'id' => [\n                        'name' => 'id',\n                        'resource' => null,\n                        'range' => $range,\n                        'cardinality' => CardinalitiesExtractor::CARDINALITY_1_1,\n                        'ormColumn' => null,\n                        'isArray' => false,\n                        'isReadable' => true,\n                        'isWritable' => $writable,\n                        'isNullable' => $nullable,\n                        'isUnique' => false,\n                        'isCustom' => true,\n                        'isEnum' => false,\n                        'isId' => true,\n                        'typeHint' => $typeHint,\n                    ],\n                ] + $class['fields'];\n            }\n        }\n\n        // Initialize annotation generators\n        $annotationGenerators = [];\n        foreach ($config['annotationGenerators'] as $annotationGenerator) {\n            $generator = new $annotationGenerator($this->logger, $this->graphs, $this->cardinalities, $config, $classes);\n\n            $annotationGenerators[] = $generator;\n        }\n\n        $interfaceMappings = [];\n        $generatedFiles = [];\n\n        foreach ($classes as $className => &$class) {\n            $class['uses'] = $this->generateClassUses($annotationGenerators, $classes, $className);\n            $class['annotations'] = $this->generateClassAnnotations($annotationGenerators, $className);\n            if (false === isset($typesToGenerate[$className])) {\n                $class['interfaceAnnotations'] = $this->generateInterfaceAnnotations($annotationGenerators, $className);\n            }\n\n            foreach ($class['constants'] as $constantName => $constant) {\n                $class['constants'][$constantName]['annotations'] = $this->generateConstantAnnotations($annotationGenerators, $className, $constantName);\n            }\n\n            foreach ($class['fields'] as $fieldName => &$field) {\n                $field['annotations'] = $this->generateFieldAnnotations($annotationGenerators, $className, $fieldName);\n                $field['getterAnnotations'] = $this->generateGetterAnnotations($annotationGenerators, $className, $fieldName);\n\n                if ($field['isArray']) {\n                    $field['adderAnnotations'] = $this->generateAdderAnnotations($annotationGenerators, $className, $fieldName);\n                    $field['removerAnnotations'] = $this->generateRemoverAnnotations($annotationGenerators, $className, $fieldName);\n                } else {\n                    $field['setterAnnotations'] = $this->generateSetterAnnotations($annotationGenerators, $className, $fieldName);\n                }\n            }\n\n            $classDir = $this->namespaceToDir($config, $class['namespace']);\n\n            if (!file_exists($classDir)) {\n                mkdir($classDir, 0777, true);\n            }\n\n            $path = sprintf('%s%s.php', $classDir, $className);\n            $generatedFiles[] = $path;\n\n            file_put_contents(\n                $path,\n                $this->twig->render('class.php.twig', [\n                    'config' => $config,\n                    'class' => $class,\n                ])\n            );\n\n            if (isset($class['interfaceNamespace'])) {\n                $interfaceDir = $this->namespaceToDir($config, $class['interfaceNamespace']);\n\n                if (!file_exists($interfaceDir)) {\n                    mkdir($interfaceDir, 0777, true);\n                }\n\n                $path = sprintf('%s%s.php', $interfaceDir, $class['interfaceName']);\n                $generatedFiles[] = $path;\n                file_put_contents(\n                    $path,\n                    $this->twig->render('interface.php.twig', [\n                        'config' => $config,\n                        'class' => $class,\n                    ])\n                );\n\n                if ($config['doctrine']['resolveTargetEntityConfigPath'] && !$class['abstract']) {\n                    $interfaceMappings[$class['interfaceNamespace'].'\\\\'.$class['interfaceName']] = $class['namespace'].'\\\\'.$className;\n                }\n            }\n        }\n\n        if (!$interfaceMappings && $config['doctrine']['resolveTargetEntityConfigPath']) {\n            $file = $config['output'].'/'.$config['doctrine']['resolveTargetEntityConfigPath'];\n            $dir = dirname($file);\n            if (!file_exists($dir)) {\n                mkdir($dir, 0777, true);\n            }\n\n            file_put_contents(\n                $file,\n                $this->twig->render('doctrine.xml.twig', ['mappings' => $interfaceMappings])\n            );\n\n            $generatedFiles[] = $file;\n        }\n\n        $this->fixCs($generatedFiles);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Checks word against list of common honorific prefixes\n\n@param string $word the single word you wish to test\n@return boolean [SEP] protected function is_salutation($word)\r\n\t{\r\n\t\t$word = str_replace('.', '', mb_strtolower($word));\r\n\t\tforeach ($this->dict['prefix'] as $replace => $originals) {\r\n\t\t\tif (in_array($word, $originals)) {\r\n\t\t\t\treturn $replace;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "加密.\n\n@param string $value\n@param int    $expiry\n\n@return string [SEP] public function encrypt(string $value, int $expiry = 0): string\n    {\n        $iv = $this->createIv();\n\n        $value = $this->packData($value, $expiry, $iv);\n\n        return $this->encryptData($value, $iv);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "@param \\DOMElement            $node\n@param DeserializationContext $context\n@param string                 $elementName\n@param string                 $class\n@param string                 $namespacePrefix\n\n@throws \\LogicException [SEP] protected function oneElementFromXml(\\DOMElement $node, DeserializationContext $context, $elementName, $class, $namespacePrefix)\n    {\n        if ($namespacePrefix) {\n            $query = sprintf('./%s:%s', $namespacePrefix, $elementName);\n        } else {\n            $query = sprintf('./%s', $elementName);\n        }\n        $arr = $context->getXpath()->query($query, $node);\n        $value = $arr->length > 0 ? $arr->item(0) : null;\n\n        if ($value) {\n            $setter = 'set'.$elementName;\n            if (false == method_exists($this, $setter)) {\n                throw new \\LogicException(sprintf(\n                    \"Unable to find setter for element '%s' in class '%s'\",\n                    $elementName,\n                    get_class($this)\n                ));\n            }\n\n            if ($class) {\n                /** @var AbstractSamlModel $object */\n                $object = new $class();\n                if (false == $object instanceof \\LightSaml\\Model\\SamlElementInterface) {\n                    throw new \\LogicException(sprintf(\n                        \"Specified class '%s' for element '%s' must implement SamlElementInterface\",\n                        $class,\n                        $elementName\n                    ));\n                }\n\n                $object->deserialize($value, $context);\n            } else {\n                $object = $value->textContent;\n            }\n\n            $this->{$setter}($object);\n        }\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Setter for value. Supports dot notation.\nCan set value to objects, arrays, Containers, instances of ArrayableContract and ObjectContract\nor create nested arrays (if dot notation is used) if was not set.\n\n@param string|StringContract $property\n@param mixed $value\n@return $this [SEP] public function set($property, $value)\n    {\n        Arr::set($this, $this->getStringable($property), $value);\n\n        return $this;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "The Negotiate class provides the content negotiation features for\nworking the request to determine correct language, encoding, charset,\nand more.\n\n@param \\CodeIgniter\\HTTP\\RequestInterface $request\n@param boolean                            $getShared\n\n@return \\CodeIgniter\\HTTP\\Negotiate [SEP] public static function negotiator(RequestInterface $request = null, bool $getShared = true)\n\t{\n\t\tif ($getShared)\n\t\t{\n\t\t\treturn static::getSharedInstance('negotiator', $request);\n\t\t}\n\n\t\tif (is_null($request))\n\t\t{\n\t\t\t$request = static::request();\n\t\t}\n\n\t\treturn new Negotiate($request);\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Opens an existing session.\n\nOpens and returns the data for an existing session, if and only if the\nclient sent a valid existing session ID. Otherwise returns null.\n\n@param array $cookieData\n@param null $userProfile\n@return Session|null [SEP] public function openSessionByID($sessionID, $userProfile = null)\n    {\n        $session = $this->driver->openSessionByID(\n            $sessionID,\n            $this,\n            $userProfile\n        );\n        \n        if ($session == null) {\n            $this->invalidSessionAccessed();\n        }\n\n        return $session;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets an installed package by its name. [SEP] private function get_installed_package_by_name( $package_name ) {\n\t\tforeach ( $this->get_installed_packages() as $package ) {\n\t\t\tif ( $package_name === $package->getPrettyName() ) {\n\t\t\t\treturn $package;\n\t\t\t}\n\t\t\t// Also check non-pretty (lowercase) name in case of legacy incorrect name.\n\t\t\tif ( $package_name === $package->getName() ) {\n\t\t\t\treturn $package;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "{@inheritDoc}\n@see \\n2n\\persistence\\orm\\property\\EntityProperty::createSelection() [SEP] public function createSelection(MetaTreePoint $metaTreePoint, QueryState $queryState) {\r\n\t\treturn new SimpleSelection($this->createQueryColumn($metaTreePoint->getMeta()), 'bool');\r\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Loads a model from the server using the collection type and the id.\n@param  string $collection The collection to load from. For graphs, this can only be \"vertex\" or \"edge\".\n@param  string $id         The id (key in ArangoDB jargon) of the document, edge or vertex.\n@return AModel [SEP] public function load($collection, $id)\n    {\n        return $this->getToolbox($this->_currentConnection)->getPodManager()->load($collection, $id);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "{@inheritDoc} [SEP] public function toPsr7($input)\n    {\n        return new Response(\n            $input->getStatusCode(),\n            $input->getHeaders(),\n            $input->getBody(),\n            $this->getProtocolVersion(),\n            $input->getStatusDescription()\n        );\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "function resetMessageById() - Send message where the payload has only\none message in its listing\n@param   mixed $messageId\n\n@return  boolean [SEP] public function sendMessageOne($sendSettings) {\r\n        $this->_bootstrapMailHandler();\r\n        \r\n        //get the key of the first message\r\n        reset($this->messages);\r\n        $key = key($this->messages);\r\n        $this->_bootstrapMailMessage($key);\r\n        \r\n        //TODO: Chain exceptions here\r\n        //try {\r\n        $messageObj = $this->messages[$key]['messageObj'];\r\n        $this->mailHandler->send($messageObj);\r\n        //} catch (phpmailerException $ex) {\r\n            //echo $ex->errorMessage();\r\n        //}\r\n        \r\n        //pop the message stack\r\n        $msgStack = $this->messages;\r\n        array_shift($msgStack);\r\n        $this->messages = $msgStack;\r\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute the menu handler and construct the response.\n\n@return array [SEP] protected function execute()\n    {\n        $this->resetHeaders();\n        $this->resetStaticCache();\n\n        // Move to drupal root where the index.php is\n        $current_dir = getcwd();\n        chdir(DRUPAL_ROOT);\n\n        $value = '';\n        ob_start(function ($str) use (&$value) {\n            $value .= $str;\n        });\n        $buffer = menu_execute_active_handler($this->path, false);\n        ob_end_clean();\n\n        $status = 200;\n        if ($buffer === MENU_NOT_FOUND) {\n            $status = 404;\n            $value = '';\n            ob_start(function ($str) use (&$value) {\n                $value .= $str;\n            });\n            drupal_not_found();\n            ob_end_clean();\n        } elseif ($buffer === MENU_ACCESS_DENIED) {\n            $status = 403;\n            $value = '';\n            ob_start(function ($str) use (&$value) {\n                $value .= $str;\n            });\n            drupal_access_denied();\n            ob_end_clean();\n        } elseif (empty($value)) {\n            $value = drupal_render_page($buffer);\n        }\n\n        // Go back to the test directory\n        chdir($current_dir);\n\n        return [\n            $status,\n            $value,\n            drupal_get_http_header(),\n        ];\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Run npm update.\n\n@return bool True if npm is successful. False otherwise. [SEP] private function npm()\n    {\n        $cmd = new Command('cd');\n        $cmd->addParam($this->installDir)\n            ->addSubCommand('&&')\n            ->addSubCommand('npm')\n            ->addParam('update');\n\n        return $this->ex($cmd);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "(non-PHPdoc)\n@see Ding\\Reflection.IReflectionFactory::getClass() [SEP] public function getClass($class)\n    {\n        if (isset($this->_reflectionClasses[$class])) {\n            return $this->_reflectionClasses[$class];\n        }\n        $this->_reflectionClasses[$class] = new \\ReflectionClass($class);\n        return $this->_reflectionClasses[$class];\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Make a new driver instance.\n\n@param array  $config\n@param string $method\n@param string $errorMessage\n\n@throws \\Viserio\\Component\\Contract\\Manager\\Exception\\InvalidArgumentException\n\n@return mixed [SEP] protected function create(array $config, string $method, string $errorMessage)\n    {\n        if (isset($this->extensions[$config['name']])) {\n            return $this->callCustomCreator($config['name'], $config);\n        }\n\n        if (\\method_exists($this, $method)) {\n            return $this->{$method}($config);\n        }\n\n        throw new InvalidArgumentException(\\sprintf($errorMessage, $config['name']));\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns detailed information about the specific item in the cache.\n\n@param string $key Cache item name.\n\n@return mixed [SEP] public function getMetaData(string $key)\n\t{\n\t\t$key = $this->prefix . $key;\n\n\t\tif (! is_file($this->path . $key))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t$data = @unserialize(file_get_contents($this->path . $key));\n\n\t\tif (is_array($data))\n\t\t{\n\t\t\t$mtime = filemtime($this->path . $key);\n\n\t\t\tif (! isset($data['ttl']))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn [\n\t\t\t\t'expire' => $mtime + $data['ttl'],\n\t\t\t\t'mtime'  => $mtime,\n\t\t\t\t'data'   => $data['data'],\n\t\t\t];\n\t\t}\n\n\t\treturn false;\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "finds and return content of requested block by name\n@param $name\n@param bool $isGlobal\n@return bool|string\n@throws BadRequestHttpException [SEP] public function loadBlock($name, $isGlobal = false)\n    {\n        if (is_null($name)) {\n            throw new BadRequestHttpException('Block name not specified.');\n        }\n\n        $find = [\n            'title' => $name,\n        ];\n\n        if ($isGlobal === false) {\n            //if not global\n            if (isset($this->params['block']['id'])) {\n                $find['parent'] = $this->params['block']['id'];\n            }\n            if (isset($this->params['block']['layout'])) {\n                $find['parent_layout'] = $this->params['block']['layout'];\n            }\n\n            if (isset($this->params['block']['slug'])) {\n                //get parent page id\n                /**\n                 * @var $page \\backend\\models\\Page\n                 */\n                if ($page = Page::findOne([\n                    'slug' => $this->params['block']['slug'],\n                ])) {\n                    $find['parent'] = $page->id;\n                }\n            }\n        }\n\n        /**\n         * @var $block \\backend\\models\\Block\n         */\n        if ($block = Block::findOne($find)) {\n            //if block found\n            return $block->render();\n        }\n\n        return false;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extracts the elements of the passed value by exploding them\nwith the also passed delimiter.\n\n@param string|null $value     The value to extract\n@param string|null $delimiter The delimiter used to extrace the elements\n\n@return array|null The exploded values\n@see \\TechDivision\\Import\\Serializers\\SerializerInterface::unserialize() [SEP] public function explode($value = null, $delimiter = null)\n    {\n        return $this->getValueCsvSerializer()->explode($value, $delimiter);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns a Cache Item representing the specified key.\n\nThis method must always return an ItemInterface object, even in case of\na cache miss. It MUST NOT return null.\n\n@param string $key\nThe key for which to return the corresponding Cache Item.\n@return \\Psr\\Cache\\ItemInterface\nThe corresponding Cache Item.\n@throws \\Psr\\Cache\\InvalidArgumentException\nIf the $key string is not a legal value a \\Psr\\Cache\\InvalidArgumentException\nMUST be thrown. [SEP] public function getItem($key)\n    {\n        // no check for legality atm, since we can use everything as a key\n        // usually you want that to reflect the limitations put in place by psr-6\n        $map = self::mapKey($key);\n\n        if (!file_exists($this->path .'/'. $map['dir'])) {\n            mkdir($this->path .'/'. $map['dir']);\n        }\n\n        return FileItem::fromFile($this->path .'/'. $map['dir'] . '/' . $map['file'], $key);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Extract first bit of a long string and add ellipsis\n\n@param  string  $string\n@param  integer $length\n@return string [SEP] public function excerpt(string $string, int $length = 20): string\n\t{\n\t\treturn (strlen($string) > $length) ? substr($string, 0, $length - 3) . '...' : $string;\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Gets product module by its number.See NetLicensingAPI for details:\nhttps://www.labs64.de/confluence/display/NLICPUB/Product+Module+Services#ProductModuleServices-Getproductmodule\n\ndetermines the vendor on whose behalf the call is performed\n@param \\NetLicensing\\Context $context\n\nthe product module number\n@param string $number\n\nreturn the product module object\n@return ProductModule|null\n@throws MalformedArgumentsException\n@throws RestException\n@throws \\ErrorException [SEP] public static function get(Context $context, $number)\n    {\n        CheckUtils::paramNotEmpty($number, Constants::NUMBER);\n\n        $response = NetLicensingService::getInstance()\n            ->get($context, Constants::PRODUCT_MODULE_ENDPOINT_PATH . '/' . $number);\n\n        $productModule = null;\n\n        if (!empty($response->items->item[0])) {\n            $productModule = ItemToProductModuleConverter::convert($response->items->item[0]);\n            $productModule->exists = true;\n        }\n\n        return $productModule;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Class autoloader to scan bundles directory\n\n@param   string          $classname  The name of the class to load\n@param   null/string     $type       The namespace type (Controller for example)\n@param   bool            $silent     Exit silently if not found (default is false)\n@return  bool/string     TRUE if the classfile had been found\n@throws  \\CarteBlanche\\Exception\\ErrorException if the class can't be found & $silent is false [SEP] public static function loadClass($classname, $type = null, $silent = false)\n    {\n        // search in bundles\n        $bundles = CarteBlanche::getContainer()->get('bundles');\n        $full_classname = $type.$classname;\n        $classfile = ucfirst($classname).'.php';\n        if (!empty($bundles)) {\n            foreach($bundles as $_n=>$_bundle) {\n                $_namespace = $_bundle->getNamespace();\n                if (!empty($type)) {\n                    $bundle_file = rtrim($_bundle->getDirectory(), '/').'/'\n                        .rtrim($type, '/').'/'\n                        .$classfile;\n                    $full_namespace = '\\\\'.$_namespace.'\\\\'.$type.'\\\\'.ucfirst($classname);\n                    if ($_ce = self::classExists($full_namespace)) {\n                        return $full_namespace;\n                    } elseif ($_f = Locator::locate($bundle_file)) {\n                        if (true===self::load($_f)) {\n                            return $full_namespace;\n                        }\n                    }\n                } else {\n                    if ($_namespace == substr(trim($classname, '\\\\'), 0, strlen($_namespace))) {\n                        $bundle_file = str_replace('\\\\', DIRECTORY_SEPARATOR,\n                            rtrim($_bundle->getDirectory(), '/')\n                            .substr(trim($classname, '\\\\'), strlen($_namespace))\n                            .'.php'\n                        );\n                        $full_namespace = $classname;\n                        if ($_ce = self::classExists($full_namespace)) {\n                            return $full_namespace;\n                        } elseif ($_f = Locator::locate($bundle_file)) {\n                            if (true===self::load($_f)) {\n                                return $classname;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // silently return if the class has not been found\n        if (0!==error_reporting() && true!==$silent) {\n            throw new ErrorException(\"Class '$classname' not found!\");\n        }\n        return false;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Specifies a single route to match for multiple HTTP Verbs.\n\nExample:\n$route->match( ['get', 'post'], 'users/(:num)', 'users/$1);\n\n@param array        $verbs\n@param string       $from\n@param string|array $to\n@param array        $options\n\n@return \\CodeIgniter\\Router\\RouteCollectionInterface [SEP] public function match(array $verbs = [], string $from, $to, array $options = null): RouteCollectionInterface\n\t{\n\t\tforeach ($verbs as $verb)\n\t\t{\n\t\t\t$verb = strtolower($verb);\n\n\t\t\t$this->{$verb}($from, $to, $options);\n\t\t}\n\n\t\treturn $this;\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "{@inheritdoc} [SEP] public function getAssignment($roleName, $userId)\n    {\n        return isset($this->assignments[$userId][$roleName])\n            ? resolve($this->assignments[$userId][$roleName])\n            : reject(new Error(\"Assignment for user '$userId' with role '$roleName' not found\"));\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Init the plugin and start listening to messages [SEP] public function init()\n    {\n        $this->addResponses();\n\n        $config = $this->bot->getConfig();\n\n        // detects someone speaking to the bot\n        $responses = $this->responses;\n        $address_re = \"/(^{$config['nick']}(.+)|(.+){$config['nick']}[!.?]*)$/i\";\n        $this->bot->onChannel($address_re, function(Event $event) use ($responses) {\n            $matches = $event->getMatches();\n            $message = $matches[1] ? $matches[1] : $matches[2];\n            \n            foreach ($responses as $regex => $function) {\n                if (preg_match($regex, $message, $matches)) {\n                    $event->addResponse(\n                        Response::msg($event->getRequest()->getSource(), $function($matches))\n                    );\n                }\n            }\n        });\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates promise to update metadata headers on the share.\n\n@param string                  $share    name\n@param array                   $metadata metadata key/value pair.\n@param FileServiceOptions|null $options optional  parameters\n\n@return \\GuzzleHttp\\Promise\\PromiseInterface\n\n@see https://docs.microsoft.com/en-us/rest/api/storageservices/set-share-metadata [SEP] public function setShareMetadataAsync(\n        $share,\n        array $metadata,\n        FileServiceOptions $options = null\n    ) {\n        return $this->setSharePropertiesAsyncImpl(\n            $share,\n            $metadata,\n            $options,\n            'metadata'\n        );\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Test if point A is in one of the triangle's segments\n\n@param   \\Maths\\PointInterface   $a\n@return  bool [SEP] public function isValidPoint(PointInterface $a)\n    {\n        return (bool) (\n            $this->getSegmentAB()->isValidPoint($a) ||\n            $this->getSegmentBC()->isValidPoint($a) ||\n            $this->getSegmentCA()->isValidPoint($a)\n        );\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "{@inheritdoc} [SEP] public function clean(SplFileInfo $file)\n    {\n        $array = file($file->getRealPath());\n\n        if (count($array)) {\n            // Crowdin adds --- on the beginning of every Yaml during the export.\n            if (1 === preg_match(\"/^---/\", $array[0])) {\n                unset($array[0]);\n            }\n\n            file_put_contents($file->getRealPath(), $array);\n        }\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Handle index requests\n\n@throws \\SilverStripe\\Control\\HTTPResponse_Exception [SEP] public function index()\n    {\n        if ($cart = $this->Cart()) {\n            return $this->redirect($cart->CartLink);\n        } elseif ($response = ErrorPage::response_for(404)) {\n            return $response;\n        }\n        return $this->httpError(404, _t('SilverShop\\Cart\\ShoppingCart.NoCartInitialised', 'no cart initialised'));\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "添加语言包语句.\n\n@param string $i18nName\n@param array  $data [SEP] public function addtext(string $i18n, array $data = []): void\n    {\n        if (array_key_exists($i18n, $this->text)) {\n            $this->text[$i18n] = array_merge($this->text[$i18n], $data);\n        } else {\n            $this->text[$i18n] = $data;\n        }\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Setup actions. [SEP] protected function setup_actions() {\n\t\tif ( papi_is_admin() ) {\n\t\t\tadd_action( 'admin_init', [$this, 'admin_bar_menu'] );\n\t\t\tadd_action( 'admin_menu', [$this, 'page_items_menu'] );\n\t\t\tadd_action( 'admin_menu', [$this, 'post_types_menu'] );\n\t\t} else {\n\t\t\tadd_action( 'admin_bar_menu', [$this, 'admin_bar_menu'] );\n\t\t}\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Tries to inject by looking up a property by name.\n\n@param object $bean\n@param string $name\n@param string $value\n\n@return boolean [SEP] private function _propertyInject($bean, $name, $value)\n    {\n        $rClass = $this->_reflectionFactory->getClass(get_class($bean));\n        if ($rClass->hasProperty($name)) {\n             $rProperty = $rClass->getProperty($name);\n             if (!$rProperty->isPublic()) {\n                $rProperty->setAccessible(true);\n             }\n            $rProperty->setValue($bean, $value);\n            return true;\n        }\n        return false;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Submits the task to a worker and returns a promise which resolves or rejects with the resolve value of the task.\n@param \\CharlotteDunois\\Phoebe\\AsyncTask  $task\n@return \\React\\Promise\\ExtendedPromiseInterface\n@throws \\InvalidArgumentException [SEP] function submitTask(\\CharlotteDunois\\Phoebe\\AsyncTask $task) {\n        if(!$task->id) {\n            throw new \\InvalidArgumentException('Async Task has no ID - did you call parent::__construct() in your constructor?');\n        }\n        \n        return $this->submit($task)->then(function (\\CharlotteDunois\\Phoebe\\Worker $worker) use (&$task) {\n            $itask = new \\CharlotteDunois\\Phoebe\\InternalTask($worker, $task);\n            $this->tasks->set($task->id, $itask);\n            \n            return $itask->getDeferred()->promise();\n        });\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Provides an opportunity for extending classes to modify the model in some way when they themselves are not\ndirectly responsible for the model creation. [SEP] protected function onModelCreated()\n    {\n        parent::onModelCreated();\n\n        if ($this->incomingRestModel instanceof Model){\n            $this->setRestModel($this->incomingRestModel);\n        } elseif ($this->incomingRestModel instanceof Collection){\n            $this->setRestCollection($this->incomingRestModel);\n        }\n\n        $this->model->createSubLeafFromNameEvent->attachHandler(function($leafName){\n\n            if (!$this->hasRestModelOrCollection) {\n                return null;\n            }\n\n            $restModel = $this->model->restModel;\n\n            if ($restModel) {\n                $class = $restModel->getModelName();\n                $schema = $restModel->getSchema();\n            } else {\n                $restCollection = $this->model->restCollection;\n\n                $class = $restCollection->getModelClassName();\n                $schema = $restCollection->getModelSchema();\n            }\n\n            $leaf = $this->createLeafForLeafName($leafName);\n\n            if ($leaf){\n                return $leaf;\n            }\n\n            // See if the model has a relationship with this name.\n            $relationships = SolutionSchema::getAllOneToOneRelationshipsForModelBySourceColumnName($class);\n\n            $columnRelationships = false;\n\n            if (isset($relationships[$leafName])) {\n                $columnRelationships = $relationships[$leafName];\n            } else {\n                if ($leafName == $schema->uniqueIdentifierColumnName) {\n                    if (isset($relationships[\"\"])) {\n                        $columnRelationships = $relationships[\"\"];\n                    }\n                }\n            }\n\n            if ($columnRelationships) {\n                $relationship = $relationships[$leafName];\n\n                $collection = $relationship->getCollection();\n\n                $dropDown = new DropDown($leafName);\n                $dropDown->setSelectionItems(\n                    [\n                        [\"\", \"Please Select\"],\n                        $collection\n                    ]\n                );\n\n                $dropDown->setLabel(StringTools::wordifyStringByUpperCase($relationship->getNavigationPropertyName()));\n\n                return $dropDown;\n            }\n\n            $columns = $schema->getColumns();\n\n            if (!isset($columns[$leafName])) {\n                return null;\n            }\n\n            $column = $columns[$leafName];\n\n            return $this->createLeafFromColumn($column, $leafName);\n        });\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "{@inheritdoc} [SEP] public function getUserBookNumber(UserInterface $user)\n    {\n        $qb = $this->createGetUserBooksQueryBuilder($user);\n\n        return (int)$qb->select($qb->expr()->count('c'))\n            ->getQuery()\n            ->getSingleScalarResult();\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Callback function called by cURL for reading the request body\n\n@param resource $ch     cURL handle\n@param resource $fd     file descriptor (not used)\n@param integer  $length maximum length of data to return\n\n@return   string      part of the request body, up to $length bytes [SEP] protected function callbackReadBody($ch, $fd, $length)\r\n    {\r\n        if (!$this->eventSentHeaders) {\r\n            $this->request->setLastEvent(\r\n                'sentHeaders', curl_getinfo($ch, CURLINFO_HEADER_OUT)\r\n            );\r\n            $this->eventSentHeaders = true;\r\n        }\r\n        if (in_array($this->request->getMethod(), self::$bodyDisallowed)\r\n            || 0 == $this->contentLength || $this->position >= $this->contentLength\r\n        ) {\r\n            return '';\r\n        }\r\n        if (is_string($this->requestBody)) {\r\n            $string = substr($this->requestBody, $this->position, $length);\r\n        } elseif (is_resource($this->requestBody)) {\r\n            $string = fread($this->requestBody, $length);\r\n        } else {\r\n            $string = $this->requestBody->read($length);\r\n        }\r\n        $this->request->setLastEvent('sentBodyPart', strlen($string));\r\n        $this->position += strlen($string);\r\n        return $string;\r\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sort a list of arrays of array(downloaded packagefilename) by dependency.\n\nThis uses the topological sort method from graph theory, and the\nStructures_Graph package to properly sort dependencies for installation.\n@param array an array of downloaded PEAR_Downloader_Packages\n@return array array of array(packagefilename, package.xml contents) [SEP] function sortPackagesForInstall(&$packages)\n    {\n        require_once 'Structures/Graph.php';\n        require_once 'Structures/Graph/Node.php';\n        require_once 'Structures/Graph/Manipulator/TopologicalSorter.php';\n        $depgraph = new Structures_Graph(true);\n        $nodes = array();\n        $reg = &$this->config->getRegistry();\n        foreach ($packages as $i => $package) {\n            $pname = $reg->parsedPackageNameToString(\n                array(\n                    'channel' => $package->getChannel(),\n                    'package' => strtolower($package->getPackage()),\n                ));\n            $nodes[$pname] = new Structures_Graph_Node;\n            $nodes[$pname]->setData($packages[$i]);\n            $depgraph->addNode($nodes[$pname]);\n        }\n\n        $deplinks = array();\n        foreach ($nodes as $package => $node) {\n            $pf = &$node->getData();\n            $pdeps = $pf->getDeps(true);\n            if (!$pdeps) {\n                continue;\n            }\n\n            if ($pf->getPackagexmlVersion() == '1.0') {\n                foreach ($pdeps as $dep) {\n                    if ($dep['type'] != 'pkg' ||\n                          (isset($dep['optional']) && $dep['optional'] == 'yes')) {\n                        continue;\n                    }\n\n                    $dname = $reg->parsedPackageNameToString(\n                          array(\n                              'channel' => 'pear.php.net',\n                              'package' => strtolower($dep['name']),\n                          ));\n\n                    if (isset($nodes[$dname])) {\n                        if (!isset($deplinks[$dname])) {\n                            $deplinks[$dname] = array();\n                        }\n\n                        $deplinks[$dname][$package] = 1;\n                        // dependency is in installed packages\n                        continue;\n                    }\n\n                    $dname = $reg->parsedPackageNameToString(\n                          array(\n                              'channel' => 'pecl.php.net',\n                              'package' => strtolower($dep['name']),\n                          ));\n\n                    if (isset($nodes[$dname])) {\n                        if (!isset($deplinks[$dname])) {\n                            $deplinks[$dname] = array();\n                        }\n\n                        $deplinks[$dname][$package] = 1;\n                        // dependency is in installed packages\n                        continue;\n                    }\n                }\n            } else {\n                // the only ordering we care about is:\n                // 1) subpackages must be installed before packages that depend on them\n                // 2) required deps must be installed before packages that depend on them\n                if (isset($pdeps['required']['subpackage'])) {\n                    $t = $pdeps['required']['subpackage'];\n                    if (!isset($t[0])) {\n                        $t = array($t);\n                    }\n\n                    $this->_setupGraph($t, $reg, $deplinks, $nodes, $package);\n                }\n\n                if (isset($pdeps['group'])) {\n                    if (!isset($pdeps['group'][0])) {\n                        $pdeps['group'] = array($pdeps['group']);\n                    }\n\n                    foreach ($pdeps['group'] as $group) {\n                        if (isset($group['subpackage'])) {\n                            $t = $group['subpackage'];\n                            if (!isset($t[0])) {\n                                $t = array($t);\n                            }\n\n                            $this->_setupGraph($t, $reg, $deplinks, $nodes, $package);\n                        }\n                    }\n                }\n\n                if (isset($pdeps['optional']['subpackage'])) {\n                    $t = $pdeps['optional']['subpackage'];\n                    if (!isset($t[0])) {\n                        $t = array($t);\n                    }\n\n                    $this->_setupGraph($t, $reg, $deplinks, $nodes, $package);\n                }\n\n                if (isset($pdeps['required']['package'])) {\n                    $t = $pdeps['required']['package'];\n                    if (!isset($t[0])) {\n                        $t = array($t);\n                    }\n\n                    $this->_setupGraph($t, $reg, $deplinks, $nodes, $package);\n                }\n\n                if (isset($pdeps['group'])) {\n                    if (!isset($pdeps['group'][0])) {\n                        $pdeps['group'] = array($pdeps['group']);\n                    }\n\n                    foreach ($pdeps['group'] as $group) {\n                        if (isset($group['package'])) {\n                            $t = $group['package'];\n                            if (!isset($t[0])) {\n                                $t = array($t);\n                            }\n\n                            $this->_setupGraph($t, $reg, $deplinks, $nodes, $package);\n                        }\n                    }\n                }\n            }\n        }\n\n        $this->_detectDepCycle($deplinks);\n        foreach ($deplinks as $dependent => $parents) {\n            foreach ($parents as $parent => $unused) {\n                $nodes[$dependent]->connectTo($nodes[$parent]);\n            }\n        }\n\n        $installOrder = Structures_Graph_Manipulator_TopologicalSorter::sort($depgraph);\n        $ret = array();\n        for ($i = 0, $count = count($installOrder); $i < $count; $i++) {\n            foreach ($installOrder[$i] as $index => $sortedpackage) {\n                $data = &$installOrder[$i][$index]->getData();\n                $ret[] = &$nodes[$reg->parsedPackageNameToString(\n                          array(\n                              'channel' => $data->getChannel(),\n                              'package' => strtolower($data->getPackage()),\n                          ))]->getData();\n            }\n        }\n\n        $packages = $ret;\n        return;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Inserts an ActiveRecord into DB without considering transaction.\n@param array                    $attributes list of attributes that need to be saved. Defaults to `null`,\nmeaning all attributes that are loaded from DB will be saved.\n@param ConnectionInterface|null $connection\n@return ExtendedPromiseInterface with bool whether the record is inserted successfully. [SEP] protected function insertInternal($attributes = null, $connection = null)\n    {\n        if (!$this->beforeSave(true)) {\n            return reject(false);\n        }\n        $values = $this->getDirtyAttributes($attributes);\n        return static::getDb()->getSchema()->insert(static::tableName(), $values, $connection)->then(\n            function($primaryKeys) use ($values) {\n                if ($primaryKeys === false) {\n                    return reject(false);\n                }\n                foreach ($primaryKeys as $name => $value) {\n                    $id = static::getTableSchema()->columns[$name]->phpTypecast($value);\n                    $this->setAttribute($name, $id);\n                    $values[$name] = $id;\n                }\n\n                $changedAttributes = array_fill_keys(array_keys($values), null);\n                $this->setOldAttributes($values);\n                $this->afterSave(true, $changedAttributes);\n                return true;\n            }\n        );\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize screaming snake/kebab case value to regular snake/kebab case.\n\n@param string $value\n\n@return string [SEP] private static function normalizeScreamingCase(string $value): string\n    {\n        if (\\ctype_upper(\\str_replace(['_', '-'], '', $value))) {\n            return \\mb_strtolower($value);\n        }\n\n        return $value;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Register the error handler. The level at which the conversion to Exception is done\n(null to use the error_reporting() value and 0 to disable)\n\n@param  integer $level\n@return The     registered error handler [SEP] public static function register($level = null)\n    {\n        $handler = new static();\n        $handler->setLevel($level);\n\n        ini_set('display_errors', 0);\n        set_exception_handler(array($handler, 'handleException'));\n        set_error_handler(array($handler, 'handle'));\n        register_shutdown_function(array($handler, 'handleFatal'));\n        $handler->reservedMemory = str_repeat('x', 10240);\n\n        return $handler;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "注解路由匹配成功处理.\n\n@param array $routers\n@param array $matcheVars\n\n@return array [SEP] protected function matcheSuccessed(array $routers, array $matcheVars = []): array\n    {\n        // 协议匹配\n        if (!empty($routers['scheme']) &&\n            false === $this->matcheScheme($routers['scheme'])) {\n            return [];\n        }\n\n        // 域名匹配\n        if (false === ($domainVars = $this->matcheDomain($routers))) {\n            return [];\n        }\n\n        // 未绑定\n        if (!$routers['bind']) {\n            return [];\n        }\n\n        $result = [];\n\n        $result[IRouter::BIND] = $routers['bind'];\n        $result[IRouter::APP] = $this->findApp($routers['bind']);\n\n        $result['params'] = [];\n\n        // 域名匹配参数 {subdomain}.{domain}\n        if ($domainVars) {\n            $result['params'] = $domainVars;\n        }\n\n        // 路由匹配参数 /v1/pet/{id}\n        if ($matcheVars) {\n            $result['params'] = array_merge($result['params'], $matcheVars);\n        }\n\n        // 额外参数 ['extend1' => 'foo']\n        if (isset($routers['params']) && is_array($routers['params'])) {\n            $result['params'] = array_merge($result['params'], $routers['params']);\n        }\n\n        $result[IRouter::PARAMS] = $result['params'];\n        unset($result['params']);\n\n        // 中间件\n        if (isset($routers['middlewares'])) {\n            $this->middlewares = $this->mergeMiddlewares($this->middlewares, $routers['middlewares']);\n        }\n\n        $result[IRouter::MIDDLEWARES] = $this->middlewares;\n\n        // 匹配的变量\n        $result[IRouter::VARS] = $this->matchedVars;\n\n        return $result;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "@Route(\"/rename/{fileName}\", name=\"file_manager_rename\")\n\n@param Request $request\n@param $fileName\n\n@return \\Symfony\\Component\\HttpFoundation\\RedirectResponse\n\n@throws \\Exception [SEP] public function renameFileAction(Request $request, $fileName)\n    {\n        $translator = $this->get('translator');\n        $queryParameters = $request->query->all();\n        $formRename = $this->createRenameForm();\n        /* @var Form $formRename */\n        $formRename->handleRequest($request);\n        if ($formRename->isSubmitted() && $formRename->isValid()) {\n            $data = $formRename->getData();\n            $extension = $data['extension'] ? '.'.$data['extension'] : '';\n            $newfileName = $data['name'].$extension;\n            if ($newfileName !== $fileName && isset($data['name'])) {\n                $fileManager = $this->newFileManager($queryParameters);\n                $NewfilePath = $fileManager->getCurrentPath().DIRECTORY_SEPARATOR.$newfileName;\n                $OldfilePath = realpath($fileManager->getCurrentPath().DIRECTORY_SEPARATOR.$fileName);\n                if (0 !== strpos($NewfilePath, $fileManager->getCurrentPath())) {\n                    $this->addFlash('danger', $translator->trans('file.renamed.unauthorized'));\n                } else {\n                    $fs = new Filesystem();\n                    try {\n                        $fs->rename($OldfilePath, $NewfilePath);\n                        $this->addFlash('success', $translator->trans('file.renamed.success'));\n                        //File has been renamed successfully\n                    } catch (IOException $exception) {\n                        $this->addFlash('danger', $translator->trans('file.renamed.danger'));\n                    }\n                }\n            } else {\n                $this->addFlash('warning', $translator->trans('file.renamed.nochanged'));\n            }\n        }\n\n        return $this->redirectToRoute('file_manager', $queryParameters);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Move the uploaded file to a new location.\n\nUse this method as an alternative to move_uploaded_file(). This method\nis\nguaranteed to work in both SAPI and non-SAPI environments.\nImplementations must determine which environment they are in, and use\nthe appropriate method (move_uploaded_file(), rename(), or a stream\noperation) to perform the operation.\n\n$targetPath may be an absolute path, or a relative path. If it is a\nrelative path, resolution should be the same as used by PHP's rename()\nfunction.\n\nThe original file or stream MUST be removed on completion.\n\nIf this method is called more than once, any subsequent calls MUST raise\nan exception.\n\nWhen used in an SAPI environment where $_FILES is populated, when\nwriting files via moveTo(), is_uploaded_file() and\nmove_uploaded_file() SHOULD be used to ensure permissions and upload\nstatus are verified correctly.\n\nIf you wish to move to a stream, use getStream(), as SAPI operations\ncannot guarantee writing to stream destinations.\n\n@see http://php.net/is_uploaded_file\n@see http://php.net/move_uploaded_file\n\n@param string $targetPath Path to which to move the uploaded file.\n\n@throws \\InvalidArgumentException if the $targetPath specified is\ninvalid.\n@throws \\RuntimeException on any error during the move operation, or\non the second or subsequent call to the method.\n@throws \\Valkyrja\\HttpMessage\\Exceptions\\InvalidStream\n\n@return void [SEP] public function moveTo(string $targetPath): void\n    {\n        // If the error status is not OK\n        if (UPLOAD_ERR_OK !== $this->errorStatus) {\n            // Throw a runtime exception as there's been an uploaded file error\n            throw new RuntimeException(\n                'Cannot retrieve stream due to upload error'\n            );\n        }\n\n        // If the file has already been moved\n        if ($this->moved) {\n            // Throw a runtime exception as subsequent moves are not allowed\n            // in PSR-7\n            throw new RuntimeException(\n                'Cannot move file after it has already been moved'\n            );\n        }\n\n        $targetDirectory = \\dirname($targetPath);\n\n        // If the target directory is not a directory\n        // or the target directory is not writable\n        if (! is_dir($targetDirectory) || ! is_writable($targetDirectory)) {\n            // Throw a runtime exception\n            throw new RuntimeException(\n                sprintf(\n                    'The target directory `%s` does not exists '\n                    . 'or is not writable',\n                    $targetDirectory\n                )\n            );\n        }\n\n        $sapi = PHP_SAPI;\n\n        // If the PHP_SAPI value is empty\n        // or there is no file\n        // or the PHP_SAPI value is set to a CLI environment\n        if (\n            empty($sapi)\n            || ! $this->file\n            || 0 === strpos($sapi, 'cli')\n        ) {\n            // Non-SAPI environment, or no filename present\n            $this->writeStream($targetPath);\n        }\n        // Otherwise try to use the move_uploaded_file function\n        // and if the move_uploaded_file function call failed\n        elseif (false === move_uploaded_file($this->file, $targetPath)) {\n            // Throw a runtime exception\n            throw new RuntimeException(\n                'Error occurred while moving uploaded file'\n            );\n        }\n\n        $this->moved = true;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Persists a model to the server.\n@param  AModel $model\n@return int    The id of the saved pod. [SEP] public function store(AModel $model)\n    {\n        $driver = $this->_toolbox->getDriver();\n        $pod = $model->getPod();\n\n        //Signal here\n        $this->notify(\"before_store\", $pod);\n\n        $id = null;\n\n        try {\n            switch ($pod) {\n\n                   case $pod instanceof Vertex:\n                       if ($pod->isNew()) {\n\n                           if ($this->hasTransaction()) {\n                               $id = $this->determinePreviouslyStored($model);\n                               $this->_toolbox->getTransactionManager()->addWriteCollection($this->_toolbox->getVertexCollectionName());\n\n                               //In a transaction, since all commands are executed in a block on commit, the pod will not have a saved state if it has a previous\n                               //store command. This determines if that is the case and rewrites the command as a replace.\n                               if ($id !== false) {\n                                       return $this->addTransactionCommand(\"db.{$this->_toolbox->getVertexCollectionName()}.replace(result.$id._id, {$pod->toTransactionJSON()});\", \"PodManager:store\", $model, true);\n                               } else {\n                                       return $this->addTransactionCommand(\"graph.addVertex(null, {$pod->toTransactionJSON()})._properties;\", \"PodManager:store\", $model, true);\n                               }\n\n                           } else {\n                               $doc = $pod->toDriverDocument();\n                               $driver->saveVertex($this->_toolbox->getGraph(), $doc);\n                               $id = $doc->getInternalId();\n                           }\n\n                       } else {\n\n                           if ($this->hasTransaction()) {\n                               $this->_toolbox->getTransactionManager()->addWriteCollection($this->_toolbox->getVertexCollectionName());\n\n                               return $this->addTransactionCommand(\"db.{$this->_toolbox->getVertexCollectionName()}.replace('{$pod->getId()}', {$pod->toTransactionJSON()});\", \"PodManager:store\", $model, true);\n                           } else {\n                               $doc = $pod->toDriverDocument();\n                               $driver->replaceVertex($this->_toolbox->getGraph(), $pod->getId(), $doc);\n                           }\n                    }\n                    break;\n\n                   case $pod instanceof Edge:\n\n                       //Check to see if we have existing keys for the _to and _from vertices\n                       $fromKey = $pod->getFromId();\n                       $toKey = $pod->getToId();\n                       $fromKeyIsJSVar = false;\n                       $toKeyIsJSVar = false;\n\n                       //If we don't have a key for from\n                       if (!$fromKey) {\n\n                           //Get the from vertex\n                        $from = $pod->getFrom();\n\n                        //Save the vertices to get a key for them\n                           if ($from) {\n                               if ($from->hasChanged()) {\n\n                                   if ($this->hasTransaction()) {\n                                       $fromKey = $this->store($from);\n                                       $fromKeyIsJSVar = true;\n                                   } else {\n                                       $this->store($from);\n                                       $fromKey = $from->getPod()->getId();\n                                       $pod->setFrom($from);\n                                   }\n                               }\n\n                               //If there are no vertices, throw an error\n                        } else {\n                            throw new PodManagerException(\"An edge must have a valid 'from' vertex.\");\n                        }\n                    }\n\n                       //If we don't have a key for to\n                       if (!$toKey) {\n\n                        //Get the from vertex\n                        $to = $pod->getTo();\n\n                        //Save the vertices to get a key for them\n                           if ($to) {\n                               if ($to->hasChanged()) {\n\n                                   if ($this->hasTransaction()) {\n                                       $toKey = $this->store($to);\n                                       $toKeyIsJSVar = true;\n                                   } else {\n                                       $this->store($to);\n                                       $toKey = $to->getPod()->getId();\n                                       $pod->setTo($to);\n                                   }\n                               }\n\n                        //If there are no vertices, throw an error\n                        } else {\n                            throw new PodManagerException(\"An edge must have a valid 'to' vertex.\");\n                        }\n                       }\n\n                       if ($pod->isNew()) {\n\n                           if ($this->hasTransaction()) {\n\n                               $id = $this->determinePreviouslyStored($model);\n                               $this->_toolbox->getTransactionManager()->addWriteCollection($this->_toolbox->getEdgeCollectionName());\n\n                               //In a transaction, since all commands are executed in a block on commit, the pod will not have a saved state if it has a previous\n                               //store command. This determines if that is the case and rewrites the command as a replace.\n                               if ($id !== false) {\n                                       $this->addTransactionCommand(\"function () {graph.removeEdge(graph.getEdge(result.$id._id)); return true;}();\", \"PodManager:store\", $model, true);\n                                       $this->addTransactionCommand($this->generateCreateEdgeCommand($fromKeyIsJSVar, $fromKey, $toKeyIsJSVar, $toKey, $pod->toTransactionJSON(), \"result.$id._key\", true, $pod->getLabel()), \"PodManager:store\", $model, true);\n                               } else {\n                                       $this->addTransactionCommand($this->generateCreateEdgeCommand($fromKeyIsJSVar, $fromKey, $toKeyIsJSVar, $toKey, $pod->toTransactionJSON(), null, false, $pod->getLabel()), \"PodManager:store\", $model, true);\n                               }\n                           } else {\n                               $doc = $pod->toDriverDocument();\n\n                               $driver->saveEdge($this->_toolbox->getGraph(), $fromKey, $toKey, null, $doc);\n                               $id = $doc->getInternalId();\n                           }\n\n                       } else {\n                        //We delete the pod then save it, because ArangoDB does not provide a way to update the To and From vertices.\n                        if ($this->hasTransaction()) {\n                            $this->_toolbox->getTransactionManager()->addWriteCollection($this->_toolbox->getEdgeCollectionName());\n                            $this->addTransactionCommand(\"function () {graph.removeEdge(graph.getEdge('{$pod->getId()}')); return true;}();\", \"PodManager:store\", $model, true);\n                            $this->addTransactionCommand($this->generateCreateEdgeCommand($fromKeyIsJSVar, $fromKey, $toKeyIsJSVar, $toKey, $pod->toTransactionJSON(), $pod->getKey(), false, $pod->getLabel()), \"PodManager:store\", $model, true);\n                        } else {\n                            $id = $pod->getId();\n                            $revision = $pod->getRevision() + mt_rand(0, 1000);\n                            $this->delete($model);\n\n                            //Add the id and revision back, because deleting removes it\n                            $pod->setId($id);\n                            $pod->setRevision($revision);\n\n                            $doc = $pod->toDriverDocument();\n                            $driver->saveEdge($this->_toolbox->getGraph(), $fromKey, $toKey, null, $doc);\n                        }\n                    }\n                    break;\n\n                default:\n                    $doc = $pod->toDriverDocument();\n\n                    if ($pod->isNew()) {\n\n                        if ($this->hasTransaction()) {\n                            $id = $this->determinePreviouslyStored($model);\n                            $this->_toolbox->getTransactionManager()->addWriteCollection($pod->getType());\n\n                            //In a transaction, since all commands are executed in a block on commit, the pod will not have a saved state if it has a previous\n                            //store command. This determines if that is the case and rewrites the command as a replace.\n                            if ($id !== false) {\n                                $this->addTransactionCommand(\"db.{$pod->getType()}.replace(result.$id._id, {$pod->toTransactionJSON()}, true);\", \"PodManager:store\", $model);\n                            } else {\n                                $this->addTransactionCommand(\"db.{$pod->getType()}.save({$pod->toTransactionJSON()});\", \"PodManager:store\", $model);\n                            }\n\n                        } else {\n                            $driver->save($pod->getType(), $doc);\n                            $id = $doc->getInternalId();\n                        }\n\n                    } else {\n\n                        if ($this->hasTransaction()) {\n                            $this->_toolbox->getTransactionManager()->addWriteCollection($pod->getType());\n                            $this->addTransactionCommand(\"db.{$pod->getType()}.replace('{$pod->getId()}', {$pod->toTransactionJSON()}, true);\", \"PodManager:store\", $model);\n                        } else {\n                            $driver->replace($doc);\n                        }\n                    }\n\n            }\n        } catch (\\Exception $e) {\n            $normalised = $this->_toolbox->normaliseDriverExceptions($e);\n            throw new PodManagerException($normalised['message'], $normalised['code']);\n        }\n\n        if (!$this->hasTransaction()) {\n            return $this->processStoreResult($pod, $doc->getRevision(), $id);\n        }\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "@param Column $column\n\n@return string [SEP] public function writeColumnWithAlias(Column $column)\n    {\n        if (($alias = $column->getAlias()) && !$column->isAll()) {\n            return $this->writeColumn($column).' AS '.$this->writer->writeColumnAlias($alias);\n        }\n\n        return $this->writeColumn($column);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "@param array $response\n\n@return Project [SEP] public static function createFromAPIResponse(array $response): Project\n    {\n        $project = new Project();\n\n        $renders = [];\n\n        if (key_exists('renders', $response)) {\n            $renders = RenderFactory::createFromAPIResponse($response['renders']);\n        }\n\n        $project\n            ->setId($response['id'])\n            ->setLabel($response['label'])\n            ->setDescription($response['description'])\n            ->setThumbnailPath($response['thumb'])\n            ->setRenders($renders)\n            ->setArchived($response['archived'])\n            ->setPending($response['pending'])\n            ->setCreatedAt(new \\DateTimeImmutable($response['created_at']))\n            ->setUpdatedAt(new \\DateTimeImmutable($response['updated_at']))\n            ->setCreatedBy((string) $response['created_by'])\n        ;\n\n        return $project;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Send the message.\n\n@param bool $testmode Testmode to use\n\n@return mixed [SEP] public function send($testmode = false)\n    {\n        $data = array_replace($this->params, [\n            'username' => $this->username,\n            'password' => $this->password,\n            'message'  => $this->message->getMessage(),\n            'msisdn'   => $this->message->getRecipient(),\n        ]);\n\n        $concat = $this->message->getConcatParts();\n\n        if ($concat > 1) {\n            $data['allow_concat_text_sms']     = 1;\n            $data['concat_text_sms_max_parts'] = $concat;\n        }\n\n        // add test params if required\n        if ($testmode) {\n            if ($testmode == BulkSmsService::TEST_ALWAYS_SUCCEED) {\n                $data['test_always_succeed'] = 1;\n            } elseif ($testmode == BulkSmsService::TEST_ALWAYS_FAIL) {\n                $data['test_always_fail'] = 1;\n            }\n        }\n\n        return $this->curl->post($this->getUrl(), $data);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add an ArrayOfType based on the xsd:complexType syntax if type[] is detected in return value doc comment.\n\n@param string $type\n@return string tns:xsd-type [SEP] public function addComplexType($type)\n    {\n        if (in_array($type, $this->_inProcess)) {\n            require_once \"Zend/Soap/Wsdl/Exception.php\";\n            throw new Zend_Soap_Wsdl_Exception(\"Infinite recursion, cannot nest '\".$type.\"' into itself.\");\n        }\n        $this->_inProcess[$type] = $type;\n\n        $nestingLevel = $this->_getNestedCount($type);\n\n        if ($nestingLevel > 1) {\n            require_once \"Zend/Soap/Wsdl/Exception.php\";\n            throw new Zend_Soap_Wsdl_Exception(\n                \"ArrayOfTypeComplex cannot return nested ArrayOfObject deeper than \".\n                \"one level. Use array object properties to return deep nested data.\n            \");\n        }\n\n        $singularType = $this->_getSingularPhpType($type);\n\n        if (!class_exists($singularType)) {\n            require_once \"Zend/Soap/Wsdl/Exception.php\";\n            throw new Zend_Soap_Wsdl_Exception(sprintf(\n                \"Cannot add a complex type %s that is not an object or where \".\n                \"class could not be found in 'DefaultComplexType' strategy.\", $type\n            ));\n        }\n\n        if ($nestingLevel == 1) {\n            // The following blocks define the Array of Object structure\n            $xsdComplexTypeName = $this->_addArrayOfComplexType($singularType, $type);\n        } else {\n            $xsdComplexTypeName = $singularType;\n        }\n\n        // The array for the objects has been created, now build the object definition:\n        if (!in_array($singularType, $this->getContext()->getTypes())) {\n            parent::addComplexType($singularType);\n        }\n\n        unset($this->_inProcess[$type]);\n        return \"tns:\".$xsdComplexTypeName;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Provide a BC wrapper for CSRF token manager/provider compatibility between versions.\n\n@param Request $request [SEP] protected function validateCsrfToken(Request $request)\n    {\n        if (is_null($this->csrfTokenManager)) {\n            return;\n        }\n        $csrfToken = $this->getParameterFromRequest($request, $this->options['csrf_parameter']);\n\n        if (false === $this->csrfTokenManager->isTokenValid(new CsrfToken($this->options['intention'], $csrfToken))) {\n            throw new InvalidCsrfTokenException('Invalid CSRF token.');\n        }\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "{@inheritdoc} [SEP] public function generate(string $name, array $parameters = [], int $referenceType = self::ABSOLUTE_PATH): string\n    {\n        $routes = $this->routes;\n\n        if (($route = $routes->getByName($name)) !== null || ($route = $routes->getByAction($name)) !== null) {\n            return $this->toRoute($route, $parameters, $referenceType);\n        }\n\n        throw new RouteNotFoundException(\\sprintf('Unable to generate a URL for the named/action route [%s] as such route does not exist.', $name));\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns an array with the available categories and their\nresolved path as keys.\n\n@return array The array with the categories [SEP] public function getCategoriesWithResolvedPath()\n    {\n\n        // prepare the categories\n        $categories = array();\n\n        // load the categories from the database\n        $availableCategories = $this->categoryRepository->findAll();\n\n        // create the array with the resolved category path as keys\n        foreach ($availableCategories as $category) {\n            // expload the entity IDs from the category path\n            $entityIds = explode('/', $category[MemberNames::PATH]);\n\n            // cut-off the root category\n            array_shift($entityIds);\n\n            // continue with the next category if no entity IDs are available\n            if (sizeof($entityIds) === 0) {\n                continue;\n            }\n\n            // initialize the array for the path elements\n            $path = array();\n            foreach ($entityIds as $entityId) {\n                $cat = $this->categoryVarcharRepository->findByEntityId($entityId);\n                $path[] = $cat[MemberNames::VALUE];\n            }\n\n            // append the catogory with the string path as key\n            $categories[implode('/', $path)] = $category;\n        }\n\n        // return array with the categories\n        return $categories;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Render AJAX request. [SEP] public function render_ajax_request() {\n\t\t$items = $this->get_settings_properties();\n\n\t\tif ( papi_doing_ajax() ) {\n\t\t\t$counter       = papi_get_qs( 'counter' );\n\t\t\t$this->counter = intval( $counter );\n\t\t}\n\n\t\t$this->render_properties( $items, false );\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Sets the CSRF Hash and cookie.\n\n@return string\n@throws \\Exception [SEP] protected function CSRFSetHash(): string\n\t{\n\t\tif ($this->CSRFHash === null)\n\t\t{\n\t\t\t// If the cookie exists we will use its value.\n\t\t\t// We don't necessarily want to regenerate it with\n\t\t\t// each page load since a page could contain embedded\n\t\t\t// sub-pages causing this feature to fail\n\t\t\tif (isset($_COOKIE[$this->CSRFCookieName]) && is_string($_COOKIE[$this->CSRFCookieName]) && preg_match('#^[0-9a-f]{32}$#iS', $_COOKIE[$this->CSRFCookieName]) === 1\n\t\t\t)\n\t\t\t{\n\t\t\t\treturn $this->CSRFHash = $_COOKIE[$this->CSRFCookieName];\n\t\t\t}\n\n\t\t\t$rand           = random_bytes(16);\n\t\t\t$this->CSRFHash = bin2hex($rand);\n\t\t}\n\n\t\treturn $this->CSRFHash;\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a single translated attribute.\n\n@param $attribute\n@param null $language\n@param bool $fallback\n\n@return null [SEP] public function getTranslatedAttribute($attribute, $language = null, $fallback = true)\n    {\n        list($value) = $this->getTranslatedAttributeMeta($attribute, $language, $fallback);\n\n        return $value;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Map the parameter.\n\n@param string $name parameter\n\n@return null|string [SEP] public function getRouteParametersMapping($name)\n    {\n        return isset($this->routeParametersMapping[$name]) ? $this->routeParametersMapping[$name] : null;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Bind a shared Closure into the container.\n\n@param  string  $abstract\n@param  Closure $closure\n\n@return IContainer [SEP] public function bindShared( $abstract, Closure $closure )\r\n    {\r\n        $this->bind( $abstract, $this->share( $closure ), TRUE );\r\n\r\n        return $this;\r\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "@param \\Doctrine\\Common\\Persistence\\Mapping\\ClassMetadata $metadata\n@param                                                    $model\n\n@return array [SEP] protected function processFieldNames(ClassMetadata $metadata, $model)\n    {\n        $data = array();\n        foreach ($metadata->getFieldNames() as $fieldName) {\n            if ($metadata->isIdentifier($fieldName) && $metadata->usesIdGenerator()) {\n                continue;\n            }\n\n            $value = $this->readProperty($model, $fieldName);\n            if ($this->skipNullValues && $value === null) {\n                continue;\n            }\n\n            $data[$fieldName] = $this->navigator->accept($this->getVisitor(), $value);\n        }\n        \n        foreach ($this->fieldNamesPostProcessors as $postProcessor) {\n            /** @var FieldNamesPostProcessorInterface $postProcessor */\n            if ($postProcessor->supports($model, $metadata, $data)) {\n                $data = $postProcessor->getData($model, $metadata, $data);\n            }\n        }\n\n        return $data;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Submits the work to a worker. Resolves with the worker who accepted the job.\n@param \\Threaded  $work\n@return \\React\\Promise\\ExtendedPromiseInterface [SEP] function submit(\\Threaded $work) {\n        if($this->timer === null) {\n            $this->attachTimer();\n        }\n        \n        $worker = ($this->freeWorkers->count() > 0 ? $this->freeWorkers->dequeue() : null);\n        if(!$worker) {\n            if(\\count($this->workers) >= $this->size) {\n                $iwork = new \\CharlotteDunois\\Phoebe\\InternalWork($work);\n                $this->workQueue->enqueue($iwork);\n                \n                return $iwork->getDeferred()->promise();\n            }\n            \n            $worker = $this->spawnWorker();\n        }\n        \n        $worker = $this->checkAlive($worker);\n        \n        $this->busyWorkers->add($worker);\n        $worker->stack($work);\n        \n        if($this->messenger->usesSockets()) {\n            $msg = new \\CharlotteDunois\\Phoebe\\Message('internal-worker-stack-increased', null);\n            $this->sendMessageToWorker($worker, $msg);\n        }\n        \n        return \\React\\Promise\\resolve($worker);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Migrates us up or down to the version specified as $currentVersion\nin the migrations config file.\n\n@param array $params [SEP] public function run(array $params = [])\n\t{\n\t\t$runner = Services::migrations();\n\n\t\tCLI::write(lang('Migrations.toVersion'), 'yellow');\n\n\t\t$group = $params['-g'] ?? CLI::getOption('g');\n\t\ttry\n\t\t{\n\t\t\t$runner->current($group);\n\t\t\t$messages = $runner->getCliMessages();\n\t\t\tforeach ($messages as $message)\n\t\t\t{\n\t\t\t\tCLI::write($message);\n\t\t\t}\n\n\t\t\tCLI::write('Done');\n\t\t}\n\t\tcatch (\\Exception $e)\n\t\t{\n\t\t\t$this->showError($e);\n\t\t}\n\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the primary key definition.\n@param array $pk\n@param array $columns\n@param int $indent the number of text indent\n@return string the primary key definition [SEP] public function getPrimaryKey(array $pk, array $columns, $indent = 0)\n    {\n        if (empty($pk)) {\n            return '';\n        }\n\n        // Composite primary keys\n        if (2 <= count($pk)) {\n            $compositePk = implode(', ', $pk);\n            return $this->textIndent($indent) . \"'PRIMARY KEY ($compositePk)',\" . self::ENTER;\n        }\n        // Primary key not an auto-increment\n        $flag = false;\n        foreach ($columns as $column) {\n            if ($column->autoIncrement) {\n                $flag = true;\n            }\n        }\n        if (false === $flag) {\n            return $this->textIndent($indent) . sprintf(\"'PRIMARY KEY (%s)',\" . self::ENTER, $pk[0]);\n        }\n        return '';\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "{@inheritDoc} [SEP] public function createConfig(array $config = array())\n    {\n        $config = ArrayObject::ensureArrayObject($config);\n        $config->defaults($this->defaultConfig);\n        $config->defaults($this->coreGatewayFactory->createConfig());\n\n        $config->defaults(array(\n            'payum.factory_name' => 'redsys',\n            'payum.factory_title' => 'Redsys',\n\n            'payum.action.capture' => new CaptureAction(),\n            'payum.action.notify' => new NotifyAction(),\n            'payum.action.convert_payment' => new ConvertPaymentAction(),\n            'payum.action.status' => new StatusAction(),\n        ));\n\n        if (false == $config['payum.api']) {\n            $config['payum.default_options'] = array(\n                'merchant_code' => '',\n                'terminal' => '',\n                'secret_key' => '',\n                'sandbox' => true,\n            );\n\n            $config->defaults($config['payum.default_options']);\n            $config['payum.required_options'] = array('merchant_code', 'terminal', 'secret_key');\n\n            $config['payum.api'] = function (ArrayObject $config) {\n                $config->validateNotEmpty($config['payum.required_options']);\n\n                $redsysConfig = array(\n                    'merchant_code' => $config['merchant_code'],\n                    'terminal' => $config['terminal'],\n                    'secret_key' => $config['secret_key'],\n                    'sandbox' => $config['sandbox'],\n                );\n\n                return new Api($redsysConfig);\n            };\n        }\n\n        return (array) $config;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute SQL statement string\n@param string $sql Statement SQL string\n@param array  $params Statement parameters\n@param bool   $lazy Use lazy promise\n@return ExtendedPromiseInterface|LazyPromiseInterface [SEP] public function executeSql($sql, $params = [], $lazy = true) {\n        list($sql, $params) = $this->convertSqlToIndexed($sql, $params);\n        $promiseResolver = function($r, $c) use ($sql, $params) {\n            $result = [];\n            $this->getPgClient()->executeStatement($sql, $params)->subscribe(\n                function($row) use (&$result) {\n                    $result[] = $row;\n                },\n                function($error = null) use (&$c) {\n                    $c($error);\n                },\n                function() use (&$r, &$result) {\n                    $r($result);\n                }\n            );\n        };\n        if (!$lazy) {\n            return new Promise($promiseResolver);\n        }\n        $promiseCreator = function() use (&$promiseResolver) {\n            return new Promise($promiseResolver);\n        };\n        return new LazyPromise($promiseCreator);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Resolve a non-class hinted dependency.\n\n@param \\ReflectionParameter $parameter\n\n@return mixed\n\n@throws BindingResolutionException [SEP] protected function resolveNonClass(\\ReflectionParameter $parameter)\n    {\n        if ($parameter->isDefaultValueAvailable()) {\n            return $parameter->getDefaultValue();\n        }\n\n        $message = \"Unresolvable dependency resolving [$parameter] in class {$parameter->getDeclaringClass()->getName()}\";\n\n        throw new BindingResolutionException($message);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "获取一个大于0的金额\n@param string $name 参数名称\n@param string $msg 错误信息\n@return float [SEP] protected function getPositiveMoneyMust(string $name = 'money', string $msg = ''): float\n    {\n        $v = $this->getMoneyMust($name, $msg);\n        if ($v <= 0) {\n            trigger_error('金额必须大于零', E_USER_ERROR);\n        }\n        return $v;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Creates the promise to get the table.\n\n@param string          $table   The name of the table.\n@param GetTableOptions $options The optional parameters.\n\n@return \\GuzzleHttp\\Promise\\PromiseInterface [SEP] public function getTableAsync(\n        $table,\n        GetTableOptions $options = null\n    ) {\n        Validate::canCastAsString($table, 'table');\n        Validate::notNullOrEmpty($table, 'table');\n\n        $method      = Resources::HTTP_GET;\n        $headers     = array();\n        $postParams  = array();\n        $queryParams = array();\n        $path        = \"Tables('$table')\";\n\n        if (is_null($options)) {\n            $options = new GetTableOptions();\n        }\n\n        $this->addOptionalHeader(\n            $headers,\n            Resources::CONTENT_TYPE,\n            Resources::JSON_CONTENT_TYPE\n        );\n        $this->addOptionalHeader(\n            $headers,\n            Resources::ACCEPT_HEADER,\n            $options->getAccept()\n        );\n\n        $odataSerializer = $this->odataSerializer;\n\n        return $this->sendAsync(\n            $method,\n            $headers,\n            $queryParams,\n            $postParams,\n            $path,\n            Resources::STATUS_OK,\n            Resources::EMPTY_STRING,\n            $options\n        )->then(function ($response) use ($odataSerializer) {\n            return GetTableResult::create($response->getBody(), $odataSerializer);\n        }, null);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Normalize relations to force an [identifier => constraint/transformer] structure.\n\n@param  array $relations\n@return array [SEP] protected function normalizeRelations(array $relations): array\n    {\n        return array_reduce(array_keys($relations), function ($normalized, $relation) use ($relations) {\n            if (is_numeric($relation)) {\n                return array_merge($normalized, [$relations[$relation] => null]);\n            }\n\n            return array_merge($normalized, [$relation => $relations[$relation]]);\n        }, []);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Executes the query and returns a single row of result.\n@param DatabaseInterface|DbConnectionGetterInterface $db the database connection used to generate the SQL statement.\nIf this parameter is not given, the `db` application component will be used.\n@return LazyPromiseInterface with array the first row (in terms of an array) of the query result. Rejects if the query\nresults in nothing. [SEP] public function one($db = null)\n    {\n        if ($this->emulateExecution) {\n            return new LazyPromise(function() { return reject(null); });\n        }\n\n        return $this->createCommand($db)->queryOne();\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get connection ready for query execution\n@return pgConnection\n@deprecated\n@see getIdleConnection() [SEP] private function getIdleConnectionOld(): pgConnection\n    {\n        // we want to get the first available one\n        // this will keep the connections at the front the busiest\n        // and then we can add an idle timer to the connections\n        foreach ($this->connections as $connection) {\n            // need to figure out different states (in trans etc.)\n            if ($connection->getState() === pgConnection::STATE_READY) {\n                return $connection;\n            }\n        }\n\n        if (count($this->connections) >= $this->maxConnections) {\n            return null;\n        }\n\n        return $this->createNewConnection();\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "注册新建实体.\n\n@param \\Leevel\\Database\\Ddd\\IEntity $entity\n@param int                          $priority\n\n@return $this [SEP] public function create(IEntity $entity, int $priority = 500): IUnitOfWork\n    {\n        $this->createEntity($entity);\n\n        $id = spl_object_id($entity);\n        $this->createsFlag[$id] = $priority;\n\n        return $this;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "This function uses common keys for obtaining the users real IP.\nWe use this for verbo se operating systems support.\n@link http://blackbe.lt/advanced-method-to-obtain-the-client-ip-in-php/\n@return mixed|string [SEP] private function IP_FILTER()\n    {\n        $ip_keys = array('HTTP_CLIENT_IP', 'HTTP_X_FORWARDED_FOR', 'HTTP_X_FORWARDED', 'HTTP_X_CLUSTER_CLIENT_IP', 'HTTP_FORWARDED_FOR', 'HTTP_FORWARDED', 'REMOTE_ADDR');\n        foreach ($ip_keys as $key) {\n            if (array_key_exists($key, $_SERVER) === true) {\n                foreach (explode(',', $_SERVER[$key]) as $ip) {\n                    // trim for safety measures\n                    $ip = trim($ip);\n                    if ($ip = filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4 | FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) {\n                        \\define('IP', $ip);\n                        return IP;\n                    }\n                }\n            }\n        }   // TODO - log invalid ip addresses\n        print 'Could not establish an IP address.';\n        die(1);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Clone the Github project [SEP] public function cloneProject()\n    {\n        $origin = sprintf('git@github.com:%s/%s.git', $this->username, $this->project);\n        $upstream = sprintf('https://github.com/%s/%s.git', $this->organization, $this->project);\n\n        $this->systemLog(sprintf('git clone %s %s', $origin, $this->projectPath));\n        $this->systemLog(sprintf('cd %s && git config user.name \"%s\"', $this->projectPath, $this->username));\n        $this->systemLog(sprintf('cd %s && git config user.email %s', $this->projectPath, $this->email));\n        $this->systemLog(sprintf('cd %s && git remote add upstream %s', $this->projectPath, $upstream));\n        $this->systemLog(sprintf('cd %s && git fetch upstream', $this->projectPath));\n        $this->systemLog(sprintf('cd %s && git merge upstream/master', $this->projectPath));\n        $this->systemLog(sprintf('cd %s && git push origin master', $this->projectPath));\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Ajax edit category.\n\n@return ResponseInterface [SEP] public function ajaxDelete()\n    {\n        if (!Server::getInstance()->isAjax()) {\n            throw new \\RuntimeException();\n        }\n\n        $response = new Api();\n        $response->setHttpCode(200);\n        $response->setIsSuccess(true);\n\n        try {\n            $post = Post::getInstance();\n\n            $categoryId = (int) $this->route->getParameterCollection()\n                ->getByName('id')\n                ->getValue();\n            $accountId  = (int) $post->get('accountId');\n\n            //~ Retrieve user account / account\n            $mapper = new AccountUserMapper(Database::get('money'));\n            $accountUser = $mapper->findByKeys(array(\n                'user_id'    => Session::getInstance()->get('id'),\n                'account_id' => $accountId\n            ));\n            $account = $accountUser->getAccount();\n\n            //~ Retrieve category\n            $categoryMapper = new CategoryMapper(Database::get('money'));\n            $category       = $categoryMapper->findById($categoryId);\n\n            if ($category->getAccountId() !== $account->getId()) {\n                throw new \\RuntimeException();\n            }\n\n            if ($category->getParentId() === 0 && $categoryMapper->rowExists('category_parent_id', $category->getId())) {\n                throw new \\RuntimeException('Current category has children! It cannot be deleted.', 1001);\n            }\n\n            $categoryMapper->delete($category);\n\n            //~ Reset category id for each transaction with old category id\n            $transactionMapper = new TransactionMapper(Database::get('money'));\n            $transactionMapper->addWhere('category_id', (int) $category->getId());\n            $transactionMapper->addWhere('account_id',  (int) $account->getId());\n            foreach ($transactionMapper->select() as $transaction) {\n                $transaction->setCategoryId(0);\n                $transactionMapper->update($transaction);\n            }\n\n        } catch (\\Exception $exception) {\n            $response->setIsSuccess(false)\n                ->setHttpCode(500)\n                ->setErrorCode($exception->getCode())\n                ->setErrorMessage($exception->getMessage())\n                ->setContent(true);\n        }\n\n        return $response;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "MapEntry ::= ( T_LABEL | ( QuotedString ':' ) ) Statement [SEP] protected function parseMapEntry($label, Node $val): array\n    {\n        return [\n            \\is_array($label) ? $label[0]->value : $label->value,\n            $val\n        ];\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "@param $operation\n\n@return null [SEP] protected function getOpenBizPackage($operation)\n    {\n        if ($operation instanceof InstallOperation) {\n            $package = $operation->getPackage();\n        } elseif ($operation instanceof UpdateOperation) {\n            $package = $operation->getTargetPackage();\n        }\n        if (isset($package) && $package instanceof PackageInterface && $package->getName() == $this->OenBizPackageName) {\n            return $package;\n        }\n\n        return null;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Add the headers found to the translations instance.\n\n@param array $headers\n@param array $entries\n\n@return array [SEP] private static function extractHeaders(array $headers, array $entries): array\n    {\n        $currentHeader = null;\n\n        foreach ($headers as $header) {\n            $header = \\trim($header);\n            $header = self::convertString($header);\n\n            if ($header === '') {\n                continue;\n            }\n\n            if (self::isHeaderDefinition($header)) {\n                $header                             = \\explode(':', $header, 2);\n                $currentHeader                      = \\trim($header[0]);\n                $entries['headers'][$currentHeader] = \\trim($header[1]);\n            } else {\n                $entries['headers'][$currentHeader] = [$entries['headers'][$currentHeader] ?? '', \\trim($header)];\n            }\n        }\n\n        return $entries;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Encode au format HTML\n\n@param  string  $string        Chaîne de caractères\n@param  boolean $specialChars  (optional) Si TRUE, encode également les caractères spéciaux &\"'<> (TRUE par défaut)\n@return string                 Chaîne encodée [SEP] public static function htmlEncode($string, $specialChars = true)\r\n  {\r\n    if ($specialChars) {\r\n      $string = htmlspecialchars($string);\r\n    }\r\n    return htmlentities($string);\r\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get Category data object.\n\n@param  bool $isForceReload\n@return Category [SEP] public function getCategory($isForceReload = false)\n    {\n        if ($isForceReload || null === $this->joinOneCacheCategory) {\n            $mapper = new CategoryMapper($this->dependencyContainer->getDatabase('money'));\n            $this->joinOneCacheCategory = $mapper->findByKeys(array(\n                'category_id' => $this->getCategoryId(),\n            ));\n        }\n        \n        return $this->joinOneCacheCategory;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Serializes given array into xml. The array indices must be string to use\nthem as XML tags.\n\n@param array  $array      object to serialize represented in array.\n@param string $rootName   name of the XML root element.\n@param string $defaultTag default tag for non-tagged elements.\n@param string $standalone adds 'standalone' header tag, values 'yes'/'no'\n\n@return string [SEP] public static function serialize(\n        array $array,\n        $rootName,\n        $defaultTag = null,\n        $standalone = null\n    ) {\n        $xmlVersion  = '1.0';\n        $xmlEncoding = 'UTF-8';\n\n        if (!is_array($array)) {\n            return false;\n        }\n\n        $xmlw = new \\XmlWriter();\n        $xmlw->openMemory();\n        $xmlw->startDocument($xmlVersion, $xmlEncoding, $standalone);\n\n        $xmlw->startElement($rootName);\n\n        self::_arr2xml($xmlw, $array, $defaultTag);\n\n        $xmlw->endElement();\n\n        return $xmlw->outputMemory(true);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updates the queue object\n\n@param string $queue_name\n@param array $options Parameters to change. keys:\n\n@return object [SEP] public function updateQueue($queue_name, $options)\n    {\n        $this->setJsonHeaders();\n        $queue = rawurlencode($queue_name);\n        $url = \"projects/{$this->project_id}/queues/$queue\";\n        return self::json_decode($this->apiCall(self::PATCH, $url, array('queue' => $options)));\n    }", "target": 1, "target_options": ["no_match", "match"]}
