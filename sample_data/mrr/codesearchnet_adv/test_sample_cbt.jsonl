{"input": "Private method to execute command with data . [SEP] def Func ( arg_0 , arg_1 , arg_2 = None , arg_3 = True ) : if not arg_2 : arg_2 = { } arg_2 . setdefault ( 'element_id' , arg_0 . element_id ) return arg_0 . _driver . Func ( arg_1 , arg_2 , arg_3 )", "target": 1, "target_options": [0, 1]}
{"input": "Create the decoder function . [SEP] def Func ( arg_0 , arg_1 ) : arg_2 = tf . compat . v1 . get_variable ( \"topics_words_logits\" , shape = [ arg_0 , arg_1 ] , initializer = tf . compat . v1 . glorot_normal_initializer ( ) ) arg_3 = tf . nn . softmax ( arg_2 , axis = - 1 ) def decoder ( arg_4 ) : arg_5 = tf . matmul ( arg_4 , arg_3 ) return tfd . OneHotCategorical ( probs = arg_5 , name = \"bag_of_words\" ) return decoder , arg_3", "target": 1, "target_options": [0, 1]}
{"input": "Parse and send the colored source . [SEP] def Func ( arg_0 , arg_1 , arg_2 = None , arg_3 = '' ) : arg_4 = 0 if arg_2 == 'str' or arg_0 . out == 'str' or isinstance ( arg_0 . out , StringIO . StringIO ) : arg_5 = arg_0 . out arg_0 . out = StringIO . StringIO ( ) arg_4 = 1 elif arg_2 is not None : arg_0 . out = arg_2 if arg_3 == 'NoColor' : arg_6 = False arg_0 . out . write ( arg_1 ) if arg_4 : return arg_1 , arg_6 else : return None , arg_6 arg_7 = arg_0 . color_table [ arg_3 ] . colors arg_0 . colors = arg_7 arg_0 . raw = arg_1 . expandtabs ( ) . rstrip ( ) arg_0 . lines = [ 0 , 0 ] arg_9 = 0 arg_10 = arg_0 . raw . find arg_11 = arg_0 . lines . append while 1 : arg_9 = arg_10 ( '\\n' , arg_9 ) + 1 if not arg_9 : break arg_11 ( arg_9 ) arg_11 ( len ( arg_0 . raw ) ) arg_0 . pos = 0 arg_12 = StringIO . StringIO ( arg_0 . raw ) arg_6 = False try : for arg_13 in generate_tokens ( arg_12 . readline ) : arg_0 ( * arg_13 ) except tokenize . TokenError as ex : arg_14 = ex . args [ 0 ] arg_15 = ex . args [ 1 ] [ 0 ] arg_0 . out . write ( \"%s\\n\\n*** ERROR: %s%s%s\\n\" % ( arg_7 [ token . ERRORTOKEN ] , arg_14 , arg_0 . raw [ arg_0 . lines [ arg_15 ] : ] , arg_7 . normal ) ) arg_6 = True arg_0 . out . write ( arg_7 . normal + '\\n' ) if arg_4 : arg_16 = arg_0 . out . getvalue ( ) arg_0 . out = arg_5 return ( arg_16 , arg_6 ) return ( None , arg_6 )", "target": 1, "target_options": [0, 1]}
{"input": "Write data to the stack and decrement the stack pointer accordingly . [SEP] def Func ( arg_0 , arg_1 , arg_2 = False ) : arg_0 . STACK -= len ( arg_1 ) arg_0 . write_bytes ( arg_0 . STACK , arg_1 , arg_2 ) return arg_0 . STACK", "target": 1, "target_options": [0, 1]}
{"input": "Calculate the margin in pixels below the plot area setting border_bottom . [SEP] def Func ( arg_0 ) : arg_1 = 7 if arg_0 . key and arg_0 . key_position == 'bottom' : arg_1 += len ( arg_0 . data ) * ( arg_0 . font_size + 5 ) arg_1 += 10 if arg_0 . show_x_labels : arg_2 = arg_0 . x_label_font_size if arg_0 . rotate_x_labels : arg_3 = map ( len , arg_0 . get_x_labels ( ) ) arg_4 = functools . reduce ( max , arg_3 ) arg_2 *= 0.6 * arg_4 arg_1 += arg_2 if arg_0 . stagger_x_labels : arg_1 += arg_2 + 10 if arg_0 . show_x_title : arg_1 += arg_0 . x_title_font_size + 5 arg_0 . border_bottom = arg_1", "target": 1, "target_options": [0, 1]}
{"input": "This function takes an app or library name and will return the corresponding repo for that app or library [SEP] def Func ( arg_0 ) : arg_1 = get_specs ( ) arg_2 = arg_1 . get_app_or_lib ( arg_0 ) [ 'repo' ] if not arg_2 : return None return Repo ( arg_2 )", "target": 1, "target_options": [0, 1]}
{"input": "The upload operation [SEP] def Func ( arg_0 , arg_1 , arg_2 , arg_3 , arg_4 , arg_5 ) : arg_1 , arg_6 = destination_from_source ( arg_1 ) if len ( arg_6 ) == len ( arg_1 ) : if arg_0 . prepare ( ) : for arg_7 , arg_8 in zip ( arg_1 , arg_6 ) : if arg_3 : arg_0 . file_remove ( os . path . splitext ( arg_8 ) [ 0 ] + '.lc' ) arg_0 . write_file ( arg_7 , arg_8 , arg_2 ) if arg_3 and arg_8 != 'init.lua' : arg_0 . file_compile ( arg_8 ) arg_0 . file_remove ( arg_8 ) if arg_4 : arg_0 . file_do ( os . path . splitext ( arg_8 ) [ 0 ] + '.lc' ) elif arg_4 : arg_0 . file_do ( arg_8 ) else : raise Exception ( 'Error preparing nodemcu for reception' ) else : raise Exception ( 'You must specify a destination filename for each file you want to upload.' ) if arg_5 : arg_0 . node_restart ( ) log . info ( 'All done!' )", "target": 1, "target_options": [0, 1]}
{"input": "Write changed . pth file back to disk [SEP] def Func ( arg_0 ) : if not arg_0 . dirty : return arg_1 = '\\n' . join ( map ( arg_0 . make_relative , arg_0 . paths ) ) if arg_1 : log . debug ( \"Saving %s\" , arg_0 . filename ) arg_1 = ( \"import sys; sys.__plen = len(sys.path)\\n\" \"%s\\n\" \"import sys; new=sys.path[sys.__plen:];\" \" del sys.path[sys.__plen:];\" \" p=getattr(sys,'__egginsert',0); sys.path[p:p]=new;\" \" sys.__egginsert = p+len(new)\\n\" ) % arg_1 if os . path . islink ( arg_0 . filename ) : os . unlink ( arg_0 . filename ) arg_2 = open ( arg_0 . filename , 'wt' ) arg_2 . write ( arg_1 ) arg_2 . close ( ) elif os . path . exists ( arg_0 . filename ) : log . debug ( \"Deleting empty %s\" , arg_0 . filename ) os . unlink ( arg_0 . filename ) arg_0 . dirty = False", "target": 1, "target_options": [0, 1]}
{"input": "Function to calculate checksum as per Satel manual . [SEP] def Func ( arg_0 ) : arg_1 = 0x147A for arg_2 in arg_0 : arg_1 = ( ( arg_1 << 1 ) & 0xFFFF ) | ( arg_1 & 0x8000 ) >> 15 arg_1 = arg_1 ^ 0xFFFF arg_1 = ( arg_1 + ( arg_1 >> 8 ) + arg_2 ) & 0xFFFF return arg_1", "target": 1, "target_options": [0, 1]}
{"input": "Handle provided columns and if necessary convert columns to a list for internal strage . [SEP] def Func ( arg_0 , arg_1 ) : if type ( arg_1 ) == list : arg_0 . columns = arg_1 elif type ( arg_1 ) == str : arg_0 . columns = [ c . strip ( ) for c in arg_1 . split ( ) ] elif type ( arg_1 ) == IntEnum : arg_0 . columns = [ str ( c ) for c in arg_1 ] else : raise RawlException ( \"Unknown format for columns\" )", "target": 1, "target_options": [0, 1]}
{"input": "Kill some or all containers [SEP] def Func ( arg_0 ) : arg_1 = arg_0 . signal if hasattr ( arg_0 , 'signal' ) else \"SIGKILL\" __with_containers ( arg_0 , Blockade . kill , signal = arg_1 )", "target": 1, "target_options": [0, 1]}
{"input": "Modify an existing domain . [SEP] def Func ( arg_0 , arg_1 , arg_2 = False , arg_3 = None ) : arg_4 = arg_0 . _get_domain_from_db ( arg_1 ) if arg_4 is None : raise NoSuchDomainException if arg_2 : _logger . info ( \"Generating new salt..\" ) arg_4 . new_salt ( ) if arg_3 is not None : arg_4 . username = arg_3 return arg_4", "target": 1, "target_options": [0, 1]}
{"input": "Yields the result of applying an expression to each item in the input sequence . [SEP] def Func ( arg_0 , arg_1 , arg_2 ) : from . import context , parse as uxpathparse if hasattr ( arg_1 , 'compute' ) : arg_1 = arg_1 . compute ( arg_0 ) arg_2 = next ( string_arg ( arg_0 , arg_2 ) , '' ) arg_3 = uxpathparse ( arg_2 ) for arg_4 in arg_1 : arg_5 = arg_0 . copy ( arg_4 = arg_4 ) yield from arg_3 . compute ( arg_5 )", "target": 1, "target_options": [0, 1]}
{"input": "Read a cell array . Returns an array with rows of the cell array . [SEP] def Func ( arg_0 , arg_1 , arg_2 ) : arg_3 = [ list ( ) for i in range ( arg_2 [ 'dims' ] [ 0 ] ) ] for arg_4 in range ( arg_2 [ 'dims' ] [ 0 ] ) : for arg_5 in range ( arg_2 [ 'dims' ] [ 1 ] ) : arg_6 , arg_7 , arg_8 = read_var_header ( arg_0 , arg_1 ) arg_9 = read_var_array ( arg_8 , arg_1 , arg_6 ) arg_3 [ arg_4 ] . append ( arg_9 ) arg_0 . seek ( arg_7 ) if arg_2 [ 'dims' ] [ 0 ] == 1 : return squeeze ( arg_3 [ 0 ] ) return squeeze ( arg_3 )", "target": 1, "target_options": [0, 1]}
{"input": "Build and send a message via stream or socket . [SEP] def Func ( arg_0 , arg_1 , arg_2 , arg_3 = None , arg_4 = None , arg_5 = None , arg_6 = None , arg_7 = None , arg_8 = False , arg_9 = None ) : if not isinstance ( arg_1 , ( zmq . Socket , ZMQStream ) ) : raise TypeError ( \"stream must be Socket or ZMQStream, not %r\" % type ( arg_1 ) ) elif arg_8 and isinstance ( arg_1 , ZMQStream ) : raise TypeError ( \"ZMQStream cannot track messages\" ) if isinstance ( arg_2 , ( Message , dict ) ) : arg_10 = arg_2 else : arg_10 = arg_0 . msg ( arg_2 , arg_3 = arg_3 , arg_4 = arg_4 , arg_7 = arg_7 , arg_9 = arg_9 ) arg_6 = [ ] if arg_6 is None else arg_6 arg_11 = arg_0 . serialize ( arg_10 , arg_5 ) arg_12 = 0 if arg_6 : arg_12 = zmq . SNDMORE arg_13 = False else : arg_13 = arg_8 if arg_8 : arg_14 = arg_1 . Func_multipart ( arg_11 , arg_12 , copy = False , arg_8 = arg_13 ) else : arg_14 = arg_1 . Func_multipart ( arg_11 , arg_12 , copy = False ) for arg_15 in arg_6 [ : - 1 ] : arg_1 . Func ( arg_15 , arg_12 , copy = False ) if arg_6 : if arg_8 : arg_14 = arg_1 . Func ( arg_6 [ - 1 ] , copy = False , arg_8 = arg_8 ) else : arg_14 = arg_1 . Func ( arg_6 [ - 1 ] , copy = False ) if arg_0 . debug : pprint . pprint ( arg_10 ) pprint . pprint ( arg_11 ) pprint . pprint ( arg_6 ) arg_10 [ 'tracker' ] = arg_14 return arg_10", "target": 1, "target_options": [0, 1]}
{"input": "Specify the data to which kernel values should be computed . [SEP] def Func ( arg_0 , arg_1 , arg_2 = None ) : arg_0 . features_ = as_features ( arg_1 , stack = True , bare = True ) return arg_0", "target": 1, "target_options": [0, 1]}
{"input": "Attemps connection to the server [SEP] def Func ( arg_0 ) : arg_0 . logger . info ( \"Attempting connection to %s:%s\" , arg_0 . server [ 0 ] , arg_0 . server [ 1 ] ) try : arg_0 . _open_socket ( ) arg_1 = arg_0 . sock . getpeername ( ) arg_0 . logger . info ( \"Connected to %s\" , str ( arg_1 ) ) arg_0 . sock . setblocking ( 1 ) arg_0 . sock . settimeout ( 5 ) arg_0 . sock . setsockopt ( socket . SOL_SOCKET , socket . SO_KEEPALIVE , 1 ) arg_2 = arg_0 . sock . recv ( 512 ) if is_py3 : arg_2 = arg_2 . decode ( 'latin-1' ) if arg_2 [ 0 ] == \"#\" : arg_0 . logger . debug ( \"Banner: %s\" , arg_2 . rstrip ( ) ) else : raise ConnectionError ( \"invalid banner from server\" ) except ConnectionError as e : arg_0 . logger . error ( str ( e ) ) arg_0 . close ( ) raise except ( socket . error , socket . timeout ) as e : arg_0 . close ( ) arg_0 . logger . error ( \"Socket error: %s\" % str ( e ) ) if str ( e ) == \"timed out\" : raise ConnectionError ( \"no banner from server\" ) else : raise ConnectionError ( e ) arg_0 . Funced = True", "target": 1, "target_options": [0, 1]}
{"input": "Provide a zipped stream of the docs tree . [SEP] def Func ( arg_0 , arg_1 ) : with pushd ( arg_1 ) : with tempfile . NamedTemporaryFile ( prefix = 'pythonhosted-' , delete = False ) as ziphandle : pass arg_2 = shutil . make_archive ( ziphandle . name , 'zip' ) notify . info ( \"Uploading {:.1f} MiB from '{}' to '{}'...\" . format ( os . path . getsize ( arg_2 ) / 1024.0 , arg_2 , arg_0 . target ) ) with io . open ( arg_2 , 'rb' ) as zipread : try : yield zipread finally : os . remove ( ziphandle . name ) os . remove ( ziphandle . name + '.zip' )", "target": 1, "target_options": [0, 1]}
{"input": "Applies a proximal operator to the columns of a matrix [SEP] def Func ( arg_0 , arg_1 , arg_2 ) : arg_3 = np . zeros_like ( arg_0 ) for arg_4 in range ( arg_0 . shape [ 1 ] ) : arg_3 [ : , arg_4 ] = arg_2 ( arg_0 [ : , arg_4 ] , arg_1 ) return arg_3", "target": 1, "target_options": [0, 1]}
{"input": "Write one log file into the summary text file . [SEP] def Func ( arg_0 , arg_1 ) : if os . path . isfile ( arg_1 ) : with open ( arg_1 , 'r' ) as tfile : arg_0 . write ( '============ Content of ' + arg_1 ) arg_0 . write ( '\\n' ) arg_0 . write ( tfile . read ( ) ) arg_0 . write ( '\\n\\n' )", "target": 1, "target_options": [0, 1]}
{"input": "The buffer list this instance operates on . [SEP] def Func ( arg_0 ) : if arg_0 . _iocb . aio_lio_opcode == libaio . IO_CMD_POLL : raise AttributeError return arg_0 . _Func", "target": 1, "target_options": [0, 1]}
{"input": "Removes all rows of the associated date from the given csv file . Defaults to today . [SEP] def Func ( arg_0 , arg_1 = '' , arg_2 = arg_3 ( arg_4 . date . today ( ) ) ) : arg_6 = os . path . isfile ( arg_1 ) if arg_6 : with open ( arg_1 , 'rb' ) as inp , open ( 'temp.csv' , 'wb' ) as out : arg_7 = csv . writer ( out ) for arg_8 in csv . reader ( inp ) : if arg_8 [ 0 ] != arg_2 : arg_7 . writerow ( arg_8 ) inp . close ( ) out . close ( ) os . remove ( arg_1 ) os . rename ( \"temp.csv\" , arg_1 )", "target": 1, "target_options": [0, 1]}
{"input": "The App decorator function . [SEP] def Func ( arg_0 , arg_1 = None , arg_2 = 60 , arg_3 = False , arg_4 = 'all' ) : from parsl . app . python import PythonFunc from parsl . app . bash import BashFunc logger . warning ( \"The 'Func' decorator will be deprecated in Parsl 0.8. Please use 'python_app' or 'bash_app' instead.\" ) if arg_0 == 'python' : arg_5 = PythonFunc elif arg_0 == 'bash' : arg_5 = BashFunc else : raise InvalidFuncTypeError ( \"Invalid apptype requested {}; must be 'python' or 'bash'\" . format ( arg_0 ) ) def wrapper ( arg_6 ) : return arg_5 ( arg_6 , arg_1 = arg_1 , arg_2 = arg_2 , arg_3 = arg_3 , arg_4 = arg_4 ) return wrapper", "target": 1, "target_options": [0, 1]}
{"input": "Create a record object from the marcxml description . [SEP] def Func ( arg_0 = None , arg_1 = arg_2 , arg_3 = arg_4 , arg_5 = '' , arg_6 = False , arg_7 = arg_8 ) : if arg_0 is None : return { } try : arg_9 = _Func_lxml ( arg_0 , arg_1 , arg_3 , arg_7 = arg_7 ) except InvenioBibRecordParserError as ex1 : return ( None , 0 , str ( ex1 ) ) if arg_6 : _record_sort_by_indicators ( arg_9 ) arg_10 = [ ] if arg_3 : arg_10 = _correct_record ( arg_9 ) return ( arg_9 , int ( not arg_10 ) , arg_10 )", "target": 1, "target_options": [0, 1]}
{"input": "Return all pipelines as a list [SEP] def Func ( arg_0 ) : arg_1 = list ( map ( arg_0 . get_pipeline , arg_0 . pipeline_dict . keys ( ) ) ) arg_0 . _construct_solid_defs ( arg_1 ) return arg_1", "target": 1, "target_options": [0, 1]}
{"input": "GSEA main procedure [SEP] def Func ( arg_0 ) : assert arg_0 . permutation_type in [ \"phenotype\" , \"gene_set\" ] assert arg_0 . min_size <= arg_0 . max_size arg_0 . _logger . info ( \"Parsing data files for GSEA.............................\" ) arg_1 , arg_2 , arg_3 = gsea_cls_parser ( arg_0 . classes ) arg_4 = arg_0 . load_data ( arg_3 ) assert len ( arg_4 ) > 1 arg_5 = ranking_metric ( df = arg_4 , method = arg_0 . method , pos = arg_1 , neg = arg_2 , classes = arg_3 , ascending = arg_0 . ascending ) arg_0 . ranking = arg_5 arg_7 = arg_0 . load_gmt ( gene_list = arg_5 . index . values , arg_7 = arg_0 . gene_sets ) arg_0 . _logger . info ( \"%04d gene_sets used for further statistical testing.....\" % len ( arg_7 ) ) arg_0 . _logger . info ( \"Start to Func GSEA...Might take a while..................\" ) arg_0 . _set_cores ( ) arg_8 = arg_4 if arg_0 . permutation_type == 'phenotype' else arg_5 arg_9 , arg_10 , arg_11 , arg_12 = gsea_compute_tensor ( data = arg_8 , arg_7 = arg_7 , n = arg_0 . permutation_num , weighted_score_type = arg_0 . weighted_score_type , permutation_type = arg_0 . permutation_type , method = arg_0 . method , pheno_pos = arg_1 , pheno_neg = arg_2 , classes = arg_3 , ascending = arg_0 . ascending , processes = arg_0 . _processes , seed = arg_0 . seed ) arg_0 . _logger . info ( \"Start to generate GSEApy reports and figures............\" ) arg_13 = zip ( arg_12 , list ( arg_9 ) , arg_10 , arg_11 ) arg_0 . _save_results ( zipdata = arg_13 , outdir = arg_0 . outdir , module = arg_0 . module , arg_7 = arg_7 , rank_metric = arg_5 , permutation_type = arg_0 . permutation_type ) arg_0 . _heatmat ( df = arg_4 . loc [ arg_5 . index ] , classes = arg_3 , pheno_pos = arg_1 , pheno_neg = arg_2 ) if not arg_0 . _noplot : arg_0 . _plotting ( rank_metric = arg_5 , results = arg_0 . results , graph_num = arg_0 . graph_num , outdir = arg_0 . outdir , figsize = arg_0 . figsize , format = arg_0 . format , pheno_pos = arg_1 , pheno_neg = arg_2 ) arg_0 . _logger . info ( \"Congratulations. GSEApy ran successfully.................\\n\" ) if arg_0 . _outdir is None : arg_0 . _tmpdir . cleanup ( ) return", "target": 1, "target_options": [0, 1]}
{"input": "Extend list from object if object is list . [SEP] def Func ( arg_0 , arg_1 ) : if arg_0 . meta_type == 'dict' : raise AssertionError ( 'Cannot Func to object of `dict` base type!' ) if arg_0 . meta_type == 'list' : arg_0 . _list . Func ( arg_1 ) return", "target": 1, "target_options": [0, 1]}
{"input": "This method deletes all synapses whose permanence is less than minPermanence and deletes any segments that have less than minNumSyns synapses remaining . [SEP] def Func ( arg_0 , arg_1 = None , arg_2 = None ) : if arg_1 is None : arg_1 = arg_0 . connectedPerm if arg_2 is None : arg_2 = arg_0 . activationThreshold arg_3 , arg_4 = 0 , 0 for arg_5 , arg_6 in itertools . product ( xrange ( arg_0 . numberOfCols ) , xrange ( arg_0 . cellsPerColumn ) ) : ( arg_7 , arg_8 ) = arg_0 . _FuncInCell ( colIdx = arg_5 , cellIdx = arg_6 , segList = arg_0 . cells [ arg_5 ] [ arg_6 ] , arg_1 = arg_1 , arg_2 = arg_2 ) arg_3 += arg_7 arg_4 += arg_8 if arg_0 . verbosity >= 5 : print \"Cells, all segments:\" arg_0 . printCells ( predictedOnly = False ) return arg_3 , arg_4", "target": 1, "target_options": [0, 1]}
{"input": "Called when the websocket is closed [SEP] def Func ( arg_0 , arg_1 ) : if arg_0 . status == \"disconnected\" : return logging . debug ( \"ConnectorDB:WS: Websocket closed\" ) if arg_0 . pingtimer is not None : arg_0 . pingtimer . cancel ( ) arg_0 . disconnected_time = time . time ( ) if arg_0 . status == \"disconnecting\" : arg_0 . status = \"disconnected\" elif arg_0 . status == \"connected\" : arg_0 . __reconnect ( )", "target": 1, "target_options": [0, 1]}
{"input": "Split list of integers into blocks of block_size and return block indices . [SEP] def Func ( arg_0 , arg_1 , arg_2 = 0 ) : arg_3 = [ ] for arg_4 in arg_0 : arg_5 = ( arg_4 - arg_2 ) // float ( arg_1 ) if arg_5 not in arg_3 : arg_3 . append ( arg_5 ) arg_3 . sort ( ) return arg_3", "target": 1, "target_options": [0, 1]}
{"input": "Limit a document to just the three fields we should upload . [SEP] def Func ( arg_0 ) : arg_0 = dict ( arg_0 ) if 'text' not in arg_0 : raise ValueError ( \"The document {!r} has no text field\" . format ( arg_0 ) ) return { 'text' : arg_0 [ 'text' ] , 'metadata' : arg_0 . get ( 'metadata' , [ ] ) , 'title' : arg_0 . get ( 'title' , '' ) }", "target": 1, "target_options": [0, 1]}
{"input": "Parses a file at the given path a file - like object . or bytes as a aggregate DMARC report [SEP] def Func ( arg_0 , arg_1 = None , arg_2 = 2.0 , arg_3 = False ) : arg_4 = extract_xml ( arg_0 ) return parse_aggregate_report_xml ( arg_4 , arg_1 = arg_1 , timeout = arg_2 , arg_3 = arg_3 )", "target": 1, "target_options": [0, 1]}
{"input": "Scan for available templates in effect_templates [SEP] def Func ( arg_0 ) : arg_1 = list_templates ( ) if arg_0 not in arg_1 : raise ArgumentTypeError ( \"Effect template '{}' does not exist.\\n Available templates: {} \" . format ( arg_0 , \", \" . join ( arg_1 ) ) ) return arg_0", "target": 1, "target_options": [0, 1]}
{"input": "Return link by email . [SEP] def Func ( arg_0 , arg_1 ) : try : arg_2 = User . objects . get ( email = arg_1 ) try : return arg_0 . get ( user_id = arg_2 . id ) except EnterpriseCustomerUser . DoesNotExist : pass except User . DoesNotExist : pass try : return PendingEnterpriseCustomerUser . objects . get ( arg_1 = arg_1 ) except PendingEnterpriseCustomerUser . DoesNotExist : pass return None", "target": 1, "target_options": [0, 1]}
{"input": "Internal callback for gateway notification messages parses source device from topic string and passes the information on to the registered device command callback [SEP] def Func ( arg_0 , arg_1 , arg_2 , arg_3 ) : try : arg_4 = Notification ( arg_3 , arg_0 . _messageCodecs ) except InvalidEventException as e : arg_0 . logger . critical ( str ( e ) ) else : arg_0 . logger . debug ( \"Received Notification\" ) if arg_0 . notificationCallback : arg_0 . notificationCallback ( arg_4 )", "target": 1, "target_options": [0, 1]}
{"input": "hidden wrapped function to start step 4 [SEP] def Func ( arg_0 , arg_1 , arg_2 , arg_3 ) : if arg_0 . _headers : print ( \"\\n  Step 4: Joint estimation of error rate and heterozygosity\" ) arg_1 = _get_samples ( arg_0 , arg_1 ) if not arg_0 . _samples_precheck ( arg_1 , 4 , arg_2 ) : raise IPyradError ( FIRST_RUN_3 ) elif not arg_2 : if all ( [ arg_4 . stats . state >= 4 for arg_4 in arg_1 ] ) : print ( JOINTS_EXIST . format ( len ( arg_1 ) ) ) return assemble . jointestimate . run ( arg_0 , arg_1 , arg_2 , arg_3 )", "target": 1, "target_options": [0, 1]}
{"input": "Convert a BGR image to grayscale image . [SEP] def Func ( arg_0 , arg_1 = False ) : arg_2 = cv2 . cvtColor ( arg_0 , cv2 . COLOR_BGR2GRAY ) if arg_1 : arg_2 = arg_2 [ ... , None ] return arg_2", "target": 1, "target_options": [0, 1]}
{"input": "Sets byte if greater or equal . [SEP] def Func ( arg_0 , arg_1 ) : arg_1 . write ( Operators . ITEBV ( arg_1 . size , arg_0 . SF == arg_0 . OF , 1 , 0 ) )", "target": 1, "target_options": [0, 1]}
{"input": "Decorator that logs function calls in their self . log [SEP] def Func ( arg_0 ) : def wrapper ( arg_1 , * arg_2 , ** arg_3 ) : arg_1 . log . log ( group = arg_0 . __name__ , message = 'Enter' ) arg_0 ( arg_1 , * arg_2 , ** arg_3 ) arg_1 . log . log ( group = arg_0 . __name__ , message = 'Exit' ) return wrapper", "target": 1, "target_options": [0, 1]}
{"input": "Remove Vorbis comments from a file . [SEP] def Func ( arg_0 , arg_1 = None ) : if arg_1 is None : arg_1 = arg_0 . filename for arg_2 in list ( arg_0 . metadata_blocks ) : if isinstance ( arg_2 , VCFLACDict ) : arg_0 . metadata_blocks . remove ( arg_2 ) arg_0 . tags = None arg_0 . save ( ) break", "target": 1, "target_options": [0, 1]}
{"input": "List of axes for this object s degrees of freedom . [SEP] def Func ( arg_0 ) : return [ np . array ( arg_0 . ode_obj . getAxis ( arg_1 ) ) for arg_1 in range ( arg_0 . ADOF or arg_0 . LDOF ) ]", "target": 1, "target_options": [0, 1]}
{"input": "Teardown a polyaxon deployment given a config file . [SEP] def Func ( arg_0 ) : arg_1 = read_deployment_config ( arg_0 ) arg_2 = DeployManager ( arg_1 = arg_1 , filepath = arg_0 ) arg_3 = None try : if click . confirm ( 'Would you like to execute pre-delete hooks?' , default = True ) : arg_2 . Func ( hooks = True ) else : arg_2 . Func ( hooks = False ) except Exception as e : Printer . print_error ( 'Polyaxon could not Func the deployment.' ) arg_3 = e if arg_3 : Printer . print_error ( 'Error message `{}`.' . format ( arg_3 ) )", "target": 1, "target_options": [0, 1]}
{"input": "Renames an existing REQUIRED CONSTRAINT for the specified hstore key . [SEP] def Func ( arg_0 , arg_1 , arg_2 , arg_3 , arg_4 , arg_5 ) : arg_6 = arg_0 . _required_constraint_name ( arg_1 , arg_3 , arg_5 ) arg_7 = arg_0 . _required_constraint_name ( arg_2 , arg_4 , arg_5 ) arg_8 = arg_0 . sql_hstore_required_rename . format ( table = arg_0 . quote_name ( arg_2 ) , arg_6 = arg_0 . quote_name ( arg_6 ) , arg_7 = arg_0 . quote_name ( arg_7 ) ) arg_0 . execute ( arg_8 )", "target": 1, "target_options": [0, 1]}
{"input": "Returns a message that includes a set of suggested actions and optional text . [SEP] def Func ( arg_0 : arg_1 [ arg_2 ] , arg_3 : arg_4 = None , arg_5 : arg_4 = None , arg_6 : arg_7 [ arg_8 , arg_4 ] = arg_8 . accepting_input ) -> Activity : arg_0 = SuggestedActions ( arg_0 = arg_0 ) arg_10 = Activity ( type = ActivityTypes . message , arg_6 = arg_6 , Func = arg_0 ) if arg_3 : arg_10 . text = arg_3 if arg_5 : arg_10 . speak = arg_5 return arg_10", "target": 1, "target_options": [0, 1]}
{"input": "Constrain state . [SEP] def Func ( arg_0 , arg_1 ) : arg_1 = arg_0 . migrate_expression ( arg_1 ) arg_0 . _Functs . add ( arg_1 )", "target": 1, "target_options": [0, 1]}
{"input": "initialize tornado webapp and httpserver [SEP] def Func ( arg_0 ) : arg_0 . web_app = NotebookWebApplication ( arg_0 , arg_0 . kernel_manager , arg_0 . notebook_manager , arg_0 . cluster_manager , arg_0 . log , arg_0 . base_project_url , arg_0 . webapp_settings ) if arg_0 . certfile : arg_2 = dict ( certfile = arg_0 . certfile ) if arg_0 . keyfile : arg_2 [ 'keyfile' ] = arg_0 . keyfile else : arg_2 = None arg_0 . web_app . password = arg_0 . password arg_0 . http_server = httpserver . HTTPServer ( arg_0 . web_app , arg_2 = arg_2 ) if arg_2 is None and not arg_0 . ip and not ( arg_0 . read_only and not arg_0 . password ) : arg_0 . log . critical ( 'WARNING: the notebook server is listening on all IP addresses ' 'but not using any encryption or authentication. This is highly ' 'insecure and not recommended.' ) arg_5 = None for arg_6 in random_ports ( arg_0 . port , arg_0 . port_retries + 1 ) : try : arg_0 . http_server . listen ( arg_6 , arg_0 . ip ) except socket . error , e : if e . errno != errno . EADDRINUSE : raise arg_0 . log . info ( 'The port %i is already in use, trying another random port.' % arg_6 ) else : arg_0 . port = arg_6 arg_5 = True break if not arg_5 : arg_0 . log . critical ( 'ERROR: the notebook server could not be started because ' 'no available port could be found.' ) arg_0 . exit ( 1 )", "target": 1, "target_options": [0, 1]}
{"input": "Calculates the total absorption from water phytoplankton and CDOM [SEP] def Func ( arg_0 ) : lg . info ( 'Building total absorption' ) arg_0 . a = arg_0 . a_water + arg_0 . a_cdom + arg_0 . a_phi", "target": 1, "target_options": [0, 1]}
{"input": "Checks if a CAS number is valid . Returns False if the parser cannot parse the given string .. [SEP] def Func ( arg_0 ) : try : arg_1 = arg_0 [ - 1 ] arg_0 = arg_0 [ : : - 1 ] [ 1 : ] arg_2 = 0 arg_3 = 1 for arg_4 in arg_0 : if arg_4 == '-' : pass else : arg_2 += arg_3 * int ( arg_4 ) arg_3 += 1 return ( arg_2 % 10 == int ( arg_1 ) ) except : return False", "target": 1, "target_options": [0, 1]}
{"input": "init visit variable _accessed [SEP] def Func ( arg_0 , arg_1 ) : arg_0 . _check_bases_classes ( arg_1 ) if arg_1 . type == \"class\" and has_known_bases ( arg_1 ) : try : arg_1 . local_attr ( \"__init__\" ) except astroid . NotFoundError : arg_0 . add_message ( \"no-init\" , args = arg_1 , arg_1 = arg_1 ) arg_0 . _check_slots ( arg_1 ) arg_0 . _check_proper_bases ( arg_1 ) arg_0 . _check_consistent_mro ( arg_1 )", "target": 1, "target_options": [0, 1]}
{"input": "Returns a list of dimension sizes or None if rank is unknown . [SEP] def Func ( arg_0 ) : if isinstance ( arg_0 , tf . TensorShape ) : return arg_0 . Func arg_1 = tf . TensorShape ( arg_0 ) . Func return None if arg_1 is None else list ( map ( tf . compat . dimension_value , arg_1 ) )", "target": 1, "target_options": [0, 1]}
{"input": "Query Wolfram Alpha and return a Result object [SEP] def Func ( arg_0 , arg_1 = '' , arg_2 = { } ) : arg_3 = { 'input' : arg_1 , 'appid' : arg_0 . appid } for arg_4 , arg_5 in arg_2 . items ( ) : if isinstance ( arg_5 , ( list , tuple ) ) : arg_3 [ arg_4 ] = ',' . join ( arg_5 ) else : arg_3 [ arg_4 ] = arg_5 try : arg_6 = requests . get ( \"http://api.wolframalpha.com/v2/Func\" , arg_2 = arg_3 ) if arg_6 . status_code != 200 : raise Exception ( 'Invalid response status code: %s' % ( arg_6 . status_code ) ) if arg_6 . encoding != 'utf-8' : raise Exception ( 'Invalid encoding: %s' % ( arg_6 . encoding ) ) except Exception , e : return Result ( error = e ) return Result ( xml = arg_6 . text )", "target": 1, "target_options": [0, 1]}
{"input": "Define the list of exported variables with prefix with values from env [SEP] def Func ( arg_0 , arg_1 , arg_2 ) : for arg_3 in arg_1 : arg_4 [ \"_\" . join ( [ arg_0 , arg_3 ] ) ] = arg_2 [ arg_3 ]", "target": 1, "target_options": [0, 1]}
{"input": "Create a complete copy of the stream . [SEP] def Func ( arg_0 ) : arg_1 = copy . copy ( arg_0 ) arg_1 . _compound_mfrs = copy . deepcopy ( arg_0 . _compound_mfrs ) return arg_1", "target": 1, "target_options": [0, 1]}
{"input": "Spawn a new process using subprocess [SEP] def Func ( arg_0 , arg_1 , arg_2 = \"\" , arg_3 = False , arg_4 = False , arg_5 = 2 ) : try : if type ( arg_1 ) != list : raise PJFInvalidType ( type ( arg_1 ) , list ) if type ( arg_2 ) != str : raise PJFInvalidType ( type ( arg_2 ) , str ) if type ( arg_3 ) != bool : raise PJFInvalidType ( type ( arg_3 ) , bool ) arg_0 . _in = arg_2 try : arg_0 . process = subprocess . Popen ( arg_1 , stdout = PIPE , stderr = PIPE , arg_3 = PIPE , arg_4 = arg_4 ) arg_0 . finish_read ( arg_5 , arg_2 , arg_3 ) if arg_0 . process . poll ( ) is not None : arg_0 . close ( ) except KeyboardInterrupt : return except OSError : raise PJFProcessExecutionError ( \"Binary <%s> does not exist\" % arg_1 [ 0 ] ) except Exception as e : raise PJFBaseException ( e . message if hasattr ( e , \"message\" ) else str ( e ) )", "target": 1, "target_options": [0, 1]}
{"input": "Parses the External Document ID SPDX Document URI and Checksum . [SEP] def Func ( arg_0 , arg_1 ) : for arg_2 , arg_3 , arg_4 in arg_0 . graph . triples ( ( arg_1 , arg_0 . spdx_namespace [ 'externalDocumentId' ] , None ) ) : try : arg_0 . builder . set_ext_doc_id ( arg_0 . doc , six . text_type ( arg_4 ) ) except SPDXValueError : arg_0 . value_error ( 'EXT_DOC_REF_VALUE' , 'External Document ID' ) break for arg_2 , arg_3 , arg_4 in arg_0 . graph . triples ( ( arg_1 , arg_0 . spdx_namespace [ 'spdxDocument' ] , None ) ) : try : arg_0 . builder . set_spdx_doc_uri ( arg_0 . doc , six . text_type ( arg_4 ) ) except SPDXValueError : arg_0 . value_error ( 'EXT_DOC_REF_VALUE' , 'SPDX Document URI' ) break for arg_2 , arg_3 , arg_5 in arg_0 . graph . triples ( ( arg_1 , arg_0 . spdx_namespace [ 'checksum' ] , None ) ) : for arg_6 , arg_6 , arg_7 in arg_0 . graph . triples ( ( arg_5 , arg_0 . spdx_namespace [ 'checksumValue' ] , None ) ) : try : arg_0 . builder . set_chksum ( arg_0 . doc , six . text_type ( arg_7 ) ) except SPDXValueError : arg_0 . value_error ( 'EXT_DOC_REF_VALUE' , 'Checksum' ) break", "target": 1, "target_options": [0, 1]}
{"input": "Consecutively numbers contiguous booleans in array . [SEP] def Func ( arg_0 , arg_1 = 0 ) : arg_2 = bool_2_indices ( arg_0 ) arg_3 = np . full ( arg_0 . size , arg_1 , dtype = int ) for arg_4 , arg_5 in enumerate ( arg_2 ) : arg_3 [ arg_5 [ 0 ] : arg_5 [ - 1 ] + 1 ] = arg_1 + arg_4 + 1 return arg_3", "target": 1, "target_options": [0, 1]}
{"input": "Handle arguments for the lumi - download command . [SEP] def Func ( arg_0 ) : arg_1 = argparse . ArgumentParser ( description = DESCRIPTION , formatter_class = argparse . RawDescriptionHelpFormatter ) arg_1 . add_argument ( '-b' , '--base-url' , default = URL_BASE , help = 'API root url, default: %s' % URL_BASE , ) arg_1 . add_argument ( '-e' , '--expanded' , help = \"Include Luminoso's analysis of each document, such as terms and\" ' document vectors' , action = 'store_true' , ) arg_1 . add_argument ( '-t' , '--token' , help = 'API authentication token' ) arg_1 . add_argument ( '-s' , '--save-token' , action = 'store_true' , help = 'save --token for --base-url to ~/.luminoso/tokens.json' , ) arg_1 . add_argument ( 'project_id' , help = 'The ID of the project in the Daylight API' ) arg_1 . add_argument ( 'output_file' , nargs = '?' , default = None , help = 'The JSON lines (.jsons) file to write to' ) arg_2 = arg_1 . parse_args ( arg_0 ) if arg_2 . save_token : if not arg_2 . token : raise ValueError ( \"error: no token provided\" ) LuminosoClient . save_token ( arg_2 . token , domain = urlparse ( arg_2 . base_url ) . netloc ) arg_3 = LuminosoClient . connect ( url = arg_2 . base_url , token = arg_2 . token ) arg_4 = arg_3 . client_for_path ( 'projects/{}' . format ( arg_2 . project_id ) ) download_docs ( arg_4 , arg_2 . output_file , arg_2 . expanded )", "target": 1, "target_options": [0, 1]}
{"input": "Return all disease terms that overlaps a gene [SEP] def Func ( arg_0 , arg_1 = None ) : arg_2 = { } if arg_1 : LOG . debug ( \"Fetching all diseases for gene %s\" , arg_1 ) arg_2 [ 'genes' ] = arg_1 else : LOG . info ( \"Fetching all disease terms\" ) return list ( arg_0 . disease_term_collection . find ( arg_2 ) )", "target": 1, "target_options": [0, 1]}
{"input": "Returns a big list of all log lines since the last run [SEP] def Func ( arg_0 , arg_1 = None ) : arg_2 = [ ] arg_0 . Func_fn ( lambda row : arg_2 . append ( row ) , arg_1 = arg_1 ) return arg_2", "target": 1, "target_options": [0, 1]}
{"input": "method to wait for a kernel to be ready [SEP] def Func ( arg_0 , arg_1 = None ) : arg_2 = time . time ( ) arg_0 . km . hb_channel . unpause ( ) while True : arg_0 . run_cell ( '1' , False ) if arg_0 . km . hb_channel . is_beating ( ) : break else : if arg_1 is not None and ( time . time ( ) - arg_2 ) > arg_1 : return False return True", "target": 1, "target_options": [0, 1]}
{"input": "Add a member to the board using the id . Membership type can be normal or admin . Returns JSON of all members if successful or raises an Unauthorised exception if not . [SEP] def Func ( arg_0 , arg_1 , arg_2 = 'normal' ) : return arg_0 . fetch_json ( uri_path = arg_0 . base_uri + '/members/%s' % arg_1 , http_method = 'PUT' , query_params = { 'type' : arg_2 } )", "target": 1, "target_options": [0, 1]}
{"input": "Report a timing . [SEP] def Func ( arg_0 , arg_1 , arg_2 , arg_3 = None ) : arg_0 . _log ( 'Func' , arg_1 , arg_2 , arg_3 )", "target": 1, "target_options": [0, 1]}
{"input": "Convenience function to add property info can set any attribute and leave the others blank it won t over - write previously set items . [SEP] def Func ( arg_0 , arg_1 = None , arg_2 = None , arg_3 = None , arg_4 = None , arg_5 = None ) : arg_6 = { \"title\" : arg_1 , \"subject\" : arg_2 , \"author\" : arg_3 , \"keywords\" : arg_4 , \"creator\" : arg_5 } for arg_7 , arg_8 in arg_6 . iteritems ( ) : if hasattr ( arg_0 , arg_7 ) : if arg_8 : setattr ( arg_0 , arg_7 , arg_8 ) else : setattr ( arg_0 , arg_7 , None )", "target": 1, "target_options": [0, 1]}
{"input": "Return only the part of the row which should be printed . [SEP] def Func ( arg_0 , arg_1 ) : if not arg_0 : return arg_1 return tuple ( arg_1 [ arg_2 ] for arg_2 in arg_0 )", "target": 1, "target_options": [0, 1]}
{"input": "Check for uncommitted changes return True if everything is clean . [SEP] def Func ( arg_0 , arg_1 = False ) : arg_0 . run ( 'git update-index -q --ignore-submodules --refresh' , ** RUN_KWARGS ) arg_2 = True try : arg_0 . run ( 'git diff-files --quiet --ignore-submodules --' , report_error = False , ** RUN_KWARGS ) except exceptions . Failure : arg_2 = False if not arg_1 : notify . warning ( 'You have unstaged changes!' ) arg_0 . run ( 'git diff-files --name-status -r --ignore-submodules -- >&2' , ** RUN_KWARGS ) try : arg_0 . run ( 'git diff-index --cached --quiet HEAD --ignore-submodules --' , report_error = False , ** RUN_KWARGS ) except exceptions . Failure : arg_2 = False if not arg_1 : notify . warning ( 'Your index contains uncommitted changes!' ) arg_0 . run ( 'git diff-index --cached --name-status -r --ignore-submodules HEAD -- >&2' , ** RUN_KWARGS ) return arg_2", "target": 1, "target_options": [0, 1]}
{"input": "XPAT command . [SEP] def Func ( arg_0 , arg_1 , arg_2 , * arg_3 ) : return [ arg_4 for arg_4 in arg_0 . Func_gen ( arg_1 , arg_2 , * arg_3 ) ]", "target": 1, "target_options": [0, 1]}
{"input": "Create an account in the general ledger structure . [SEP] def Func ( arg_0 , arg_1 , arg_2 , arg_3 ) : arg_4 = GeneralLedgerAccount ( arg_1 , None , arg_2 , arg_3 ) arg_0 . accounts . append ( arg_4 ) return arg_4", "target": 1, "target_options": [0, 1]}
{"input": "Task to send learner data to each linked integrated channel . [SEP] def Func ( arg_0 , arg_1 , arg_2 ) : arg_3 = time . time ( ) arg_4 = User . objects . get ( arg_0 = arg_0 ) arg_5 = INTEGRATED_CHANNEL_CHOICES [ arg_1 ] . objects . get ( pk = arg_2 ) LOGGER . info ( 'Processing learners for integrated channel using configuration: [%s]' , arg_5 ) arg_5 . Func ( arg_4 ) arg_6 = time . time ( ) - arg_3 LOGGER . info ( 'Learner data transmission task for integrated channel configuration [%s] took [%s] seconds' , arg_5 , arg_6 )", "target": 1, "target_options": [0, 1]}
{"input": "Returns json compatible state of the ButtonsFrame instance . [SEP] def Func ( arg_0 ) -> dict : arg_1 = { } if arg_0 . text : arg_1 [ 'text' ] = arg_0 . text arg_1 [ 'controls' ] = [ control . Func ( ) for control in arg_0 . content ] arg_0 . control_Func [ 'content' ] = arg_1 return arg_0 . control_Func", "target": 1, "target_options": [0, 1]}
{"input": "Scale brightness from 0 .. 255 to 1 .. 32 . [SEP] def Func ( arg_0 , arg_1 , arg_2 , arg_3 ) : arg_4 = round ( ( arg_3 * 31 ) / 255 ) + 1 arg_5 = \"!%sFdP%d|Lights %d|%s\" % ( arg_1 , arg_4 , arg_4 , arg_2 ) arg_0 . _send_message ( arg_5 )", "target": 1, "target_options": [0, 1]}
{"input": "Translates input JS file to python and saves the it to the output path . It appends some convenience code at the end so that it is easy to import JS objects . [SEP] def Func ( arg_0 , arg_1 ) : arg_2 = get_file_contents ( arg_0 ) arg_3 = translate_js ( arg_2 ) arg_4 = os . path . basename ( arg_1 ) . split ( '.' ) [ 0 ] arg_5 = '__all__ = [%s]\\n\\n# Don\\'t look below, you will not understand this Python code :) I don\\'t.\\n\\n' % repr ( arg_4 ) arg_6 = '\\n\\n# Add lib to the module scope\\n%s = var.to_python()' % arg_4 arg_7 = arg_5 + arg_3 + arg_6 write_file_contents ( arg_1 , arg_7 )", "target": 1, "target_options": [0, 1]}
{"input": "Explores the parameter according to the iterable . [SEP] def Func ( arg_0 , arg_1 ) : if arg_0 . v_locked : raise pex . ParameterLockedException ( 'Parameter `%s` is locked!' % arg_0 . v_full_name ) if arg_0 . f_has_range ( ) : raise TypeError ( 'Your parameter `%s` is already explored, ' 'cannot Func it further!' % arg_0 . _name ) if arg_0 . _data is None : raise TypeError ( 'Your parameter `%s` has no default value, please specify one ' 'via `f_set` before exploration. ' % arg_0 . v_full_name ) arg_2 = arg_0 . _data_sanity_checks ( arg_1 ) arg_0 . Funcd_range = arg_2 arg_0 . Funcd = True arg_0 . f_lock ( )", "target": 1, "target_options": [0, 1]}
{"input": "Check if the given node has a parent of the given type . [SEP] def Func ( arg_0 , arg_1 , arg_2 ) : arg_3 = arg_0 . parent while not isinstance ( arg_3 , arg_1 ) and arg_2 . parent_of ( arg_3 ) : arg_3 = arg_3 . parent return isinstance ( arg_3 , arg_1 )", "target": 1, "target_options": [0, 1]}
{"input": "Call IUIAutomation ElementFromPoint x y . May return None if mouse is over cmd s title bar icon . Return Control subclass or None . [SEP] def Func ( arg_0 : arg_1 , arg_2 : arg_1 ) -> Control : arg_3 = _AutomationClient . instance ( ) . IUIAutomation . ElementFromPoint ( ctypes . wintypes . POINT ( arg_0 , arg_2 ) ) return Control . CreateControlFromElement ( arg_3 )", "target": 1, "target_options": [0, 1]}
{"input": "Update the Expression by joining the specified additional elements using an AND Operator [SEP] def Func ( arg_0 , * arg_1 ) : arg_2 = arg_0 . add_operator ( Operator ( ';' ) ) for arg_3 in arg_1 : arg_2 . add_element ( arg_3 ) return arg_2", "target": 1, "target_options": [0, 1]}
{"input": "Speak loudly! FIVE! Use upper case! [SEP] def Func ( arg_0 , arg_1 = 'englist' ) : arg_2 = getattr ( arg_0 , arg_1 , None ) if arg_2 : return arg_2 ( ) . upper ( ) else : return arg_0 . english ( ) . upper ( )", "target": 1, "target_options": [0, 1]}
{"input": "Translate an image in fourier - space with plane waves [SEP] def Func ( arg_0 , arg_1 ) : arg_2 = arg_0 . shape [ 0 ] arg_3 = 2 * np . pi * np . fft . fftfreq ( arg_2 ) arg_4 , arg_5 , arg_6 = np . meshgrid ( * ( arg_3 , ) * 3 , indexing = 'ij' ) arg_7 = np . array ( [ arg_4 , arg_5 , arg_6 ] ) . T arg_8 = np . fft . fftn ( arg_0 ) * np . exp ( - 1.j * ( arg_7 * arg_1 ) . sum ( axis = - 1 ) ) . T return np . real ( np . fft . ifftn ( arg_8 ) )", "target": 1, "target_options": [0, 1]}
{"input": "Removes itself from the cache [SEP] def Func ( arg_0 ) : log . debug ( \"Deleting grant %s for client %s\" % ( arg_0 . code , arg_0 . client_id ) ) arg_0 . _cache . Func ( arg_0 . key ) return None", "target": 1, "target_options": [0, 1]}
{"input": "Get a list of absolute paths to the system config files . [SEP] def Func ( arg_0 ) : return [ os . path . join ( arg_1 , arg_0 . filename ) for arg_1 in get_system_config_dirs ( arg_0 . app_name , arg_0 . app_author ) ]", "target": 1, "target_options": [0, 1]}
{"input": "Seeks to a given position in the track . [SEP] async def Func ( arg_0 , arg_1 : arg_2 ) : await arg_0 . _lavalink . ws . send ( op = 'Func' , guildId = arg_0 . guild_id , position = arg_1 )", "target": 1, "target_options": [0, 1]}
{"input": "Returns all of the items from queryset which are enabled by a user being a presenter or copresenter of a non - cancelled proposal . [SEP] def Func ( arg_0 , arg_1 , arg_2 ) : arg_1 = arg_1 . filter ( proposal_kind__proposalbase__presentation__cancelled = False ) arg_3 = arg_2 arg_4 = Q ( is_presenter = True , proposal_kind__proposalbase__presentation__speaker__user = arg_3 , ) arg_5 = Q ( is_copresenter = True , proposal_kind__proposalbase__presentation__additional_speakers__user = arg_3 , ) return arg_1 . filter ( arg_4 | arg_5 )", "target": 1, "target_options": [0, 1]}
{"input": "Run one training iteration . [SEP] def Func ( arg_0 , arg_1 , arg_2 , arg_3 = None ) : arg_0 . network . train_logger . record_epoch ( arg_1 + 1 ) arg_4 = arg_0 . train_step ( arg_2 , arg_3 ) if not arg_1 % arg_0 . config . monitor_frequency : arg_0 . report ( dict ( arg_4 ) , \"train\" , arg_1 ) arg_0 . last_run_costs = arg_4 return arg_4", "target": 1, "target_options": [0, 1]}
{"input": "Delete a specific event identified by its uid . Note that only recorded events can be deleted . Events in the buffer for upcoming events are regularly replaced anyway and a manual removal could have unpredictable effects . [SEP] def Func ( arg_0 ) : logger . info ( 'deleting event %s via api' , arg_0 ) arg_1 = get_session ( ) arg_2 = arg_1 . query ( RecordedEvent ) . filter ( RecordedEvent . uid == arg_0 ) if not arg_2 . count ( ) : return make_error_response ( 'No event with specified uid' , 404 ) arg_3 = request . args . get ( 'hard' , 'false' ) if arg_3 == 'true' : logger . info ( 'deleting recorded files at %s' , arg_2 [ 0 ] . directory ( ) ) shutil . rmtree ( arg_2 [ 0 ] . directory ( ) ) arg_2 . delete ( ) arg_1 . commit ( ) return make_response ( '' , 204 )", "target": 1, "target_options": [0, 1]}
{"input": "Convert a string - based key into a hasher class [SEP] def Func ( arg_0 ) : if xxhash is not None : if arg_0 in { 'xxh32' , 'xx32' , 'xxhash' } : return xxhash . xxh32 if arg_0 in { 'xxh64' , 'xx64' } : return xxhash . xxh64 if arg_0 is NoParam or arg_0 == 'default' : arg_0 = DEFAULT_HASHER elif isinstance ( arg_0 , six . string_types ) : if arg_0 not in hashlib . algorithms_available : raise KeyError ( 'unknown hasher: {}' . format ( arg_0 ) ) else : arg_0 = getattr ( hashlib , arg_0 ) elif isinstance ( arg_0 , HASH ) : return lambda : arg_0 return arg_0", "target": 1, "target_options": [0, 1]}
{"input": "Switch to the given window . [SEP] def Func ( arg_0 , arg_1 ) : arg_2 = { 'name' : arg_1 } arg_0 . _execute ( Command . SWITCH_TO_WINDOW , arg_2 )", "target": 1, "target_options": [0, 1]}
{"input": "Update user information . [SEP] def Func ( arg_0 , arg_1 ) : arg_0 . presence = MucPresence ( arg_1 ) arg_2 = arg_1 . get_type ( ) if arg_2 == \"unavailable\" : arg_0 . role = \"none\" arg_0 . affiliation = \"none\" arg_0 . room_jid = arg_0 . presence . get_from ( ) arg_0 . nick = arg_0 . room_jid . resource arg_7 = arg_0 . presence . get_muc_child ( ) if isinstance ( arg_7 , MucUserX ) : arg_8 = arg_7 . get_items ( ) for arg_9 in arg_8 : if not isinstance ( arg_9 , MucItem ) : continue if arg_9 . role : arg_0 . role = arg_9 . role if arg_9 . affiliation : arg_0 . affiliation = arg_9 . affiliation if arg_9 . jid : arg_0 . real_jid = arg_9 . jid if arg_9 . nick : arg_0 . new_nick = arg_9 . nick break", "target": 1, "target_options": [0, 1]}
{"input": "Query the configured SLUGS service with the provided credentials . [SEP] def Func ( arg_0 , arg_1 = None , arg_2 = None , arg_3 = None ) : if ( arg_0 . users_url is None ) or ( arg_0 . groups_url is None ) : raise exceptions . ConfigurationError ( \"The SLUGS URL must be specified.\" ) arg_4 = utils . get_client_identity_from_certificate ( arg_1 ) try : arg_5 = requests . get ( arg_0 . users_url . format ( arg_4 ) ) except Exception : raise exceptions . ConfigurationError ( \"A connection could not be established using the SLUGS URL.\" ) if arg_5 . status_code == 404 : raise exceptions . PermissionDenied ( \"Unrecognized user ID: {}\" . format ( arg_4 ) ) arg_5 = requests . get ( arg_0 . groups_url . format ( arg_4 ) ) if arg_5 . status_code == 404 : raise exceptions . PermissionDenied ( \"Group information could not be retrieved for user ID: \" \"{}\" . format ( arg_4 ) ) return arg_4 , arg_5 . json ( ) . get ( 'groups' )", "target": 1, "target_options": [0, 1]}
{"input": "Attaches transaction trytes to the Tangle then broadcasts and stores them . [SEP] def Func ( arg_0 , arg_1 , arg_2 = 3 , arg_3 = None ) : if arg_3 is None : arg_3 = arg_0 . default_min_weight_magnitude return extended . SendTrytesCommand ( arg_0 . adapter ) ( arg_1 = arg_1 , arg_2 = arg_2 , minWeightMagnitude = arg_3 , )", "target": 1, "target_options": [0, 1]}
{"input": "Calculate the objective value conditioned on all combinations of fluxes for a set of chosen reactions [SEP] def Func ( arg_0 , arg_1 , arg_2 = None , arg_3 = None , arg_4 = 20 , arg_5 = None ) : arg_1 = arg_0 . reactions . get_by_any ( arg_1 ) arg_2 = arg_0 . solver . objective if arg_2 is None else arg_2 arg_6 = dict ( ) if arg_3 is None : arg_7 = find_carbon_sources ( arg_0 ) else : arg_7 = arg_0 . reactions . get_by_any ( arg_3 ) if arg_7 is None : arg_6 [ 'carbon_source' ] = None elif hasattr ( arg_7 , 'id' ) : arg_6 [ 'carbon_source' ] = arg_7 . id else : arg_6 [ 'carbon_source' ] = ', ' . join ( rxn . id for rxn in arg_7 ) arg_5 = normalize_cutoff ( arg_0 , arg_5 ) arg_8 = arg_4 ** len ( arg_1 ) for arg_9 in ( 'minimum' , 'maximum' ) : arg_6 [ 'flux_{}' . format ( arg_9 ) ] = full ( arg_8 , nan , dtype = float ) arg_6 [ 'carbon_yield_{}' . format ( arg_9 ) ] = full ( arg_8 , nan , dtype = float ) arg_6 [ 'mass_yield_{}' . format ( arg_9 ) ] = full ( arg_8 , nan , dtype = float ) arg_11 = pd . DataFrame ( arg_6 ) with arg_0 : arg_0 . objective = arg_2 arg_12 = list ( sutil . linear_reaction_coefficients ( arg_0 ) ) if len ( arg_12 ) != 1 : raise ValueError ( 'cannot calculate yields for objectives with ' 'multiple reactions' ) arg_13 = arg_12 [ 0 ] arg_14 = fva ( arg_0 , arg_1 , fraction_of_optimum = 0 ) arg_14 [ arg_14 . abs ( ) < arg_5 ] = 0.0 arg_4 = list ( product ( * [ linspace ( arg_14 . at [ rxn . id , \"minimum\" ] , arg_14 . at [ rxn . id , \"maximum\" ] , arg_4 , endpoint = True ) for rxn in arg_1 ] ) ) arg_16 = pd . DataFrame ( arg_4 , columns = [ rxn . id for rxn in arg_1 ] ) arg_11 = pd . concat ( [ arg_11 , arg_16 ] , axis = 1 , copy = False ) add_envelope ( arg_0 , arg_1 , arg_11 , arg_7 , arg_13 , arg_5 ) return arg_11", "target": 1, "target_options": [0, 1]}
{"input": "Return the current content of the inactive - db . json file . [SEP] def Func ( arg_0 ) : if PyFunceble . CONFIGURATION [ \"inactive_database\" ] : arg_0 . _reformat_historical_formating_error ( ) if PyFunceble . path . isfile ( arg_0 . inactive_db_path ) : arg_0 . _merge ( )", "target": 1, "target_options": [0, 1]}
{"input": "Get a dictionary of file information [SEP] def Func ( arg_0 ) : arg_1 = { 'channels' : channels ( arg_0 ) , 'sample_rate' : sample_rate ( arg_0 ) , 'bitrate' : bitrate ( arg_0 ) , 'duration' : duration ( arg_0 ) , 'num_samples' : num_samples ( arg_0 ) , 'encoding' : encoding ( arg_0 ) , 'silent' : silent ( arg_0 ) } return arg_1", "target": 1, "target_options": [0, 1]}
{"input": "r Compare two sequences of lines ; generate the delta as a context diff . [SEP] def Func ( arg_0 , arg_1 , arg_2 = '' , arg_3 = '' , arg_4 = '' , arg_5 = '' , arg_6 = 3 , arg_7 = '\\n' ) : arg_8 = dict ( insert = '+ ' , delete = '- ' , replace = '! ' , equal = '  ' ) arg_9 = False for arg_10 in SequenceMatcher ( None , arg_0 , arg_1 ) . get_grouped_opcodes ( arg_6 ) : if not arg_9 : arg_9 = True arg_11 = '\\t%s' % ( arg_4 ) if arg_4 else '' arg_12 = '\\t%s' % ( arg_5 ) if arg_5 else '' yield '*** %s%s%s' % ( arg_2 , arg_11 , arg_7 ) yield '--- %s%s%s' % ( arg_3 , arg_12 , arg_7 ) arg_13 , arg_14 = arg_10 [ 0 ] , arg_10 [ - 1 ] yield '***************' + arg_7 arg_15 = _format_range_context ( arg_13 [ 1 ] , arg_14 [ 2 ] ) yield '*** %s ****%s' % ( arg_15 , arg_7 ) if any ( arg_16 in ( 'replace' , 'delete' ) for arg_16 , arg_17 , arg_17 , arg_17 , arg_17 in arg_10 ) : for arg_16 , arg_18 , arg_19 , arg_17 , arg_17 in arg_10 : if arg_16 != 'insert' : for arg_20 in arg_0 [ arg_18 : arg_19 ] : yield arg_8 [ arg_16 ] + arg_20 arg_21 = _format_range_context ( arg_13 [ 3 ] , arg_14 [ 4 ] ) yield '--- %s ----%s' % ( arg_21 , arg_7 ) if any ( arg_16 in ( 'replace' , 'insert' ) for arg_16 , arg_17 , arg_17 , arg_17 , arg_17 in arg_10 ) : for arg_16 , arg_17 , arg_17 , arg_22 , arg_23 in arg_10 : if arg_16 != 'delete' : for arg_20 in arg_1 [ arg_22 : arg_23 ] : yield arg_8 [ arg_16 ] + arg_20", "target": 1, "target_options": [0, 1]}
{"input": "This has to be in a method for TerminalIPythonApp to be available . [SEP] def Func ( arg_0 ) : return [ InteractiveShellApp , arg_0 . __class__ , TerminalInteractiveShell , PromptManager , HistoryManager , ProfileDir , PlainTextFormatter , IPCompleter , ScriptMagics , ]", "target": 1, "target_options": [0, 1]}
{"input": "REST Call Helper [SEP] def Func ( arg_0 , arg_1 ) : arg_2 = '/' + arg_0 . api_version + '/Call/' arg_3 = 'POST' return arg_0 . request ( arg_2 , arg_3 , arg_1 )", "target": 1, "target_options": [0, 1]}
{"input": "Apply barrier to circuit . If qargs is None applies to all the qbits . Args is a list of QuantumRegister or single qubits . For QuantumRegister applies barrier to all the qubits in that register . [SEP] def Func ( arg_0 , * arg_1 ) : arg_2 = [ ] arg_1 = _convert_to_bits ( arg_1 , [ qbit for arg_3 in arg_0 . qregs for qbit in arg_3 ] ) if not arg_1 : for arg_3 in arg_0 . qregs : for arg_4 in range ( arg_3 . size ) : arg_2 . append ( ( arg_3 , arg_4 ) ) for arg_5 in arg_1 : if isinstance ( arg_5 , ( QuantumRegister , list ) ) : if isinstance ( arg_5 , QuantumRegister ) : arg_2 . extend ( [ ( arg_5 , arg_4 ) for arg_4 in range ( arg_5 . size ) ] ) else : arg_2 . extend ( arg_5 ) else : arg_2 . append ( arg_5 ) return arg_0 . append ( Barrier ( len ( arg_2 ) ) , arg_2 , [ ] )", "target": 1, "target_options": [0, 1]}
{"input": "Add up a list of freq counts to get the total counts . [SEP] def Func ( arg_0 ) : arg_1 = np . zeros_like ( arg_0 [ 0 ] ) for arg_2 in arg_0 : arg_1 += arg_2 return arg_1", "target": 1, "target_options": [0, 1]}
{"input": "Reads SBML model from given filename . [SEP] def Func ( arg_0 , arg_1 = arg_2 , arg_3 = arg_4 , arg_5 = False , ** arg_6 ) : try : arg_7 = _get_doc_from_filename ( arg_0 ) return _sbml_to_model ( arg_7 , arg_1 = arg_1 , arg_3 = arg_3 , arg_5 = arg_5 , ** arg_6 ) except IOError as e : raise e except Exception : LOGGER . error ( traceback . print_exc ( ) ) raise CobraSBMLError ( \"Something went wrong reading the SBML model. Most likely the SBML\" \" model is not valid. Please check that your model is valid using \" \"the `cobra.io.sbml.validate_sbml_model` function or via the \" \"online validator at http://sbml.org/validator .\\n\" \"\\t`(model, errors) = validate_sbml_model(filename)`\" \"\\nIf the model is valid and cannot be read please open an issue \" \"at https://github.com/opencobra/cobrapy/issues .\" )", "target": 1, "target_options": [0, 1]}
{"input": "Pass for nodes that have the given namespace . [SEP] def Func ( arg_0 : arg_1 , arg_2 : arg_3 ) -> bool : arg_4 = arg_0 . get ( NAMESPACE ) return arg_4 is not None and arg_4 == arg_2", "target": 1, "target_options": [0, 1]}
{"input": "Run files from IPythonApp . exec_files [SEP] def Func ( arg_0 ) : if not arg_0 . exec_files : return arg_0 . log . debug ( \"Running files in IPythonApp.exec_files...\" ) try : for arg_1 in arg_0 . exec_files : arg_0 . _exec_file ( arg_1 ) except : arg_0 . log . warn ( \"Unknown error in handling IPythonApp.exec_files:\" ) arg_0 . shell . showtraceback ( )", "target": 1, "target_options": [0, 1]}
{"input": "Updates all rows that match the filter . [SEP] def Func ( arg_0 , ** arg_1 ) : arg_0 . _for_write = True if django . VERSION >= ( 2 , 0 ) : arg_3 = arg_0 . query . chain ( UpdateQuery ) else : arg_3 = arg_0 . query . clone ( UpdateQuery ) arg_3 . _annotations = None arg_3 . add_Func_values ( arg_1 ) arg_5 = django . db . connections [ arg_0 . db ] arg_6 = PostgresReturningUpdateCompiler ( arg_3 , arg_5 , arg_0 . db ) with transaction . atomic ( using = arg_0 . db , savepoint = False ) : arg_7 = arg_6 . execute_sql ( CURSOR ) arg_0 . _result_cache = None for arg_9 in arg_7 : signals . Func . send ( arg_0 . model , pk = arg_9 [ 0 ] ) return len ( arg_7 )", "target": 1, "target_options": [0, 1]}
