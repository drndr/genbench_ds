{"input": "For measuring methods and logging their duration. [SEP] def measure_method(index:,\n                       level:,\n                       message:,\n                       min_duration:,\n                       metric:,\n                       log_exception:,\n                       on_exception_level:)\n\n      # Ignores filter, silence, payload\n      exception = nil\n      start     = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n      begin\n        yield\n      rescue Exception => exc\n        exception = exc\n      ensure\n        log = Log.new(name, level, index)\n        # May return false due to elastic logging\n        should_log = log.assign(\n          message:            message,\n          min_duration:       min_duration,\n          exception:          exception,\n          metric:             metric,\n          duration:           1_000.0 * (Process.clock_gettime(Process::CLOCK_MONOTONIC) - start),\n          log_exception:      log_exception,\n          on_exception_level: on_exception_level\n        )\n\n        # Log level may change during assign due to :on_exception_level\n        log(log) if should_log && should_log?(log)\n        raise exception if exception\n      end\n    end", "target": 1, "target_options": ["no_match", "match"]}
{"input": "For measuring methods and logging their duration. [SEP] def update_all(attributes={})\n      # Update using an attribute hash, or you can pass a block\n      # and update the attributes directly on the objects.\n      if block_given?\n        to_a.each { |record| yield record }\n      else\n        to_a.each { |record| record.attributes = attributes }\n      end\n      zobject_class.update(to_a)\n    end", "target": 0, "target_options": ["no_match", "match"]}
{"input": "提醒任务执行者，任务即将到期，并且修改任务下次提醒时间。\n 如果`next_reminding_at`返回`nil`，则表示该任务不再需要提醒。 [SEP] def remind\n      Task.transaction do\n        assignee.remind_of_expiring_task(self) if assignee.respond_to?(:remind_of_expiring_task)\n\n        update_attributes!(reminding_at: next_reminding_at)\n      end\n    end", "target": 1, "target_options": ["no_match", "match"]}
{"input": "提醒任务执行者，任务即将到期，并且修改任务下次提醒时间。\n 如果`next_reminding_at`返回`nil`，则表示该任务不再需要提醒。 [SEP] def restore_ancestry_integrity!\n      parents = {}\n      # Wrap the whole thing in a transaction ...\n      self.ancestry_base_class.transaction do\n        unscoped_where do |scope|\n          # For each node ...\n          scope.find_each do |node|\n            # ... set its ancestry to nil if invalid\n            if !node.valid? and !node.errors[node.class.ancestry_column].blank?\n              node.without_ancestry_callbacks do\n                node.update_attribute node.ancestry_column, nil\n              end\n            end\n            # ... save parent of this node in parents array if it exists\n            parents[node.id] = node.parent_id if exists? node.parent_id\n\n            # Reset parent id in array to nil if it introduces a cycle\n            parent = parents[node.id]\n            until parent.nil? || parent == node.id\n              parent = parents[parent]\n            end\n            parents[node.id] = nil if parent == node.id\n          end\n\n          # For each node ...\n          scope.find_each do |node|\n            # ... rebuild ancestry from parents array\n            ancestry, parent = nil, parents[node.id]\n            until parent.nil?\n              ancestry, parent = if ancestry.nil? then parent else \"#{parent}/#{ancestry}\" end, parents[parent]\n            end\n            node.without_ancestry_callbacks do\n              node.update_attribute node.ancestry_column, ancestry\n            end\n          end\n        end\n      end\n    end", "target": 0, "target_options": ["no_match", "match"]}
{"input": "commit changes to session [SEP] def commit_changes(session, branch, sha1, msg)\n    if session.status.lines.any?\n      # add before commit because the path can be below a not yet added path\n      session.execute(\"git add --all\")\n      msg_file = Tempfile.new('message')\n      begin\n        msg_file << msg\n        msg_file.close\n        session.execute(\"git commit -F #{msg_file.path}\")\n      ensure\n        msg_file.close(true)\n      end\n      # create tag\n      session.execute(\"git tag rim-#{sha1} refs/heads/#{branch}\")\n    end\n  end", "target": 1, "target_options": ["no_match", "match"]}
{"input": "commit changes to session [SEP] def build_instances(template = nil)\n      build_args =\n        if template == :template\n          [build_options.first.merge(count: 1)]\n        else\n          build_options\n        end\n\n      build_args.map do |args|\n        instances = create_instance args\n        apply_tags(instances)\n        instances\n      end.flatten\n    end", "target": 0, "target_options": ["no_match", "match"]}
{"input": "Updating / Deleting [SEP] def update_all(attributes={})\n      # Update using an attribute hash, or you can pass a block\n      # and update the attributes directly on the objects.\n      if block_given?\n        to_a.each { |record| yield record }\n      else\n        to_a.each { |record| record.attributes = attributes }\n      end\n      zobject_class.update(to_a)\n    end", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Updating / Deleting [SEP] def measure_method(index:,\n                       level:,\n                       message:,\n                       min_duration:,\n                       metric:,\n                       log_exception:,\n                       on_exception_level:)\n\n      # Ignores filter, silence, payload\n      exception = nil\n      start     = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n      begin\n        yield\n      rescue Exception => exc\n        exception = exc\n      ensure\n        log = Log.new(name, level, index)\n        # May return false due to elastic logging\n        should_log = log.assign(\n          message:            message,\n          min_duration:       min_duration,\n          exception:          exception,\n          metric:             metric,\n          duration:           1_000.0 * (Process.clock_gettime(Process::CLOCK_MONOTONIC) - start),\n          log_exception:      log_exception,\n          on_exception_level: on_exception_level\n        )\n\n        # Log level may change during assign due to :on_exception_level\n        log(log) if should_log && should_log?(log)\n        raise exception if exception\n      end\n    end", "target": 0, "target_options": ["no_match", "match"]}
{"input": "Integrity restoration [SEP] def restore_ancestry_integrity!\n      parents = {}\n      # Wrap the whole thing in a transaction ...\n      self.ancestry_base_class.transaction do\n        unscoped_where do |scope|\n          # For each node ...\n          scope.find_each do |node|\n            # ... set its ancestry to nil if invalid\n            if !node.valid? and !node.errors[node.class.ancestry_column].blank?\n              node.without_ancestry_callbacks do\n                node.update_attribute node.ancestry_column, nil\n              end\n            end\n            # ... save parent of this node in parents array if it exists\n            parents[node.id] = node.parent_id if exists? node.parent_id\n\n            # Reset parent id in array to nil if it introduces a cycle\n            parent = parents[node.id]\n            until parent.nil? || parent == node.id\n              parent = parents[parent]\n            end\n            parents[node.id] = nil if parent == node.id\n          end\n\n          # For each node ...\n          scope.find_each do |node|\n            # ... rebuild ancestry from parents array\n            ancestry, parent = nil, parents[node.id]\n            until parent.nil?\n              ancestry, parent = if ancestry.nil? then parent else \"#{parent}/#{ancestry}\" end, parents[parent]\n            end\n            node.without_ancestry_callbacks do\n              node.update_attribute node.ancestry_column, ancestry\n            end\n          end\n        end\n      end\n    end", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Integrity restoration [SEP] def produce_report(*args)\n      # Check xcov availability, install it if needed\n      `gem install xcov` unless xcov_available?\n      unless xcov_available?\n        puts \"xcov is not available on this machine\"\n        return\n      end\n\n      require \"xcov\"\n      require \"fastlane_core\"\n\n      # Init Xcov\n      config = FastlaneCore::Configuration.create(Xcov::Options.available_options, convert_options(args.first))\n      Xcov.config = config\n      Xcov.ignore_handler = Xcov::IgnoreHandler.new\n\n      # Init project\n      manager =  Xcov::Manager.new(config)\n\n      # Parse .xccoverage\n      report_json = manager.parse_xccoverage\n\n      # Map and process report\n      process_report(Xcov::Report.map(report_json))\n    end", "target": 0, "target_options": ["no_match", "match"]}
{"input": "Build instances using build options\n\n if :template is passed, only build on, used as a template for a new image [SEP] def build_instances(template = nil)\n      build_args =\n        if template == :template\n          [build_options.first.merge(count: 1)]\n        else\n          build_options\n        end\n\n      build_args.map do |args|\n        instances = create_instance args\n        apply_tags(instances)\n        instances\n      end.flatten\n    end", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Build instances using build options\n\n if :template is passed, only build on, used as a template for a new image [SEP] def produce_report(*args)\n      # Check xcov availability, install it if needed\n      `gem install xcov` unless xcov_available?\n      unless xcov_available?\n        puts \"xcov is not available on this machine\"\n        return\n      end\n\n      require \"xcov\"\n      require \"fastlane_core\"\n\n      # Init Xcov\n      config = FastlaneCore::Configuration.create(Xcov::Options.available_options, convert_options(args.first))\n      Xcov.config = config\n      Xcov.ignore_handler = Xcov::IgnoreHandler.new\n\n      # Init project\n      manager =  Xcov::Manager.new(config)\n\n      # Parse .xccoverage\n      report_json = manager.parse_xccoverage\n\n      # Map and process report\n      process_report(Xcov::Report.map(report_json))\n    end", "target": 0, "target_options": ["no_match", "match"]}
{"input": "Produces and processes a report for use in the report method\n It takes the same arguments as report, and returns the same\n object as process_report [SEP] def produce_report(*args)\n      # Check xcov availability, install it if needed\n      `gem install xcov` unless xcov_available?\n      unless xcov_available?\n        puts \"xcov is not available on this machine\"\n        return\n      end\n\n      require \"xcov\"\n      require \"fastlane_core\"\n\n      # Init Xcov\n      config = FastlaneCore::Configuration.create(Xcov::Options.available_options, convert_options(args.first))\n      Xcov.config = config\n      Xcov.ignore_handler = Xcov::IgnoreHandler.new\n\n      # Init project\n      manager =  Xcov::Manager.new(config)\n\n      # Parse .xccoverage\n      report_json = manager.parse_xccoverage\n\n      # Map and process report\n      process_report(Xcov::Report.map(report_json))\n    end", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Produces and processes a report for use in the report method\n It takes the same arguments as report, and returns the same\n object as process_report [SEP] def measure_method(index:,\n                       level:,\n                       message:,\n                       min_duration:,\n                       metric:,\n                       log_exception:,\n                       on_exception_level:)\n\n      # Ignores filter, silence, payload\n      exception = nil\n      start     = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n      begin\n        yield\n      rescue Exception => exc\n        exception = exc\n      ensure\n        log = Log.new(name, level, index)\n        # May return false due to elastic logging\n        should_log = log.assign(\n          message:            message,\n          min_duration:       min_duration,\n          exception:          exception,\n          metric:             metric,\n          duration:           1_000.0 * (Process.clock_gettime(Process::CLOCK_MONOTONIC) - start),\n          log_exception:      log_exception,\n          on_exception_level: on_exception_level\n        )\n\n        # Log level may change during assign due to :on_exception_level\n        log(log) if should_log && should_log?(log)\n        raise exception if exception\n      end\n    end", "target": 0, "target_options": ["no_match", "match"]}
{"input": "add new field which will be saved into redis\n * name - name of your variable\n * type - type of your variable (:integer, :float, :string, :array, :hash)\n * (default) - default value of your variable [SEP] def redis_field name, type, default = nil\n      redis_user_field_config << name\n\n      # remember field to save into redis\n      redis_fields_config[name] = type\n\n      # remember field default value\n      redis_fields_defaults_config[name] = default\n\n      define_attribute_method name\n    end", "target": 1, "target_options": ["no_match", "match"]}
{"input": "add new field which will be saved into redis\n * name - name of your variable\n * type - type of your variable (:integer, :float, :string, :array, :hash)\n * (default) - default value of your variable [SEP] def remind\n      Task.transaction do\n        assignee.remind_of_expiring_task(self) if assignee.respond_to?(:remind_of_expiring_task)\n\n        update_attributes!(reminding_at: next_reminding_at)\n      end\n    end", "target": 0, "target_options": ["no_match", "match"]}
{"input": "@todo test if every param is actually required\n Sets subreddit settings.\n\n @param (see #delete_header)\n @param (see LinksComments#info)\n @option opts [String] :title The subreddit's title\n @option opts [String] :public_description The subreddit's public description\n @option opts [String] :description The subreddit's sidebar\n @option opts [String] :lang (en) The default language. ISO language code\n @option opts [public, private, restricted] :type (public) The subreddits type\n @option opts [any, link, self] :link_type (any) The type of posts allowed on this subreddit\n @option opts [true, false] :allow_top (true) Allow this subreddit to appear on the front page\n @option opts [true, false] :show_media (true) show thumbnails and media embeds\n @option opts [String] :header-title The header mouse-over text\n @option opts [true, false] :over_18 (false) If the subreddit requires over 18 access\n @return (see #clear_sessions) [SEP] def subreddit_settings subreddit, opts = {}\n      logged_in?\n      params = {\n        type: 'public',\n        link_type: 'any',\n        lang: 'en',\n        r: subreddit,\n        uh: @modhash,\n        allow_top: true,\n        show_media: true,\n        over_18: false,\n        api_type: 'json'\n      }\n      params.merge! opts\n      post('/api/site_admin', body: params)\n    end", "target": 1, "target_options": ["no_match", "match"]}
{"input": "@todo test if every param is actually required\n Sets subreddit settings.\n\n @param (see #delete_header)\n @param (see LinksComments#info)\n @option opts [String] :title The subreddit's title\n @option opts [String] :public_description The subreddit's public description\n @option opts [String] :description The subreddit's sidebar\n @option opts [String] :lang (en) The default language. ISO language code\n @option opts [public, private, restricted] :type (public) The subreddits type\n @option opts [any, link, self] :link_type (any) The type of posts allowed on this subreddit\n @option opts [true, false] :allow_top (true) Allow this subreddit to appear on the front page\n @option opts [true, false] :show_media (true) show thumbnails and media embeds\n @option opts [String] :header-title The header mouse-over text\n @option opts [true, false] :over_18 (false) If the subreddit requires over 18 access\n @return (see #clear_sessions) [SEP] def build_instances(template = nil)\n      build_args =\n        if template == :template\n          [build_options.first.merge(count: 1)]\n        else\n          build_options\n        end\n\n      build_args.map do |args|\n        instances = create_instance args\n        apply_tags(instances)\n        instances\n      end.flatten\n    end", "target": 0, "target_options": ["no_match", "match"]}
{"input": "Execute user defined function on server and return results.\n  The function operates on a single record.\n  The package name is used to locate the udf file location:\n\n  udf file = <server udf dir>/<package name>.lua\n\n  This method is only supported by Aerospike 3 servers. [SEP] def execute_udf(key, package_name, function_name, args=[], options = nil)\n      policy = create_policy(options, WritePolicy, default_write_policy)\n\n      command = ExecuteCommand.new(@cluster, policy, key, package_name, function_name, args)\n      execute_command(command)\n\n      record = command.record\n\n      return nil if !record || record.bins.empty?\n\n      result_map = record.bins\n\n      # User defined functions don't have to return a value.\n      key, obj = result_map.detect{ |k, _| k.include?('SUCCESS') }\n      return obj if key\n\n      key, obj = result_map.detect{ |k, _| k.include?('FAILURE') }\n      message = key ? obj.to_s : \"Invalid UDF return value\"\n      raise Aerospike::Exceptions::Aerospike.new(Aerospike::ResultCode::UDF_BAD_RESPONSE, message)\n    end", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Execute user defined function on server and return results.\n  The function operates on a single record.\n  The package name is used to locate the udf file location:\n\n  udf file = <server udf dir>/<package name>.lua\n\n  This method is only supported by Aerospike 3 servers. [SEP] def build_instances(template = nil)\n      build_args =\n        if template == :template\n          [build_options.first.merge(count: 1)]\n        else\n          build_options\n        end\n\n      build_args.map do |args|\n        instances = create_instance args\n        apply_tags(instances)\n        instances\n      end.flatten\n    end", "target": 0, "target_options": ["no_match", "match"]}
