{"input": "Parse filter query parameters and partition into an {Array}. The first\n index will contain the valid filters and the second index will contain\n the invalid filters.\n\n @param [Array<String>] filter_query_params an array of filter strings\n        encoded in JSON\n @return [Array<Array<Hash>, Array<String>] the first index holds the\n         valid, filter {Hash hashes}; the second index holds the invalid,\n         filter {String strings} [SEP] def parse_filters(filter_query_params)\n      filter_query_params.map { |filter_string|\n        begin\n          MultiJson.load filter_string\n        rescue MultiJson::ParseError => ex\n          \"#{ex} (filter: #{filter_string})\"\n        end\n      }.partition { |filter|\n        filter.is_a?(Hash)\n      }\n    end", "target": 1, "target_options": [0, 1]}
{"input": "Parse filter query parameters and partition into an {Array}. The first\n index will contain the valid filters and the second index will contain\n the invalid filters.\n\n @param [Array<String>] filter_query_params an array of filter strings\n        encoded in JSON\n @return [Array<Array<Hash>, Array<String>] the first index holds the\n         valid, filter {Hash hashes}; the second index holds the invalid,\n         filter {String strings} [SEP] def print(input, data, message: nil, name: nil)\n      _op(:print, input, data, message: message, name: name)\n    end", "target": 0, "target_options": [0, 1]}
{"input": "Returns the numeric type ID for a string, so you don't have to manage \"magic numbers\" in your application.\n The argument can be a string or a symbol, and is case insensitive. Underscores will be converted to spaces.\n\n Examples:\n   type_id('alliance')       # => 16159\n   type_id('character')      # => 1377\n   type_id('corporation')    # => 2\n   type_id('constellation')  # => 4\n   type_id('region')         # => 3\n   type_id('Solar System')   # => 5\n   type_id(:solar_system)    # => 5\n   type_id(:station)         # => 3867 [SEP] def type_id(which)\n      which = which.to_s.humanize unless which.kind_of?(String)\n      which.downcase!\n      case which\n        when 'alliance' then 16159\n        when 'character' then 1377\n        when 'corporation' then 2\n        when 'constellation' then 4\n        when 'region' then 3\n        when 'solar system', 'solarsystem' then 5\n        when 'station' then 3867\n        else raise ArgumentError, \"Unknown type: #{which}\"\n      end\n    end", "target": 1, "target_options": [0, 1]}
{"input": "Returns the numeric type ID for a string, so you don't have to manage \"magic numbers\" in your application.\n The argument can be a string or a symbol, and is case insensitive. Underscores will be converted to spaces.\n\n Examples:\n   type_id('alliance')       # => 16159\n   type_id('character')      # => 1377\n   type_id('corporation')    # => 2\n   type_id('constellation')  # => 4\n   type_id('region')         # => 3\n   type_id('Solar System')   # => 5\n   type_id(:solar_system)    # => 5\n   type_id(:station)         # => 3867 [SEP] def rate_time\n      regexp = Regexp.new(/\\d\\d\\d\\d-\\d\\d-\\d\\d/)\n      page.search('//p[@class=\"nag\"]').each do |p|\n        p.search('b').each do |b|\n          if regexp.match(b.content)\n            return DateTime.strptime(b.content, \"%Y-%m-%d\")\n          end\n        end\n      end\n    end", "target": 0, "target_options": [0, 1]}
{"input": "Returns true if strict ancestor of [SEP] def strict_ancestor_of?(block_start)\n      block_start && block_start.parent && (self == block_start.parent || strict_ancestor_of?(block_start.parent))\n    end", "target": 1, "target_options": [0, 1]}
{"input": "Returns true if strict ancestor of [SEP] def parse_filters(filter_query_params)\n      filter_query_params.map { |filter_string|\n        begin\n          MultiJson.load filter_string\n        rescue MultiJson::ParseError => ex\n          \"#{ex} (filter: #{filter_string})\"\n        end\n      }.partition { |filter|\n        filter.is_a?(Hash)\n      }\n    end", "target": 0, "target_options": [0, 1]}
{"input": "Iterates over params hash and\n applies non-empty values as filters\n @param params [Hash] filters list\n @return [ActiveRecord::Relation] filtered list [SEP] def filter(params)\n      results = where(nil)\n      params.each do |key, value|\n        results = results.public_send(key, value) if value.present?\n      end\n      results\n    end", "target": 1, "target_options": [0, 1]}
{"input": "Iterates over params hash and\n applies non-empty values as filters\n @param params [Hash] filters list\n @return [ActiveRecord::Relation] filtered list [SEP] def print(input, data, message: nil, name: nil)\n      _op(:print, input, data, message: message, name: name)\n    end", "target": 0, "target_options": [0, 1]}
{"input": "Get the time for this rate (based on the information on the website) [SEP] def rate_time\n      regexp = Regexp.new(/\\d\\d\\d\\d-\\d\\d-\\d\\d/)\n      page.search('//p[@class=\"nag\"]').each do |p|\n        p.search('b').each do |b|\n          if regexp.match(b.content)\n            return DateTime.strptime(b.content, \"%Y-%m-%d\")\n          end\n        end\n      end\n    end", "target": 1, "target_options": [0, 1]}
{"input": "Get the time for this rate (based on the information on the website) [SEP] def print(input, data, message: nil, name: nil)\n      _op(:print, input, data, message: message, name: name)\n    end", "target": 0, "target_options": [0, 1]}
{"input": "evaluate the files to check\n @return [Array<String>] list of files [SEP] def files_to_check\n      files = config[\"check\"].reduce([]) { |a, e| a + Dir[e] }\n      config[\"ignore\"].reduce(files) { |a, e| a - Dir[e] }\n    end", "target": 1, "target_options": [0, 1]}
{"input": "evaluate the files to check\n @return [Array<String>] list of files [SEP] def parse_filters(filter_query_params)\n      filter_query_params.map { |filter_string|\n        begin\n          MultiJson.load filter_string\n        rescue MultiJson::ParseError => ex\n          \"#{ex} (filter: #{filter_string})\"\n        end\n      }.partition { |filter|\n        filter.is_a?(Hash)\n      }\n    end", "target": 0, "target_options": [0, 1]}
{"input": "Prints a list of tensors.\n\n This is an identity op (behaves like tf.identity) with the side effect of printing data when evaluating. [SEP] def print(input, data, message: nil, name: nil)\n      _op(:print, input, data, message: message, name: name)\n    end", "target": 1, "target_options": [0, 1]}
{"input": "Prints a list of tensors.\n\n This is an identity op (behaves like tf.identity) with the side effect of printing data when evaluating. [SEP] def rate_time\n      regexp = Regexp.new(/\\d\\d\\d\\d-\\d\\d-\\d\\d/)\n      page.search('//p[@class=\"nag\"]').each do |p|\n        p.search('b').each do |b|\n          if regexp.match(b.content)\n            return DateTime.strptime(b.content, \"%Y-%m-%d\")\n          end\n        end\n      end\n    end", "target": 0, "target_options": [0, 1]}
{"input": "Finds the class representing the objects within the collection [SEP] def default_class_for(collection)\n      if collection.respond_to?(:klass) # ActiveRecord::Relation\n        collection.klass\n      elsif !collection.empty?\n        collection.first.class\n      end\n    end", "target": 1, "target_options": [0, 1]}
{"input": "Finds the class representing the objects within the collection [SEP] def print(input, data, message: nil, name: nil)\n      _op(:print, input, data, message: message, name: name)\n    end", "target": 0, "target_options": [0, 1]}
{"input": "layout [SEP] def newlayout\n      @item = model.new({:tpl_format=>Optimacms::Template::EXTENSION_DEFAULT, :type_id=>TemplateType::TYPE_LAYOUT})\n      item_init_parent\n      @item.set_basedirpath_from_parent\n\n      @url_back = url_list\n    end", "target": 1, "target_options": [0, 1]}
{"input": "layout [SEP] def print(input, data, message: nil, name: nil)\n      _op(:print, input, data, message: message, name: name)\n    end", "target": 0, "target_options": [0, 1]}
{"input": "Creates an IsbmAdaptor::Message from a ISBM response.\n\n @param response [Savon::Response] the ISBM response\n @return [IsbmAdaptor::Message] the extracted message [SEP] def extract_message(response)\n      # Extract the message element\n      # e.g. /Envelope/Body/ReadPublicationResponse/PublicationMessage\n      soap_ns = 'http://schemas.xmlsoap.org/soap/envelope/'\n      message = response.doc.xpath('s:Envelope/s:Body', s: soap_ns).first.first_element_child.first_element_child\n\n      return nil unless message\n\n      id = message.element_children[0].text\n      content = message.element_children[1].first_element_child\n      topics = message.element_children[2..-1].map {|e| e.text}\n\n      # Retain any ancestor namespaces in case they are applicable for the element\n      # and/or children. This is because content.to_xml does not output ancestor\n      # namespaces.\n      # There may be unnecessary namespaces carried across (e.g. ISBM, SOAP), but we\n      # can't tell if the content uses them without parsing the content itself.\n      content.namespaces.each do |key, value|\n        # Don't replace default namespace if it already exists\n        next if key == 'xmlns' && content['xmlns']\n        content[key] = value\n      end\n\n      # Wrap content in a separate Nokogiri document. This allows the ability to\n      # validate the content against a schema.\n      doc = Nokogiri::XML(content.to_xml)\n\n      IsbmAdaptor::Message.new(id, doc, topics)\n    end", "target": 1, "target_options": [0, 1]}
{"input": "Creates an IsbmAdaptor::Message from a ISBM response.\n\n @param response [Savon::Response] the ISBM response\n @return [IsbmAdaptor::Message] the extracted message [SEP] def type_id(which)\n      which = which.to_s.humanize unless which.kind_of?(String)\n      which.downcase!\n      case which\n        when 'alliance' then 16159\n        when 'character' then 1377\n        when 'corporation' then 2\n        when 'constellation' then 4\n        when 'region' then 3\n        when 'solar system', 'solarsystem' then 5\n        when 'station' then 3867\n        else raise ArgumentError, \"Unknown type: #{which}\"\n      end\n    end", "target": 0, "target_options": [0, 1]}
