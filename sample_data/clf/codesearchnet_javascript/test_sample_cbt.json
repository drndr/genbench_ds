{"input": "25.4.5.3.2 PromiseResolutionHandlerFunctions [SEP] function PromiseResolutionHandlerFunction () {\n    return function F ( x ) {\n      var promise = F['[[Promise]]'],\n        fulfillmentHandler = F['[[FulfillmentHandler]]'],\n        rejectionHandler = F['[[RejectionHandler]]'],\n        selfResolutionError, C, promiseCapability, updateResult;\n      if ( SameValue(x, promise) ) {\n        selfResolutionError = TypeError();\n        return rejectionHandler.call(undefined, selfResolutionError);\n      }\n      C = promise['[[PromiseConstructor]]'];\n      try {\n        promiseCapability = NewPromiseCapability(C);\n      } catch ( e ) {\n        return e;\n      }\n      try {\n        updateResult = UpdatePromiseFromPotentialThenable(x,\n          promiseCapability\n        );\n      } catch ( e ) {\n        return e;\n      }\n      if ( updateResult !== 'not a thenable') {\n        return promiseCapability['[[Promise]]'].then(fulfillmentHandler,\n          rejectionHandler\n        );\n      }\n      return fulfillmentHandler.call(undefined, x);\n    };\n  }", "target": 1, "target_options": [0, 1]}
{"input": "25.4.5.3.2 PromiseResolutionHandlerFunctions [SEP] function videojs(id, options, ready) {\n  var tag = void 0;\n\n  // Allow for element or ID to be passed in\n  // String ID\n  if (typeof id === 'string') {\n    var players = videojs.getPlayers();\n\n    // Adjust for jQuery ID syntax\n    if (id.indexOf('#') === 0) {\n      id = id.slice(1);\n    }\n\n    // If a player instance has already been created for this ID return it.\n    if (players[id]) {\n\n      // If options or ready function are passed, warn\n      if (options) {\n        log$1.warn('Player \"' + id + '\" is already initialised. Options will not be applied.');\n      }\n\n      if (ready) {\n        players[id].ready(ready);\n      }\n\n      return players[id];\n    }\n\n    // Otherwise get element for ID\n    tag = $('#' + id);\n\n    // ID is a media element\n  } else {\n    tag = id;\n  }\n\n  // Check for a useable element\n  // re: nodeName, could be a box div also\n  if (!tag || !tag.nodeName) {\n    throw new TypeError('The element or ID supplied is not valid. (videojs)');\n  }\n\n  // Element may have a player attr referring to an already created player instance.\n  // If so return that otherwise set up a new player below\n  if (tag.player || Player.players[tag.playerId]) {\n    return tag.player || Player.players[tag.playerId];\n  }\n\n  options = options || {};\n\n  videojs.hooks('beforesetup').forEach(function (hookFunction) {\n    var opts = hookFunction(tag, mergeOptions(options));\n\n    if (!isObject(opts) || Array.isArray(opts)) {\n      log$1.error('please return an object in beforesetup hooks');\n      return;\n    }\n\n    options = mergeOptions(options, opts);\n  });\n\n  var PlayerComponent = Component.getComponent('Player');\n  // If not, set up a new player\n  var player = new PlayerComponent(tag, options, ready);\n\n  videojs.hooks('setup').forEach(function (hookFunction) {\n    return hookFunction(player);\n  });\n\n  return player;\n}", "target": 0, "target_options": [0, 1]}
{"input": "Add a CSS class name to an element\n\n@param {Element} element\nElement to add class name to.\n\n@param {string} classToAdd\nClass name to add.\n\n@return {Element}\nThe dom element with the added class name. [SEP] function addClass(element, classToAdd) {\n  if (element.classList) {\n    element.classList.add(classToAdd);\n\n    // Don't need to `throwIfWhitespace` here because `hasElClass` will do it\n    // in the case of classList not being supported.\n  } else if (!hasClass(element, classToAdd)) {\n    element.className = (element.className + ' ' + classToAdd).trim();\n  }\n\n  return element;\n}", "target": 1, "target_options": [0, 1]}
{"input": "Add a CSS class name to an element\n\n@param {Element} element\nElement to add class name to.\n\n@param {string} classToAdd\nClass name to add.\n\n@return {Element}\nThe dom element with the added class name. [SEP] function getStartStopBoundaries(parent, sidebar, topOffset) {\n  const bbox = parent.getBoundingClientRect();\n  const sidebarBbox = sidebar.getBoundingClientRect();\n  const bodyBbox = document.body.getBoundingClientRect();\n\n  const containerAbsoluteTop = bbox.top - bodyBbox.top;\n  const sidebarAbsoluteTop = sidebarBbox.top - bodyBbox.top;\n  const marginTop = sidebarAbsoluteTop - containerAbsoluteTop;\n  const start = containerAbsoluteTop - topOffset;\n  const stop = bbox.height + containerAbsoluteTop - sidebarBbox.height - marginTop - topOffset;\n\n  return {\n    start,\n    stop,\n  };\n}", "target": 0, "target_options": [0, 1]}
{"input": "Test if the triple (attribute, operator, value) is already refined.\nIf only the attribute and the operator are provided, it tests if the\ncontains any refinement value.\n@method\n@param {string} attribute attribute for which the refinement is applied\n@param {string} [operator] operator of the refinement\n@param {string} [value] value of the refinement\n@return {boolean} true if it is refined [SEP] function isNumericRefined(attribute, operator, value) {\n    if (isUndefined(value) && isUndefined(operator)) {\n      return !!this.numericRefinements[attribute];\n    }\n\n    var isOperatorDefined = this.numericRefinements[attribute] &&\n      !isUndefined(this.numericRefinements[attribute][operator]);\n\n    if (isUndefined(value) || !isOperatorDefined) {\n      return isOperatorDefined;\n    }\n\n    var parsedValue = valToNumber(value);\n    var isAttributeValueDefined = !isUndefined(\n      findArray(this.numericRefinements[attribute][operator], parsedValue)\n    );\n\n    return isOperatorDefined && isAttributeValueDefined;\n  }", "target": 1, "target_options": [0, 1]}
{"input": "Test if the triple (attribute, operator, value) is already refined.\nIf only the attribute and the operator are provided, it tests if the\ncontains any refinement value.\n@method\n@param {string} attribute attribute for which the refinement is applied\n@param {string} [operator] operator of the refinement\n@param {string} [value] value of the refinement\n@return {boolean} true if it is refined [SEP] function videojs(id, options, ready) {\n  var tag = void 0;\n\n  // Allow for element or ID to be passed in\n  // String ID\n  if (typeof id === 'string') {\n    var players = videojs.getPlayers();\n\n    // Adjust for jQuery ID syntax\n    if (id.indexOf('#') === 0) {\n      id = id.slice(1);\n    }\n\n    // If a player instance has already been created for this ID return it.\n    if (players[id]) {\n\n      // If options or ready function are passed, warn\n      if (options) {\n        log$1.warn('Player \"' + id + '\" is already initialised. Options will not be applied.');\n      }\n\n      if (ready) {\n        players[id].ready(ready);\n      }\n\n      return players[id];\n    }\n\n    // Otherwise get element for ID\n    tag = $('#' + id);\n\n    // ID is a media element\n  } else {\n    tag = id;\n  }\n\n  // Check for a useable element\n  // re: nodeName, could be a box div also\n  if (!tag || !tag.nodeName) {\n    throw new TypeError('The element or ID supplied is not valid. (videojs)');\n  }\n\n  // Element may have a player attr referring to an already created player instance.\n  // If so return that otherwise set up a new player below\n  if (tag.player || Player.players[tag.playerId]) {\n    return tag.player || Player.players[tag.playerId];\n  }\n\n  options = options || {};\n\n  videojs.hooks('beforesetup').forEach(function (hookFunction) {\n    var opts = hookFunction(tag, mergeOptions(options));\n\n    if (!isObject(opts) || Array.isArray(opts)) {\n      log$1.error('please return an object in beforesetup hooks');\n      return;\n    }\n\n    options = mergeOptions(options, opts);\n  });\n\n  var PlayerComponent = Component.getComponent('Player');\n  // If not, set up a new player\n  var player = new PlayerComponent(tag, options, ready);\n\n  videojs.hooks('setup').forEach(function (hookFunction) {\n    return hookFunction(player);\n  });\n\n  return player;\n}", "target": 0, "target_options": [0, 1]}
{"input": "Returns the buffered output from an asynchronous {@link DirectoryReader},\nvia an error-first callback or a {@link Promise}.\n\n@param {string} dir\n@param {object} [options]\n@param {function} [callback]\n@param {object} internalOptions [SEP] function readdirAsync (dir, options, callback, internalOptions) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  return maybe(callback, new Promise(((resolve, reject) => {\n    let results = [];\n\n    internalOptions.facade = asyncFacade;\n\n    let reader = new DirectoryReader(dir, options, internalOptions);\n    let stream = reader.stream;\n\n    stream.on('error', err => {\n      reject(err);\n      stream.pause();\n    });\n    stream.on('data', result => {\n      results.push(result);\n    });\n    stream.on('end', () => {\n      resolve(results);\n    });\n  })));\n}", "target": 1, "target_options": [0, 1]}
{"input": "Returns the buffered output from an asynchronous {@link DirectoryReader},\nvia an error-first callback or a {@link Promise}.\n\n@param {string} dir\n@param {object} [options]\n@param {function} [callback]\n@param {object} internalOptions [SEP] function(systemId, env, cb) {\n    var repoPath = _meta.repoPath(systemId);\n    var tagName = baseTag + env;\n    var editsTagName = editsTag + env;\n\n    ngit.Repository.open(repoPath, function(err, repo) {\n      if (err) { return cb(err); }\n\n      ngit.Reference.nameToId(repo, tagName, function(err, head) {\n        if (err && (!err.message || err.message.indexOf('not found') === -1)) { return cb(err); }\n        if (head) {\n          cb(null, head.toString());\n        }\n        else {\n          ngit.Reference.nameToId(repo, editsTagName, function(err) {\n            if (err) { return cb(err); }\n            cb(null, EDITS);\n          });\n        }\n      });\n    });\n  }", "target": 0, "target_options": [0, 1]}
{"input": "Takes an array of arguments given to `on()` or `one()`, validates them, and\nnormalizes them into an object.\n\n@private\n@param  {Object} self\nThe evented object on which `on()` or `one()` was called. This\nobject will be bound as the `this` value for the listener.\n\n@param  {Array} args\nAn array of arguments passed to `on()` or `one()`.\n\n@return {Object}\nAn object containing useful values for `on()` or `one()` calls. [SEP] function normalizeListenArgs(self, args) {\n\n  // If the number of arguments is less than 3, the target is always the\n  // evented object itself.\n  var isTargetingSelf = args.length < 3 || args[0] === self || args[0] === self.eventBusEl_;\n  var target = void 0;\n  var type = void 0;\n  var listener = void 0;\n\n  if (isTargetingSelf) {\n    target = self.eventBusEl_;\n\n    // Deal with cases where we got 3 arguments, but we are still listening to\n    // the evented object itself.\n    if (args.length >= 3) {\n      args.shift();\n    }\n\n    type = args[0];\n    listener = args[1];\n  } else {\n    target = args[0];\n    type = args[1];\n    listener = args[2];\n  }\n\n  validateTarget(target);\n  validateEventType(type);\n  validateListener(listener);\n\n  listener = bind(self, listener);\n\n  return { isTargetingSelf: isTargetingSelf, target: target, type: type, listener: listener };\n}", "target": 1, "target_options": [0, 1]}
{"input": "Takes an array of arguments given to `on()` or `one()`, validates them, and\nnormalizes them into an object.\n\n@private\n@param  {Object} self\nThe evented object on which `on()` or `one()` was called. This\nobject will be bound as the `this` value for the listener.\n\n@param  {Array} args\nAn array of arguments passed to `on()` or `one()`.\n\n@return {Object}\nAn object containing useful values for `on()` or `one()` calls. [SEP] function getStartStopBoundaries(parent, sidebar, topOffset) {\n  const bbox = parent.getBoundingClientRect();\n  const sidebarBbox = sidebar.getBoundingClientRect();\n  const bodyBbox = document.body.getBoundingClientRect();\n\n  const containerAbsoluteTop = bbox.top - bodyBbox.top;\n  const sidebarAbsoluteTop = sidebarBbox.top - bodyBbox.top;\n  const marginTop = sidebarAbsoluteTop - containerAbsoluteTop;\n  const start = containerAbsoluteTop - topOffset;\n  const stop = bbox.height + containerAbsoluteTop - sidebarBbox.height - marginTop - topOffset;\n\n  return {\n    start,\n    stop,\n  };\n}", "target": 0, "target_options": [0, 1]}
{"input": "Doubles as the main function for users to create a player instance and also\nthe main library object.\nThe `videojs` function can be used to initialize or retrieve a player.\n\n@param {string|Element} id\nVideo element or video element ID\n\n@param {Object} [options]\nOptional options object for config/settings\n\n@param {Component~ReadyCallback} [ready]\nOptional ready callback\n\n@return {Player}\nA player instance [SEP] function videojs(id, options, ready) {\n  var tag = void 0;\n\n  // Allow for element or ID to be passed in\n  // String ID\n  if (typeof id === 'string') {\n    var players = videojs.getPlayers();\n\n    // Adjust for jQuery ID syntax\n    if (id.indexOf('#') === 0) {\n      id = id.slice(1);\n    }\n\n    // If a player instance has already been created for this ID return it.\n    if (players[id]) {\n\n      // If options or ready function are passed, warn\n      if (options) {\n        log$1.warn('Player \"' + id + '\" is already initialised. Options will not be applied.');\n      }\n\n      if (ready) {\n        players[id].ready(ready);\n      }\n\n      return players[id];\n    }\n\n    // Otherwise get element for ID\n    tag = $('#' + id);\n\n    // ID is a media element\n  } else {\n    tag = id;\n  }\n\n  // Check for a useable element\n  // re: nodeName, could be a box div also\n  if (!tag || !tag.nodeName) {\n    throw new TypeError('The element or ID supplied is not valid. (videojs)');\n  }\n\n  // Element may have a player attr referring to an already created player instance.\n  // If so return that otherwise set up a new player below\n  if (tag.player || Player.players[tag.playerId]) {\n    return tag.player || Player.players[tag.playerId];\n  }\n\n  options = options || {};\n\n  videojs.hooks('beforesetup').forEach(function (hookFunction) {\n    var opts = hookFunction(tag, mergeOptions(options));\n\n    if (!isObject(opts) || Array.isArray(opts)) {\n      log$1.error('please return an object in beforesetup hooks');\n      return;\n    }\n\n    options = mergeOptions(options, opts);\n  });\n\n  var PlayerComponent = Component.getComponent('Player');\n  // If not, set up a new player\n  var player = new PlayerComponent(tag, options, ready);\n\n  videojs.hooks('setup').forEach(function (hookFunction) {\n    return hookFunction(player);\n  });\n\n  return player;\n}", "target": 1, "target_options": [0, 1]}
{"input": "Doubles as the main function for users to create a player instance and also\nthe main library object.\nThe `videojs` function can be used to initialize or retrieve a player.\n\n@param {string|Element} id\nVideo element or video element ID\n\n@param {Object} [options]\nOptional options object for config/settings\n\n@param {Component~ReadyCallback} [ready]\nOptional ready callback\n\n@return {Player}\nA player instance [SEP] function addClass(element, classToAdd) {\n  if (element.classList) {\n    element.classList.add(classToAdd);\n\n    // Don't need to `throwIfWhitespace` here because `hasElClass` will do it\n    // in the case of classList not being supported.\n  } else if (!hasClass(element, classToAdd)) {\n    element.className = (element.className + ' ' + classToAdd).trim();\n  }\n\n  return element;\n}", "target": 0, "target_options": [0, 1]}
{"input": "Create a merge commit builder\n@param {TreeConflict} treeConflict The solved TreeConflict\n@param {Array<SHA>} parents Parent commits\n@param {Author} options.author\n@param {String} [options.message='Merge commit']\n@return {CommitBuilder} [SEP] function mergeCommit(treeConflict, parents, options) {\n    options = options || {};\n\n    const opts = {};\n\n    // Assume the commit is not empty\n    opts.empty = false;\n\n    // Parent SHAs\n    opts.parents = new Immutable.List(parents);\n\n    opts.author = options.author;\n    opts.message = options.message || 'Merged commit';\n\n    // Get the solved tree entries\n    const solvedEntries = _getSolvedEntries(treeConflict);\n    opts.treeEntries = solvedEntries;\n\n    // Create map of blobs that needs to be created\n    const solvedConflicts = treeConflict.getConflicts();\n    opts.blobs = solvedEntries.filter((treeEntry) => {\n        return !treeEntry.hasSha();\n    }).map((treeEntry, path) => {\n        return solvedConflicts.get(path).getSolvedContent();\n    });\n\n    return CommitBuilder.create(opts);\n}", "target": 1, "target_options": [0, 1]}
{"input": "Create a merge commit builder\n@param {TreeConflict} treeConflict The solved TreeConflict\n@param {Array<SHA>} parents Parent commits\n@param {Author} options.author\n@param {String} [options.message='Merge commit']\n@return {CommitBuilder} [SEP] function isNumericRefined(attribute, operator, value) {\n    if (isUndefined(value) && isUndefined(operator)) {\n      return !!this.numericRefinements[attribute];\n    }\n\n    var isOperatorDefined = this.numericRefinements[attribute] &&\n      !isUndefined(this.numericRefinements[attribute][operator]);\n\n    if (isUndefined(value) || !isOperatorDefined) {\n      return isOperatorDefined;\n    }\n\n    var parsedValue = valToNumber(value);\n    var isAttributeValueDefined = !isUndefined(\n      findArray(this.numericRefinements[attribute][operator], parsedValue)\n    );\n\n    return isOperatorDefined && isAttributeValueDefined;\n  }", "target": 0, "target_options": [0, 1]}
{"input": "get the currently deployed revision [SEP] function(systemId, env, cb) {\n    var repoPath = _meta.repoPath(systemId);\n    var tagName = baseTag + env;\n    var editsTagName = editsTag + env;\n\n    ngit.Repository.open(repoPath, function(err, repo) {\n      if (err) { return cb(err); }\n\n      ngit.Reference.nameToId(repo, tagName, function(err, head) {\n        if (err && (!err.message || err.message.indexOf('not found') === -1)) { return cb(err); }\n        if (head) {\n          cb(null, head.toString());\n        }\n        else {\n          ngit.Reference.nameToId(repo, editsTagName, function(err) {\n            if (err) { return cb(err); }\n            cb(null, EDITS);\n          });\n        }\n      });\n    });\n  }", "target": 1, "target_options": [0, 1]}
{"input": "get the currently deployed revision [SEP] function getStartStopBoundaries(parent, sidebar, topOffset) {\n  const bbox = parent.getBoundingClientRect();\n  const sidebarBbox = sidebar.getBoundingClientRect();\n  const bodyBbox = document.body.getBoundingClientRect();\n\n  const containerAbsoluteTop = bbox.top - bodyBbox.top;\n  const sidebarAbsoluteTop = sidebarBbox.top - bodyBbox.top;\n  const marginTop = sidebarAbsoluteTop - containerAbsoluteTop;\n  const start = containerAbsoluteTop - topOffset;\n  const stop = bbox.height + containerAbsoluteTop - sidebarBbox.height - marginTop - topOffset;\n\n  return {\n    start,\n    stop,\n  };\n}", "target": 0, "target_options": [0, 1]}
{"input": "Consumes full character pair, if possible\n@param {StreamReader} stream\n@param {Number} close\n@param {Number} open\n@return {Boolean} [SEP] function consumePair(stream, close, open) {\n\tconst start = stream.pos;\n\tif (stream.eat(close)) {\n\t\twhile (!stream.sol()) {\n\t\t\tif (stream.eat(open)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tstream.pos--;\n\t\t}\n\t}\n\n\tstream.pos = start;\n\treturn false;\n}", "target": 1, "target_options": [0, 1]}
{"input": "Consumes full character pair, if possible\n@param {StreamReader} stream\n@param {Number} close\n@param {Number} open\n@return {Boolean} [SEP] function normalizeListenArgs(self, args) {\n\n  // If the number of arguments is less than 3, the target is always the\n  // evented object itself.\n  var isTargetingSelf = args.length < 3 || args[0] === self || args[0] === self.eventBusEl_;\n  var target = void 0;\n  var type = void 0;\n  var listener = void 0;\n\n  if (isTargetingSelf) {\n    target = self.eventBusEl_;\n\n    // Deal with cases where we got 3 arguments, but we are still listening to\n    // the evented object itself.\n    if (args.length >= 3) {\n      args.shift();\n    }\n\n    type = args[0];\n    listener = args[1];\n  } else {\n    target = args[0];\n    type = args[1];\n    listener = args[2];\n  }\n\n  validateTarget(target);\n  validateEventType(type);\n  validateListener(listener);\n\n  listener = bind(self, listener);\n\n  return { isTargetingSelf: isTargetingSelf, target: target, type: type, listener: listener };\n}", "target": 0, "target_options": [0, 1]}
{"input": "Defines the limits where to start or stop the stickiness\n@param {HTMLElement} parent the outer container of the sidebar\n@param {HTMLElement} sidebar the sidebar\n@param {number} topOffset an optional top offset for sticky menu [SEP] function getStartStopBoundaries(parent, sidebar, topOffset) {\n  const bbox = parent.getBoundingClientRect();\n  const sidebarBbox = sidebar.getBoundingClientRect();\n  const bodyBbox = document.body.getBoundingClientRect();\n\n  const containerAbsoluteTop = bbox.top - bodyBbox.top;\n  const sidebarAbsoluteTop = sidebarBbox.top - bodyBbox.top;\n  const marginTop = sidebarAbsoluteTop - containerAbsoluteTop;\n  const start = containerAbsoluteTop - topOffset;\n  const stop = bbox.height + containerAbsoluteTop - sidebarBbox.height - marginTop - topOffset;\n\n  return {\n    start,\n    stop,\n  };\n}", "target": 1, "target_options": [0, 1]}
{"input": "Defines the limits where to start or stop the stickiness\n@param {HTMLElement} parent the outer container of the sidebar\n@param {HTMLElement} sidebar the sidebar\n@param {number} topOffset an optional top offset for sticky menu [SEP] function(systemId, env, cb) {\n    var repoPath = _meta.repoPath(systemId);\n    var tagName = baseTag + env;\n    var editsTagName = editsTag + env;\n\n    ngit.Repository.open(repoPath, function(err, repo) {\n      if (err) { return cb(err); }\n\n      ngit.Reference.nameToId(repo, tagName, function(err, head) {\n        if (err && (!err.message || err.message.indexOf('not found') === -1)) { return cb(err); }\n        if (head) {\n          cb(null, head.toString());\n        }\n        else {\n          ngit.Reference.nameToId(repo, editsTagName, function(err) {\n            if (err) { return cb(err); }\n            cb(null, EDITS);\n          });\n        }\n      });\n    });\n  }", "target": 0, "target_options": [0, 1]}
