{"input": "Fill 'er up! From here down, all logic is associated with touch scroll handling elem references the overthrow element in use [SEP] function( val ){\n\t\t\t\tinputs = elem.querySelectorAll( \"textarea, input\" );\n\t\t\t\tfor( var i = 0, il = inputs.length; i < il; i++ ) {\n\t\t\t\t\tinputs[ i ].style.pointerEvents = val;\n\t\t\t\t}\n\t\t\t}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Fill 'er up! From here down, all logic is associated with touch scroll handling elem references the overthrow element in use [SEP] function wrapPromise(promise) {\n  return promise.then(function (value) {\n    return new Promise(function (resolve, reject) {\n      _object2.default.delay(function () {\n        resolve(value);\n      });\n      _object2.default._queueFlush();\n    });\n  }, function (reason) {\n    return new Promise(function (resolve, reject) {\n      _object2.default.delay(function () {\n        reject(reason);\n      });\n      _object2.default._queueFlush();\n    });\n  });\n}", "target": 0, "target_options": ["no_match", "match"]}
{"input": "通过和文件的 md5 对比，判断 UploadId 是否可用 [SEP] function (PartList, callback) {\n        var PartCount = PartList.length;\n        // 如果没有分片，通过\n        if (PartCount === 0) {\n            return callback(null, true);\n        }\n        // 检查分片数量\n        if (PartCount > SliceCount) {\n            return callback(null, false);\n        }\n        // 检查分片大小\n        if (PartCount > 1) {\n            var PartSliceSize = Math.max(PartList[0].Size, PartList[1].Size);\n            if (PartSliceSize !== SliceSize) {\n                return callback(null, false);\n            }\n        }\n        // 逐个分片计算并检查 ETag 是否一致\n        var next = function (index) {\n            if (index < PartCount) {\n                var Part = PartList[index];\n                getChunkETag(Part.PartNumber, function (err, chunk) {\n                    if (chunk && chunk.ETag === Part.ETag && chunk.Size === Part.Size) {\n                        next(index + 1);\n                    } else {\n                        callback(null, false);\n                    }\n                });\n            } else {\n                callback(null, true);\n            }\n        };\n        next(0);\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "通过和文件的 md5 对比，判断 UploadId 是否可用 [SEP] function() {\n    return {\n      r: Math.floor(Math.random() * 256),\n      g: Math.floor(Math.random() * 256),\n      b: Math.floor(Math.random() * 256),\n      a: 255\n    };\n  }", "target": 0, "target_options": ["no_match", "match"]}
{"input": "/*\nprivate methods [SEP] function getAdd (opts) {\n    opts = opts || {}\n    var times = opts.times\n    var doesConsume = opts.doesConsume\n    return function add () {\n      var lastArg = arguments[arguments.length - 1]\n      var func = typeof lastArg === 'function' ? lastArg : function () { return lastArg }\n      var validators = arguments.length > 1 ? Array.prototype.slice.call(arguments, 0, -1) : []\n      var newAdapter = {\n        doesConsume: doesConsume, // calling this adapter will remove the event posted\n        times: times,\n        func: func,\n        validators: ut.combineValidators(validators),\n        ns: _ns\n      }\n      _adapters.push(newAdapter)\n\n      // trigger all published event matching this adapter\n      ut.filterArray(_events, function (event) {\n        if (newAdapter.times === 0) return true\n        var filteredAdapters = ut.filterAndSort(event.args, [newAdapter])\n        filteredAdapters.forEach(ut.countdown)\n        ut.filterArray(_adapters, ut.notExausted)\n        ut.triggerAll(event.context, event.args, filteredAdapters)\n        // if the adapter consume the event, this gets filtered out\n        return !(doesConsume && filteredAdapters.length)\n      })\n      return or\n    }\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "/*\nprivate methods [SEP] function wrapPromise(promise) {\n  return promise.then(function (value) {\n    return new Promise(function (resolve, reject) {\n      _object2.default.delay(function () {\n        resolve(value);\n      });\n      _object2.default._queueFlush();\n    });\n  }, function (reason) {\n    return new Promise(function (resolve, reject) {\n      _object2.default.delay(function () {\n        reject(reason);\n      });\n      _object2.default._queueFlush();\n    });\n  });\n}", "target": 0, "target_options": ["no_match", "match"]}
{"input": "Internal: Wraps the given promise so that subsequent chained promises are called after the next flush cycle has been run. [SEP] function wrapPromise(promise) {\n  return promise.then(function (value) {\n    return new Promise(function (resolve, reject) {\n      _object2.default.delay(function () {\n        resolve(value);\n      });\n      _object2.default._queueFlush();\n    });\n  }, function (reason) {\n    return new Promise(function (resolve, reject) {\n      _object2.default.delay(function () {\n        reject(reason);\n      });\n      _object2.default._queueFlush();\n    });\n  });\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Internal: Wraps the given promise so that subsequent chained promises are called after the next flush cycle has been run. [SEP] function linkTokenSuccess(req, res, next) {\n    var provider = getProviderToken(req.path);\n    res.status(200).json({\n      ok: true,\n      success: util.capitalizeFirstLetter(provider) + ' successfully linked',\n      provider: provider\n    });\n  }", "target": 0, "target_options": ["no_match", "match"]}
{"input": "Called after an account has been succesfully linked using access_token provider [SEP] function linkTokenSuccess(req, res, next) {\n    var provider = getProviderToken(req.path);\n    res.status(200).json({\n      ok: true,\n      success: util.capitalizeFirstLetter(provider) + ' successfully linked',\n      provider: provider\n    });\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Called after an account has been succesfully linked using access_token provider [SEP] function getCombinedNodeFlags(node) {\n        node = walkUpBindingElementsAndPatterns(node);\n        var flags = node.flags;\n        if (node.kind === 211 /* VariableDeclaration */) {\n            node = node.parent;\n        }\n        if (node && node.kind === 212 /* VariableDeclarationList */) {\n            flags |= node.flags;\n            node = node.parent;\n        }\n        if (node && node.kind === 193 /* VariableStatement */) {\n            flags |= node.flags;\n        }\n        return flags;\n    }", "target": 0, "target_options": ["no_match", "match"]}
{"input": "Check if a path exists.\n\n@param {String} path - The full path to the file to check.\n@param {Object} [options] - fileExists options.\n@param {Boolean} [options.returnFile] - If true, resolve to input filename on\nsuccess. Otherwise, resolve to boolean. Defaults to false (boolean).\n@returns {Promise} Resolves to true (or file) if exists, false otherwise. [SEP] function pathExists (path, options) {\n  options = options || {\n    returnFile: false\n  };\n\n  // Defaults to F_OK\n  return nodeCall(fs.access, path)\n    .then(function () {\n      return options.returnFile ? path : true;\n    })\n    .catch(function () {\n      if (fs.existsSync(path)) {\n        return options.returnFile ? path : true;\n      }\n      return false;\n    });\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Check if a path exists.\n\n@param {String} path - The full path to the file to check.\n@param {Object} [options] - fileExists options.\n@param {Boolean} [options.returnFile] - If true, resolve to input filename on\nsuccess. Otherwise, resolve to boolean. Defaults to false (boolean).\n@returns {Promise} Resolves to true (or file) if exists, false otherwise. [SEP] function( val ){\n\t\t\t\tinputs = elem.querySelectorAll( \"textarea, input\" );\n\t\t\t\tfor( var i = 0, il = inputs.length; i < il; i++ ) {\n\t\t\t\t\tinputs[ i ].style.pointerEvents = val;\n\t\t\t\t}\n\t\t\t}", "target": 0, "target_options": ["no_match", "match"]}
{"input": "/*\nThis tells the slider to increment its step non linearly over the\ncurrent range, based on the histogram on where results are.\n\nthe input parameter 'histogram' identifies an empirical probability\ndensity function (PDF). [SEP] function (histogram) {\n            var $this = this;\n\n            $this.data('last_step_histogram', histogram);\n\n            if (typeof histogram === 'undefined') {\n                $.error('got an undefined histogram in set_step_histogram');\n                _methods.unset_step_histogram.call($this);\n            }\n\n            var sliderWidthPx = _methods.getSliderWidthPx.call($this) - $this.data('left_grip_width'),\n                nbuckets = histogram.length;\n\n            if (sliderWidthPx <= 0) {\n                // that means the slider is not visible...\n                return;\n            }\n\n            //\n            // we need to transform this pdf into a cdf, and use it to obtain\n            // two mappings: pixel to value and value to pixel.\n            //\n            // 1) normalize the pdf to sum to sliderWidthPx first\n            var i;\n            var histogram_sum = 0;\n            for (i=0; i<nbuckets; i++) {\n                histogram_sum += histogram[i]; \n            }\n\n            //\n            // if the sum of the histogram is 0 it means that all is 0 in the \n            // histogram! (i.e, flat histogram). In this case we already know\n            // what's going to be the answer...\n            //\n            if (histogram_sum === 0) {\n                // ... and the answer is: a linear scale between min_range and\n                // max range!\n                methods.unset_step_histogram.call($this);\n\n                return $this;\n            }\n\n            // coefficient for normalization\n            var coeff = parseFloat(histogram_sum)/sliderWidthPx;\n\n            // go normalize the histogram using this coefficient!\n            for (i=0; i<nbuckets; i++) {\n                histogram[i] = histogram[i]/coeff;\n            }\n\n            // 2) now that the histogram is normalized, extract the cumulative\n            // distribution function (CDF). This is an always increasing function\n            // that ranges between 0 and sliderWidthPx;\n            //\n            // We also build the inverted cdf, just the cdf read the other way\n            // around.\n            //\n            var cdf = [ histogram[0] ];  // points to pixels\n            for (i=1; i<nbuckets; i++) {\n                var cdf_x = cdf[i-1] + histogram[i];\n                cdf.push(cdf_x);\n            }\n            cdf.push(sliderWidthPx);\n\n\n            // the first value here is always min_range as the cdf is supposed\n            // to start from 0 (also first pixel = min_range)\n            var pixel_to_value_lookup = [ $this.data('range_min') ];\n\n            var last_filled = 0; // we've already filled 0\n\n            // now stretch over the rest of the cdf\n            var last_price_for_cdf_bucket = pixel_to_value_lookup[0];\n\n            var cdf_bucket_count = 0;\n            while (last_filled <= sliderWidthPx) { // do until all pixels are filled\n\n                // get next item from cdf\n                var fill_up_to_px = parseInt(cdf.shift(), 10);\n                var price_for_cdf_bucket = \n                    _methods.inverse_rangemap_0_to_n.call($this, cdf_bucket_count+1, nbuckets+1);\n\n                cdf_bucket_count++;\n\n                // how many pixels do we have to fill\n                var fill_tot = fill_up_to_px - last_filled;\n\n                // interpolate and fill\n                var diff = price_for_cdf_bucket - last_price_for_cdf_bucket;\n                for (i = last_filled; i < fill_up_to_px; i++) {\n                    var next_price_for_cdf_bucket = \n                        last_price_for_cdf_bucket + (diff * (i-last_filled+1) / fill_tot);\n\n                    pixel_to_value_lookup.push(next_price_for_cdf_bucket);\n\n                    last_filled++;\n\n                    last_price_for_cdf_bucket = next_price_for_cdf_bucket;\n                }\n\n                if (last_filled === sliderWidthPx) {\n                    break;\n                }\n            }\n            pixel_to_value_lookup[pixel_to_value_lookup.length-1] = $this.data('range_max');\n\n            // 3) build lookup functions to extract pixels and values from the\n            // cdf and the inverted cdf.\n            //\n            var pixel_to_value_mapping = function (pixel) {\n                return pixel_to_value_lookup[parseInt(pixel, 10)];\n            };\n\n            var value_to_pixel_mapping = function (value) {\n                //\n                // Binary search into the array of pixels, returns always the\n                // rightmost pixel if there is no exact match.\n                //\n                var suggestedPixel = _methods.binarySearch.call($this, pixel_to_value_lookup, value, \n                    function(a, i) { return a[i]; },  // access a value in the array\n                    _methods.binarySearchValueToPxCompareFunc\n                );\n\n                // exact match\n                if (pixel_to_value_lookup[suggestedPixel] === value) {\n                    return suggestedPixel;\n                }\n\n                // approx match: we need to check if it's closer to the value\n                // at suggestedPixel or the value at suggestedPixel-1\n                if ( Math.abs(pixel_to_value_lookup[suggestedPixel-1] - value) <\n                     Math.abs(pixel_to_value_lookup[suggestedPixel] - value) ) {\n\n                     return suggestedPixel-1;\n                }\n                return suggestedPixel;\n            };\n\n            //\n            // these two functions will be stored and then used internally to\n            // decide what value to display given a certain pixel, and what\n            // pixel to put the slider on given a certain value.\n            //\n            $this.data('pixel_to_value_mapping', pixel_to_value_mapping);\n            $this.data('value_to_pixel_mapping', value_to_pixel_mapping);\n\n            return $this;\n        }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "/*\nThis tells the slider to increment its step non linearly over the\ncurrent range, based on the histogram on where results are.\n\nthe input parameter 'histogram' identifies an empirical probability\ndensity function (PDF). [SEP] function getAdd (opts) {\n    opts = opts || {}\n    var times = opts.times\n    var doesConsume = opts.doesConsume\n    return function add () {\n      var lastArg = arguments[arguments.length - 1]\n      var func = typeof lastArg === 'function' ? lastArg : function () { return lastArg }\n      var validators = arguments.length > 1 ? Array.prototype.slice.call(arguments, 0, -1) : []\n      var newAdapter = {\n        doesConsume: doesConsume, // calling this adapter will remove the event posted\n        times: times,\n        func: func,\n        validators: ut.combineValidators(validators),\n        ns: _ns\n      }\n      _adapters.push(newAdapter)\n\n      // trigger all published event matching this adapter\n      ut.filterArray(_events, function (event) {\n        if (newAdapter.times === 0) return true\n        var filteredAdapters = ut.filterAndSort(event.args, [newAdapter])\n        filteredAdapters.forEach(ut.countdown)\n        ut.filterArray(_adapters, ut.notExausted)\n        ut.triggerAll(event.context, event.args, filteredAdapters)\n        // if the adapter consume the event, this gets filtered out\n        return !(doesConsume && filteredAdapters.length)\n      })\n      return or\n    }\n  }", "target": 0, "target_options": ["no_match", "match"]}
{"input": "channel error handler [SEP] function errorHandler (app, key, err) {\n  // delete app key\n  delete app[key]\n  // log and adjust err message\n  const msg = `\"app.${key}\" unexpectedly errored: ${err.message}`\n  debug(msg, err)\n  err.message = msg\n  // throw the error\n  throw err\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "channel error handler [SEP] function wrapPromise(promise) {\n  return promise.then(function (value) {\n    return new Promise(function (resolve, reject) {\n      _object2.default.delay(function () {\n        resolve(value);\n      });\n      _object2.default._queueFlush();\n    });\n  }, function (reason) {\n    return new Promise(function (resolve, reject) {\n      _object2.default.delay(function () {\n        reject(reason);\n      });\n      _object2.default._queueFlush();\n    });\n  });\n}", "target": 0, "target_options": ["no_match", "match"]}
{"input": "Get a random color\n\n@return {Object} RGBA value [SEP] function() {\n    return {\n      r: Math.floor(Math.random() * 256),\n      g: Math.floor(Math.random() * 256),\n      b: Math.floor(Math.random() * 256),\n      a: 255\n    };\n  }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Get a random color\n\n@return {Object} RGBA value [SEP] function getCombinedNodeFlags(node) {\n        node = walkUpBindingElementsAndPatterns(node);\n        var flags = node.flags;\n        if (node.kind === 211 /* VariableDeclaration */) {\n            node = node.parent;\n        }\n        if (node && node.kind === 212 /* VariableDeclarationList */) {\n            flags |= node.flags;\n            node = node.parent;\n        }\n        if (node && node.kind === 193 /* VariableStatement */) {\n            flags |= node.flags;\n        }\n        return flags;\n    }", "target": 0, "target_options": ["no_match", "match"]}
{"input": "Returns the node flags for this node and all relevant parent nodes.  This is done so that nodes like variable declarations and binding elements can returned a view of their flags that includes the modifiers from their container.  i.e. flags like export/declare aren't stored on the variable declaration directly, but on the containing variable statement (if it has one).  Similarly, flags for let/const are store on the variable declaration list.  By calling this function, all those flags are combined so that the client can treat the node as if it actually had those flags. [SEP] function getCombinedNodeFlags(node) {\n        node = walkUpBindingElementsAndPatterns(node);\n        var flags = node.flags;\n        if (node.kind === 211 /* VariableDeclaration */) {\n            node = node.parent;\n        }\n        if (node && node.kind === 212 /* VariableDeclarationList */) {\n            flags |= node.flags;\n            node = node.parent;\n        }\n        if (node && node.kind === 193 /* VariableStatement */) {\n            flags |= node.flags;\n        }\n        return flags;\n    }", "target": 1, "target_options": ["no_match", "match"]}
{"input": "Returns the node flags for this node and all relevant parent nodes.  This is done so that nodes like variable declarations and binding elements can returned a view of their flags that includes the modifiers from their container.  i.e. flags like export/declare aren't stored on the variable declaration directly, but on the containing variable statement (if it has one).  Similarly, flags for let/const are store on the variable declaration list.  By calling this function, all those flags are combined so that the client can treat the node as if it actually had those flags. [SEP] function pathExists (path, options) {\n  options = options || {\n    returnFile: false\n  };\n\n  // Defaults to F_OK\n  return nodeCall(fs.access, path)\n    .then(function () {\n      return options.returnFile ? path : true;\n    })\n    .catch(function () {\n      if (fs.existsSync(path)) {\n        return options.returnFile ? path : true;\n      }\n      return false;\n    });\n}", "target": 0, "target_options": ["no_match", "match"]}
