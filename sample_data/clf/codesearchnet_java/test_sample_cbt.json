{"input": "Remove context from the local thread. [SEP] public static void unset() {\n    final String correlationId = CORRELATION_ID.get();\n    if (correlationId != null) {\n      CONTEXT_MAP.remove(correlationId);\n    }\n    CORRELATION_ID.remove();\n  }", "target": 1, "target_options": [0, 1]}
{"input": "Remove context from the local thread. [SEP] private void write(Record record) throws OnRecordErrorException {\n    // This is a contrived example, normally you may be performing an operation that could throw\n    // an exception or produce an error condition. In that case you can throw an OnRecordErrorException\n    // to send this record to the error pipeline with some details.\n    if (!record.has(\"/someField\")) {\n      throw new OnRecordErrorException(Errors.SAMPLE_01, record, \"exception detail message.\");\n    }\n\n    // TODO: write the records to your final destination\n  }", "target": 0, "target_options": [0, 1]}
{"input": "Deletes all cached log entries.\n\n@param logger       logger to use\n@param appenderName name of the appender which will be cleared [SEP] public void clear(final AppenderAttachable logger, final String appenderName) {\n\t\t((CaptureAppender) logger.getAppender(CaptureAppender.getAppenderNameFor(\n\t\t\t\tappenderName))).clear();\n\t}", "target": 1, "target_options": [0, 1]}
{"input": "Deletes all cached log entries.\n\n@param logger       logger to use\n@param appenderName name of the appender which will be cleared [SEP] private void write(Record record) throws OnRecordErrorException {\n    // This is a contrived example, normally you may be performing an operation that could throw\n    // an exception or produce an error condition. In that case you can throw an OnRecordErrorException\n    // to send this record to the error pipeline with some details.\n    if (!record.has(\"/someField\")) {\n      throw new OnRecordErrorException(Errors.SAMPLE_01, record, \"exception detail message.\");\n    }\n\n    // TODO: write the records to your final destination\n  }", "target": 0, "target_options": [0, 1]}
{"input": "Converts a {@code String} into a {@code Array}.\n\n@param s the {@code String} to convert\n@return an {@code Array} which contains {@code s} [SEP] @Override\n\tpublic Object unsafeParse(final String s) throws ParseException {\n\t\tfinal StringTokenizer t = new StringTokenizer(s, \",\");\n\t\tfinal Object array = Array.newInstance(componentAdapter.getType(), t.countTokens());\n\t\tfor (int i = 0; t.hasMoreTokens(); i++) {\n\t\t\tArray.set(array, i, componentAdapter.parse(t.nextToken().trim()));\n\t\t}\n\t\treturn array;\n\t}", "target": 1, "target_options": [0, 1]}
{"input": "Converts a {@code String} into a {@code Array}.\n\n@param s the {@code String} to convert\n@return an {@code Array} which contains {@code s} [SEP] public ProfileTableUsageMBean newProfileTableUsageMBean(\n\t\t\tString profileTableName, ProfileSpecificationComponent component)\n\t\t\tthrows NotCompliantMBeanException, MalformedObjectNameException,\n\t\t\tNullPointerException {\n\t\treturn new ProfileTableUsageMBeanImpl(profileTableName, component,\n\t\t\t\tsleeContainer);\n\t}", "target": 0, "target_options": [0, 1]}
{"input": "Drop the connection to the remote host and release the underlying connector thread if it has been created. [SEP] public void cleanUp()\n    {\n        if (oos != null)\n        {\n            try\n            {\n                oos.close();\n            }\n            catch (IOException e)\n            {\n                LogLog.error(\"Could not close oos.\", e);\n            }\n\n            oos = null;\n        }\n\n        if (connector != null)\n        {\n            // LogLog.debug(\"Interrupting the connector.\");\n            connector.interrupted = true;\n            connector = null; // allow gc\n        }\n    }", "target": 1, "target_options": [0, 1]}
{"input": "Drop the connection to the remote host and release the underlying connector thread if it has been created. [SEP] public char getScalarChar(int recnum, StructureMembers.Member m) {\r\n    if (m.getDataType() != DataType.CHAR)\r\n      throw new IllegalArgumentException(\"Type is \" + m.getDataType() + \", must be char\");\r\n    Array data = m.getDataArray();\r\n    return data.getChar(recnum * m.getSize()); // gets first one in the array\r\n  }", "target": 0, "target_options": [0, 1]}
{"input": "Get scalar member data of type char.\n\n@param recnum get data from the recnum-th StructureData of the ArrayStructure. Must be less than getSize();\n@param m      get data from this StructureMembers.Member. Must be of type char.\n@return scalar double value [SEP] public char getScalarChar(int recnum, StructureMembers.Member m) {\r\n    if (m.getDataType() != DataType.CHAR)\r\n      throw new IllegalArgumentException(\"Type is \" + m.getDataType() + \", must be char\");\r\n    Array data = m.getDataArray();\r\n    return data.getChar(recnum * m.getSize()); // gets first one in the array\r\n  }", "target": 1, "target_options": [0, 1]}
{"input": "Get scalar member data of type char.\n\n@param recnum get data from the recnum-th StructureData of the ArrayStructure. Must be less than getSize();\n@param m      get data from this StructureMembers.Member. Must be of type char.\n@return scalar double value [SEP] public ProfileTableUsageMBean newProfileTableUsageMBean(\n\t\t\tString profileTableName, ProfileSpecificationComponent component)\n\t\t\tthrows NotCompliantMBeanException, MalformedObjectNameException,\n\t\t\tNullPointerException {\n\t\treturn new ProfileTableUsageMBeanImpl(profileTableName, component,\n\t\t\t\tsleeContainer);\n\t}", "target": 0, "target_options": [0, 1]}
{"input": "/*\n(non-Javadoc)\n\n@seeorg.mobicents.slee.container.management.UsageParametersManagement#\nnewProfileTableUsageMBean(java.lang.String,\norg.mobicents.slee.core.component.profile.ProfileSpecificationComponent) [SEP] public ProfileTableUsageMBean newProfileTableUsageMBean(\n\t\t\tString profileTableName, ProfileSpecificationComponent component)\n\t\t\tthrows NotCompliantMBeanException, MalformedObjectNameException,\n\t\t\tNullPointerException {\n\t\treturn new ProfileTableUsageMBeanImpl(profileTableName, component,\n\t\t\t\tsleeContainer);\n\t}", "target": 1, "target_options": [0, 1]}
{"input": "/*\n(non-Javadoc)\n\n@seeorg.mobicents.slee.container.management.UsageParametersManagement#\nnewProfileTableUsageMBean(java.lang.String,\norg.mobicents.slee.core.component.profile.ProfileSpecificationComponent) [SEP] private void write(Record record) throws OnRecordErrorException {\n    // This is a contrived example, normally you may be performing an operation that could throw\n    // an exception or produce an error condition. In that case you can throw an OnRecordErrorException\n    // to send this record to the error pipeline with some details.\n    if (!record.has(\"/someField\")) {\n      throw new OnRecordErrorException(Errors.SAMPLE_01, record, \"exception detail message.\");\n    }\n\n    // TODO: write the records to your final destination\n  }", "target": 0, "target_options": [0, 1]}
{"input": "Writes a single record to the destination.\n\n@param record the record to write to the destination.\n@throws OnRecordErrorException when a record cannot be written. [SEP] private void write(Record record) throws OnRecordErrorException {\n    // This is a contrived example, normally you may be performing an operation that could throw\n    // an exception or produce an error condition. In that case you can throw an OnRecordErrorException\n    // to send this record to the error pipeline with some details.\n    if (!record.has(\"/someField\")) {\n      throw new OnRecordErrorException(Errors.SAMPLE_01, record, \"exception detail message.\");\n    }\n\n    // TODO: write the records to your final destination\n  }", "target": 1, "target_options": [0, 1]}
{"input": "Writes a single record to the destination.\n\n@param record the record to write to the destination.\n@throws OnRecordErrorException when a record cannot be written. [SEP] private void makeDatasetBest(GribCollectionMutable.Dataset ds2D, boolean isComplete) {\n    GribCollectionMutable.Dataset dsBest = result.makeDataset(isComplete ? GribCollectionImmutable.Type.BestComplete : GribCollectionImmutable.Type.Best);\n\n    int npart = result.getPartitionSize();\n\n    // for each 2D group\n    for (GribCollectionMutable.GroupGC group2D : ds2D.groups) {\n      GribCollectionMutable.GroupGC groupB = dsBest.addGroupCopy(group2D);  // make copy of group, add to Best dataset\n      groupB.isTwoD = false;\n\n      // for each time2D, create the best time coordinates\n      HashMap<Coordinate, CoordinateTimeAbstract> map2DtoBest = new HashMap<>(); // associate 2D coord with best\n      CoordinateSharerBest sharer = new CoordinateSharerBest();\n      for (Coordinate coord : group2D.coords) {\n        if (coord instanceof CoordinateRuntime) continue; // skip it\n        if (coord instanceof CoordinateTime2D) {\n          CoordinateTimeAbstract best = ((CoordinateTime2D) coord).makeBestTimeCoordinate(result.masterRuntime);\n          if (!isComplete) best = best.makeBestFromComplete();\n          sharer.addCoordinate(best);\n          map2DtoBest.put(coord, best);\n        } else {\n          sharer.addCoordinate(coord);\n        }\n      }\n      groupB.coords = sharer.finish();  // these are the unique coords for group Best\n\n      // transfer variables to Best group, set shared Coordinates\n      for (GribCollectionMutable.VariableIndex vi2d : group2D.variList) {\n        // copy vi2d and add to groupB\n        PartitionCollectionMutable.VariableIndexPartitioned vip = result.makeVariableIndexPartitioned(groupB, vi2d, npart);\n        vip.finish();\n\n        // set shared coordinates\n        List<Coordinate> newCoords = new ArrayList<>();\n        for (Integer groupIndex : vi2d.coordIndex) {\n          Coordinate coord2D = group2D.coords.get(groupIndex);\n          if (coord2D instanceof CoordinateRuntime) continue; // skip runtime;\n          if (coord2D instanceof CoordinateTime2D) {\n            newCoords.add(map2DtoBest.get(coord2D)); // add the best coordinate for that CoordinateTime2D\n          } else {\n            newCoords.add(coord2D);\n          }\n        }\n        vip.coordIndex = sharer.reindex(newCoords);\n      }\n\n    } // loop over groups\n  }", "target": 0, "target_options": [0, 1]}
{"input": "/* LOOK heres a place where one could \"post process\" and combine, instead of at coverage level.\nthis would benefit iosp, ie the netcdf API\nprivate void makeTime2runtime(GribCollectionMutable.Dataset ds2D, boolean isComplete) throws IOException {\n\nfor (GribCollectionMutable.GroupGC group2D : ds2D.groups) {\nfor each time2D, add time2runtime\nfor (Coordinate coord : group2D.coords) {\nif (coord instanceof CoordinateTime2D) {\n((CoordinateTime2D) coord).makeTime2runtime(result.masterRuntime);\n}\n}\n}\n} [SEP] private void makeDatasetBest(GribCollectionMutable.Dataset ds2D, boolean isComplete) {\n    GribCollectionMutable.Dataset dsBest = result.makeDataset(isComplete ? GribCollectionImmutable.Type.BestComplete : GribCollectionImmutable.Type.Best);\n\n    int npart = result.getPartitionSize();\n\n    // for each 2D group\n    for (GribCollectionMutable.GroupGC group2D : ds2D.groups) {\n      GribCollectionMutable.GroupGC groupB = dsBest.addGroupCopy(group2D);  // make copy of group, add to Best dataset\n      groupB.isTwoD = false;\n\n      // for each time2D, create the best time coordinates\n      HashMap<Coordinate, CoordinateTimeAbstract> map2DtoBest = new HashMap<>(); // associate 2D coord with best\n      CoordinateSharerBest sharer = new CoordinateSharerBest();\n      for (Coordinate coord : group2D.coords) {\n        if (coord instanceof CoordinateRuntime) continue; // skip it\n        if (coord instanceof CoordinateTime2D) {\n          CoordinateTimeAbstract best = ((CoordinateTime2D) coord).makeBestTimeCoordinate(result.masterRuntime);\n          if (!isComplete) best = best.makeBestFromComplete();\n          sharer.addCoordinate(best);\n          map2DtoBest.put(coord, best);\n        } else {\n          sharer.addCoordinate(coord);\n        }\n      }\n      groupB.coords = sharer.finish();  // these are the unique coords for group Best\n\n      // transfer variables to Best group, set shared Coordinates\n      for (GribCollectionMutable.VariableIndex vi2d : group2D.variList) {\n        // copy vi2d and add to groupB\n        PartitionCollectionMutable.VariableIndexPartitioned vip = result.makeVariableIndexPartitioned(groupB, vi2d, npart);\n        vip.finish();\n\n        // set shared coordinates\n        List<Coordinate> newCoords = new ArrayList<>();\n        for (Integer groupIndex : vi2d.coordIndex) {\n          Coordinate coord2D = group2D.coords.get(groupIndex);\n          if (coord2D instanceof CoordinateRuntime) continue; // skip runtime;\n          if (coord2D instanceof CoordinateTime2D) {\n            newCoords.add(map2DtoBest.get(coord2D)); // add the best coordinate for that CoordinateTime2D\n          } else {\n            newCoords.add(coord2D);\n          }\n        }\n        vip.coordIndex = sharer.reindex(newCoords);\n      }\n\n    } // loop over groups\n  }", "target": 1, "target_options": [0, 1]}
{"input": "/* LOOK heres a place where one could \"post process\" and combine, instead of at coverage level.\nthis would benefit iosp, ie the netcdf API\nprivate void makeTime2runtime(GribCollectionMutable.Dataset ds2D, boolean isComplete) throws IOException {\n\nfor (GribCollectionMutable.GroupGC group2D : ds2D.groups) {\nfor each time2D, add time2runtime\nfor (Coordinate coord : group2D.coords) {\nif (coord instanceof CoordinateTime2D) {\n((CoordinateTime2D) coord).makeTime2runtime(result.masterRuntime);\n}\n}\n}\n} [SEP] @Override\n\tpublic Object unsafeParse(final String s) throws ParseException {\n\t\tfinal StringTokenizer t = new StringTokenizer(s, \",\");\n\t\tfinal Object array = Array.newInstance(componentAdapter.getType(), t.countTokens());\n\t\tfor (int i = 0; t.hasMoreTokens(); i++) {\n\t\t\tArray.set(array, i, componentAdapter.parse(t.nextToken().trim()));\n\t\t}\n\t\treturn array;\n\t}", "target": 0, "target_options": [0, 1]}
{"input": "wml2:Collection/wml2:observationMember/om:OM_Observation/om:phenomenonTime/gml:TimePeriod [SEP] public static TimePeriodType initTimePeriod(\n            TimePeriodType timePeriod, StationTimeSeriesFeature stationFeat) throws IOException {\n        // @gml:id\n        String id = MarshallingUtil.createIdForType(TimePeriodType.class);\n        timePeriod.setId(id);\n\n        CollectionInfo info;\n        try {\n            info = new DsgCollectionHelper(stationFeat).calcBounds();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        CalendarDateRange cdr = info.getCalendarDateRange(stationFeat.getTimeUnit());\n        if (cdr != null) {\n\n            // gml:beginPosition\n            NcTimePositionType.initBeginPosition(timePeriod.addNewBeginPosition(), cdr.getStart());\n\n            // gml:endPosition\n            NcTimePositionType.initEndPosition(timePeriod.addNewEndPosition(), cdr.getEnd());\n        }\n\n        return timePeriod;\n    }", "target": 1, "target_options": [0, 1]}
{"input": "wml2:Collection/wml2:observationMember/om:OM_Observation/om:phenomenonTime/gml:TimePeriod [SEP] public void cleanUp()\n    {\n        if (oos != null)\n        {\n            try\n            {\n                oos.close();\n            }\n            catch (IOException e)\n            {\n                LogLog.error(\"Could not close oos.\", e);\n            }\n\n            oos = null;\n        }\n\n        if (connector != null)\n        {\n            // LogLog.debug(\"Interrupting the connector.\");\n            connector.interrupted = true;\n            connector = null; // allow gc\n        }\n    }", "target": 0, "target_options": [0, 1]}
{"input": "Throws an exception for invalid byte. [SEP] private void invalidByte(int position, int count, int c) \n        throws UTFDataFormatException {\n\n        throw new UTFDataFormatException(\n                Localizer.getMessage(\"jsp.error.xml.invalidByte\",\n\t\t\t\t     Integer.toString(position),\n\t\t\t\t     Integer.toString(count)));\n    }", "target": 1, "target_options": [0, 1]}
{"input": "Throws an exception for invalid byte. [SEP] public char getScalarChar(int recnum, StructureMembers.Member m) {\r\n    if (m.getDataType() != DataType.CHAR)\r\n      throw new IllegalArgumentException(\"Type is \" + m.getDataType() + \", must be char\");\r\n    Array data = m.getDataArray();\r\n    return data.getChar(recnum * m.getSize()); // gets first one in the array\r\n  }", "target": 0, "target_options": [0, 1]}
