{"input": "Raises OrderError if no package or file defined . Raises SPDXValueError if not free form text . Raises CardinalityError if more than one . [SEP] def Func ( arg_0 , arg_1 , arg_2 ) : if arg_0 . has_package ( arg_1 ) and arg_0 . has_file ( arg_1 ) : if not arg_0 . file_notice_set : arg_0 . file_notice_set = True if validations . validate_file_notice ( arg_2 ) : arg_0 . file ( arg_1 ) . notice = str_from_text ( arg_2 ) else : raise SPDXValueError ( 'File::Notice' ) else : raise CardinalityError ( 'File::Notice' ) else : raise OrderError ( 'File::Notice' )", "target": "True", "target_options": ["False", "True"]}
{"input": "Raises OrderError if no package or file defined . Raises SPDXValueError if not free form text . Raises CardinalityError if more than one . [SEP] def Func ( arg_0 : arg_1 ) -> None : arg_2 = defaultdict ( set ) arg_3 = set ( ) arg_4 = tqdm ( itt . combinations ( arg_0 , r = 2 ) , total = arg_0 . number_of_nodes ( ) * ( arg_0 . number_of_nodes ( ) - 1 ) / 2 ) for arg_5 , arg_6 in arg_4 : if arg_6 in arg_3 : continue arg_7 , arg_8 = arg_5 . get ( NAME ) , arg_6 . get ( NAME ) if not arg_7 or not arg_8 or arg_7 . lower ( ) != arg_8 . lower ( ) : continue if arg_5 . keys ( ) != arg_6 . keys ( ) : continue for arg_9 in set ( arg_5 . keys ( ) ) - { NAME , NAMESPACE } : if arg_5 [ arg_9 ] != arg_6 [ arg_9 ] : continue arg_2 [ arg_5 ] . add ( arg_6 ) arg_3 . add ( arg_6 ) collapse_nodes ( arg_0 , arg_2 )", "target": "False", "target_options": ["False", "True"]}
{"input": "Collapse all nodes with the same name merging namespaces by picking first alphabetical one . [SEP] def Func ( arg_0 : arg_1 ) -> None : arg_2 = defaultdict ( set ) arg_3 = set ( ) arg_4 = tqdm ( itt . combinations ( arg_0 , r = 2 ) , total = arg_0 . number_of_nodes ( ) * ( arg_0 . number_of_nodes ( ) - 1 ) / 2 ) for arg_5 , arg_6 in arg_4 : if arg_6 in arg_3 : continue arg_7 , arg_8 = arg_5 . get ( NAME ) , arg_6 . get ( NAME ) if not arg_7 or not arg_8 or arg_7 . lower ( ) != arg_8 . lower ( ) : continue if arg_5 . keys ( ) != arg_6 . keys ( ) : continue for arg_9 in set ( arg_5 . keys ( ) ) - { NAME , NAMESPACE } : if arg_5 [ arg_9 ] != arg_6 [ arg_9 ] : continue arg_2 [ arg_5 ] . add ( arg_6 ) arg_3 . add ( arg_6 ) collapse_nodes ( arg_0 , arg_2 )", "target": "True", "target_options": ["False", "True"]}
{"input": "Collapse all nodes with the same name merging namespaces by picking first alphabetical one . [SEP] def Func ( arg_0 : arg_1 , arg_2 : arg_3 , arg_4 : arg_5 = None , arg_6 : arg_5 = 0 , arg_7 : arg_8 = None ) -> SamplePulse : if arg_4 is None : arg_4 = 1 / arg_0 return _sampled_Func_pulse ( arg_0 , arg_2 , arg_4 , arg_6 = arg_6 , arg_7 = arg_7 )", "target": "False", "target_options": ["False", "True"]}
{"input": "Generates cosine wave SamplePulse . [SEP] def Func ( arg_0 : arg_1 , arg_2 : arg_3 , arg_4 : arg_5 = None , arg_6 : arg_5 = 0 , arg_7 : arg_8 = None ) -> SamplePulse : if arg_4 is None : arg_4 = 1 / arg_0 return _sampled_Func_pulse ( arg_0 , arg_2 , arg_4 , arg_6 = arg_6 , arg_7 = arg_7 )", "target": "True", "target_options": ["False", "True"]}
{"input": "Generates cosine wave SamplePulse . [SEP] def Func ( arg_0 , arg_1 = None ) : arg_2 = KitsuneClient . FIRST_PAGE if arg_1 : arg_2 += int ( arg_1 / KitsuneClient . ITEMS_PER_PAGE ) while True : arg_3 = urijoin ( arg_0 . base_url , '/question' ) + '/' arg_4 = { \"page\" : arg_2 , \"ordering\" : \"updated\" } arg_5 = arg_0 . fetch ( arg_3 , arg_4 ) yield arg_5 arg_6 = json . loads ( arg_5 ) arg_7 = arg_6 [ 'next' ] if not arg_7 : break arg_2 += 1", "target": "False", "target_options": ["False", "True"]}
{"input": "Retrieve questions from older to newer updated starting offset [SEP] def Func ( arg_0 , arg_1 = None ) : arg_2 = KitsuneClient . FIRST_PAGE if arg_1 : arg_2 += int ( arg_1 / KitsuneClient . ITEMS_PER_PAGE ) while True : arg_3 = urijoin ( arg_0 . base_url , '/question' ) + '/' arg_4 = { \"page\" : arg_2 , \"ordering\" : \"updated\" } arg_5 = arg_0 . fetch ( arg_3 , arg_4 ) yield arg_5 arg_6 = json . loads ( arg_5 ) arg_7 = arg_6 [ 'next' ] if not arg_7 : break arg_2 += 1", "target": "True", "target_options": ["False", "True"]}
{"input": "Retrieve questions from older to newer updated starting offset [SEP] def Func ( arg_0 , arg_1 , arg_2 ) : if arg_0 . has_package ( arg_1 ) and arg_0 . has_file ( arg_1 ) : if not arg_0 . file_notice_set : arg_0 . file_notice_set = True if validations . validate_file_notice ( arg_2 ) : arg_0 . file ( arg_1 ) . notice = str_from_text ( arg_2 ) else : raise SPDXValueError ( 'File::Notice' ) else : raise CardinalityError ( 'File::Notice' ) else : raise OrderError ( 'File::Notice' )", "target": "False", "target_options": ["False", "True"]}
{"input": "Re - order the conversations when an event occurs . [SEP] def Func ( arg_0 , arg_1 ) : arg_0 . sort ( key = lambda conv_button : conv_button . last_modified , reverse = True )", "target": "True", "target_options": ["False", "True"]}
{"input": "Re - order the conversations when an event occurs . [SEP] def Func ( arg_0 , arg_1 = None ) : arg_2 = KitsuneClient . FIRST_PAGE if arg_1 : arg_2 += int ( arg_1 / KitsuneClient . ITEMS_PER_PAGE ) while True : arg_3 = urijoin ( arg_0 . base_url , '/question' ) + '/' arg_4 = { \"page\" : arg_2 , \"ordering\" : \"updated\" } arg_5 = arg_0 . fetch ( arg_3 , arg_4 ) yield arg_5 arg_6 = json . loads ( arg_5 ) arg_7 = arg_6 [ 'next' ] if not arg_7 : break arg_2 += 1", "target": "False", "target_options": ["False", "True"]}
{"input": "Generate time in seconds to retransmit DHCPREQUEST . [SEP] def Func ( arg_0 ) : arg_1 = ( arg_0 . rebinding_time - arg_0 . renewing_time ) * RENEW_PERC if arg_1 < 60 : arg_1 = 60 logger . debug ( 'Next request in renew will happen on %s' , future_dt_str ( nowutc ( ) , arg_1 ) ) return arg_1", "target": "True", "target_options": ["False", "True"]}
{"input": "Generate time in seconds to retransmit DHCPREQUEST . [SEP] def Func ( arg_0 , arg_1 = None ) : arg_2 = KitsuneClient . FIRST_PAGE if arg_1 : arg_2 += int ( arg_1 / KitsuneClient . ITEMS_PER_PAGE ) while True : arg_3 = urijoin ( arg_0 . base_url , '/question' ) + '/' arg_4 = { \"page\" : arg_2 , \"ordering\" : \"updated\" } arg_5 = arg_0 . fetch ( arg_3 , arg_4 ) yield arg_5 arg_6 = json . loads ( arg_5 ) arg_7 = arg_6 [ 'next' ] if not arg_7 : break arg_2 += 1", "target": "False", "target_options": ["False", "True"]}
{"input": "Write the content into the given file . [SEP] def Func ( arg_0 , arg_1 , arg_2 ) : if not PyFunceble . CONFIGURATION [ \"no_files\" ] : if not isinstance ( arg_1 , dict ) : arg_1 = { } Dict ( arg_1 ) . to_json ( arg_2 )", "target": "True", "target_options": ["False", "True"]}
{"input": "Write the content into the given file . [SEP] def Func ( arg_0 , arg_1 , arg_2 ) : if arg_0 . has_package ( arg_1 ) and arg_0 . has_file ( arg_1 ) : if not arg_0 . file_notice_set : arg_0 . file_notice_set = True if validations . validate_file_notice ( arg_2 ) : arg_0 . file ( arg_1 ) . notice = str_from_text ( arg_2 ) else : raise SPDXValueError ( 'File::Notice' ) else : raise CardinalityError ( 'File::Notice' ) else : raise OrderError ( 'File::Notice' )", "target": "False", "target_options": ["False", "True"]}
{"input": "Try to pull a date from the request by looking first at the x - amz - date header and if that s not present then the Date header . [SEP] def Func ( arg_0 , arg_1 ) : arg_2 = None for arg_3 in [ 'x-amz-date' , 'date' ] : if arg_3 not in arg_1 . headers : continue try : arg_4 = arg_0 . parse_date ( arg_1 . headers [ arg_3 ] ) except DateFormatError : continue try : arg_2 = datetime . datetime . strptime ( arg_4 , '%Y-%m-%d' ) . date ( ) except ValueError : continue else : break return arg_2", "target": "True", "target_options": ["False", "True"]}
{"input": "Try to pull a date from the request by looking first at the x - amz - date header and if that s not present then the Date header . [SEP] def Func ( arg_0 ) : arg_1 = ( arg_0 . rebinding_time - arg_0 . renewing_time ) * RENEW_PERC if arg_1 < 60 : arg_1 = 60 logger . debug ( 'Next request in renew will happen on %s' , future_dt_str ( nowutc ( ) , arg_1 ) ) return arg_1", "target": "False", "target_options": ["False", "True"]}
{"input": "Disassemble byte string of code . If end_line is negative it counts the number of statement linestarts to use . [SEP] def Func ( arg_0 , arg_1 , arg_2 , arg_3 = - 1 , arg_4 = 0 , arg_5 = - 1 , arg_6 = None , arg_7 = False , arg_8 = ( ) , arg_9 = ( ) , arg_10 = ( ) , arg_11 = ( ) , arg_12 = ( ) , arg_13 = { } , arg_14 = 'light' , arg_15 = 0 , arg_16 = None ) : arg_17 = 10000 if arg_6 is None : arg_6 = 10000 elif arg_7 : arg_6 += arg_5 - 1 pass arg_18 = findlabels ( arg_2 ) arg_19 = lambda x : None if arg_5 > arg_4 : arg_20 = arg_19 arg_21 = arg_19 else : arg_20 = arg_1 arg_21 = arg_0 for arg_22 in get_instructions_bytes ( arg_2 , opc , arg_8 , arg_9 , arg_10 , arg_11 , arg_13 ) : arg_23 = arg_22 . offset if arg_16 and arg_23 > arg_16 : break if arg_22 . starts_line : if arg_23 : arg_21 ( \"\" ) arg_4 = arg_22 . starts_line if ( arg_5 and ( ( arg_5 > arg_4 ) or arg_15 and arg_15 > arg_23 ) ) : arg_20 = arg_19 arg_21 = arg_19 else : arg_17 -= 1 arg_20 = arg_1 arg_21 = arg_0 pass if ( ( arg_4 > arg_6 ) or ( arg_16 and arg_23 > arg_16 ) ) : break arg_20 ( format_token ( Mformat . LineNumber , \"%4d\" % arg_4 , arg_14 = arg_14 ) ) else : if arg_15 and arg_23 and arg_15 <= arg_23 : arg_20 = arg_1 arg_21 = arg_0 pass arg_20 ( '    ' ) if arg_23 == arg_3 : arg_20 ( format_token ( Mformat . Arrow , '-->' , arg_14 = arg_14 ) ) else : arg_20 ( '   ' ) if arg_23 in arg_18 : arg_20 ( format_token ( Mformat . Arrow , '>>' , arg_14 = arg_14 ) ) else : arg_20 ( '  ' ) arg_20 ( repr ( arg_23 ) . rjust ( 4 ) ) arg_20 ( ' ' ) arg_20 ( format_token ( Mformat . Opcode , arg_22 . opname . ljust ( 20 ) , arg_14 = arg_14 ) ) arg_20 ( repr ( arg_22 . arg ) . ljust ( 10 ) ) arg_20 ( ' ' ) arg_21 ( format_token ( Mformat . Name , arg_22 . argrepr . ljust ( 20 ) , arg_14 = arg_14 ) ) pass return arg_2 , arg_23", "target": "True", "target_options": ["False", "True"]}
{"input": "Disassemble byte string of code . If end_line is negative it counts the number of statement linestarts to use . [SEP] def Func ( arg_0 : arg_1 ) -> None : arg_2 = defaultdict ( set ) arg_3 = set ( ) arg_4 = tqdm ( itt . combinations ( arg_0 , r = 2 ) , total = arg_0 . number_of_nodes ( ) * ( arg_0 . number_of_nodes ( ) - 1 ) / 2 ) for arg_5 , arg_6 in arg_4 : if arg_6 in arg_3 : continue arg_7 , arg_8 = arg_5 . get ( NAME ) , arg_6 . get ( NAME ) if not arg_7 or not arg_8 or arg_7 . lower ( ) != arg_8 . lower ( ) : continue if arg_5 . keys ( ) != arg_6 . keys ( ) : continue for arg_9 in set ( arg_5 . keys ( ) ) - { NAME , NAMESPACE } : if arg_5 [ arg_9 ] != arg_6 [ arg_9 ] : continue arg_2 [ arg_5 ] . add ( arg_6 ) arg_3 . add ( arg_6 ) collapse_nodes ( arg_0 , arg_2 )", "target": "False", "target_options": ["False", "True"]}
{"input": "Calculate the phase s magnetic contribution to entropy at the specified temperature . [SEP] def Func ( arg_0 , arg_1 ) : arg_2 = arg_1 / arg_0 . Tc_mag if arg_2 <= 1.0 : arg_3 = 1 - ( arg_0 . _B_mag * ( 2 * arg_2 ** 3 / 3 + 2 * arg_2 ** 9 / 27 + 2 * arg_2 ** 15 / 75 ) ) / arg_0 . _D_mag else : arg_3 = ( 2 * arg_2 ** - 5 / 5 + 2 * arg_2 ** - 15 / 45 + 2 * arg_2 ** - 25 / 125 ) / arg_0 . _D_mag return - R * math . log ( arg_0 . beta0_mag + 1 ) * arg_3", "target": "True", "target_options": ["False", "True"]}
{"input": "Calculate the phase s magnetic contribution to entropy at the specified temperature . [SEP] def Func ( arg_0 , arg_1 , arg_2 ) : if not PyFunceble . CONFIGURATION [ \"no_files\" ] : if not isinstance ( arg_1 , dict ) : arg_1 = { } Dict ( arg_1 ) . to_json ( arg_2 )", "target": "False", "target_options": ["False", "True"]}
