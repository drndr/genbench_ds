{"repo": "relekang/rmoq", "path": "rmoq/base.py", "func_name": "Mock.activate", "original_string": "def activate(self, prefix=None, backend=None):\n        \"\"\"\n        A decorator used to activate the mocker.\n\n        :param prefix:\n        :param backend: An instance of a storage backend.\n        \"\"\"\n        if isinstance(prefix, compat.string_types):\n            self.prefix = prefix\n\n        if isinstance(backend, RmoqStorageBackend):\n            self.backend = backend\n\n        def activate(func):\n            if isinstance(func, type):\n                return self._decorate_class(func)\n\n            def wrapper(*args, **kwargs):\n                with self:\n                    return func(*args, **kwargs)\n\n            return wrapper\n\n        return activate", "language": "python", "code": "def activate(self, prefix=None, backend=None):\n        \"\"\"\n        A decorator used to activate the mocker.\n\n        :param prefix:\n        :param backend: An instance of a storage backend.\n        \"\"\"\n        if isinstance(prefix, compat.string_types):\n            self.prefix = prefix\n\n        if isinstance(backend, RmoqStorageBackend):\n            self.backend = backend\n\n        def activate(func):\n            if isinstance(func, type):\n                return self._decorate_class(func)\n\n            def wrapper(*args, **kwargs):\n                with self:\n                    return func(*args, **kwargs)\n\n            return wrapper\n\n        return activate", "code_tokens": ["def", "activate", "(", "self", ",", "prefix", "=", "None", ",", "backend", "=", "None", ")", ":", "if", "isinstance", "(", "prefix", ",", "compat", ".", "string_types", ")", ":", "self", ".", "prefix", "=", "prefix", "if", "isinstance", "(", "backend", ",", "RmoqStorageBackend", ")", ":", "self", ".", "backend", "=", "backend", "def", "activate", "(", "func", ")", ":", "if", "isinstance", "(", "func", ",", "type", ")", ":", "return", "self", ".", "_decorate_class", "(", "func", ")", "def", "wrapper", "(", "*", "args", ",", "*", "*", "kwargs", ")", ":", "with", "self", ":", "return", "func", "(", "*", "args", ",", "*", "*", "kwargs", ")", "return", "wrapper", "return", "activate"], "docstring": "A decorator used to activate the mocker.\n\n        :param prefix:\n        :param backend: An instance of a storage backend.", "docstring_tokens": ["A", "decorator", "used", "to", "activate", "the", "mocker", "."], "sha": "61fd2a221e247b7aca87492f10c3bc3894536260", "url": "https://github.com/relekang/rmoq/blob/61fd2a221e247b7aca87492f10c3bc3894536260/rmoq/base.py#L38-L61", "partition": "train", "idx": 98021}
{"repo": "tbielawa/bitmath", "path": "bitmath/__init__.py", "func_name": "Bitmath.from_other", "original_string": "def from_other(cls, item):\n        \"\"\"Factory function to return instances of `item` converted into a new\ninstance of ``cls``. Because this is a class method, it may be called\nfrom any bitmath class object without the need to explicitly\ninstantiate the class ahead of time.\n\n*Implicit Parameter:*\n\n* ``cls`` A bitmath class, implicitly set to the class of the\n  instance object it is called on\n\n*User Supplied Parameter:*\n\n* ``item`` A :class:`bitmath.Bitmath` subclass instance\n\n*Example:*\n\n   >>> import bitmath\n   >>> kib = bitmath.KiB.from_other(bitmath.MiB(1))\n   >>> print kib\n   KiB(1024.0)\n\n        \"\"\"\n        if isinstance(item, Bitmath):\n            return cls(bits=item.bits)\n        else:\n            raise ValueError(\"The provided items must be a valid bitmath class: %s\" %\n                             str(item.__class__))", "language": "python", "code": "def from_other(cls, item):\n        \"\"\"Factory function to return instances of `item` converted into a new\ninstance of ``cls``. Because this is a class method, it may be called\nfrom any bitmath class object without the need to explicitly\ninstantiate the class ahead of time.\n\n*Implicit Parameter:*\n\n* ``cls`` A bitmath class, implicitly set to the class of the\n  instance object it is called on\n\n*User Supplied Parameter:*\n\n* ``item`` A :class:`bitmath.Bitmath` subclass instance\n\n*Example:*\n\n   >>> import bitmath\n   >>> kib = bitmath.KiB.from_other(bitmath.MiB(1))\n   >>> print kib\n   KiB(1024.0)\n\n        \"\"\"\n        if isinstance(item, Bitmath):\n            return cls(bits=item.bits)\n        else:\n            raise ValueError(\"The provided items must be a valid bitmath class: %s\" %\n                             str(item.__class__))", "code_tokens": ["def", "from_other", "(", "cls", ",", "item", ")", ":", "if", "isinstance", "(", "item", ",", "Bitmath", ")", ":", "return", "cls", "(", "bits", "=", "item", ".", "bits", ")", "else", ":", "raise", "ValueError", "(", "\"The provided items must be a valid bitmath class: %s\"", "%", "str", "(", "item", ".", "__class__", ")", ")"], "docstring": "Factory function to return instances of `item` converted into a new\ninstance of ``cls``. Because this is a class method, it may be called\nfrom any bitmath class object without the need to explicitly\ninstantiate the class ahead of time.\n\n*Implicit Parameter:*\n\n* ``cls`` A bitmath class, implicitly set to the class of the\n  instance object it is called on\n\n*User Supplied Parameter:*\n\n* ``item`` A :class:`bitmath.Bitmath` subclass instance\n\n*Example:*\n\n   >>> import bitmath\n   >>> kib = bitmath.KiB.from_other(bitmath.MiB(1))\n   >>> print kib\n   KiB(1024.0)", "docstring_tokens": ["Factory", "function", "to", "return", "instances", "of", "item", "converted", "into", "a", "new", "instance", "of", "cls", ".", "Because", "this", "is", "a", "class", "method", "it", "may", "be", "called", "from", "any", "bitmath", "class", "object", "without", "the", "need", "to", "explicitly", "instantiate", "the", "class", "ahead", "of", "time", "."], "sha": "58ad3ac5f076cc6e53f36a91af055c6028c850a5", "url": "https://github.com/tbielawa/bitmath/blob/58ad3ac5f076cc6e53f36a91af055c6028c850a5/bitmath/__init__.py#L371-L398", "partition": "train", "idx": 192904}
{"repo": "BlueBrain/NeuroM", "path": "neurom/fst/_neuritefunc.py", "func_name": "section_lengths", "original_string": "def section_lengths(neurites, neurite_type=NeuriteType.all):\n    '''section lengths in a collection of neurites'''\n    return map_sections(_section_length, neurites, neurite_type=neurite_type)", "language": "python", "code": "def section_lengths(neurites, neurite_type=NeuriteType.all):\n    '''section lengths in a collection of neurites'''\n    return map_sections(_section_length, neurites, neurite_type=neurite_type)", "code_tokens": ["def", "section_lengths", "(", "neurites", ",", "neurite_type", "=", "NeuriteType", ".", "all", ")", ":", "return", "map_sections", "(", "_section_length", ",", "neurites", ",", "neurite_type", "=", "neurite_type", ")"], "docstring": "section lengths in a collection of neurites", "docstring_tokens": ["section", "lengths", "in", "a", "collection", "of", "neurites"], "sha": "254bb73535b20053d175bc4725bade662177d12b", "url": "https://github.com/BlueBrain/NeuroM/blob/254bb73535b20053d175bc4725bade662177d12b/neurom/fst/_neuritefunc.py#L104-L106", "partition": "train", "idx": 235485}
{"repo": "biolink/ontobio", "path": "ontobio/lexmap.py", "func_name": "LexicalMapEngine.index_ontology", "original_string": "def index_ontology(self, ont):\n        \"\"\"\n        Adds an ontology to the index\n\n        This iterates through all labels and synonyms in the ontology, creating an index\n        \"\"\"\n        self.merged_ontology.merge([ont])\n        syns = ont.all_synonyms(include_label=True)\n        \n        include_id = self._is_meaningful_ids()\n        logging.info(\"Include IDs as synonyms: {}\".format(include_id))\n        if include_id:\n            for n in ont.nodes():\n                v = n\n                # Get fragment\n                if v.startswith('http'):\n                    v = re.sub('.*/','',v)\n                    v = re.sub('.*#','',v)\n                syns.append(Synonym(n, val=v, pred='label'))\n        \n        logging.info(\"Indexing {} syns in {}\".format(len(syns),ont))\n        logging.info(\"Distinct lexical values: {}\".format(len(self.lmap.keys())))\n        for syn in syns:\n            self.index_synonym(syn, ont)\n        for nid in ont.nodes():\n            self.id_to_ontology_map[nid].append(ont)", "language": "python", "code": "def index_ontology(self, ont):\n        \"\"\"\n        Adds an ontology to the index\n\n        This iterates through all labels and synonyms in the ontology, creating an index\n        \"\"\"\n        self.merged_ontology.merge([ont])\n        syns = ont.all_synonyms(include_label=True)\n        \n        include_id = self._is_meaningful_ids()\n        logging.info(\"Include IDs as synonyms: {}\".format(include_id))\n        if include_id:\n            for n in ont.nodes():\n                v = n\n                # Get fragment\n                if v.startswith('http'):\n                    v = re.sub('.*/','',v)\n                    v = re.sub('.*#','',v)\n                syns.append(Synonym(n, val=v, pred='label'))\n        \n        logging.info(\"Indexing {} syns in {}\".format(len(syns),ont))\n        logging.info(\"Distinct lexical values: {}\".format(len(self.lmap.keys())))\n        for syn in syns:\n            self.index_synonym(syn, ont)\n        for nid in ont.nodes():\n            self.id_to_ontology_map[nid].append(ont)", "code_tokens": ["def", "index_ontology", "(", "self", ",", "ont", ")", ":", "self", ".", "merged_ontology", ".", "merge", "(", "[", "ont", "]", ")", "syns", "=", "ont", ".", "all_synonyms", "(", "include_label", "=", "True", ")", "include_id", "=", "self", ".", "_is_meaningful_ids", "(", ")", "logging", ".", "info", "(", "\"Include IDs as synonyms: {}\"", ".", "format", "(", "include_id", ")", ")", "if", "include_id", ":", "for", "n", "in", "ont", ".", "nodes", "(", ")", ":", "v", "=", "n", "# Get fragment", "if", "v", ".", "startswith", "(", "'http'", ")", ":", "v", "=", "re", ".", "sub", "(", "'.*/'", ",", "''", ",", "v", ")", "v", "=", "re", ".", "sub", "(", "'.*#'", ",", "''", ",", "v", ")", "syns", ".", "append", "(", "Synonym", "(", "n", ",", "val", "=", "v", ",", "pred", "=", "'label'", ")", ")", "logging", ".", "info", "(", "\"Indexing {} syns in {}\"", ".", "format", "(", "len", "(", "syns", ")", ",", "ont", ")", ")", "logging", ".", "info", "(", "\"Distinct lexical values: {}\"", ".", "format", "(", "len", "(", "self", ".", "lmap", ".", "keys", "(", ")", ")", ")", ")", "for", "syn", "in", "syns", ":", "self", ".", "index_synonym", "(", "syn", ",", "ont", ")", "for", "nid", "in", "ont", ".", "nodes", "(", ")", ":", "self", ".", "id_to_ontology_map", "[", "nid", "]", ".", "append", "(", "ont", ")"], "docstring": "Adds an ontology to the index\n\n        This iterates through all labels and synonyms in the ontology, creating an index", "docstring_tokens": ["Adds", "an", "ontology", "to", "the", "index"], "sha": "4e512a7831cfe6bc1b32f2c3be2ba41bc5cf7345", "url": "https://github.com/biolink/ontobio/blob/4e512a7831cfe6bc1b32f2c3be2ba41bc5cf7345/ontobio/lexmap.py#L113-L138", "partition": "train", "idx": 204842}
{"repo": "rackerlabs/rackspace-python-neutronclient", "path": "neutronclient/v2_0/client.py", "func_name": "Client.update_router", "original_string": "def update_router(self, router, body=None):\n        \"\"\"Updates a router.\"\"\"\n        return self.put(self.router_path % (router), body=body)", "language": "python", "code": "def update_router(self, router, body=None):\n        \"\"\"Updates a router.\"\"\"\n        return self.put(self.router_path % (router), body=body)", "code_tokens": ["def", "update_router", "(", "self", ",", "router", ",", "body", "=", "None", ")", ":", "return", "self", ".", "put", "(", "self", ".", "router_path", "%", "(", "router", ")", ",", "body", "=", "body", ")"], "docstring": "Updates a router.", "docstring_tokens": ["Updates", "a", "router", "."], "sha": "5a5009a8fe078e3aa1d582176669f1b28ab26bef", "url": "https://github.com/rackerlabs/rackspace-python-neutronclient/blob/5a5009a8fe078e3aa1d582176669f1b28ab26bef/neutronclient/v2_0/client.py#L725-L727", "partition": "train", "idx": 99407}
{"repo": "DataDog/integrations-core", "path": "tokumx/datadog_checks/tokumx/vendor/pymongo/server_description.py", "func_name": "ServerDescription.round_trip_time", "original_string": "def round_trip_time(self):\n        \"\"\"The current average latency or None.\"\"\"\n        # This override is for unittesting only!\n        if self._address in self._host_to_round_trip_time:\n            return self._host_to_round_trip_time[self._address]\n\n        return self._round_trip_time", "language": "python", "code": "def round_trip_time(self):\n        \"\"\"The current average latency or None.\"\"\"\n        # This override is for unittesting only!\n        if self._address in self._host_to_round_trip_time:\n            return self._host_to_round_trip_time[self._address]\n\n        return self._round_trip_time", "code_tokens": ["def", "round_trip_time", "(", "self", ")", ":", "# This override is for unittesting only!", "if", "self", ".", "_address", "in", "self", ".", "_host_to_round_trip_time", ":", "return", "self", ".", "_host_to_round_trip_time", "[", "self", ".", "_address", "]", "return", "self", ".", "_round_trip_time"], "docstring": "The current average latency or None.", "docstring_tokens": ["The", "current", "average", "latency", "or", "None", "."], "sha": "ebd41c873cf9f97a8c51bf9459bc6a7536af8acd", "url": "https://github.com/DataDog/integrations-core/blob/ebd41c873cf9f97a8c51bf9459bc6a7536af8acd/tokumx/datadog_checks/tokumx/vendor/pymongo/server_description.py#L168-L174", "partition": "train", "idx": 130354}
{"repo": "openid/JWTConnect-Python-OidcService", "path": "src/oidcservice/service.py", "func_name": "Service.do_post_construct", "original_string": "def do_post_construct(self, request_args, **kwargs):\n        \"\"\"\n        Will run the post_construct methods one at the time in order.\n\n        :param request_args: Request arguments\n        :param kwargs: Arguments used by the post_construct method\n        :return: Possible modified set of request arguments.\n        \"\"\"\n        _args = self.method_args('post_construct', **kwargs)\n\n        for meth in self.post_construct:\n            request_args = meth(request_args, service=self, **_args)\n\n        return request_args", "language": "python", "code": "def do_post_construct(self, request_args, **kwargs):\n        \"\"\"\n        Will run the post_construct methods one at the time in order.\n\n        :param request_args: Request arguments\n        :param kwargs: Arguments used by the post_construct method\n        :return: Possible modified set of request arguments.\n        \"\"\"\n        _args = self.method_args('post_construct', **kwargs)\n\n        for meth in self.post_construct:\n            request_args = meth(request_args, service=self, **_args)\n\n        return request_args", "code_tokens": ["def", "do_post_construct", "(", "self", ",", "request_args", ",", "*", "*", "kwargs", ")", ":", "_args", "=", "self", ".", "method_args", "(", "'post_construct'", ",", "*", "*", "kwargs", ")", "for", "meth", "in", "self", ".", "post_construct", ":", "request_args", "=", "meth", "(", "request_args", ",", "service", "=", "self", ",", "*", "*", "_args", ")", "return", "request_args"], "docstring": "Will run the post_construct methods one at the time in order.\n\n        :param request_args: Request arguments\n        :param kwargs: Arguments used by the post_construct method\n        :return: Possible modified set of request arguments.", "docstring_tokens": ["Will", "run", "the", "post_construct", "methods", "one", "at", "the", "time", "in", "order", "."], "sha": "759ab7adef30a7e3b9d75475e2971433b9613788", "url": "https://github.com/openid/JWTConnect-Python-OidcService/blob/759ab7adef30a7e3b9d75475e2971433b9613788/src/oidcservice/service.py#L140-L153", "partition": "train", "idx": 38452}
{"repo": "pantsbuild/pex", "path": "pex/util.py", "func_name": "DistributionHelper.access_zipped_assets", "original_string": "def access_zipped_assets(cls, static_module_name, static_path, dir_location=None):\n    \"\"\"\n    Create a copy of static resource files as we can't serve them from within the pex file.\n\n    :param static_module_name: Module name containing module to cache in a tempdir\n    :type static_module_name: string, for example 'twitter.common.zookeeper' or similar\n    :param static_path: Module name, for example 'serverset'\n    :param dir_location: create a new temporary directory inside, or None to have one created\n    :returns temp_dir: Temporary directory with the zipped assets inside\n    :rtype: str\n    \"\"\"\n\n    # asset_path is initially a module name that's the same as the static_path, but will be\n    # changed to walk the directory tree\n    def walk_zipped_assets(static_module_name, static_path, asset_path, temp_dir):\n      for asset in resource_listdir(static_module_name, asset_path):\n        asset_target = os.path.normpath(\n            os.path.join(os.path.relpath(asset_path, static_path), asset))\n        if resource_isdir(static_module_name, os.path.join(asset_path, asset)):\n          safe_mkdir(os.path.join(temp_dir, asset_target))\n          walk_zipped_assets(static_module_name, static_path, os.path.join(asset_path, asset),\n            temp_dir)\n        else:\n          with open(os.path.join(temp_dir, asset_target), 'wb') as fp:\n            path = os.path.join(static_path, asset_target)\n            file_data = resource_string(static_module_name, path)\n            fp.write(file_data)\n\n    if dir_location is None:\n      temp_dir = safe_mkdtemp()\n    else:\n      temp_dir = dir_location\n\n    walk_zipped_assets(static_module_name, static_path, static_path, temp_dir)\n\n    return temp_dir", "language": "python", "code": "def access_zipped_assets(cls, static_module_name, static_path, dir_location=None):\n    \"\"\"\n    Create a copy of static resource files as we can't serve them from within the pex file.\n\n    :param static_module_name: Module name containing module to cache in a tempdir\n    :type static_module_name: string, for example 'twitter.common.zookeeper' or similar\n    :param static_path: Module name, for example 'serverset'\n    :param dir_location: create a new temporary directory inside, or None to have one created\n    :returns temp_dir: Temporary directory with the zipped assets inside\n    :rtype: str\n    \"\"\"\n\n    # asset_path is initially a module name that's the same as the static_path, but will be\n    # changed to walk the directory tree\n    def walk_zipped_assets(static_module_name, static_path, asset_path, temp_dir):\n      for asset in resource_listdir(static_module_name, asset_path):\n        asset_target = os.path.normpath(\n            os.path.join(os.path.relpath(asset_path, static_path), asset))\n        if resource_isdir(static_module_name, os.path.join(asset_path, asset)):\n          safe_mkdir(os.path.join(temp_dir, asset_target))\n          walk_zipped_assets(static_module_name, static_path, os.path.join(asset_path, asset),\n            temp_dir)\n        else:\n          with open(os.path.join(temp_dir, asset_target), 'wb') as fp:\n            path = os.path.join(static_path, asset_target)\n            file_data = resource_string(static_module_name, path)\n            fp.write(file_data)\n\n    if dir_location is None:\n      temp_dir = safe_mkdtemp()\n    else:\n      temp_dir = dir_location\n\n    walk_zipped_assets(static_module_name, static_path, static_path, temp_dir)\n\n    return temp_dir", "code_tokens": ["def", "access_zipped_assets", "(", "cls", ",", "static_module_name", ",", "static_path", ",", "dir_location", "=", "None", ")", ":", "# asset_path is initially a module name that's the same as the static_path, but will be", "# changed to walk the directory tree", "def", "walk_zipped_assets", "(", "static_module_name", ",", "static_path", ",", "asset_path", ",", "temp_dir", ")", ":", "for", "asset", "in", "resource_listdir", "(", "static_module_name", ",", "asset_path", ")", ":", "asset_target", "=", "os", ".", "path", ".", "normpath", "(", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "relpath", "(", "asset_path", ",", "static_path", ")", ",", "asset", ")", ")", "if", "resource_isdir", "(", "static_module_name", ",", "os", ".", "path", ".", "join", "(", "asset_path", ",", "asset", ")", ")", ":", "safe_mkdir", "(", "os", ".", "path", ".", "join", "(", "temp_dir", ",", "asset_target", ")", ")", "walk_zipped_assets", "(", "static_module_name", ",", "static_path", ",", "os", ".", "path", ".", "join", "(", "asset_path", ",", "asset", ")", ",", "temp_dir", ")", "else", ":", "with", "open", "(", "os", ".", "path", ".", "join", "(", "temp_dir", ",", "asset_target", ")", ",", "'wb'", ")", "as", "fp", ":", "path", "=", "os", ".", "path", ".", "join", "(", "static_path", ",", "asset_target", ")", "file_data", "=", "resource_string", "(", "static_module_name", ",", "path", ")", "fp", ".", "write", "(", "file_data", ")", "if", "dir_location", "is", "None", ":", "temp_dir", "=", "safe_mkdtemp", "(", ")", "else", ":", "temp_dir", "=", "dir_location", "walk_zipped_assets", "(", "static_module_name", ",", "static_path", ",", "static_path", ",", "temp_dir", ")", "return", "temp_dir"], "docstring": "Create a copy of static resource files as we can't serve them from within the pex file.\n\n    :param static_module_name: Module name containing module to cache in a tempdir\n    :type static_module_name: string, for example 'twitter.common.zookeeper' or similar\n    :param static_path: Module name, for example 'serverset'\n    :param dir_location: create a new temporary directory inside, or None to have one created\n    :returns temp_dir: Temporary directory with the zipped assets inside\n    :rtype: str", "docstring_tokens": ["Create", "a", "copy", "of", "static", "resource", "files", "as", "we", "can", "t", "serve", "them", "from", "within", "the", "pex", "file", "."], "sha": "87b2129d860250d3b9edce75b9cb62f9789ee521", "url": "https://github.com/pantsbuild/pex/blob/87b2129d860250d3b9edce75b9cb62f9789ee521/pex/util.py#L49-L84", "partition": "train", "idx": 146985}
{"repo": "ArduPilot/MAVProxy", "path": "MAVProxy/modules/lib/mp_module.py", "func_name": "MPModule.module_matching", "original_string": "def module_matching(self, name):\n        '''Find a list of modules matching a wildcard pattern'''\n        import fnmatch\n        ret = []\n        for mname in self.mpstate.public_modules.keys():\n            if fnmatch.fnmatch(mname, name):\n                ret.append(self.mpstate.public_modules[mname])\n        return ret", "language": "python", "code": "def module_matching(self, name):\n        '''Find a list of modules matching a wildcard pattern'''\n        import fnmatch\n        ret = []\n        for mname in self.mpstate.public_modules.keys():\n            if fnmatch.fnmatch(mname, name):\n                ret.append(self.mpstate.public_modules[mname])\n        return ret", "code_tokens": ["def", "module_matching", "(", "self", ",", "name", ")", ":", "import", "fnmatch", "ret", "=", "[", "]", "for", "mname", "in", "self", ".", "mpstate", ".", "public_modules", ".", "keys", "(", ")", ":", "if", "fnmatch", ".", "fnmatch", "(", "mname", ",", "name", ")", ":", "ret", ".", "append", "(", "self", ".", "mpstate", ".", "public_modules", "[", "mname", "]", ")", "return", "ret"], "docstring": "Find a list of modules matching a wildcard pattern", "docstring_tokens": ["Find", "a", "list", "of", "modules", "matching", "a", "wildcard", "pattern"], "sha": "f50bdeff33064876f7dc8dc4683d278ff47f75d5", "url": "https://github.com/ArduPilot/MAVProxy/blob/f50bdeff33064876f7dc8dc4683d278ff47f75d5/MAVProxy/modules/lib/mp_module.py#L63-L70", "partition": "train", "idx": 230409}
{"repo": "wmayner/pyphi", "path": "pyphi/labels.py", "func_name": "NodeLabels.coerce_to_indices", "original_string": "def coerce_to_indices(self, nodes):\n        \"\"\"Return the nodes indices for nodes, where ``nodes`` is either\n        already integer indices or node labels.\n        \"\"\"\n        if nodes is None:\n            return self.node_indices\n\n        if all(isinstance(node, str) for node in nodes):\n            indices = self.labels2indices(nodes)\n        else:\n            indices = map(int, nodes)\n        return tuple(sorted(set(indices)))", "language": "python", "code": "def coerce_to_indices(self, nodes):\n        \"\"\"Return the nodes indices for nodes, where ``nodes`` is either\n        already integer indices or node labels.\n        \"\"\"\n        if nodes is None:\n            return self.node_indices\n\n        if all(isinstance(node, str) for node in nodes):\n            indices = self.labels2indices(nodes)\n        else:\n            indices = map(int, nodes)\n        return tuple(sorted(set(indices)))", "code_tokens": ["def", "coerce_to_indices", "(", "self", ",", "nodes", ")", ":", "if", "nodes", "is", "None", ":", "return", "self", ".", "node_indices", "if", "all", "(", "isinstance", "(", "node", ",", "str", ")", "for", "node", "in", "nodes", ")", ":", "indices", "=", "self", ".", "labels2indices", "(", "nodes", ")", "else", ":", "indices", "=", "map", "(", "int", ",", "nodes", ")", "return", "tuple", "(", "sorted", "(", "set", "(", "indices", ")", ")", ")"], "docstring": "Return the nodes indices for nodes, where ``nodes`` is either\n        already integer indices or node labels.", "docstring_tokens": ["Return", "the", "nodes", "indices", "for", "nodes", "where", "nodes", "is", "either", "already", "integer", "indices", "or", "node", "labels", "."], "sha": "deeca69a084d782a6fde7bf26f59e93b593c5d77", "url": "https://github.com/wmayner/pyphi/blob/deeca69a084d782a6fde7bf26f59e93b593c5d77/pyphi/labels.py#L82-L93", "partition": "train", "idx": 248860}
