{"code": "def activate ( self , prefix = None , backend = None ) : if isinstance ( prefix , compat . string_types ) : self . prefix = prefix if isinstance ( backend , RmoqStorageBackend ) : self . backend = backend def activate ( func ) : if isinstance ( func , type ) : return self . _decorate_class ( func ) def wrapper ( * args , * * kwargs ) : with self : return func ( * args , * * kwargs ) return wrapper return activate", "docstring": "A decorator used to activate the mocker .", "idx": 98021}
{"code": "def from_other ( cls , item ) : if isinstance ( item , Bitmath ) : return cls ( bits = item . bits ) else : raise ValueError ( \"The provided items must be a valid bitmath class: %s\" % str ( item . __class__ ) )", "docstring": "Factory function to return instances of item converted into a new instance of cls . Because this is a class method it may be called from any bitmath class object without the need to explicitly instantiate the class ahead of time .", "idx": 192904}
{"code": "def section_lengths ( neurites , neurite_type = NeuriteType . all ) : return map_sections ( _section_length , neurites , neurite_type = neurite_type )", "docstring": "section lengths in a collection of neurites", "idx": 235485}
{"code": "def index_ontology ( self , ont ) : self . merged_ontology . merge ( [ ont ] ) syns = ont . all_synonyms ( include_label = True ) include_id = self . _is_meaningful_ids ( ) logging . info ( \"Include IDs as synonyms: {}\" . format ( include_id ) ) if include_id : for n in ont . nodes ( ) : v = n # Get fragment if v . startswith ( 'http' ) : v = re . sub ( '.*/' , '' , v ) v = re . sub ( '.*#' , '' , v ) syns . append ( Synonym ( n , val = v , pred = 'label' ) ) logging . info ( \"Indexing {} syns in {}\" . format ( len ( syns ) , ont ) ) logging . info ( \"Distinct lexical values: {}\" . format ( len ( self . lmap . keys ( ) ) ) ) for syn in syns : self . index_synonym ( syn , ont ) for nid in ont . nodes ( ) : self . id_to_ontology_map [ nid ] . append ( ont )", "docstring": "Adds an ontology to the index", "idx": 204842}
{"code": "def update_router ( self , router , body = None ) : return self . put ( self . router_path % ( router ) , body = body )", "docstring": "Updates a router .", "idx": 99407}
{"code": "def round_trip_time ( self ) : # This override is for unittesting only! if self . _address in self . _host_to_round_trip_time : return self . _host_to_round_trip_time [ self . _address ] return self . _round_trip_time", "docstring": "The current average latency or None .", "idx": 130354}
{"code": "def do_post_construct ( self , request_args , * * kwargs ) : _args = self . method_args ( 'post_construct' , * * kwargs ) for meth in self . post_construct : request_args = meth ( request_args , service = self , * * _args ) return request_args", "docstring": "Will run the post_construct methods one at the time in order .", "idx": 38452}
{"code": "def access_zipped_assets ( cls , static_module_name , static_path , dir_location = None ) : # asset_path is initially a module name that's the same as the static_path, but will be # changed to walk the directory tree def walk_zipped_assets ( static_module_name , static_path , asset_path , temp_dir ) : for asset in resource_listdir ( static_module_name , asset_path ) : asset_target = os . path . normpath ( os . path . join ( os . path . relpath ( asset_path , static_path ) , asset ) ) if resource_isdir ( static_module_name , os . path . join ( asset_path , asset ) ) : safe_mkdir ( os . path . join ( temp_dir , asset_target ) ) walk_zipped_assets ( static_module_name , static_path , os . path . join ( asset_path , asset ) , temp_dir ) else : with open ( os . path . join ( temp_dir , asset_target ) , 'wb' ) as fp : path = os . path . join ( static_path , asset_target ) file_data = resource_string ( static_module_name , path ) fp . write ( file_data ) if dir_location is None : temp_dir = safe_mkdtemp ( ) else : temp_dir = dir_location walk_zipped_assets ( static_module_name , static_path , static_path , temp_dir ) return temp_dir", "docstring": "Create a copy of static resource files as we can t serve them from within the pex file .", "idx": 146985}
{"code": "def module_matching ( self , name ) : import fnmatch ret = [ ] for mname in self . mpstate . public_modules . keys ( ) : if fnmatch . fnmatch ( mname , name ) : ret . append ( self . mpstate . public_modules [ mname ] ) return ret", "docstring": "Find a list of modules matching a wildcard pattern", "idx": 230409}
{"code": "def coerce_to_indices ( self , nodes ) : if nodes is None : return self . node_indices if all ( isinstance ( node , str ) for node in nodes ) : indices = self . labels2indices ( nodes ) else : indices = map ( int , nodes ) return tuple ( sorted ( set ( indices ) ) )", "docstring": "Return the nodes indices for nodes where nodes is either already integer indices or node labels .", "idx": 248860}
