{"code": "def bigtable_users ( self ) : result = set ( ) for member in self . _bindings . get ( BIGTABLE_USER_ROLE , ( ) ) : result . add ( member ) return frozenset ( result )", "docstring": "Access to bigtable . user role memebers", "idx": 167504}
{"code": "def theme_static_with_version ( ctx , filename , external = False ) : if current_app . theme_manager . static_folder : url = assets . cdn_for ( '_themes.static' , filename = current . identifier + '/' + filename , _external = external ) else : url = assets . cdn_for ( '_themes.static' , themeid = current . identifier , filename = filename , _external = external ) if url . endswith ( '/' ) : # this is a directory, no need for cache burst return url if current_app . config [ 'DEBUG' ] : burst = time ( ) else : burst = current . entrypoint . dist . version return '{url}?_={burst}' . format ( url = url , burst = burst )", "docstring": "Override the default theme static to add cache burst", "idx": 247312}
{"code": "def insert ( self , i , species , coords , coords_are_cartesian = False , validate_proximity = False , properties = None ) : if not coords_are_cartesian : new_site = PeriodicSite ( species , coords , self . _lattice , properties = properties ) else : frac_coords = self . _lattice . get_fractional_coords ( coords ) new_site = PeriodicSite ( species , frac_coords , self . _lattice , properties = properties ) if validate_proximity : for site in self : if site . distance ( new_site ) < self . DISTANCE_TOLERANCE : raise ValueError ( \"New site is too close to an existing \" \"site!\" ) self . _sites . insert ( i , new_site )", "docstring": "Insert a site to the structure .", "idx": 134257}
{"code": "def data ( place ) : lat , lon = place url = \"https://api.forecast.io/forecast/%s/%s,%s?solar\" % ( APIKEY , lat , lon ) w_data = json . loads ( urllib2 . urlopen ( url ) . read ( ) ) return w_data", "docstring": "get forecast data .", "idx": 83406}
{"code": "def minute_trend_times ( start , end ) : if start % 60 : start = int ( start ) // 60 * 60 if end % 60 : end = int ( end ) // 60 * 60 + 60 return int ( start ) , int ( end )", "docstring": "Expand a [ start end ) interval for use in querying for minute trends", "idx": 211239}
{"code": "def _sample_batch ( ) : if _sample_probability == 1.0 or random . random ( ) < _sample_probability : return True # Pop off all the metrics for the batch for database in _measurements : _measurements [ database ] = _measurements [ database ] [ _max_batch_size : ] return False", "docstring": "Determine if a batch should be processed and if not pop off all of the pending metrics for that batch .", "idx": 11297}
{"code": "def _convert_rename ( self , fc ) : old = fc . old_path new = fc . new_path keep_old = self . _path_to_be_kept ( old ) keep_new = self . _path_to_be_kept ( new ) if keep_old and keep_new : fc . old_path = self . _adjust_for_new_root ( old ) fc . new_path = self . _adjust_for_new_root ( new ) return fc elif keep_old : # The file has been renamed to a non-interesting location. # Delete it! old = self . _adjust_for_new_root ( old ) return commands . FileDeleteCommand ( old ) elif keep_new : # The file has been renamed into an interesting location # We really ought to add it but we don't currently buffer # the contents of all previous files and probably never want # to. Maybe fast-import-info needs to be extended to # remember all renames and a config file can be passed # into here ala fast-import? self . warning ( \"cannot turn rename of %s into an add of %s yet\" % ( old , new ) ) return None", "docstring": "Convert a FileRenameCommand into a new FileCommand .", "idx": 80585}
{"code": "def group_view ( name , * * kwargs ) : ctx = Context ( * * kwargs ) ctx . execute_action ( 'group:view' , * * { 'storage' : ctx . repo . create_secure_service ( 'storage' ) , 'name' : name , } )", "docstring": "Show specified routing group .", "idx": 6403}
{"code": "def _ReadN ( self , n ) : ret = \"\" while True : chunk = self . _read_file . read ( n - len ( ret ) ) ret += chunk if len ( ret ) == n or not chunk : return ret", "docstring": "Reads n characters from the input stream or until EOF .", "idx": 239493}
{"code": "def check_config ( ) : configfile = ConfigFile ( ) global data if data . keys ( ) > 0 : # FIXME: run a better check of this file print ( \"gitberg config file exists\" ) print ( \"\\twould you like to edit your gitberg config file?\" ) else : print ( \"No config found\" ) print ( \"\\twould you like to create a gitberg config file?\" ) answer = input ( \"-->  [Y/n]\" ) # By default, the answer is yes, as denoted by the capital Y if not answer : answer = 'Y' # If yes, generate a new configuration # to be written out as yaml if answer in 'Yy' : print ( \"Running gitberg config generator ...\" ) # config.exists_or_make() config_gen = ConfigGenerator ( current = data ) config_gen . ask ( ) # print(config_gen.answers) data = config_gen . answers configfile . write ( ) print ( \"Config written to {}\" . format ( configfile . file_path ) )", "docstring": "Report if there is an existing config file", "idx": 8633}
