{"code": "def vector ( p1 , p2 ) : return np . subtract ( p1 [ COLS . XYZ ] , p2 [ COLS . XYZ ] )", "docstring": "compute vector between two 3D points", "idx": 235528}
{"code": "def get_available_modes ( self ) : resource = \"modes\" resource_event = self . publish_and_get_event ( resource ) if resource_event : properties = resource_event . get ( \"properties\" ) return properties . get ( \"modes\" ) return None", "docstring": "Return a list of available mode objects for an Arlo user .", "idx": 239989}
{"code": "def run ( self ) : if self . is_root_state : self . execution_history . push_call_history_item ( self , CallType . EXECUTE , None , self . input_data ) logger . debug ( \"Running {0}{1}\" . format ( self , \" (backwards)\" if self . backward_execution else \"\" ) ) if self . backward_execution : self . setup_backward_run ( ) else : self . setup_run ( ) try : outcome = self . _execute ( self . input_data , self . output_data , self . backward_execution ) self . state_execution_status = StateExecutionStatus . WAIT_FOR_NEXT_STATE if self . backward_execution : # outcome handling is not required as we are in backward mode and the execution order is fixed result = self . finalize ( ) else : # check output data self . check_output_data_type ( ) result = self . finalize ( outcome ) if self . is_root_state : self . execution_history . push_return_history_item ( self , CallType . EXECUTE , None , self . output_data ) return result except Exception as e : exc_type , exc_value , exc_traceback = sys . exc_info ( ) formatted_exc = traceback . format_exception ( exc_type , exc_value , exc_traceback ) truncated_exc = [ ] for line in formatted_exc : if os . path . join ( \"rafcon\" , \"core\" ) not in line : truncated_exc . append ( line ) logger . error ( \"{0} had an internal error: {1}: {2}\\n{3}\" . format ( self , type ( e ) . __name__ , e , '' . join ( truncated_exc ) ) ) # write error to the output_data of the state self . output_data [ \"error\" ] = e self . state_execution_status = StateExecutionStatus . WAIT_FOR_NEXT_STATE return self . finalize ( Outcome ( - 1 , \"aborted\" ) )", "docstring": "This defines the sequence of actions that are taken when the execution state is executed", "idx": 40652}
{"code": "def delete_atom ( self , * atom_numbers ) : for atom_number in atom_numbers : deletion_atom = self . atom_by_number ( atom_number = atom_number ) # update atom numbers for atom in self . atoms : if int ( atom . atom_number ) > int ( atom_number ) : atom . atom_number = str ( int ( atom . atom_number ) - 1 ) # find index of a bond to remove and update ctab data dict with new atom numbers for index , bond in enumerate ( self . bonds ) : bond . update_atom_numbers ( ) if atom_number in { bond . first_atom_number , bond . second_atom_number } : self . bonds . remove ( bond ) # remove atom from neighbors list for atom in self . atoms : if deletion_atom in atom . neighbors : atom . neighbors . remove ( deletion_atom ) self . atoms . remove ( deletion_atom )", "docstring": "Delete atoms by atom number .", "idx": 9522}
{"code": "def idxterms ( self ) : try : terms = listify ( self . _json . get ( \"idxterms\" , { } ) . get ( 'mainterm' , [ ] ) ) except AttributeError : # idxterms is empty return None try : return [ d [ '$' ] for d in terms ] except AttributeError : return None", "docstring": "List of index terms .", "idx": 203586}
{"code": "def load_code_info ( self ) : return PhaseGroup ( setup = load_code_info ( self . setup ) , main = load_code_info ( self . main ) , teardown = load_code_info ( self . teardown ) , name = self . name )", "docstring": "Load coded info for all contained phases .", "idx": 221917}
{"code": "def getVersion ( self ) : if isinstance ( self . version , versions . Version ) : return self . version if self . version : # verify specified version exists version = versions . Version ( self . version ) # create this object to allow self._version_ to be specified in multiple different ways by the user if version . baseVersion not in self . installedApp . versionMap ( ) : # verify that the selected version has an executable raise runConfigs . lib . SC2LaunchError ( \"specified game version %s executable is not available.%s    available:  %s\" % ( version , os . linesep , \"  \" . join ( self . installedApp . listVersions ( ) ) ) ) self . version = version else : # get most recent executable's version path = self . installedApp . exec_path ( ) vResult = self . installedApp . mostRecentVersion self . version = versions . Version ( vResult ) if self . debug : print ( os . linesep . join ( [ \"Game configuration detail:\" , \"    platform:   %s\" % ( self . os ) , \"    app:        %s\" % ( self . execPath ) , \"    version:    %s\" % ( self . version ) ] ) ) return self . version", "docstring": "the executable application s version", "idx": 80445}
{"code": "def read_user_dict ( var_name , default_value ) : # Please see http://click.pocoo.org/4/api/#click.prompt if not isinstance ( default_value , dict ) : raise TypeError default_display = 'default' user_value = click . prompt ( var_name , default = default_display , type = click . STRING , value_proc = process_json , ) if user_value == default_display : # Return the given default w/o any processing return default_value return user_value", "docstring": "Prompt the user to provide a dictionary of data .", "idx": 172143}
{"code": "def _ProcessMessages ( self , notification , queue_manager ) : flow_obj = None session_id = notification . session_id try : # Take a lease on the flow: flow_name = session_id . FlowName ( ) if flow_name in self . well_known_flows : # Well known flows are not necessarily present in the data store so # we need to create them instead of opening. expected_flow = self . well_known_flows [ flow_name ] . __class__ flow_obj = aff4 . FACTORY . CreateWithLock ( session_id , expected_flow , lease_time = self . well_known_flow_lease_time , blocking = False , token = self . token ) else : flow_obj = aff4 . FACTORY . OpenWithLock ( session_id , lease_time = self . flow_lease_time , blocking = False , token = self . token ) now = time . time ( ) logging . debug ( \"Got lock on %s\" , session_id ) # If we get here, we now own the flow. We can delete the notifications # we just retrieved but we need to make sure we don't delete any that # came in later. queue_manager . DeleteNotification ( session_id , end = notification . timestamp ) if flow_name in self . well_known_flows : stats_collector_instance . Get ( ) . IncrementCounter ( \"well_known_flow_requests\" , fields = [ str ( session_id ) ] ) # We remove requests first and then process them in the thread pool. # On one hand this approach increases the risk of losing requests in # case the worker process dies. On the other hand, it doesn't hold # the lock while requests are processed, so other workers can # process well known flows requests as well. with flow_obj : responses = flow_obj . FetchAndRemoveRequestsAndResponses ( session_id ) flow_obj . ProcessResponses ( responses , self . thread_pool ) else : with flow_obj : self . _ProcessRegularFlowMessages ( flow_obj , notification ) elapsed = time . time ( ) - now logging . debug ( \"Done processing %s: %s sec\" , session_id , elapsed ) stats_collector_instance . Get ( ) . RecordEvent ( \"worker_flow_processing_time\" , elapsed , fields = [ flow_obj . Name ( ) ] ) # Everything went well -> session can be run again. self . queued_flows . ExpireObject ( session_id ) except aff4 . LockError : # Another worker is dealing with this flow right now, we just skip it. # We expect lots of these when there are few messages (the system isn't # highly loaded) but it is interesting when the system is under load to # know if we are pulling the optimal number of messages off the queue. # A high number of lock fails when there is plenty of work to do would # indicate we are wasting time trying to process work that has already # been completed by other workers. stats_collector_instance . Get ( ) . IncrementCounter ( \"worker_flow_lock_error\" ) except FlowProcessingError : # Do nothing as we expect the error to be correctly logged and accounted # already. pass except Exception as e : # pylint: disable=broad-except # Something went wrong when processing this session. In order not to spin # here, we just remove the notification. logging . exception ( \"Error processing session %s: %s\" , session_id , e ) stats_collector_instance . Get ( ) . IncrementCounter ( \"worker_session_errors\" , fields = [ str ( type ( e ) ) ] ) queue_manager . DeleteNotification ( session_id )", "docstring": "Does the real work with a single flow .", "idx": 131566}
{"code": "def move_to ( self , x , y , h ) : if self . _has_border : start_x = 1 width = self . canvas . width - 2 start_y = self . canvas . start_line + 1 height = self . canvas . height - 2 else : start_x = 0 width = self . canvas . width start_y = self . canvas . start_line height = self . canvas . height if ( ( x >= start_x ) and ( x < start_x + width ) and ( y >= start_y ) and ( y + h < start_y + height ) ) : # Already OK - quit now. return if y < start_y : self . canvas . scroll_to ( y - 1 if self . _has_border else y ) else : line = y + h - self . canvas . height + ( 1 if self . _has_border else 0 ) self . canvas . scroll_to ( max ( 0 , line ) )", "docstring": "Make the specified location visible . This is typically used by a widget to scroll the canvas such that it is visible .", "idx": 146076}
