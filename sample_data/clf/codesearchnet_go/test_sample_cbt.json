{"input": "// GetResource gets an existing resource, errors otherwise [SEP] func (s *Storage) GetResource(name string) (common.Resource, error) {\n\ti, err := s.resources.Get(name)\n\tif err != nil {\n\t\treturn common.Resource{}, err\n\t}\n\tvar res common.Resource\n\tres, err = common.ItemToResource(i)\n\tif err != nil {\n\t\treturn common.Resource{}, err\n\t}\n\treturn res, nil\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "// GetResource gets an existing resource, errors otherwise [SEP] func (b *builder) Build(target resolver.Target, cc resolver.ClientConn, opts resolver.BuildOption) (resolver.Resolver, error) {\n\tif len(target.Authority) < 1 {\n\t\treturn nil, fmt.Errorf(\"'etcd' target scheme requires non-empty authority identifying etcd cluster being routed to\")\n\t}\n\tid := target.Authority\n\tes, err := b.getResolverGroup(id)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to build resolver: %v\", err)\n\t}\n\tr := &Resolver{\n\t\tendpointID: id,\n\t\tcc:         cc,\n\t}\n\tes.addResolver(r)\n\treturn r, nil\n}", "target": 0, "target_options": ["no_match", "match"]}
{"input": "// MarshalJSON calls json.RawMessage method of the same name. Required since\n// HawkSignatureAuthenticationResponse is of type json.RawMessage... [SEP] func (this *HawkSignatureAuthenticationResponse) MarshalJSON() ([]byte, error) {\n\tx := json.RawMessage(*this)\n\treturn (&x).MarshalJSON()\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "// MarshalJSON calls json.RawMessage method of the same name. Required since\n// HawkSignatureAuthenticationResponse is of type json.RawMessage... [SEP] func (g GeoPoint) Valid() bool {\n\treturn -90 <= g.Lat && g.Lat <= 90 && -180 <= g.Lng && g.Lng <= 180\n}", "target": 0, "target_options": ["no_match", "match"]}
{"input": "// visit visits every ancestor of 'path' (excluding 'path' itself), leaf to\n// root (i.e.  end of 'path' to beginning), and calls 'update' on each node\n// along the way. For example, if 'visit' is called with 'path'=\"/path/to/file\",\n// then updateFn is called as follows:\n//\n// 1. update(node at \"/path/to\" or nil, \"/path/to\", \"file\")\n// 2. update(node at \"/path\"    or nil, \"/path\",    \"to\")\n// 3. update(node at \"/\"        or nil, \"\",         \"path\")\n//\n// This is useful for propagating changes to size upwards. [SEP] func visit(tx *bolt.Tx, path string, update updateFn) error {\n\tfor path != \"\" {\n\t\tparent, child := split(path)\n\t\tpnode, err := get(tx, parent)\n\t\tif err != nil && Code(err) != PathNotFound {\n\t\t\treturn err\n\t\t}\n\t\tif pnode != nil && pnode.nodetype() != directory {\n\t\t\treturn errorf(PathConflict, \"attempted to visit \\\"%s\\\", but it's not a \"+\n\t\t\t\t\"directory\", path)\n\t\t}\n\t\tif pnode == nil {\n\t\t\tpnode = &NodeProto{}\n\t\t}\n\t\tif err := update(pnode, parent, child); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := put(tx, parent, pnode); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpath = parent\n\t}\n\treturn nil\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "// visit visits every ancestor of 'path' (excluding 'path' itself), leaf to\n// root (i.e.  end of 'path' to beginning), and calls 'update' on each node\n// along the way. For example, if 'visit' is called with 'path'=\"/path/to/file\",\n// then updateFn is called as follows:\n//\n// 1. update(node at \"/path/to\" or nil, \"/path/to\", \"file\")\n// 2. update(node at \"/path\"    or nil, \"/path\",    \"to\")\n// 3. update(node at \"/\"        or nil, \"\",         \"path\")\n//\n// This is useful for propagating changes to size upwards. [SEP] func (r *ProtocolLXD) GetClusterMembers() ([]api.ClusterMember, error) {\n\tif !r.HasExtension(\"clustering\") {\n\t\treturn nil, fmt.Errorf(\"The server is missing the required \\\"clustering\\\" API extension\")\n\t}\n\n\tmembers := []api.ClusterMember{}\n\t_, err := r.queryStruct(\"GET\", \"/cluster/members?recursion=1\", nil, \"\", &members)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn members, nil\n}", "target": 0, "target_options": ["no_match", "match"]}
{"input": "// Build creates or reuses an etcd resolver for the etcd cluster name identified by the authority part of the target. [SEP] func (b *builder) Build(target resolver.Target, cc resolver.ClientConn, opts resolver.BuildOption) (resolver.Resolver, error) {\n\tif len(target.Authority) < 1 {\n\t\treturn nil, fmt.Errorf(\"'etcd' target scheme requires non-empty authority identifying etcd cluster being routed to\")\n\t}\n\tid := target.Authority\n\tes, err := b.getResolverGroup(id)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to build resolver: %v\", err)\n\t}\n\tr := &Resolver{\n\t\tendpointID: id,\n\t\tcc:         cc,\n\t}\n\tes.addResolver(r)\n\treturn r, nil\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "// Build creates or reuses an etcd resolver for the etcd cluster name identified by the authority part of the target. [SEP] func (this *HawkSignatureAuthenticationResponse) MarshalJSON() ([]byte, error) {\n\tx := json.RawMessage(*this)\n\treturn (&x).MarshalJSON()\n}", "target": 0, "target_options": ["no_match", "match"]}
{"input": "// UnmarshalJSON supports json.Unmarshaler interface [SEP] func (v *PauseOnAsyncCallParams) UnmarshalJSON(data []byte) error {\n\tr := jlexer.Lexer{Data: data}\n\teasyjsonC5a4559bDecodeGithubComChromedpCdprotoDebugger29(&r, v)\n\treturn r.Error()\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "// UnmarshalJSON supports json.Unmarshaler interface [SEP] func (s *Storage) GetResource(name string) (common.Resource, error) {\n\ti, err := s.resources.Get(name)\n\tif err != nil {\n\t\treturn common.Resource{}, err\n\t}\n\tvar res common.Resource\n\tres, err = common.ItemToResource(i)\n\tif err != nil {\n\t\treturn common.Resource{}, err\n\t}\n\treturn res, nil\n}", "target": 0, "target_options": ["no_match", "match"]}
{"input": "// countUses returns the number of uses of the identifier x in scope. [SEP] func countUses(x *ast.Ident, scope []ast.Stmt) int {\n\tcount := 0\n\tff := func(n interface{}) {\n\t\tif n, ok := n.(ast.Node); ok && refersTo(n, x) {\n\t\t\tcount++\n\t\t}\n\t}\n\tfor _, n := range scope {\n\t\twalk(n, ff)\n\t}\n\treturn count\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "// countUses returns the number of uses of the identifier x in scope. [SEP] func (r *ProtocolLXD) GetClusterMembers() ([]api.ClusterMember, error) {\n\tif !r.HasExtension(\"clustering\") {\n\t\treturn nil, fmt.Errorf(\"The server is missing the required \\\"clustering\\\" API extension\")\n\t}\n\n\tmembers := []api.ClusterMember{}\n\t_, err := r.queryStruct(\"GET\", \"/cluster/members?recursion=1\", nil, \"\", &members)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn members, nil\n}", "target": 0, "target_options": ["no_match", "match"]}
{"input": "// ReadUint32 returns a uint32 read from address a of the inferior. [SEP] func (p *Process) ReadUint32(a Address) uint32 {\n\tm := p.findMapping(a)\n\tif m == nil {\n\t\tpanic(fmt.Errorf(\"address %x is not mapped in the core file\", a))\n\t}\n\tb := m.contents[a.Sub(m.min):]\n\tif len(b) < 4 {\n\t\tvar buf [4]byte\n\t\tb = buf[:]\n\t\tp.ReadAt(b, a)\n\t}\n\tif p.littleEndian {\n\t\treturn binary.LittleEndian.Uint32(b)\n\t}\n\treturn binary.BigEndian.Uint32(b)\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "// ReadUint32 returns a uint32 read from address a of the inferior. [SEP] func countUses(x *ast.Ident, scope []ast.Stmt) int {\n\tcount := 0\n\tff := func(n interface{}) {\n\t\tif n, ok := n.(ast.Node); ok && refersTo(n, x) {\n\t\t\tcount++\n\t\t}\n\t}\n\tfor _, n := range scope {\n\t\twalk(n, ff)\n\t}\n\treturn count\n}", "target": 0, "target_options": ["no_match", "match"]}
{"input": "/*\n\tRuns the entire expression using the given [parameters].\n\te.g., If the expression contains a reference to the variable \"foo\", it will be taken from `parameters.Get(\"foo\")`.\n\n\tThis function returns errors if the combination of expression and parameters cannot be run,\n\tsuch as if a variable in the expression is not present in [parameters].\n\n\tIn all non-error circumstances, this returns the single value result of the expression and parameters given.\n\te.g., if the expression is \"1 + 1\", this will return 2.0.\n\te.g., if the expression is \"foo + 1\" and parameters contains \"foo\" = 2, this will return 3.0\n*/ [SEP] func (this EvaluableExpression) Eval(parameters Parameters) (interface{}, error) {\n\n\tif this.evaluationStages == nil {\n\t\treturn nil, nil\n\t}\n\n\tif parameters != nil {\n\t\tparameters = &sanitizedParameters{parameters}\n\t} else {\n\t\tparameters = DUMMY_PARAMETERS\n\t}\n\n\treturn this.evaluateStage(this.evaluationStages, parameters)\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "/*\n\tRuns the entire expression using the given [parameters].\n\te.g., If the expression contains a reference to the variable \"foo\", it will be taken from `parameters.Get(\"foo\")`.\n\n\tThis function returns errors if the combination of expression and parameters cannot be run,\n\tsuch as if a variable in the expression is not present in [parameters].\n\n\tIn all non-error circumstances, this returns the single value result of the expression and parameters given.\n\te.g., if the expression is \"1 + 1\", this will return 2.0.\n\te.g., if the expression is \"foo + 1\" and parameters contains \"foo\" = 2, this will return 3.0\n*/ [SEP] func (this *HawkSignatureAuthenticationResponse) MarshalJSON() ([]byte, error) {\n\tx := json.RawMessage(*this)\n\treturn (&x).MarshalJSON()\n}", "target": 0, "target_options": ["no_match", "match"]}
{"input": "// GetClusterMembers returns the current members of the cluster [SEP] func (r *ProtocolLXD) GetClusterMembers() ([]api.ClusterMember, error) {\n\tif !r.HasExtension(\"clustering\") {\n\t\treturn nil, fmt.Errorf(\"The server is missing the required \\\"clustering\\\" API extension\")\n\t}\n\n\tmembers := []api.ClusterMember{}\n\t_, err := r.queryStruct(\"GET\", \"/cluster/members?recursion=1\", nil, \"\", &members)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn members, nil\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "// GetClusterMembers returns the current members of the cluster [SEP] func (p *Process) ReadUint32(a Address) uint32 {\n\tm := p.findMapping(a)\n\tif m == nil {\n\t\tpanic(fmt.Errorf(\"address %x is not mapped in the core file\", a))\n\t}\n\tb := m.contents[a.Sub(m.min):]\n\tif len(b) < 4 {\n\t\tvar buf [4]byte\n\t\tb = buf[:]\n\t\tp.ReadAt(b, a)\n\t}\n\tif p.littleEndian {\n\t\treturn binary.LittleEndian.Uint32(b)\n\t}\n\treturn binary.BigEndian.Uint32(b)\n}", "target": 0, "target_options": ["no_match", "match"]}
{"input": "// Valid returns whether a GeoPoint is within [-90, 90] latitude and [-180, 180] longitude. [SEP] func (g GeoPoint) Valid() bool {\n\treturn -90 <= g.Lat && g.Lat <= 90 && -180 <= g.Lng && g.Lng <= 180\n}", "target": 1, "target_options": ["no_match", "match"]}
{"input": "// Valid returns whether a GeoPoint is within [-90, 90] latitude and [-180, 180] longitude. [SEP] func (this EvaluableExpression) Eval(parameters Parameters) (interface{}, error) {\n\n\tif this.evaluationStages == nil {\n\t\treturn nil, nil\n\t}\n\n\tif parameters != nil {\n\t\tparameters = &sanitizedParameters{parameters}\n\t} else {\n\t\tparameters = DUMMY_PARAMETERS\n\t}\n\n\treturn this.evaluateStage(this.evaluationStages, parameters)\n}", "target": 0, "target_options": ["no_match", "match"]}
